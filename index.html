<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    :root{
      --bg:#f5f7fb; --card:#ffffff; --muted:#4b5563; --accent:#1f2937; --accent2:#374151; --danger:#374151;
      --paperText:#111; --paperRule:#444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-size:16px;font-family:Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif;background:#f3f4f6;color:#1f2937;overflow-x:hidden}
  .wrap{max-width:min(1600px,98vw);margin:0 auto;padding:24px;overflow-x:hidden}
    .hero{background:linear-gradient(135deg,#e0ecff 0%,#f0f7ff 60%,#e6fbff 100%);border:1px solid #dbeafe;border-radius:16px;padding:28px;text-align:center;color:#111;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .hero h1{margin:0 0 6px;font-size:32px}
  .tabs{display:flex;margin:16px 0;border-bottom:2px solid #e5e7eb;width:100%}
  .tab{flex:1;padding:14px 8px;background:transparent;border:none;color:#374151;font-weight:700;cursor:pointer;font-size:15px;text-align:center;white-space:nowrap}
    .tab.active{color:#111;border-bottom:3px solid var(--accent);background:#f0f9ff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;max-width:100%;overflow:visible}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:12px;padding:16px;max-width:100%;overflow:visible}
    .card h2{margin:0 0 12px;font-size:22px;color:#111;font-weight:700}
    h2{margin:0 0 12px;font-size:22px;color:#111;font-weight:700}
    h3{margin:0 0 10px;font-size:16px;color:#374151;font-weight:600}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>.field{flex:1;min-width:220px}
    .field{margin:8px 0}
    label{display:block;margin-bottom:6px;font-size:13px;color:#374151;font-weight:600}
    input,select,textarea{width:100%;padding:12px 12px;border-radius:10px;border:1px solid #d1d5db;background:#ffffff;color:#111;font-size:15px}
    input[type="checkbox"]{width:auto}
    .checks{display:flex;flex-wrap:wrap;gap:12px}
    .btn{padding:11px 16px;border-radius:10px;border:1px solid #374151;color:#f9fafb;background:#1f2937;cursor:pointer;font-weight:800;transition:background-color 0.18s ease,box-shadow 0.18s ease,transform 0.12s ease}
    .btn.secondary{background:#6b7280;border-color:#4b5563}
    .btn.danger{background:#374151;border-color:#1f2937;color:#f9fafb}
    .btn:hover{background:#111827;box-shadow:0 4px 10px rgba(15,23,42,0.35);transform:translateY(-1px)}
    .btn:active{transform:translateY(0);box-shadow:0 1px 4px rgba(15,23,42,0.3)}
    .btn:focus-visible{outline:2px solid #38bdf8;outline-offset:2px}
    .list{display:grid;gap:10px;margin-top:12px}
  .song{display:flex;gap:12px;align-items:center;justify-content:space-between;background:#ffffff;border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .song.dragging{opacity:.6}
    .song .meta{font-size:13px;color:#4b5563}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;margin-right:6px}
  .handle{cursor:grab;color:#6b7280;font-size:18px;user-select:none;margin-right:6px}
  .handle:active{cursor:grabbing}

    /* Print preview (paper look) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:flex-start;justify-content:center;padding:24px;z-index:80;overflow:auto;pointer-events:none}
    .modal.open{display:flex;pointer-events:auto}
    .modal .modalbox{pointer-events:auto}
    .modal .sheet{pointer-events:auto}
    .sheet{width:8.5in;max-width:100%;min-height:11in;height:auto;background:white;color:var(--paperText);border-radius:8px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:0.4in 0.5in;overflow:visible;margin:auto;transform:scale(0.75);transform-origin:top center}
    /* Inline preview on Setlist tab - matches print proportions, scrollable */
    #sheetInline{width:100%;aspect-ratio:8.5/11;padding:24px 32px;box-sizing:border-box;display:flex;flex-direction:column;overflow:auto}
    #sheetInline .hdr{flex:0 0 auto}
    #sheetInline .songs{flex:1 1 auto;display:flex!important;flex-direction:column!important;justify-content:space-between!important;overflow:visible}
    #sheetInline .songs .line,#sheetInline .songs .break,#sheetInline .songs .total-time{flex:0 0 auto}
  @media (max-width:768px){
    .modal{align-items:flex-start;padding:10px}
    .modal .sheet{width:100%;height:auto;max-height:none;padding:16px;box-sizing:border-box;overflow:visible}
  }
    .sheet.a4{width:210mm;min-height:277mm}
    .sheet.multipage{display:flex;flex-direction:column;gap:20px;height:auto}
    .sheet-page{width:100%;height:10.5in;min-height:10.5in;background:white;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.15);padding:0.15in 0.25in;page-break-after:always;display:flex;flex-direction:column;box-sizing:border-box}
    .sheet.a4 .sheet-page{height:277mm;min-height:277mm}
  .hdr{text-align:center;padding-bottom:4px;margin-bottom:6px;flex-shrink:0}
    .hdr .band{font-size:22pt;font-weight:900;letter-spacing:.6px}
    .hdr .venue{font-size:18pt;font-weight:800;letter-spacing:.5px;margin-top:1px}
  .hdr .sub{font-size:9pt;color:#444;margin-top:2px}
  .hdr .notes{font-size:9pt;color:#333;margin-top:1px;font-style:italic}
  .hdr .logo{display:block}
  .hdr .logo img{max-height:48pt;max-width:100%;height:auto}
    .songs{display:flex;flex-direction:column;gap:2px;flex:1;min-height:0}
  .line{display:grid;grid-template-columns:22px 1fr minmax(90px,120px) 40px;align-items:baseline;column-gap:8px;padding:1px 0}
  .line .no{font-weight:800;text-align:right;opacity:.85}
  .line .title{font-weight:900;letter-spacing:.1px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .title .notePrint{font-size:9pt;font-style:italic;font-weight:400;opacity:.75;margin-left:6px;white-space:nowrap}
  .line .key{font-size:10pt;color:#374151;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .time{font-size:10pt;text-align:right;opacity:.9}
  .line.dragging,.break.dragging{opacity:0.4}
  .line.dragging .title,.line.dragging .no,.line.dragging .time{cursor:grabbing!important}
  .break.dragging{cursor:grabbing!important}
  .break[draggable="true"]{cursor:grab}
    .no{font-weight:800;font-size:12pt;min-width:26px;text-align:right;color:#333}
  .title{flex:1;font-size:17pt;font-weight:900;letter-spacing:0.2px}
    .time{min-width:42px;text-align:right;font-size:10pt;color:#444}
  .subnotes{font-size:9pt;color:#4b5563;font-style:italic;margin-top:-2px;margin-left:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .break{font-weight:900;text-transform:uppercase;font-size:14pt;color:#7b1fa2;text-align:center;border:2px dashed #7b1fa2;padding:6px 8px;border-radius:8px;background:#f7efff}
  .total-time{flex-shrink:0;margin-top:auto}
  
  /* Editable header fields */
  .hdr [contenteditable="true"]{outline:none;transition:background 0.2s}
  .hdr [contenteditable="true"]:hover{background:rgba(59,130,246,0.05)}
  .hdr [contenteditable="true"]:focus{background:rgba(59,130,246,0.1);border-radius:4px}
  .hdr [contenteditable="true"]:empty:before{content:attr(data-placeholder);color:#9ca3af;font-style:italic}

  /* Small centered modal box for print options */
  .modalbox{background:white;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,.3);padding:24px;max-width:420px;width:90vw;max-height:80vh;overflow:auto}
  .modalbox .hdr{text-align:center;padding-bottom:12px;margin-bottom:16px;border-bottom:1px solid #e5e7eb}
  .modalbox .band{font-size:20px;font-weight:800}

  .tools{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:12px}
    .tools .paper{color:#374151}

  /* Floating Song Pool */
  .pool-flyout{position:fixed;top:76px;right:18px;width:320px;max-width:92vw;height:calc(100% - 100px);background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,.18);display:none;flex-direction:column;z-index:65}
  .pool-flyout.open{display:flex}
  .pool-head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #e5e7eb}
  .pool-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .pool-sec h4{margin:0 0 6px 0;font-size:13px;color:#6b7280;text-transform:uppercase;letter-spacing:.6px}
  /* Base pill chip styling (used in Song Pool) */
  .pill{display:inline-flex;align-items:center;gap:6px;border:2px solid #d1d5db;border-radius:999px;padding:8px 14px;background:#fff;font-size:14px;color:#111827;min-height:36px}
  .pool-sec .pill{cursor:grab}
  .pill.drag-touch{opacity:.55;outline:2px dashed #374151}
  .touch-target-highlight{box-shadow:inset 0 3px 0 #374151,inset 0 -3px 0 #374151}
  /* Live layout: no wrap on wide screens; wrap on narrow */
  #liveFlex{flex-wrap:nowrap;flex-direction:row}
  #liveLeftCol{flex:0 0 340px;min-width:340px}
  @media (max-width: 900px){ #liveFlex{flex-wrap:wrap;flex-direction:row} #liveLeftCol{flex:1 1 100%;min-width:260px} }
  /* Mood pastel chips */
  .pill.mood-upbeat{background:#FECACA;border-color:#FCA5A5}
  .pill.mood-happy{background:#FEF9C3;border-color:#FDE68A}
  .pill.mood-energetic{background:#CFFAFE;border-color:#A5F3FC}
  .pill.mood-mellow{background:#FFEDD5;border-color:#FED7AA}
  .pill.mood-sad{background:#DBEAFE;border-color:#BFDBFE}
  /* Drop indicator on preview sheet rows */
  .line.drop-before, .break.drop-before{box-shadow:inset 0 3px 0 0 #60a5fa}
  .line.drop-after, .break.drop-after{box-shadow:inset 0 -3px 0 0 #60a5fa}
  /* Tour date tabs */
  .tour-date-tab:hover{background:#f0f9ff !important;border-color:#0ea5e9 !important}
  /* Tour interest chips - draggable */
  .tour-interest-chip{
    display:flex;
    align-items:flex-start;
    gap:8px;
    padding:10px 12px;
    background:#fff;
    border:1px solid #d1d5db;
    border-radius:8px;
    cursor:move;
    font-size:13px;
    transition:all 0.2s;
    user-select:none;
    box-shadow:0 1px 3px rgba(0,0,0,0.1);
    min-width:250px;
    max-width:350px;
  }
  .tour-interest-chip:hover{
    box-shadow:0 4px 8px rgba(0,0,0,0.15);
    transform:translateY(-2px);
  }
  .tour-interest-chip.dragging{
    opacity:0.6;
    transform:scale(0.98);
  }
  .tour-interest-chip .chip-remove{
    background:none;
    border:none;
    color:#9ca3af;
    cursor:pointer;
    padding:0;
    font-size:20px;
    line-height:1;
    flex-shrink:0;
    margin-left:auto;
  }
  .tour-interest-chip .chip-remove:hover{
    color:#dc2626;
  }
  #tourInterestsDropZone.drag-over{
    background:#e0f2fe;
    border-color:#0ea5e9;
  }

    @media print{
      /* Universal print settings - works on Windows/Mac/iOS/Android */
      @page { 
        margin: 0.25in 0.35in; 
        size: letter; 
      }
      
      /* Force consistent rendering across platforms */
      body,*{
        background:transparent!important;
        overflow:visible!important;
        -webkit-print-color-adjust:exact!important;
        print-color-adjust:exact!important;
      }
      
      /* Hide all UI chrome */
      .wrap{display:none!important}
      .brand-bar{display:none!important}
      .global-actions{display:none!important}
      .tools{display:none!important}
      #printChooser{display:none!important}
      #songPoolFlyout{display:none!important}
      .print-fab{display:none!important}
      .file-menu-container{display:none!important}
      .date-header{display:none!important}
      .stage-modal{display:none!important}
      #notesModal{display:none!important}
      #stageModal{display:none!important}
      
      /* Show only modal content */
      .modal{position:static!important;display:none;background:none!important;padding:0!important;margin:0!important;visibility:visible!important;opacity:1!important}
      .modal.open{display:block!important;visibility:visible!important;opacity:1!important}
      
      /* Setlist print layout */
      .sheet{
        box-shadow:none!important;
        height:auto!important;
        max-height:none!important;
        overflow:visible!important;
        padding:0.15in 0.25in!important;
        margin:0!important;
        width:100%!important;
        max-width:100%!important;
        display:block!important;
        transform:none!important;
        visibility:visible!important;
        opacity:1!important;
        background:white!important;
        aspect-ratio:unset!important;
      }
      .sheet.multipage{gap:0!important;height:auto!important;max-height:none!important;overflow:visible!important}
      .sheet-page{
        box-shadow:none!important;
        padding:0.15in 0.25in!important;
        margin:0!important;
        page-break-after:always!important;
        page-break-inside:avoid!important;
        height:10.5in!important;
        min-height:10.5in!important;
        max-height:10.5in!important;
        overflow:hidden!important;
        display:flex!important;
        flex-direction:column!important;
        background:white!important;
      }
      .sheet-page:last-child{page-break-after:auto!important}
      .hdr{flex-shrink:0!important}
      .songs{
        flex:1!important;
        display:block!important;
        overflow:visible!important;
      }
      .songs .line, .songs .break{
        display:flex!important;
      }
      .total-time{margin-top:auto!important}
      .break.pagebreak{page-break-after:always}
      
      /* Stage plot and tech table sizing */
      #stagePrint svg, #stagePrint canvas{
        max-width:100%!important;
        height:auto!important;
        page-break-inside:avoid!important;
      }
      
      /* Lyrics print container - ensure isolation */
      #lyricsPrintContainer{
        display:block!important;
        position:relative!important;
        z-index:999999!important;
      }
      #lyricsPrintContainer > div{
        page-break-after:always!important;
        page-break-inside:avoid!important;
      }
      #lyricsPrintContainer > div:last-child{
        page-break-after:auto!important;
      }
      
      /* Hide scrollbars in print */
      *::-webkit-scrollbar{display:none!important}
      *{scrollbar-width:none!important}
    }

  /* Fullscreen Stage Editor */
  /* Inline stage editor (converted from fullscreen) */
  .stage-modal{position:static;background:transparent;display:none;z-index:auto;margin-top:12px;max-width:min(1600px,98vw);margin-left:auto;margin-right:auto}
  .stage-modal.open{display:flex}
  .stage-editor{display:grid;grid-template-columns:300px 1fr;gap:16px;background:#fff;width:100%;min-height:640px;max-width:100%}
  .stage-pane{padding:10px 12px 16px;overflow:hidden;border-right:1px solid #e5e7eb}
  .stage-pane .tool{white-space:nowrap}
  .stage-pane .toolbox-actions{display:flex;flex-wrap:wrap;gap:8px;margin:0 0 8px}
  .stage-pane .toolbox-actions button{padding:6px 10px;font-size:12px}
  .stage-canvas{padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;overflow:auto;position:relative}
  /* Stage canvas sizing - dimensions come from data-stage-width/height attributes */
  #stageSvgFull{display:block;flex:0 0 auto;max-height:60vh;max-width:100%}
  #stageFrame{max-width:100%;overflow:visible;display:inline-block}
  @media (max-width:900px){
    #stageSvgFull{max-height:45vh;max-width:100%}
    #stageFrame{max-width:calc(100vw - 48px)}
    .stage-canvas{padding:6px}
  }
  .stage-legend{max-width:900px;margin:0 auto;border:1px solid #e5e7eb;background:#f9fafb;border-radius:6px;padding:4px;display:flex;flex-direction:column;gap:2px;font-size:11px;line-height:1.1}
  .stage-legend .row{display:grid;grid-template-columns:28px 140px 110px 1fr;align-items:center;gap:6px;padding:1px 4px;}
  .stage-legend .row:nth-child(odd){background:#fff}
  .stage-legend img{width:16px;height:16px;object-fit:contain;display:block;margin:0 auto}
  .stage-legend .nm{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:11px}
  .stage-legend select,.stage-legend input[type=number]{font-size:11px;padding:0 2px;height:18px}
  .stage-legend .chain{font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:right}
  .tool[draggable="true"]{user-select:none}
  .stage-actions{position:absolute;top:10px;right:10px;display:flex;gap:8px}
  /* Hide close button in inline mode; Clear moved into toolbox footer */
  #closeStage{display:none}
  /* Tech / Stage: tech rider & stage plot (B&W) */
  .advanced-grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
  .tech-table{width:100%;border-collapse:collapse}
  .tech-table th,.tech-table td{border:1px solid #e5e7eb;padding:4px 6px;font-size:11px;line-height:1.2}
  .stage-wrap{border:1px solid #e5e7eb;border-radius:8px;background:#fff;padding:10px}
  .stage-tools{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}
  .tool{border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;padding:6px 8px;font-size:13px;cursor:pointer}
  .stage{width:100%;height:90vh;min-height:640px;border:1px dashed #cbd5e1;background:#ffffff}
  .stage svg{width:100%;height:100%;background:white}
  /* B&W outlines for glyphs, keep background white */
  .bw .stage-bg{fill:#fff;stroke:#000;stroke-width:2}
  /* Allow colored emoji backgrounds: only force outline for rects without data-bg */
  .bw rect:not([data-bg]){fill:none;stroke:#000}
  .bw path,.bw circle,.bw ellipse,.bw line,.bw polyline,.bw polygon{fill:none;stroke:#000}
  .bw text{fill:#000;stroke:none}
  /* selection visual (editor only; not printed) */
  g[data-draggable].selected path,
  g[data-draggable].selected rect,
  g[data-draggable].selected circle,
  g[data-draggable].selected ellipse,
  g[data-draggable].selected line,
  g[data-draggable].selected polyline,
  g[data-draggable].selected polygon{stroke:#374151}
  g[data-draggable].selected text{text-decoration:underline}
  g[data-draggable].selected{filter:drop-shadow(0 0 6px rgba(37,99,235,0.65));}
  .stage-inspector{display:flex;gap:10px;align-items:center;flex-wrap:wrap;position:relative;padding:8px;background:#fff;border:1px solid #e5e7eb;border-radius:6px}
  .stage-inspector .connection-chain{order:-1;flex-basis:100%;margin-bottom:4px}
  /* Stage frame & resize handles */
  #stageFrame{outline:3px solid #000;pointer-events:none}
  #stageFrame .stage-handle{position:absolute;width:16px;height:16px;background:#000;border:2px solid #fff;border-radius:4px;z-index:85;pointer-events:auto;box-shadow:0 0 0 1px #000}
  #stageFrame .stage-handle.tl{top:-10px;left:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle.tr{top:-10px;right:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.bl{bottom:-10px;left:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.br{bottom:-10px;right:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle:active{background:#374151}
  .drag-assign-handle{transition:all 0.2s ease}
  .drag-assign-handle:hover{transform:scale(1.1);box-shadow:0 4px 12px rgba(0,0,0,0.4) !important}
  .drag-assign-handle:active{transform:scale(0.95);cursor:grabbing !important}
  #stageSvgFull{pointer-events:auto}
  .stage-inspector .muted{color:#6b7280;font-size:13px}
  .gear-wrap{margin-top:8px}
  .gear-wrap textarea{width:100%;min-height:42px}
  /* Global print FAB */
  .print-fab{position:fixed;right:18px;bottom:18px;z-index:70;border-radius:999px;padding:12px 16px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
  @media print{ .print-fab{display:none} }
  /* Print-specific tweaks for tech/stage so content stays on page */
  @media print{
    #sheetTech{width:8.5in;max-width:8.5in;padding:0.5in}
    #sheetTech .tech-table th,#sheetTech .tech-table td{font-size:9pt;padding:3px 4px}
    #stagePrint svg{max-height:6.5in;max-width:7.5in;width:100%;height:auto}
    #stagePrint{overflow:hidden}
  }
  /* Touch optimizations */
  #stageSvgFull{ touch-action:none; }
  .stage-canvas{ -webkit-user-select:none; user-select:none; }
  /* Global sticky actions (top-left) */
  .global-actions{position:sticky;top:0;z-index:60;display:flex;gap:8px;flex-wrap:wrap;padding:6px 0 4px 0;margin:0 0 8px 0;background:rgba(249,250,251,0.96);backdrop-filter:blur(2px);min-height:44px}
  @media print{ .global-actions{display:none} }
  /* Database: horizontal scroll on narrow screens */
  @media (max-width: 768px){
    #dbList{overflow-x:auto;overflow-y:visible}
    .db-row{min-width:900px}
    /* Setlist page: stack columns vertically on mobile with scroll */
    #set{overflow:visible !important;max-height:none !important;height:auto !important}
    #setlistLayout{flex-wrap:wrap !important;overflow:visible !important;height:auto !important;align-items:stretch !important}
    #poolCol{flex:1 1 100% !important;min-width:100% !important;max-height:40vh !important;overflow-y:auto !important;border:2px solid #e5e7eb;border-radius:8px;padding:12px;margin-bottom:12px;background:#f9fafb;position:relative !important;top:auto !important;align-self:auto !important}
    #previewCol{flex:1 1 100% !important;min-width:100% !important;max-width:100% !important;position:relative !important;max-height:none !important;height:auto !important;top:auto !important;align-self:auto !important}
    #optionsCol{flex:1 1 100% !important;position:relative !important;top:auto !important;align-self:auto !important;margin-top:16px;padding-top:16px;border-top:2px solid #e5e7eb;height:auto !important;max-height:none !important}
  }
  /* Missing songs list */
  .missing{margin:8px 0 6px 0;display:flex;flex-wrap:wrap;gap:6px}
  .missing .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #d1d5db;border-radius:999px;padding:4px 8px;background:#fff;font-size:12px;color:#111827}
  .missing .pill .add{background:#065f46;color:#fff;border:none;border-radius:999px;padding:2px 8px;cursor:pointer}
  .missing .pill .add:hover{background:#064e3b}
  /* Tabs styling */
  .tabs{display:flex;gap:4px;margin-bottom:10px;border-bottom:1px solid #374151}
  .tab{border:none;padding:8px 14px;font-size:14px;background:#6b7280;color:#f9fafb;border-top-left-radius:8px;border-top-right-radius:8px;cursor:pointer;font-weight:600;letter-spacing:0.02em;transition:background-color 0.18s ease,color 0.18s ease,box-shadow 0.18s ease,transform 0.12s ease}
  .tab.active{background:#111827;color:#f9fafb;box-shadow:0 3px 10px rgba(15,23,42,0.35)}
  .tab:not(.active):hover{background:#4b5563;transform:translateY(-1px);box-shadow:0 2px 6px rgba(15,23,42,0.25)}
  .tab:active{transform:translateY(0);box-shadow:0 1px 3px rgba(15,23,42,0.2)}
  .tab:focus-visible{outline:2px solid #38bdf8;outline-offset:2px}
  /* Bottom brand bar */
  .brand-bar{position:fixed;bottom:0;left:0;right:0;height:20px;background:#1f2937;color:#e5e7eb;font-size:11px;display:flex;align-items:center;justify-content:center;z-index:80}
  .brand-bar a{color:inherit;text-decoration:none}
  .brand-bar a:hover{text-decoration:underline}
  /* Keep global actions visible in live mode to prevent layout jump */
  .global-actions{display:flex;align-items:center;gap:0;padding:0;margin:0}

  /* Smooth tab content entrance */
  @keyframes tabFadeSlideIn{
    from{opacity:0;transform:translateY(4px)}
    to{opacity:1;transform:translateY(0)}
  }
  .tab-panel-animate{
    animation:tabFadeSlideIn 0.22s ease-out;
  }
  
  /* Live fullscreen lyrics */
  .live-lyrics-overlay{position:fixed;inset:0;background:#020617;color:#e5e7eb;z-index:90;display:none;flex-direction:column}
  .live-lyrics-overlay.open{display:flex}
  .live-lyrics-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px 10px 60px;background:#0b1120;border-bottom:1px solid #1f2937}
  .live-lyrics-title{font-weight:700;font-size:16px;margin-right:auto;margin-left:10px}
  .live-lyrics-main{flex:1 1 auto;overflow:auto;padding:16px;display:flex;align-items:flex-start;justify-content:center}
  .live-lyrics-body{white-space:pre-wrap;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;font-size:20px;line-height:1.5;text-align:center;max-width:1100px;margin:0 auto}
  .live-lyrics-play{padding:8px 14px;border-radius:999px;border:none;background:#22c55e;color:#022c22;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-stop{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-exit{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer;margin-right:16px}
  .live-lyrics-prev,.live-lyrics-next{padding:8px 14px;border-radius:999px;border:none;background:#475569;color:#f9fafb;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-prev:hover,.live-lyrics-next:hover{background:#64748b}
  .live-lyrics-prev:disabled,.live-lyrics-next:disabled{opacity:0.4;cursor:not-allowed}
  @media (max-width:768px){
    .live-lyrics-body{font-size:18px}
  }
  /* Live tab theming */
  body.live-dark #live{background:#020617;color:#e5e7eb}
  body.live-dark #liveList{background:#020617;border-color:#1f2937}
  body.live-dark #liveList .live-row{border-bottom-color:#111827}
  body.live-dark #liveLyrics{background:#020617;border-color:#1f2937;color:#e5e7eb}
  body.live-dark .tab[data-tab="live"].active{background:#0f172a;color:#f9fafb}
  /* Desktop inline live controls stick to top while scrolling */
  #liveLyrics{position:relative}
  #liveLyrics #liveInlineControls{position:sticky;top:0;z-index:2;padding:6px 4px;margin:-12px -12px 8px -12px;border-bottom:1px solid #e5e7eb;background:linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0));backdrop-filter:saturate(1.2) blur(2px)}
  body.live-dark #liveLyrics #liveInlineControls{border-bottom-color:#1f2937;background:linear-gradient(180deg, rgba(2,6,23,0.96), rgba(2,6,23,0))}
  /* Live mode: hide brand bar and any open stage/notes modals for distraction-free view */
  body.live-mode .brand-bar{display:none}
  body.live-mode #stageModal, body.live-mode #notesModal{display:none !important}
  
  /* File menu dropdown - fixed at top left */
  .file-menu-container{position:fixed;top:8px;left:12px;z-index:200}
  .file-menu-btn{padding:4px 8px;background:#065f46;border:1px solid #064e3b;color:#fff;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;transition:background 0.2s}
  .file-menu-btn:hover{background:#047857}
  .file-menu-dropdown{display:none;position:absolute;top:100%;left:0;margin-top:4px;background:#fff;border:1px solid #d1d5db;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.25);min-width:200px;z-index:201}
  .file-menu-dropdown.open{display:block}
  .file-menu-item{padding:10px 16px;cursor:pointer;font-size:14px;color:#1f2937;border-bottom:1px solid #f3f4f6;transition:background 0.15s}
  .file-menu-item:last-child{border-bottom:none}
  .file-menu-item:hover{background:#f0f9ff}
  .file-menu-separator{height:1px;background:#e5e7eb;margin:4px 0}
  
  /* Global date selector header strip */
  .date-header{
    position:sticky;
    top:0;
    z-index:70;
    background:linear-gradient(135deg,#1e293b 0%,#334155 100%);
    border-bottom:2px solid #0ea5e9;
    padding:6px 12px;
    display:flex;
    align-items:center;
    gap:12px;
    overflow-x:auto;
    overflow-y:hidden;
    box-shadow:0 2px 8px rgba(0,0,0,0.15);
    position:relative;
  }
  /* Date box context menu */
  .date-context-menu{
    position:fixed;
    background:#fff;
    border:1px solid #d1d5db;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:10000;
    min-width:180px;
    padding:6px 0;
  }
  .date-context-menu button{
    display:block;
    width:100%;
    padding:10px 16px;
    border:none;
    background:none;
    text-align:left;
    cursor:pointer;
    font-size:14px;
    color:#1f2937;
    transition:background 0.15s;
  }
  .date-context-menu button:hover{
    background:#f3f4f6;
  }
  .date-context-menu button.danger{
    color:#dc2626;
  }
  .date-context-menu button.danger:hover{
    background:#fee2e2;
  }
  
  /* Activity chips and timeline */
  .activity-chip{
    user-select:none;
    transition:all 0.2s;
    touch-action:none;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
  }
  .activity-chip:active{
    transform:scale(0.95);
    opacity:0.8;
  }
  .activity-chip.touch-dragging{
    position:fixed;
    z-index:99999;
    pointer-events:none;
    opacity:0.9;
    transform:scale(1.1);
    box-shadow:0 8px 24px rgba(0,0,0,0.3);
  }
  .timeline-slot.touch-drop-target{
    background:#bfdbfe !important;
    box-shadow:inset 0 0 0 2px #3b82f6;
  }
  .timeline-slot.stuck-slot{
    background:#dcfce7 !important;
    box-shadow:inset 0 0 0 3px #22c55e;
  }
  .timeline-slot:hover{
    background:#f9fafb !important;
  }
  .itinerary-preview-block{
    transition:height 0.15s ease-out;
  }
  .itinerary-item{
    overflow:hidden;
  }
  .itinerary-item:hover{
    z-index:20 !important;
  }
  
  .date-header-label{
    color:#e5e7eb;
    font-size:12px;
    font-weight:700;
    white-space:nowrap;
    flex-shrink:0;
  }
  .current-date-display{
    color:#0ea5e9;
    font-size:14px;
    font-weight:800;
    white-space:nowrap;
    flex-shrink:0;
    padding:4px 12px;
    background:rgba(14,165,233,0.15);
    border-radius:6px;
    border:1px solid rgba(14,165,233,0.3);
  }
  /* Act selector styling */
  .act-selector{
    font-weight:600;
    padding:4px 10px;
    border-radius:6px;
    transition:background 0.15s;
  }
  .act-selector:hover{
    background:rgba(255,255,255,0.15);
  }
  .date-boxes-container{
    display:flex;
    gap:4px;
    flex:1;
    overflow-x:auto;
    padding:2px 0;
    scroll-behavior:smooth;
  }
  .date-box{
    min-width:70px;
    width:70px;
    height:48px;
    background:#f8fafc;
    border:2px solid #cbd5e1;
    border-radius:6px;
    cursor:pointer;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    font-size:10px;
    font-weight:600;
    color:#1e293b;
    position:relative;
    transition:all 0.15s;
    flex-shrink:0;
    padding:3px;
  }
  .date-box:hover{
    background:#e0f2fe;
    border-color:#0ea5e9;
    transform:translateY(-2px);
    box-shadow:0 2px 6px rgba(14,165,233,0.3);
  }
  .date-box.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    font-weight:800;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.has-gig{
    border-color:#22c55e;
    background:#d1fae5;
  }
  .date-box.has-gig.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  /* Status-based coloring */
  .date-box.status-complete{
    background:#d1fae5;
    border-color:#22c55e;
  }
  .date-box.status-complete.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-incomplete{
    background:#fed7aa;
    border-color:#fb923c;
  }
  .date-box.status-incomplete.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-cancelled{
    background:#fee2e2;
    border:2px dashed #dc2626;
    opacity:0.7;
  }
  .date-box.status-cancelled.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-today{
    background:#dbeafe;
    border-color:#3b82f6;
    box-shadow:0 0 0 2px #93c5fd;
  }
  .date-box.status-today.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-past{
    background:#f1f5f9;
    border-color:#cbd5e1;
    opacity:0.6;
  }
  .date-box.status-past.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-gig{
    background:#d1fae5;
    border-color:#22c55e;
  }
  .date-box.tour-gig.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-drive{
    background:#fef08a;
    border-color:#facc15;
  }
  .date-box.tour-drive.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-rest{
    background:#fed7aa;
    border-color:#fb923c;
  }
  .date-box.tour-rest.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-home{
    background:#f8fafc;
    border-color:#cbd5e1;
  }
  .date-box.tour-home.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-rehearse,
  .date-box.tour-party,
  .date-box.tour-record,
  .date-box.tour-radio,
  .date-box.tour-tv,
  .date-box.tour-dj,
  .date-box.tour-audition,
  .date-box.tour-dressrehearsal,
  .date-box.tour-custom{
    background:#e9d5ff;
    border-color:#a855f7;
  }
  .date-box.tour-rehearse.active,
  .date-box.tour-party.active,
  .date-box.tour-record.active,
  .date-box.tour-radio.active,
  .date-box.tour-tv.active,
  .date-box.tour-dj.active,
  .date-box.tour-audition.active,
  .date-box.tour-dressrehearsal.active,
  .date-box.tour-custom.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  /* Cancelled shows */
  .date-box.tour-cancelled{
    background:#fee2e2;
    border:2px dashed #dc2626;
    opacity:0.7;
  }
  .date-box.tour-cancelled.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box .date-icon{
    font-size:14px;
    line-height:1;
    margin-top:2px;
  }
  .drive-line{
    position:absolute;
    top:50%;
    left:-4px;
    right:-4px;
    height:3px;
    background:#facc15;
    z-index:-1;
  }
  .date-box .date-num{
    font-size:14px;
    line-height:1;
    margin-bottom:1px;
  }
  .date-box .date-month{
    font-size:8px;
    line-height:1;
    text-transform:uppercase;
    opacity:0.75;
  }
  .date-box .date-symbol{
    position:absolute;
    top:2px;
    right:2px;
    font-size:10px;
    line-height:1;
  }
  .date-box .date-count{
    position:absolute;
    bottom:2px;
    right:3px;
    font-size:9px;
    line-height:1;
    background:#374151;
    color:#f9fafb;
    border-radius:999px;
    min-width:14px;
    height:14px;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 3px;
  }
  .date-box.has-gig .date-count{
    background:#16a34a;
    color:#f0fdf4;
  }
  .date-box .date-city{
    font-size:8px;
    line-height:1.1;
    text-align:center;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    max-width:100%;
    margin-top:1px;
  }
  .date-box.dragging{
    opacity:0.5;
    transform:scale(0.95);
    cursor:grabbing;
  }
  .date-box.drag-over{
    outline:3px dashed #0ea5e9;
    outline-offset:2px;
  }
  .date-boxes-container::-webkit-scrollbar{
    height:6px;
  }
  .date-boxes-container::-webkit-scrollbar-track{
    background:#475569;
    border-radius:3px;
  }
  .date-boxes-container::-webkit-scrollbar-thumb{
    background:#0ea5e9;
    border-radius:3px;
  }
  @media print{
    .date-header{display:none}
  }
  </style>
</head>
<body>
  <!-- Fixed File Menu at top left -->
  <div class="file-menu-container">
    <button class="file-menu-btn" id="fileMenuBtn" title="File Menu">‚öôÔ∏è</button>
    <div class="file-menu-dropdown" id="fileMenuDropdown">
      <div class="file-menu-item" id="openPrintOptionsTop">üñ®Ô∏è Print...</div>
      <div class="file-menu-item" id="shareBtn">üì§ Share</div>
      <div class="file-menu-separator"></div>
      <div class="file-menu-item" id="saveProfile">Save Profile (.BAND)</div>
      <div class="file-menu-item" id="loadProfile">Load Profile (.BAND)</div>
      <div class="file-menu-separator"></div>
      <div class="file-menu-item" id="saveSet">Save .SET</div>
      <div class="file-menu-item" id="loadSet">Load .SET</div>
      <div class="file-menu-separator"></div>
      <div class="file-menu-item" id="helpBtn">‚ùì Help</div>
    </div>
    <input type="file" id="loadProfileFile" accept=".band,application/json" style="display:none" />
    <input type="file" id="loadSetFile" accept=".set,application/json" style="display:none" />
  </div>

  <!-- Global date selector strip: permanently visible across top -->
  <div class="date-header" style="padding-left:50px">
    <span class="act-selector" id="actSelector" style="cursor:pointer;font-weight:600;color:#60a5fa;padding:4px 12px;border-radius:6px" title="Click to switch band">Select Band...</span>
    <div class="date-boxes-container" id="dateBoxesContainer">
      <!-- Date boxes populated by JS -->
    </div>
  </div>
  
  <div class="wrap" style="padding-bottom:28px">
    <!-- Tabs row -->
    <div style="display:flex;align-items:center;gap:12px;margin:16px 0">
      <div class="tabs" style="margin:0;flex:1">
        <button class="tab active" data-tab="tour">Calendar</button>
        <button class="tab" data-tab="db">Song Database</button>
        <button class="tab" data-tab="set">Setlist</button>
        <button class="tab" data-tab="adv">Tech / Stage</button>
        <button class="tab" data-tab="live">Live</button>
      </div>
    </div>

    <div class="grid">
      <div class="card" id="db" style="grid-column:1 / -1; width:100%; max-width:100%; overflow:hidden; position:relative;">
        <!-- Database dropzone overlay -->
        <div id="dbDropzone" style="display:none;position:absolute;inset:0;background:rgba(59,130,246,0.15);border:3px dashed #3b82f6;border-radius:8px;z-index:100;pointer-events:none;flex-direction:column;align-items:center;justify-content:center">
          <div style="background:white;padding:24px 48px;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.2);text-align:center">
            <div style="font-size:48px;margin-bottom:12px">üì•</div>
            <div style="font-size:18px;font-weight:600;color:#1e40af">Drop files to import songs</div>
            <div style="font-size:13px;color:#64748b;margin-top:8px">Audio, images, PDFs, spreadsheets, text files</div>
          </div>
        </div>
        <h2>Song Database</h2>
          <div style="margin:12px 0 16px 0;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <input type="text" id="dbSearch" placeholder="Search songs..." style="flex:1 1 200px;padding:8px;border:1px solid #d1d5db;border-radius:4px;font-size:14px">
            <label style="font-size:12px;color:#64748b">Sort by:</label>
            <select id="dbSort" style="padding:6px 8px;border:1px solid #d1d5db;border-radius:4px">
              <option value="added">Order Added</option>
              <option value="alpha" selected>Alpha by Song</option>
              <option value="band">Alpha by Band</option>
              <option value="mood">Mood Order</option>
              <option value="rating">Audience Rating</option>
              <option value="mostUsed">Most Selected</option>
              <option value="leastUsed">Least Selected</option>
            </select>
          </div>
          <div style="margin:8px 0;display:flex;flex-wrap:wrap;gap:12px;align-items:center;font-size:13px">
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterCovers"> Covers</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterOriginals"> Originals</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasLyrics"> Has Lyrics</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterKaraoke"> Karaoke</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasAudio"> Has Audio</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasURL"> Has URL</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterInSet"> In Current Set</label>
            <label style="font-size:12px;color:#64748b;margin-left:8px">Mood:</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterUpbeat"> Upbeat</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHappy"> Happy</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterEnergetic"> Energetic</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterMellow"> Mellow</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterSad"> Sad</label>
            <span id="customMoodFilters"></span>
          </div>
        <!-- Profile buttons moved to global-actions -->
        <div class="list" id="dbList" style="width:100%; overflow-x:auto; max-width:100%;"></div>
        <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
          <button class="btn" id="addCustomColumn" style="background:#065f46;color:#f9fafb;border:1px solid #064e3b">+ Add Custom Column</button>
          <div style="display:flex;gap:12px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer"><input type="checkbox" id="clearDBLock" style="width:18px;height:18px"><span style="font-size:14px">üîì Unlock Clear</span></label>
            <button class="btn danger" id="clearDB" style="background:#374151;color:#f9fafb">Clear Database</button>
          </div>
        </div>
        <div class="import-block" id="importBlock" style="margin-top:22px;padding:14px;border:1px solid #e2e8f0;border-radius:8px;background:#f8fafc;position:relative">
          <!-- Spinning vinyl overlay -->
          <div id="importSpinner" style="display:none;position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(248,250,252,0.95);z-index:100;flex-direction:column;align-items:center;justify-content:center;border-radius:8px">
            <div style="width:80px;height:80px;border-radius:50%;background:linear-gradient(135deg,#1f2937 0%,#111827 50%,#1f2937 100%);position:relative;animation:spin-vinyl 1.5s linear infinite;box-shadow:0 4px 12px rgba(0,0,0,0.3)">
              <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:24px;height:24px;border-radius:50%;background:linear-gradient(135deg,#dc2626 0%,#991b1b 100%);border:2px solid #fef2f2"></div>
              <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:6px;height:6px;border-radius:50%;background:#1f2937"></div>
              <div style="position:absolute;top:10%;left:50%;transform:translateX(-50%);width:60%;height:1px;background:rgba(255,255,255,0.1)"></div>
              <div style="position:absolute;top:25%;left:50%;transform:translateX(-50%);width:50%;height:1px;background:rgba(255,255,255,0.08)"></div>
              <div style="position:absolute;top:75%;left:50%;transform:translateX(-50%);width:50%;height:1px;background:rgba(255,255,255,0.08)"></div>
              <div style="position:absolute;top:90%;left:50%;transform:translateX(-50%);width:60%;height:1px;background:rgba(255,255,255,0.1)"></div>
            </div>
            <div id="importSpinnerText" style="margin-top:16px;font-size:14px;font-weight:600;color:#374151">Processing...</div>
          </div>
          <style>@keyframes spin-vinyl{from{transform:rotate(0deg)}to{transform:rotate(360deg)}}</style>
          <h3 style="margin:0 0 10px;font-size:18px">Import Songs (OCR / Paste)</h3>
          <textarea id="importText" rows="4" placeholder="Paste lines e.g.\nSong Title - Am (Capo 2)\nAnother Song G Capo 3\nThird Song - F#m" style="width:100%;resize:vertical;font-family:monospace"></textarea>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center">
            <input type="file" id="importFile" accept=".txt,.pdf,.csv,.xls,.xlsx,.ods,image/*,audio/*,video/*,.mp3,.wav,.flac,.m4a,.aac,.ogg,.wma,.mp4,.avi,.mov,.mkv" multiple style="flex:1 1 240px" />
            <label><input type="checkbox" id="importFolder" style="width:auto;margin-right:4px">Folder</label>
            <button class="btn" id="importParseBtn" type="button">Extract</button>
            <button class="btn secondary" id="importCommitBtn" type="button" disabled>Add Songs</button>
          </div>
          <div id="importStatus" style="margin-top:8px;font-size:12px;color:#64748b"></div>
          <div id="importPreview" style="margin-top:10px;font-size:13px;line-height:1.4"></div>
          <div style="margin-top:10px;font-size:11px;color:#94a3b8">Supports: text files, PDF (OCR), images (OCR with enhanced handwriting detection), audio files (MP3/WAV/FLAC/M4A/AAC/OGG/WMA extracts title/artist/duration/embedded lyrics), video files (MP4/AVI/MOV/MKV extracts metadata), spreadsheets (CSV/XLS/XLSX/ODS). <strong>Smart matching:</strong> When scanning folders, automatically matches lyrics files (TXT/PDF/images) with audio files by name and merges them. Keys & capo detected heuristically. Review before importing.</div>
        </div>
      </div>

      <!-- Combined Setlist + Generator Tab -->
      <div class="card" id="set" style="display:none;grid-column:1 / -1;width:100%;overflow:auto;max-height:calc(100vh - 140px)">
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
          <h2>Setlist</h2>
          <button id="saveSetlistPresetBtn" class="btn" style="padding:6px 12px;font-size:13px;background:#c2410c;color:#fff" title="Save current setlist as a reusable preset">‚≠ê Preset</button>
        </div>
        <div id="setlistLayout" style="display:flex;flex-wrap:nowrap;gap:24px;align-items:flex-start;margin-top:0;width:100%">
          <div id="poolCol" style="flex:0 0 260px;display:flex;flex-direction:column;gap:12px;align-items:flex-start">
            <h3>Song Pool</h3>
            <div id="poolControls" style="display:flex;flex-direction:column;gap:6px;width:100%">
              <input type="text" id="poolSearch" placeholder="Search songs..." style="width:100%;padding:6px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Type</label>
                <select id="poolType" style="flex:1 1 auto;min-width:120px">
                  <option value="all" selected>All</option>
                  <option value="originals">Originals</option>
                  <option value="covers">Covers</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Sort</label>
                <select id="poolSort" style="flex:1 1 auto;min-width:140px">
                  <option value="alpha" selected>Alphabetical</option>
                  <option value="band">Band Name</option>
                  <option value="mood">Mood Order</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Mood</label>
                <select id="poolMood" style="flex:1 1 auto;min-width:140px">
                  <option value="all" selected>All</option>
                  <option value="upbeat">Upbeat</option>
                  <option value="happy">Happy</option>
                  <option value="energetic">Energetic</option>
                  <option value="mellow">Mellow</option>
                  <option value="sad">Sad</option>
                </select>
              </div>
            </div>
            <div id="poolOriginals" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolCoversHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Covers</h4>
            <div id="poolCovers" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolBreaksHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Break</h4>
            <div id="poolBreaks" style="display:flex;flex-direction:column;gap:6px"></div>
          </div>
          <div id="previewCol" style="flex:1 1 auto;min-width:560px;max-width:880px;position:sticky;top:12px;align-self:flex-start;max-height:calc(100vh - 24px);display:flex;flex-direction:column">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
              <h3 style="margin:0">Preview</h3>
              <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#64748b;cursor:pointer" title="Lock setlist to prevent accidental edits">
                <input type="checkbox" id="setlistLockCheckbox" style="cursor:pointer" />
                üîí Lock
              </label>
            </div>
            <div style="position:relative">
              <div id="setlistDragHandle" class="drag-assign-handle" title="Drag to assign this setlist to a calendar date" style="position:absolute;top:8px;right:8px;width:32px;height:32px;background:#000;border:2px solid #fff;border-radius:6px;cursor:grab;display:flex;align-items:center;justify-content:center;z-index:100;box-shadow:0 2px 8px rgba(0,0,0,0.3);pointer-events:auto">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M18 8.5V8a2 2 0 0 0-4 0v1M14 9.5V7a2 2 0 0 0-4 0v4M10 11V4a2 2 0 0 0-4 0v10.5" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M18 8.5a2 2 0 0 1 2 2v1.5c0 4.5-3 8-8 8s-6-3-7-5l-2.5-4a1.5 1.5 0 0 1 2.5-1.5L7 12" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="sheet" id="sheetInline">
                <div class="hdr" id="hdrInline"></div>
                <div class="songs" id="songsInline"></div>
              </div>
            </div>
            <div style="margin-top:10px;font-size:12px;color:#64748b">Drag songs from the pool directly into the preview. Drag rows to reorder. Double‚Äëclick a title to add/edit notes. Drag a Break chip to insert a break.</div>
          </div>
          
          <!-- Display Options moved to right column -->
          <div id="optionsCol" style="flex:0 0 320px;display:flex;flex-direction:column;gap:12px;position:sticky;top:12px;align-self:flex-start">
            <!-- Generator Settings -->
            <div style="padding:14px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb">
              <h4 style="margin:0 0 10px;font-size:16px">Generator Settings</h4>
              <div style="display:flex;flex-direction:column;gap:8px">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                  <div class="field"><label style="font-size:12px">Set length (min)</label><input id="gLen" type="number" min="10" value="60" style="width:100%"></div>
                  <div class="field"><label style="font-size:12px">Break length (min)</label><input id="gBreakLen" type="number" min="5" value="15" style="width:100%"></div>
                </div>
                <div class="field"><label style="font-size:12px">Cover ratio</label>
                  <select id="gCover" style="width:100%">
                    <option value="0">100% Originals</option>
                    <option value="25">25% Covers</option>
                    <option value="50" selected>50/50</option>
                    <option value="75">75% Covers</option>
                    <option value="90">90% Covers</option>
                    <option value="100">100% Covers</option>
                  </select>
                </div>
                <div class="field"><label style="font-size:12px">Breaks</label>
                  <select id="gBreaks" style="width:100%">
                    <option value="0">No breaks</option>
                    <option value="1">1 break</option>
                    <option value="2">2 breaks</option>
                    <option value="3">3 breaks</option>
                  </select>
                </div>
                <div class="field"><label style="font-size:12px">Mood</label>
                  <select id="gMood" style="width:100%">
                    <option value="mixed">Mixed</option>
                    <option value="upbeat">Upbeat</option>
                    <option value="happy">Happy</option>
                    <option value="mellow">Mellow</option>
                    <option value="energetic">Energetic</option>
                    <option value="sad">Sad</option>
                  </select>
                </div>
                <div class="field"><label style="display:inline-flex;align-items:center;gap:4px;font-size:12px"><input type="checkbox" id="gEncore"> Include Encore</label></div>
                <div class="field">
                  <label style="font-size:12px;font-weight:600;margin-bottom:4px;display:block">Grouping Rules</label>
                  <div style="display:flex;flex-direction:column;gap:4px;font-size:12px">
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepCovers"> Keep Covers Together</label>
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepKeys"> Keep Keys Together</label>
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepMoods"> Keep Moods Together</label>
                  </div>
                </div>
              </div>
              <div style="margin-top:12px;display:flex;gap:8px">
                <button class="btn" id="genBtn" style="flex:1">Generate</button>
                <button class="btn" id="newSetBtn" type="button" style="flex:1">New Setlist</button>
                <button class="btn danger" id="clearSet" type="button" style="flex:1">Clear</button>
              </div>
              <div id="genStats" style="margin-top:8px;color:#64748b;font-size:11px"></div>
            </div>
            
            <!-- Setlist Display Options -->
            <div style="padding:14px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb">
              <h4 style="margin:0 0 10px;font-size:16px">Setlist Display Options</h4>
          
          <div style="margin-bottom:12px">
            <label style="font-weight:600;font-size:13px;margin-bottom:6px;display:block">Display Columns</label>
            <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:13px">
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_artist"> Artist</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_key" checked> Key</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_capo" checked> Capo</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_bpm"> BPM</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_notes"> Notes</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_lyrics"> Lyrics Preview</label>
              <span id="setColCustom"></span>
            </div>
          </div>
          
          <div style="margin-bottom:12px">
            <label style="font-weight:600;font-size:13px;margin-bottom:6px;display:block">Page Layout</label>
            <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:13px">
              <label style="display:inline-flex;align-items:center;gap:6px">
                Paper: 
                <select id="paperFormat" style="padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
                  <option value="letter">Letter 8.5√ó11</option>
                  <option value="a4">A4 210√ó297mm</option>
                </select>
              </label>
            </div>
          </div>
          
              <div style="margin-top:8px;font-size:11px;color:#64748b">Control which fields appear in the setlist preview and print output.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="adv" style="display:none;padding-top:0;margin-top:12px">
        <h2 style="margin-bottom:12px">Tech / Stage</h2>
        <div class="row" style="gap:8px;margin-bottom:12px;padding:0">
          <button class="btn" id="stageToggle" onclick="toggleStageAndNotes()">Stage Plot</button>
          <button class="btn" id="stagePresetBtnTop" style="padding:6px 12px;font-size:13px;background:#065f46;color:#f9fafb;border:1px solid #064e3b">PRESET</button>
        </div>
      </div>

      <!-- Tour Manager: date-based scheduling, itinerary, and location services -->
      <div id="tour" style="display:none;grid-column:1 / -1;width:100%;margin-top:12px">
        
        <!-- Large Date/Venue Header with Day Navigation -->
        <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:20px;margin-bottom:12px">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:20px">
            <!-- Large Date and Venue Display -->
            <div style="flex:1">
              <div id="tourHeaderDate" style="font-size:28px;font-weight:700;color:#111827;line-height:1.2;margin-bottom:4px">Select a date</div>
              <div id="tourHeaderVenue" style="font-size:20px;font-weight:500;color:#64748b;line-height:1.3">No venue</div>
            </div>
            
            <!-- Previous / Next / Today buttons -->
            <div style="display:flex;gap:8px;align-items:center">
              <button id="tourYesterdayBtn" class="btn" style="padding:12px 20px;font-size:16px;font-weight:600" title="Go to the previous date that has a show or event">‚óÄ Previous Show</button>
              <button id="tourTomorrowBtn" class="btn" style="padding:12px 20px;font-size:16px;font-weight:600" title="Go to the next date that has a show or event">Next Show ‚ñ∂</button>
              <button id="tourTodayBtn" class="btn primary" style="padding:12px 20px;font-size:14px;margin-left:8px" title="Jump to today. If today has no date yet, create one.">Today</button>
            </div>
          </div>
        </div>
        
        <!-- Main Tour Content: Compact Layout -->
        <div id="tourContent" style="display:flex;flex-direction:column;gap:12px">
          
          <!-- Row 1: Gig Details (1) + Map (2) -->
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            
            <!-- 1. Gig Details - Compact Form -->
            <div class="card" style="padding:12px">
              <div style="font-size:13px;font-weight:600;margin-bottom:8px;color:var(--accent)">üìç Gig Details</div>
              <div id="tourNoSelection" style="color:#64748b;font-size:12px">Select or add a date</div>
              <div id="tourDateDetails" style="display:none">
                <div style="display:flex;flex-direction:column;gap:6px">
                  <input type="date" id="tourDate" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <input type="text" id="tourVenue" placeholder="Venue name" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <input type="text" id="tourAddress" placeholder="Address" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
                    <input type="time" id="tourLoadIn" placeholder="Load-In" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                    <input type="time" id="tourShowTime" placeholder="Show Time" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  </div>
                  <input type="text" id="tourBand" placeholder="Band/Artist (click header to switch)" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <select id="tourSetlistSelect" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px">
                    <option value="current">Use Current Setlist</option>
                    <option value="custom">Custom Setlist</option>
                  </select>
                  <select id="tourStagePlotSelect" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px">
                    <option value="current">Use Current Stage</option>
                    <option value="custom">Custom Stage</option>
                  </select>
                  <div style="display:flex;gap:6px;margin-top:4px">
                    <button id="tourSaveDate" class="btn primary" style="flex:1;padding:6px;font-size:12px">Save</button>
                    <button id="tourDeleteDate" class="btn danger" style="padding:6px;font-size:12px">Delete</button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 2. Map -->
            <div class="card" style="padding:12px">
              <div style="font-size:13px;font-weight:600;margin-bottom:8px">üó∫Ô∏è Location</div>
              <div id="tourMapPlaceholder" style="width:100%;height:200px;background:#f1f5f9;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#64748b;font-size:12px;cursor:pointer" title="Click to load map">
                Tap to load map for this address
              </div>
            </div>
          </div>
          
          <!-- Row 2: Itinerary (3) + Right Column (4/5/6) -->
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            
            <!-- 3. Itinerary -->
            <div class="card" style="padding:12px">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
                <div style="font-size:13px;font-weight:600">üóìÔ∏è Daily Itinerary</div>
              </div>
              <div id="tourItineraryContent">
                <div id="tourItineraryTimeline" style="overflow-y:auto;max-height:400px;padding-left:26px;position:relative">
                  <!-- Timeline items -->
                </div>
              </div>
            </div>
            
            <!-- Right Column: 4. Chips, 5. Stage, 6. Setlist -->
            <div style="display:flex;flex-direction:column;gap:12px">
              
              <!-- 4. Activity Chips -->
              <div class="card" style="padding:12px">
                <div style="font-size:13px;font-weight:600;margin-bottom:8px">üìã Activity Chips</div>
                
                <!-- Tour Activities -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">GIG DAY</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="rehearsal" data-duration="120" data-color="#8b5cf6" style="padding:4px 8px;background:#ede9fe;border:1px solid #c4b5fd;border-radius:4px;font-size:10px;cursor:move">üé∏ Rehearsal</div>
                    <div class="activity-chip" draggable="true" data-activity="soundcheck" data-duration="60" data-color="#3b82f6" style="padding:4px 8px;background:#dbeafe;border:1px solid #93c5fd;border-radius:4px;font-size:10px;cursor:move">üéöÔ∏è Soundcheck</div>
                    <div class="activity-chip" draggable="true" data-activity="loadin" data-duration="45" data-color="#6366f1" style="padding:4px 8px;background:#e0e7ff;border:1px solid #a5b4fc;border-radius:4px;font-size:10px;cursor:move">üì¶ Load-In</div>
                    <div class="activity-chip" draggable="true" data-activity="gig" data-duration="180" data-color="#ec4899" style="padding:4px 8px;background:#fce7f3;border:1px solid #f9a8d4;border-radius:4px;font-size:10px;cursor:move">üé§ Gig</div>
                  </div>
                </div>
                
                <!-- Travel -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">TRAVEL</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="drive" data-duration="120" data-color="#f59e0b" style="padding:4px 8px;background:#fef3c7;border:1px solid #fcd34d;border-radius:4px;font-size:10px;cursor:move">üöó Drive</div>
                    <div class="activity-chip" draggable="true" data-activity="home" data-duration="0" data-color="#10b981" style="padding:4px 8px;background:#d1fae5;border:1px solid #6ee7b7;border-radius:4px;font-size:10px;cursor:move">üè† Home</div>
                    <div class="activity-chip" draggable="true" data-activity="sleep" data-duration="480" data-color="#64748b" style="padding:4px 8px;background:#f1f5f9;border:1px solid #cbd5e1;border-radius:4px;font-size:10px;cursor:move">üò¥ Sleep</div>
                  </div>
                </div>
                
                <!-- Meals -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">MEALS</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="breakfast" data-duration="45" data-color="#fbbf24" style="padding:4px 8px;background:#fef3c7;border:1px solid #fde047;border-radius:4px;font-size:10px;cursor:move">ü•ê Breakfast</div>
                    <div class="activity-chip" draggable="true" data-activity="lunch" data-duration="60" data-color="#f97316" style="padding:4px 8px;background:#ffedd5;border:1px solid#fdba74;border-radius:4px;font-size:10px;cursor:move">üçî Lunch</div>
                    <div class="activity-chip" draggable="true" data-activity="dinner" data-duration="90" data-color="#dc2626" style="padding:4px 8px;background:#fee2e2;border:1px solid #fca5a5;border-radius:4px;font-size:10px;cursor:move">üçΩÔ∏è Dinner</div>
                    <div class="activity-chip" draggable="true" data-activity="snacks" data-duration="15" data-color="#84cc16" style="padding:4px 8px;background:#ecfccb;border:1px solid #bef264;border-radius:4px;font-size:10px;cursor:move">üçø Snacks</div>
                  </div>
                </div>
                
                <!-- Social -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">SOCIAL</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="meeting" data-duration="60" data-color="#06b6d4" style="padding:4px 8px;background:#cffafe;border:1px solid#67e8f9;border-radius:4px;font-size:10px;cursor:move">üíº Meeting</div>
                    <div class="activity-chip" draggable="true" data-activity="party" data-duration="180" data-color="#d946ef" style="padding:4px 8px;background:#fae8ff;border:1px solid #f0abfc;border-radius:4px;font-size:10px;cursor:move">üéâ Party</div>
                  </div>
                </div>
                
                <!-- Places Search -->
                <div style="margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">FIND PLACES</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap;margin-bottom:6px">
                    <button class="btn" data-search="hotels" style="padding:3px 6px;font-size:9px">Hotels</button>
                    <button class="btn" data-search="music stores" style="padding:3px 6px;font-size:9px">Music</button>
                    <button class="btn" data-search="rehearsal studios" style="padding:3px 6px;font-size:9px">Rehearsal</button>
                    <button class="btn" data-search="recording studios" style="padding:3px 6px;font-size:9px">Recording</button>
                    <button class="btn" data-search="radio stations" style="padding:3px 6px;font-size:9px">Radio</button>
                    <button class="btn" data-search="tv stations" style="padding:3px 6px;font-size:9px">TV</button>
                    <button class="btn" data-search="bars" style="padding:3px 6px;font-size:9px">Bars</button>
                    <button class="btn" data-search="restaurants" style="padding:3px 6px;font-size:9px">Food</button>
                    <button class="btn" data-search="cafes" style="padding:3px 6px;font-size:9px">Cafes</button>
                    <button class="btn" data-search="gas stations" style="padding:3px 6px;font-size:9px">Gas</button>
                    <button class="btn" data-search="print shops" style="padding:3px 6px;font-size:9px">Print</button>
                    <button class="btn" data-search="instrument repair" style="padding:3px 6px;font-size:9px">Repair</button>
                    <button class="btn" data-search="pa rentals" style="padding:3px 6px;font-size:9px">PA Rental</button>
                    <button class="btn" data-search="pharmacies" style="padding:3px 6px;font-size:9px">Pharmacy</button>
                  </div>
                  <div style="display:flex;gap:3px;margin-bottom:6px">
                    <input type="text" id="tourSearchLocation" placeholder="Search..." style="flex:1;padding:4px;border:1px solid #d1d5db;border-radius:4px;font-size:10px" />
                    <button id="tourSearchBtn" class="btn" style="padding:4px 12px;font-size:10px;font-weight:600">Search</button>
                    <button id="tourAddCustomBtn" class="btn" style="padding:4px 8px;font-size:14px;font-weight:600" title="Add custom search button">+</button>
                  </div>
                  <div id="customSearchButtons" style="display:flex;gap:3px;flex-wrap:wrap;margin-bottom:6px">
                    <!-- Custom search buttons -->
                  </div>
                  <div id="tourSearchResults" style="display:flex;flex-direction:column;gap:3px;max-height:100px;overflow-y:auto">
                    <!-- Search results chips -->
                  </div>
                </div>
              </div>
              
              <!-- 5 & 6. Stage Plot + Setlist Preview (side by side) -->
              <div class="card" style="padding:12px">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
                  <!-- Stage Plot -->
                  <div style="cursor:pointer" title="Double-click to edit">
                    <div style="font-size:12px;font-weight:600;margin-bottom:6px">üé∏ Stage</div>
                    <div id="tourStagePreview" style="display:flex;justify-content:center;align-items:center;min-height:100px;max-height:120px;overflow:hidden;border:1px solid #e5e7eb;border-radius:4px;padding:4px">
                      <div style="color:#64748b;font-size:10px">No stage plot</div>
                    </div>
                  </div>
                  
                  <!-- Setlist -->
                  <div style="cursor:pointer" title="Double-click to edit">
                    <div style="font-size:12px;font-weight:600;margin-bottom:6px">üéµ Setlist</div>
                    <div id="tourSetlistPreview" style="max-height:120px;overflow-y:auto;font-size:10px;line-height:1.4;border:1px solid #e5e7eb;border-radius:4px;padding:4px">
                      <div style="color:#64748b">No setlist</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          
          <!-- Calendar Tools Row -->
          <div class="card" style="padding:12px">
            <div style="display:flex;align-items:center;gap:12px">
              <label style="display:flex;align-items:center;gap:6px;font-size:12px">
                <input type="checkbox" id="tourLockCalendar" />
                üîí Lock Calendar (prevent edits)
              </label>
              <button id="tourClearCalendar" class="btn danger" style="margin-left:auto;padding:6px 12px;font-size:12px">üóëÔ∏è Clear Calendar</button>
            </div>
          </div>
          
          <!-- OLD CONTENT HIDDEN BELOW -->
          <div style="display:none">
            <div class="card" style="width:100%">
              <h3 style="margin:0 0 12px 0">Find Nearby Services (OLD)</h3>
              
              <!-- Default Search Buttons -->
              <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px">
                <button class="btn" data-search="hotels">üè® Hotels</button>
                <button class="btn" data-search="music stores">üé∏ Music Stores</button>
                <button class="btn" data-search="rehearsal studios">üéµ Rehearsal</button>
                <button class="btn" data-search="bars">üç∫ Bars</button>
                <button class="btn" data-search="restaurants">üçΩÔ∏è Food</button>
                <button class="btn" data-search="cafes">‚òï Cafes</button>
                <button class="btn" data-search="gas stations">‚õΩ Gas</button>
                <button class="btn" data-search="print shops">üñ®Ô∏è Print</button>
                <button class="btn" data-search="guitar repair">üîß Repairs</button>
                <button class="btn" data-search="pharmacies">üíä Pharmacy</button>
              </div>
              
              <!-- Custom Search -->
              <div style="margin-bottom:12px">
                <label class="muted" style="font-size:12px;margin-bottom:4px;display:block">Custom Search (e.g., "Vegan", "BBQ", "Bike Repair")</label>
                <div style="display:flex;gap:6px">
                  <input type="text" id="tourCustomSearch" placeholder="Enter custom search term" style="flex:1;padding:8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px" />
                  <button id="tourCustomSearchBtn" class="btn primary" style="white-space:nowrap">üîç Search</button>
                </div>
              </div>
              
              <!-- Inline Map -->
              <div id="tourMapEmbed" style="width:100%;height:300px;border:1px solid #e5e7eb;border-radius:6px;margin-bottom:12px;overflow:hidden;background:#f9fafb;display:flex;align-items:center;justify-content:center;color:#64748b;font-size:13px">
                Click a search button to view map and find businesses
              </div>
              
              <!-- Search Results Chips -->
              <div style="font-size:12px;font-weight:600;color:#374151;margin-bottom:6px">Drag chips to itinerary or saved places:</div>
              <div id="tourSearchResults" style="display:flex;flex-wrap:wrap;gap:8px;padding:12px;border:1px solid #e5e7eb;border-radius:6px;min-height:120px;max-height:300px;overflow-y:auto;align-content:flex-start;background:#ffffff">
                <div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">
                  Search results will appear here
                </div>
              </div>
            </div>
            
            <!-- Saved Interests / Places -->
            <div class="card" style="width:100%" id="tourSavedInterests">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
                <h3 style="margin:0">Saved Places & Interests</h3>
                <button id="tourClearInterests" class="btn danger" style="padding:4px 8px;font-size:12px">Clear All</button>
              </div>
              <div id="tourInterestsDropZone" style="min-height:100px;border:2px dashed #d1d5db;border-radius:8px;padding:12px;background:#f9fafb;display:flex;flex-wrap:wrap;gap:8px;align-items:flex-start;align-content:flex-start">
                <div style="width:100%;text-align:center;color:#64748b;font-size:13px;padding:20px" id="tourInterestsPlaceholder">
                  Drag search result chips here to save places of interest for this tour date
                </div>
              </div>
            </div>
            
          </div>
        </div>
      </div>
      


      <!-- Live Mode: full-screen, touch-first setlist + lyrics viewer -->
      <div id="live" style="display:none;grid-column:1 / -1;width:100%;margin-top:12px">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
              <h2>Live Mode</h2>
              <button id="liveThemeToggle" type="button" title="Toggle light/dark" style="margin-left:auto;border-radius:999px;border:none;width:34px;height:34px;display:flex;align-items:center;justify-content:center;font-size:18px;background:#0f172a;color:#fbbf24;cursor:pointer">üåô</button>
            </div>
        <div id="liveFlex" style="display:flex;gap:12px;min-height:60vh">
          <div id="liveLeftCol" style="display:flex;flex-direction:column;gap:6px;max-height:80vh">
            <div style="display:flex;align-items:center;gap:8px">
              <button id="armAllBtn" type="button" title="Arm local audio files for this set" class="btn">Arm All</button>
            </div>
            <input id="armAllDir" type="file" webkitdirectory directory multiple style="display:none" />
            <input id="armSongFile" type="file" accept="audio/*" style="display:none" />
            <div id="liveList" style="flex:1 1 auto;border:1px solid #e5e7eb;border-radius:8px;padding:8px;overflow:auto">
            <!-- live setlist rows injected here -->
          </div>
          </div>
          <div id="liveLyrics" style="flex:2 1 360px;min-width:280px;border:1px solid #e5e7eb;border-radius:8px;padding:12px;max-height:80vh;overflow:auto;font-size:16px;line-height:1.4">
            <div id="liveInlineControls" style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
              <button id="liveInlinePlay" class="live-lyrics-play" type="button">Play</button>
              <button id="liveInlineStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
              <div style="display:flex;align-items:center;gap:6px;margin-left:auto">
                <span style="font-size:11px;color:#64748b">Zoom</span>
                <input id="liveInlineZoom" type="range" min="16" max="32" value="20" step="1" style="width:140px">
              </div>
              <div style="display:flex;align-items:center;gap:4px">
                <button id="liveInlineSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
                <span id="liveInlineSpeedDisplay" style="font-size:12px;color:#111;font-weight:bold;min-width:56px;text-align:center">20 LPM</span>
                <button id="liveInlineSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">+</button>
              </div>
              <button id="metronomeBtn" type="button" title="Metronome: Tap once=flash, twice=click, thrice=off. Hold to set BPM" style="padding:6px 12px;border-radius:4px;border:2px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:16px;font-weight:bold;margin-left:8px">‚ô©</button>
            </div>
            <div id="liveLyricsTitle" style="font-weight:bold;font-size:20px;margin-bottom:8px"></div>
            <pre id="liveLyricsBody" style="white-space:pre-wrap;font-family:inherit"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help / Tutorial Modal -->
  <div class="modal" id="helpModal" style="display:none">
    <div class="sheet" style="max-width:820px;height:auto;display:flex;flex-direction:column">
      <h2 style="margin-top:0;margin-bottom:8px">Help</h2>

      <!-- Compact sticky single-row search + jump bar -->
      <div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:4px 0 6px 0;margin:0 0 6px 0;border-bottom:1px solid #e5e7eb">
        <div style="display:flex;align-items:center;gap:4px;font-size:11px;white-space:nowrap;overflow:hidden">
          <span style="font-weight:600;white-space:nowrap">Search:</span>
          <input id="helpSearch" type="text" placeholder="tour, songs‚Ä¶" style="width:90px;flex:0 0 auto;padding:2px 4px;border-radius:6px;border:1px solid #cbd5e1;font-size:11px">
          <button type="button" class="btn secondary" id="helpSearchPrev" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Prev</button>
          <button type="button" class="btn secondary" id="helpSearchNext" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Next</button>
          <span id="helpSearchCount" style="font-size:10px;color:#6b7280;flex:0 0 auto">0</span>
          <span style="font-weight:600;flex:0 0 auto">Jump:</span>
          <button type="button" class="btn secondary" data-help-jump="tour-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Tour</button>
          <button type="button" class="btn secondary" data-help-jump="db-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Songs</button>
          <button type="button" class="btn secondary" data-help-jump="set-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Setlist</button>
          <button type="button" class="btn secondary" data-help-jump="stage-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Stage</button>
          <button type="button" class="btn secondary" data-help-jump="live-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Live</button>
          <button type="button" class="btn secondary" data-help-jump="print-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Printing</button>
          <button type="button" class="btn secondary" data-help-jump="files-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Saving</button>
          <button type="button" class="btn secondary" data-help-jump="tips-help" style="padding:1px 6px;font-size:11px;flex:0 0 auto">Tips</button>
        </div>
      </div>

      <div id="helpContent" style="font-size:13px;line-height:1.5;max-height:60vh;overflow:auto;padding-right:6px;margin-top:0">

        <!-- 0. Getting started story -->
        <h3 id="top-help" style="margin-top:4px">0. Getting Started</h3>
        <p>Here is one simple way to use this app from a totally blank database to a full tour with several bands, dates, rehearsals, and more.</p>
        <ol>
          <li><strong>Pick your main band</strong>
            <ul>
              <li>Click <strong>"Select Band‚Ä¶"</strong> at the very top left.</li>
              <li>Type the band or artist name (for example ‚ÄúThe Kildeers‚Äù).</li>
              <li>This band now has a place for its own songs, setlists, stage plot and calendar.</li>
            </ul>
          </li>
          <li><strong>Build your song list</strong>
            <ul>
              <li>Go to the <strong>Song Database</strong> tab.</li>
              <li>drag or paste song titles into the <strong>Import Songs</strong> database page or type them one by one.</li>
              <li>For each song, fill in title, artist, key, capo, length, mood and if it is a cover or original.</li>
              <li>Add lyrics / chords where needed so Live mode can show them.</li>
            </ul>
          </li>
          <li><strong>Create your first setlist</strong>
            <ul>
              <li>Open the <strong>Setlist</strong> tab.</li>
              <li>Your available songs will be on the left to drag songs into the big setlist preview on the right.</li>
              <li>Use the <strong>Generator</strong> if you want a quick starting order, then adjust by hand.</li>
              <li>Drag in <strong>Break</strong> items so your sets are clear.</li>
            </ul>
          </li>
          <li><strong>Draw a simple stage plot</strong>
            <ul>
              <li>Go to <strong>Tech / Stage</strong>, open the Stage/ Tech tab.</li>
              <li>Drag icons for <strong>amps, guitars, bass, keyboards, drums, violins, DI boxes, microphones, vocal mics, wedges, in‚Äëear packs, DJ decks, playback laptops, fans</strong> and more onto the stage.</li>
              <li>Drag a guitar to an amp to connect them. Drag an instrument mic to the Amp and it will create the full chain.</li>
            </ul>
          </li>
          <li><strong>Pick your first day of the tour</strong>
            <ul>
              <li>Switch to the <strong>Calendar / Tour</strong> tab.</li>
              <li>Pick a date box or click <strong>+ Add Date</strong>.</li>
              <li>Fill in venue, address, load‚Äëin and show time.</li>
              <li>Attach your setlist and stage plot to this date.</li>
              <li>Drag <strong>Events / Activities</strong> into the timeline: <strong>Drive, Rehearsal, Soundcheck, Gig, DJ set, Radio, Party, Sleep, Food</strong> and more.</li>
            </ul>
          </li>
          <li><strong>Copy this to a tour</strong>
            <ul>
              <li>Add more dates in the calendar strip for the full run.</li>
              <li>Drag date boxes to move a whole day (for example when a show moves from Friday to Sunday).</li>
              <li>Mark special dates as <strong>Rehearsal, Radio, TV, Recording, DJ, Party, Rest, Travel</strong> using the date menu.</li>
              <li>Attach different setlists or stage plots to special nights if needed.</li>
            </ul>
          </li>
          <li><strong>Add a second band or project</strong>
            <ul>
              <li>Click <strong>"Select Band‚Ä¶"</strong> again.</li>
              <li>Create another band (for example ‚ÄúSweetiepies‚Äù or a DJ name).</li>
              <li>Repeat: songs ‚Üí setlists ‚Üí stage plot ‚Üí calendar, all kept separate per act.</li>
            </ul>
          </li>
          <li><strong>Lock it in and print</strong>
            <ul>
              <li>Use the setlist lock so the order does not change by accident.</li>
              <li>Open <strong>Print‚Ä¶</strong> and print setlists for the band, stage + channels for the engineer, and tech notes for the light and sound crew.</li>
              <li>Save a <strong>.BAND</strong> profile so the full tour is backed up.</li>
            </ul>
          </li>
        </ol>

        <!-- 1. Top bar and basic controls -->
        <h3>1. Calendar</h3>
        <ul>
          <li><strong>Band chooser ("Select Band‚Ä¶")</strong> click / tap to switch between bands or acts. Each band can have its own songs, stage plot and calendar.</li>
          <li><strong>Calendar strip (little date boxes)</strong> every box is a day. Green = has a show. Yellow line = travel / drive day. Purple = rehearsal / radio / party / other events. Solid outline = today.</li>
          <li><strong>Drag a date box</strong> move a whole day (including the setlist, stage and notes) to a new date. Handy when a gig is moved.</li>
          <li><strong>Right‚Äëclick / long‚Äëpress a date box</strong> opens a small menu to mark the day as: normal show, drive day, rest, home, rehearsal, recording, radio, TV, DJ, party, audition, dress rehearsal, or cancelled.</li>
          <li><strong>"‚öôÔ∏è" button</strong> save / load files:
            <ul>
              <li><strong>Save Profile (.BAND)</strong> saves all bands, songs, calendar, stage plots and notes.</li>
              <li><strong>Load Profile (.BAND)</strong> open a saved profile from your computer.</li>
              <li><strong>Save .SET</strong> saves only the current setlist.</li>
              <li><strong>Load .SET</strong> load a saved setlist into the Setlist tab.</li>
            </ul>
          </li>
          <li><strong>"Print‚Ä¶" button</strong> opens the print options window (setlist, stage, tech notes, lyrics, itinerary).</li>
          <li><strong>"üì§ Share" button</strong> lets you share / export your song database (for now this mostly works as a way to save and back things up).</li>
          <li><strong>"?" Help button</strong> opens this help window.</li>
          <li><strong>Moon / Sun button</strong> light / dark theme. Use what looks best on your screen or projector.</li>
        </ul>

        <!-- 2. Calendar / Tour Manager -->
        <h3 id="tour-help">2. Calendar / Tour</h3>
        <p>Use this tab to plan every day: gigs, drives, rehearsals, radio, parties even rest!</p>
        <ul>
          <li><strong>Big date and venue at the top</strong> shows the selected day from the date strip.</li>
          <li><strong>"‚óÄ Yesterday" / "Tomorrow ‚ñ∂"</strong> move one day back or forward.</li>
          <li><strong>"+ Add Date"</strong> create a new tour day if it does not exist yet.</li>
        </ul>
        <p><strong>Gig Details box</strong></p>
        <ul>
          <li><strong>Date</strong> gig-day.</li>
          <li><strong>Venue name</strong>  The Broom Factory, The Toucan etc.</li>
          <li><strong>Address</strong>. also used to find useful things near your show.</li>
          <li><strong>Load‚Äëin time</strong> when you start carrying gear in.</li>
          <li><strong>Show time</strong> show-time is SHOWTIME.</li>
          <li><strong>Band / Artist</strong>  which act is playing that night.</li>
          <li><strong>Setlist choice</strong> use the current setlist or a custom one for this date.</li>
          <li><strong>Stage choice</strong> use the current stage plot or a custom one for this date.</li>
          <li><strong>"Save" button</strong> keeps all of this for that date.</li>
          <li><strong>"Delete" button</strong> removes the date from the calendar (the small date box will clear).</li>
        </ul>
        <p><strong>Location box (Map)</strong></p>
        <ul>
          <li>Once you type an address, the app builds links for maps (Google Maps / Apple Maps / Waze depending on your device).</li>
          <li>Click / tap to open directions on your phone, tablet or laptop.</li>
        </ul>
        <p><strong>Daily Itinerary (timeline)</strong></p>
        <ul>
          <li>The left column shows the day as a simple timeline (morning ‚Üí night).</li>
          <li>You fill it by dragging small coloured <strong>Activity chips</strong> from the right: Rehearsal, Soundcheck, Load‚ÄëIn, Gig, Drive, Home, Sleep, Meals, Party, Meetings, etc.</li>
          <li><strong>Mouse</strong>: click and hold a chip, drag it to the time slot, then release.</li>
          <li><strong>Touch</strong>: long‚Äëpress a chip until it ‚Äúlifts up‚Äù, drag it, then lift your finger to drop.</li>
          <li>You can drag items up / down to adjust the order or time.</li>
          <li>Click / tap an item to edit its start time, length or notes.</li>
          <li>There are special chips for radio, TV, parties and other promo events so your travel and gig day all sit on one simple line.</li>
        </ul>
        <p><strong>Find Places (Hotels / Food / Music / Radio)</strong></p>
        <ul>
          <li>Buttons such as <strong>Hotels, Music, Rehearsal, Recording, Radio, TV, Bars, Food, Cafes, Gas, Print, Repair, PA Rental, Pharmacy</strong> open map searches near your venue.</li>
          <li>You can also type your own search (for example ‚Äúvegan food‚Äù or ‚Äúlate‚Äënight pizza‚Äù) and save that as a new button.</li>
          <li>Results show as little chips; you can drag these to your itinerary or to the <strong>Saved Places</strong> area for that date.</li>
        </ul>
        <p><strong>Stage & Setlist previews</strong></p>
        <ul>
          <li>The small Stage and Setlist boxes on the right show what is currently attached to this date.</li>
          <li>Double‚Äëclick / double‚Äëtap them to jump straight into editing the big Stage or Setlist views.</li>
        </ul>
        <p><strong>Calendar lock & clear</strong></p>
        <ul>
          <li><strong>"üîí Lock Calendar"</strong> stops you from moving or deleting dates by mistake.</li>
          <li><strong>"üóëÔ∏è Clear Calendar"</strong> wipes all dates. Only do this at the very start of planning a new tour.</li>
        </ul>

        <!-- 3. Song Database -->
        <h3 id="db-help">3. Song Database Your Master List</h3>
        <p>Here you keep every song you might ever play, with keys, moods, notes, links and lyrics.</p>
        <p><strong>Search and filters</strong></p>
        <ul>
          <li><strong>Search box</strong> type part of a song or artist name.</li>
          <li><strong>Sort by</strong> choose: order added, A‚ÄìZ by song, A‚ÄìZ by band, mood order, audience rating, most used, least used.</li>
          <li><strong>Filter checkboxes</strong> only show Covers, only Originals, Has Lyrics, Karaoke, Has Audio, Has URL, In Current Set, and mood filters (Upbeat, Happy, Energetic, Mellow, Sad plus your own moods).</li>
        </ul>
        <p><strong>Import songs quickly</strong></p>
        <ul>
          <li>Paste text into <strong>Import Songs</strong> (for example from a text file or OCR app) and click <strong>Extract</strong>.</li>
          <li>Or click the file chooser to add text, PDF, images, audio or spreadsheets.</li>
          <li>The app guesses titles, keys, capo, and sometimes length. Check the preview, then click <strong>Add Songs</strong>.</li>
        </ul>
        <p><strong>Song rows</strong></p>
        <ul>
          <li>Each line in the database is one song. You can click / tap fields to edit title, artist, key, capo, length, moods, links, rating, notes and custom fields.</li>
          <li>There are quick buttons to open lyrics / chords, attach or arm audio files, and send the song to the current setlist.</li>
          <li>If you add your own columns (for example ‚ÄúLanguage‚Äù or ‚ÄúShow Part‚Äù), they appear here and can also be shown in your printed setlist if you wish.</li>
        </ul>
        <p><strong>Safe clear</strong></p>
        <ul>
          <li>To empty the database you must first tick the <strong>"Unlock Clear"</strong> box, then click <strong>Clear Database</strong>.</li>
          <li>You will be asked if you want to save a .BAND backup first. Strongly recommended before wipes.</li>
        </ul>

        <!-- 4. Setlist -->
        <h3 id="set-help">4. Setlist Build the Show</h3>
        <p>Use this tab to plan the running order, breaks and total time for a gig.</p>
        <p><strong>Song Pool (left side)</strong></p>
        <ul>
          <li>Shows Originals, Covers and Break items taken from your database.</li>
          <li><strong>Search, Type, Sort, Mood</strong> narrow down the pool to the songs you want tonight.</li>
          <li><strong>Mouse</strong>: drag a song from the pool into the big setlist preview on the right.</li>
          <li><strong>Touch</strong>: long‚Äëpress a song until it ‚Äúlifts‚Äù, then drag to the setlist and release.</li>
          <li>There are special Break items you can drag in to mark sets and intervals.</li>
        </ul>
        <p><strong>Setlist preview (middle)</strong></p>
        <ul>
          <li>Shows what will actually print on paper.</li>
          <li>Click / tap the <strong>lock</strong> box to stop accidental changes (useful once the band agrees on the order).</li>
          <li><strong>Reorder songs</strong> by dragging the row up or down.</li>
          <li><strong>Double‚Äëclick / double‚Äëtap a song title</strong> to add notes (‚Äústart quiet‚Äù, ‚Äú2 solos‚Äù, ‚Äúask for drinks special‚Äù). Notes print under the song name.</li>
          <li><strong>Delete</strong> usually there is a small delete icon or context action on each row; removing a row does not affect the database.</li>
          <li>The black square handle with an arrow in the corner can be dragged onto a calendar date to attach this full setlist to that night.</li>
        </ul>
        <p><strong>Generator settings (right column, top box)</strong></p>
        <ul>
          <li><strong>Set length (min)</strong> how long you want to play.</li>
          <li><strong>Break length (min)</strong> how long you want your pauses.</li>
          <li><strong>Cover ratio</strong> pick how much of the night is covers vs originals.</li>
          <li><strong>Breaks</strong> choose number of breaks.</li>
          <li><strong>Mood</strong> overall feel: mixed, upbeat, mellow, etc.</li>
          <li><strong>Encore</strong> tick if you want the generator to leave room at the end for an encore song.</li>
          <li><strong>Grouping rules</strong> keep covers, keys or moods together if you want the flow to stay smooth (for example mid‚Äëtempo block in the middle).</li>
          <li><strong>Generate</strong> creates a suggested set from your database. You can still drag, edit and fine‚Äëtune by hand.</li>
          <li><strong>New Setlist</strong> start fresh. You will be asked if you want to save the old one as a preset.</li>
          <li><strong>Clear</strong> wipe the current setlist only.</li>
        </ul>
        <p><strong>Setlist display options (right column, bottom box)</strong></p>
        <ul>
          <li>Here you control what prints: Artist, Key, Capo, BPM, Notes, Lyrics preview and any custom fields.</li>
          <li>You can also pick paper size (Letter or A4), page count, and how many songs per page.</li>
        </ul>
        <p><strong>Setlist presets</strong></p>
        <ul>
          <li>The <strong>‚≠ê Preset</strong> button lets you save great setlists (for example ‚ÄúShort Festival Set‚Äù, ‚ÄúWedding 2 x 45‚Äù, ‚ÄúXmas Show‚Äù).</li>
          <li>You can load presets later, attach them to dates, and still tweak them for the night.</li>
        </ul>

        <!-- 5. Live Mode -->
        <h3 id="live-help">5. Live</h3>
        <p>This tab is for the actual show. Big print, simple buttons, touch‚Äëfriendly.</p>
        <ul>
          <li><strong>Arm All</strong> choose a folder of audio files (backing tracks, reference tracks). The app links files to songs by name.</li>
          <li>You can also arm a single song by using the file picker near that song.</li>
          <li>Click / tap a song in the live list to select it. The right side shows its lyrics.</li>
          <li><strong>Play / Stop</strong> buttons</li>
          <ul>
            <li>In the main Live panel and in the full‚Äëscreen overlay they start / stop the smooth auto‚Äëscroll of lyrics.</li>
            <li>They also try to start linked audio if you have armed a track.</li>
          </ul>
          <li><strong>Zoom slider</strong> makes lyrics bigger or smaller. On small phones you might want 28‚Äì32; on big screens 18‚Äì22 is often enough.</li>
          <li><strong>Speed ‚àí / +</strong> changes scroll speed. You can nudge this during the song if the band stretches or shortens sections.</li>
          <li><strong>Metronome (‚ô©)</strong> tap several times in tempo to set BPM, then it can flash or click depending on mode. Tap or hold as explained in the tooltip.</li>
          <li><strong>Full‚Äëscreen overlay</strong> usually opens automatically on phones / tablets; on desktop you can use it for a separate lyrics screen. Use the "Back to Setlist" button to return.</li>
          <li><strong>Dark / light live theme</strong> the small moon / sun button in the Live tab changes background and contrast for stage use.</li>
        </ul>

        <!-- 6. Tech / Stage -->
        <h3 id="stage-help">6. Tech / Stage - Stage Plot and Tech Notes</h3>
        <p><strong>Stage Plot</strong></p>
        <ul>
          <li>Click the <strong>Stage Plot</strong> button in the Tech / Stage tab to open the stage editor.</li>
          <li>The yellow bar at the top shows the Band, Date and Venue for this plot.</li>
          <li>In the left toolbox, drag items (mics, stands, drums, amps, wedges, players, etc.) onto the stage.</li>
          <li><strong>Mouse</strong>: drag to move, single‚Äëclick to select, use the size and rotate sliders to adjust.</li>
          <li><strong>Touch</strong>: tap to select, drag to move; use the same sliders for size and angle.</li>
          <li>In the inspector bar you can rename items (for example ‚ÄúLead Vox‚Äù, ‚ÄúKick In‚Äù, ‚ÄúGuitar L‚Äù), show / hide labels, and change label size.</li>
          <li>The black drag handle with an arrow lets you drag this whole stage plot onto a calendar date so that date always uses this layout.</li>
          <li>The small black squares around the stage frame let you change the stage size and shape.</li>
          <li><strong>New Stage</strong> saves a preset and starts a fresh layout.</li>
          <li><strong>Clear</strong> removes all icons from the stage but keeps the background; use with care.</li>
          <li>You can upload your own pictures (for example a band logo or a special instrument) or draw new icons with the Icon Maker.</li>
        </ul>
        <p><strong>Tech / Lighting Notes</strong></p>
        <ul>
          <li>The Lighting Notes window shows a table with one row per song.</li>
          <li>Here you type what the sound and light team needs: number of DI boxes, extra vocal mics, ‚Äúdrums out on last chorus‚Äù, colour changes, FX, etc.</li>
          <li>A gear list box under the table lets you list full equipment: amps, cabs, keyboards, in‚Äëears, extra stands.</li>
          <li>These notes can print together with the stage plot, or alone, from the Print options.</li>
        </ul>

        <!-- 7. Printing -->
        <h3 id="print-help">7. Printing Paper for Everyone</h3>
        <p>Use the top <strong>"Print‚Ä¶"</strong> button to open the print options.</p>
        <ul>
          <li>Select one or more of: <strong>Setlist, Stage Plot, Lighting / Tech Notes, Lyrics, Itinerary</strong>.</li>
          <li>If you choose Lyrics, you will see a list of songs and can tick which lyrics to print.</li>
          <li>Each thing prints as its own set of pages so you can hand them to different people (band, sound, lights, driver, radio host).</li>
        </ul>
        <p><strong>Windows / Mac laptop</strong></p>
        <ul>
          <li>After you click <strong>Print Selected</strong>, your normal print box opens.</li>
          <li>Pick your printer or "Save as PDF".</li>
          <li>Paper size: Letter or A4 as set in the Setlist Display Options.</li>
        </ul>
        <p><strong>iPhone / iPad</strong></p>
        <ul>
          <li>After clicking print, use the share button in the preview to save as PDF or send to AirPrint.</li>
          <li>If the printer cuts the edges, switch between Letter and A4 in the app, then try again.</li>
        </ul>
        <p><strong>Android phones / tablets</strong></p>
        <ul>
          <li>After clicking print, most Android browsers let you share to a printer app or save a PDF.</li>
          <li>If margins look odd, again try changing between Letter and A4 in Setlist Display Options.</li>
        </ul>

        <!-- 8. Files and safety -->
        <h3 id="files-help">8. Saving Files - Profiles and Sets</h3>
        <ul>
          <li><strong>.BAND profile</strong> use this to back up or move your full setup between machines.</li>
          <li><strong>.SET file</strong> use this to store favourite setlists (for specific shows or tours).</li>
          <li>The app also saves to your browser as you go, but a .BAND file is the safest way to move between computers or after a reinstall.</li>
          <li>On Windows / Mac, your browser will download these files to your usual Downloads folder unless you pick another place.</li>
        </ul>

        <!-- 9. Tips, touch vs mouse, edge cases -->
        <h3 id="tips-help">9. Tips, Touch vs Mouse, Edge Cases</h3>
        <p><strong>Mouse vs touch</strong></p>
        <ul>
          <li><strong>Mouse</strong> click, drag and right‚Äëclick as usual.</li>
          <li><strong>Touch</strong> long‚Äëpress to start a drag, then move; single tap instead of click; long‚Äëpress instead of right‚Äëclick.</li>
          <li>On small screens some panels stack vertically. Scroll up and down to see everything.</li>
        </ul>
        <p><strong>Moving shows when the date changes</strong></p>
        <ul>
          <li>If a gig moves by a day (or a week), drag the small date box to the new spot in the calendar strip.</li>
          <li>This takes the setlist, stage, itinerary and notes with it.</li>
        </ul>
        <p><strong>Cancelled shows</strong></p>
        <ul>
          <li>Use the date box menu to mark a date as <strong>Cancelled</strong>.</li>
          <li>The box gets a dashed red border so you still remember it once existed, but you will not plan new songs there by accident.</li>
        </ul>
        <p><strong>Autosave and undo</strong></p>
        <ul>
          <li>The app quietly saves while you work. Still, use .BAND and .SET files before big changes or tours.</li>
          <li>On computers you can use <strong>Ctrl+Z</strong> / <strong>Cmd+Z</strong> to undo, and <strong>Ctrl+Y</strong> / <strong>Shift+Ctrl+Z</strong> to redo, for many actions in setlist and stage.</li>
        </ul>
        <p><strong>When things seem stuck</strong></p>
        <ul>
          <li>If drag and drop stops working, refresh the page, then reload your latest .BAND or .SET backup.</li>
          <li>If printing looks tiny or huge, adjust the paper size and songs‚Äëper‚Äëpage setting, then try again.</li>
        </ul>

        <p style="margin-top:16px;font-size:13px;background:#f1f5f9;padding:10px;border-radius:8px">
          This app is free. If it saves you time and helps your band, you can buy the developer a coffee:
          <br>
          <a href="https://paypal.me/jamesmulvale" target="_blank" rel="noopener" class="btn" style="text-decoration:none;margin-top:6px;display:inline-block">Donate via PayPal</a>
          <br>Thank you and have a great show.
        </p>
      </div>

      <div style="margin-top:10px;display:flex;align-items:center;justify-content:flex-end;font-size:11px;color:#6b7280">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <!-- Floating Song Pool Flyout -->
  <div class="pool-flyout" id="songPoolFlyout">
    <div class="pool-head">
      <strong>Song Pool</strong>
      <button class="btn secondary" id="closePool" type="button">Close</button>
    </div>
    <div class="pool-body">
      <div class="pool-sec">
        <h4>Originals</h4>
        <div id="poolOriginals" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Covers</h4>
        <div id="poolCovers" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Breaks</h4>
        <div id="poolBreaks" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
    </div>
  </div>

  <!-- Global Print FAB removed; using top-row Print button for consistency -->

  <!-- Stage Fullscreen Modal -->
  <div class="stage-modal" id="stageModal">
    <div class="stage-editor">
      <div class="stage-pane">
  <h3>Toolbox <span style="font-weight:400;font-size:12px;color:#6b7280">(Drag and drop items)</span></h3>
        <div class="stage-tools" id="stageToolsFull"></div>
        <div style="margin-top:10px">
          <h4>Custom</h4>
          <button class="tool" id="uploadImageBtn">Upload Image</button>
          <input type="file" id="uploadImageInput" accept="image/*" style="display:none" />
          <button class="tool" id="newIconBtn">New Icon</button>
          <div id="customImages" style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px"></div>
        </div>
        <div style="margin-top:14px;display:flex;justify-content:flex-end;align-items:center;gap:8px">
          <button class="btn" id="newStageBtn" type="button" title="Save current as preset and start fresh stage plot">New Stage</button>
          <button class="btn danger" id="clearStage" type="button" title="Clear stage plot (keeps background & title)">Clear</button>
        </div>
      </div>
      <div class="stage-canvas">
        <!-- Date/Band/Venue Header Bar -->
        <div id="stageHeaderBar" style="background:#fef08a;padding:12px 16px;margin-bottom:12px;border-radius:6px;display:flex;align-items:center;justify-content:space-between;gap:16px">
          <div style="display:flex;align-items:center;gap:16px;font-weight:600;font-size:16px">
            <span id="stageHeaderDate" style="color:#854d0e">No date selected</span>
            <span style="color:#a16207">‚Ä¢</span>
            <span id="stageHeaderBand" style="color:#854d0e">Band</span>
            <span style="color:#a16207">‚Ä¢</span>
            <span id="stageHeaderVenue" style="color:#854d0e">Venue</span>
          </div>
          <div style="display:flex;align-items:center;gap:12px">
            <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#854d0e;cursor:pointer;font-weight:500" title="Lock stage plot to prevent accidental edits">
              <input type="checkbox" id="stageLockCheckbox" style="cursor:pointer" />
              üîí Lock
            </label>
            <div id="stageDragHandle" class="drag-assign-handle" draggable="true" title="Drag to assign this stage plot to a calendar date" style="width:32px;height:32px;background:#000;border:2px solid #fff;border-radius:6px;cursor:grab;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,0.3)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18 8.5V8a2 2 0 0 0-4 0v1M14 9.5V7a2 2 0 0 0-4 0v4M10 11V4a2 2 0 0 0-4 0v10.5" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M18 8.5a2 2 0 0 1 2 2v1.5c0 4.5-3 8-8 8s-6-3-7-5l-2.5-4a1.5 1.5 0 0 1 2.5-1.5L7 12" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
          </div>
        </div>
        <div class="stage-inspector" id="stageInspector" style="margin-bottom:8px;display:flex;min-height:42px;background:#f3f4f6;padding:8px 12px;border-radius:6px;align-items:center;gap:12px">
          <span class="muted" id="selLabel">Selected: (none)</span>
          <input id="selName" placeholder="Click an item to select" style="min-width:220px" disabled />
          <label class="muted" for="selSize">Size</label>
          <input id="selSize" type="range" min="0.3" max="5" step="0.05" value="1" style="width:160px" disabled />
          <label class="muted" for="selRotation">Rotate</label>
          <input id="selRotation" type="range" min="0" max="360" step="1" value="0" style="width:160px" disabled />
          <span id="selRotationValue" class="muted" style="min-width:35px">0¬∞</span>
          
          <label class="muted" for="selShowLabel" style="display:flex;align-items:center;gap:4px"><input type="checkbox" id="selShowLabel" disabled /> Show Label</label>
          <span id="labelSizeControls" style="display:none;align-items:center;gap:6px">
            <label class="muted" for="selLabelSize">Label Size</label>
            <input id="selLabelSize" type="range" min="8" max="32" step="1" value="16" style="width:120px" />
          </span>
          <button class="btn danger" id="delSel" disabled>Delete</button>
          <button class="btn" id="dupSel" type="button" disabled>Duplicate</button>
        </div>
        <div style="position:relative;display:inline-block;">
          <div id="stageFrame" style="position:relative;display:inline-block;">
            <svg id="stageSvgFull" class="bw" viewBox="0 0 1000 600" data-stage-width="1000" data-stage-height="600" xmlns="http://www.w3.org/2000/svg" style="display:block;width:1000px;height:600px;">
              <rect class="stage-bg" x="1" y="1" width="998" height="598"/>
              <text x="500" y="50" text-anchor="middle" font-size="26" font-weight="bold" id="stageTitleFull">Band ‚Ä¢ Date</text>
            </svg>
            <div class="stage-handle tl" data-handle="tl"></div>
            <div class="stage-handle tr" data-handle="tr"></div>
            <div class="stage-handle bl" data-handle="bl"></div>
            <div class="stage-handle br" data-handle="br"></div>
          </div>
        </div>
        <div id="stageLegend" class="stage-legend"></div>
        <div class="stage-actions">
            <button class="btn secondary" id="closeStage">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- New Icon Drawing Modal -->
  <div class="modal" id="iconMakerModal" style="display:none">
    <div class="sheet" style="max-width:480px">
      <h3 style="margin-top:0">Create New Icon</h3>
      <canvas id="iconCanvas" width="400" height="400" style="border:1px solid #d1d5db;background:transparent;display:block;width:400px;height:400px;touch-action:none"></canvas>
      <div style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <label style="font-size:12px;color:#64748b">Line Width
          <input id="iconLineWidth" type="range" min="2" max="6" step="1" value="4" style="width:160px">
        </label>
        <button class="btn" id="iconClear">Clear</button>
        <button class="btn" id="iconSave">Save Icon</button>
        <button class="btn secondary" id="iconCancel">Cancel</button>
      </div>
      <div style="margin-top:6px;font-size:11px;color:#64748b">Draw with mouse or touch. Rough shapes will auto-normalize into lines, rectangles, or ellipses where recognized.</div>
    </div>
  </div>

  <!-- Lighting Notes Fullscreen Modal -->
  <!-- Stage Preset Modal - Created dynamically via showPresetModal() -->

  <div class="stage-modal" id="notesModal">
    <div class="stage-editor" style="grid-template-columns:1fr">
      <div class="stage-pane" style="border-right:none">
        <h3>Lighting Notes</h3>
        <table class="tech-table">
          <thead><tr><th>#</th><th>Song</th><th>Notes (e.g., Blue fade to orange, Delays in chorus)</th></tr></thead>
          <tbody id="techBodyFull"></tbody>
        </table>
        <div class="gear-wrap">
          <label>Gear list (printed under stage)</label>
          <textarea id="gear" placeholder="e.g., DI x3 ‚Ä¢ Guitar amp x2 ‚Ä¢ Vox x3 ‚Ä¢ Wireless x2"></textarea>
        </div>
        <div class="stage-actions">
          <button class="btn secondary" id="closeNotes">Close</button>
          <button class="btn" id="printTech">Print Tech Rider + Stage</button>
          <button class="btn" id="printTechOnly">Print Tech Only</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Print Modal -->
  <div class="modal" id="modal">
    <div class="sheet" id="sheet">
      <div class="hdr" id="hdr"></div>
      <div class="songs" id="songs"></div>
    </div>
    <div class="tools">
      <span class="paper">Paper:</span>
      <select id="paperSel">
        <option value="letter">Letter 8.5√ó11</option>
        <option value="a4">A4 210√ó297mm</option>
      </select>
  <button class="btn" id="printSheet">Print</button>
      <button class="btn secondary" id="closeModal">Close</button>
    </div>
  </div>

  <!-- Tech/Stage Print Modal -->
  <div class="modal" id="modalTech">
    <div class="sheet" id="sheetTech">
      <div class="hdr" id="hdrTech"></div>
      <div id="techPrint"></div>
      <div id="stagePrint"></div>
    </div>
    <div class="tools">
      <button class="btn" id="printTechModal">Print</button>
      <button class="btn secondary" id="closeTech">Close</button>
    </div>
  </div>

  <!-- Print Options Modal -->
  <div class="modal" id="printChooser">
    <div class="modalbox">
      <div class="hdr"><div class="band">Print Options</div></div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <label class="chip"><input type="checkbox" id="pSet"> Setlist</label>
        <label class="chip"><input type="checkbox" id="pStage"> Stage Plot</label>
        <label class="chip"><input type="checkbox" id="pTech"> Lighting / Tech Notes</label>
        <label class="chip"><input type="checkbox" id="pLyrics"> Lyrics</label>
        <label class="chip"><input type="checkbox" id="pItinerary"> Itinerary</label>
        <div class="muted">Select one or more. Each prints separately.</div>
        
        <!-- Song selector for lyrics (shown when pLyrics is checked) -->
        <div id="lyricsSongSelector" style="display:none;margin-top:10px;padding:10px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;max-height:200px;overflow-y:auto">
          <div style="font-size:13px;font-weight:600;margin-bottom:8px">Select songs to print lyrics:</div>
          <div id="lyricsSongList" style="display:flex;flex-direction:column;gap:6px"></div>
        </div>
      </div>
      <div class="tools" style="justify-content:flex-end">
        <button class="btn" id="doPrint">Print Selected</button>
        <button class="btn secondary" id="closePrintChooser">Close</button>
      </div>
    </div>
  </div>

  <!-- Hidden storage for Stage SVG (used for save/print) -->
  <div id="stageStore" style="display:none">
    <svg id="stageSvg" class="bw" viewBox="0 0 1000 600" data-stage-width="1000" data-stage-height="600" xmlns="http://www.w3.org/2000/svg">
      <rect class="stage-bg" x="1" y="1" width="998" height="598"/>
      <text x="500" y="36" text-anchor="middle" font-size="22" font-weight="bold" id="stageTitle">Band ‚Ä¢ Date</text>
    </svg>
  </div>

  <!-- Live fullscreen lyrics overlay (phone / tablet / desktop) -->
  <div id="liveLyricsOverlay" class="live-lyrics-overlay">
    <div class="live-lyrics-header">
      <button id="liveLyricsExit" class="live-lyrics-exit" type="button">Back to Setlist</button>
      <button id="liveLyricsPrev" class="live-lyrics-prev" type="button">‚óÄ Prev</button>
      <button id="liveLyricsPlay" class="live-lyrics-play" type="button">Play</button>
      <button id="liveLyricsStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
      <button id="liveLyricsNext" class="live-lyrics-next" type="button">Next ‚ñ∂</button>
      <div id="liveLyricsOverlayTitle" class="live-lyrics-title"></div>
      <div style="display:flex;align-items:center;gap:6px;margin-right:10px">
        <span style="font-size:11px;color:#9ca3af">Zoom</span>
        <input id="liveLyricsZoom" type="range" min="16" max="96" value="20" step="1" style="width:180px">
      </div>
      <div style="display:flex;align-items:center;gap:4px;margin-right:10px">
        <button id="liveSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
        <span id="liveSpeedDisplay" style="font-size:12px;color:#e5e7eb;font-weight:bold;min-width:56px;text-align:center">20 LPM</span>
        <button id="liveSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">+</button>
      </div>
      <button id="metronomeBtnOverlay" type="button" title="Metronome: Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM." style="padding:6px 12px;border-radius:4px;border:2px solid #444;background:#1f2937;color:#fbbf24;cursor:pointer;font-size:18px;font-weight:bold">‚ô©</button>
    </div>
    <div id="liveLyricsOverlayMain" class="live-lyrics-main">
      <pre id="liveLyricsOverlayBody" class="live-lyrics-body"></pre>
    </div>
  </div>

  <script>
    // Data
  const db = []; // {id,title,artist,length,key,isCover,isUpbeat,isHappy,isMellow,isEnergetic,isSad,customMoods?:string[]}
  let setlist = []; // array of {type:'song'|'break'|'encore', ...}
  let gig = { band:'', date:'', venue:'', address:'', contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[], hiddenIcons:[], liveDark:false };
  let gearSummary = '';
  // Tech notes persist independently of the current set (keyed by song id)
  let techNotes = {};
  // Band presets: array of {id, name, defaultStage:'', logo:''}
  let bandPresets = [];
  let currentBandPresetId = null;
  // Stage plot presets: array of {name, svg} - persisted globally across all dates
  let stagePresets = [];
  // Setlist presets: array of {name, setlist:[], date:ISO, thumbnail:string} - persisted globally
  let setlistPresets = [];
  // Last used setlist: most recent non-empty setlist for quick reload
  let lastUsedSetlist = null;
  // Tour dates: array of {id, date, venue, address, loadIn, showTime, band, setlist:[], stage:string, gig:{}, itinerary:[], tourType:'gig'|'hotel'|'travel'|'home', city:'', bandPresetId:null}
  let tourDates = [];
  let selectedTourDateId = null; // Currently selected date in tour manager
  let tourViewMode = 'month'; // 'week' | 'month' | 'year'
  let tourViewDate = new Date(); // Current view period anchor
  let tourCustomSearchTerms = ''; // User-defined search terms
  let currentDateDirty = false; // Track unsaved changes for current date
  // Setlist display column preferences
  let setlistColumns = {artist:false, capo:true, key:true, notes:false, bpm:false, lyrics:false};
  // Page layout preferences
  let pageLayout = {format:'letter', pageCount:1, songsPerPage:25};
  // Live audio playback handles
  let _liveAudioEl=null; // <audio> reused element
  let _liveAudioWin=null; // external window (YouTube/Spotify)
  let _liveLastExternalUrl=null; // last non-stream URL opened (avoid duplicate popups)
  const armedAudio = {}; // session-only object URLs keyed by song id
  // App-wide undo/redo history (setlist + stage); max 25
  const appHistory=[]; let appHistoryIndex=-1; let _restoring=false;
  // Enhanced platform detection for print optimization
  function isIOS(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return /ipad|iphone|ipod/.test(ua) || (/macintosh/.test(ua) && 'ontouchend' in document);
  }
  function isAndroid(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('android');
  }
  function isWindows(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('windows') || ua.includes('win32') || ua.includes('win64');
  }
  function isMobileLike(){ return isIOS() || isAndroid(); }

  // No-op stubs for missing helpers (keeps UI stable without external modules)
  let customSearchButtons = [];
  let saveTourDateData = ()=>{};
  let renderTourPreviews = ()=>{};
  let updateActDisplay = ()=>{};
  let initDragAssignHandles = ()=>{};
  let renderDateHeader = ()=>{};
  function updateBandPresetDropdown(){ /* stub */ }
  function renderPresetList(){ /* stub */ }
  function refreshLogoPreview(){ /* stub */ }
  function tourAddItineraryItem(){ /* stub */ }
  function updateLabelVisibility(node){ const lbl = node && node.querySelector ? node.querySelector('[data-role="label"]') : null; if(lbl) lbl.style.display = node?.dataset?.showLabel === '1' ? '' : 'none'; }
  function updateLabelSize(node){ const lbl = node && node.querySelector ? node.querySelector('[data-role="label"]') : null; if(lbl) lbl.setAttribute('font-size', node.dataset.labelSize || '16'); }

  // -----------------------------
  // Help modal search + jump
  // -----------------------------
  let helpMatches = [];
  let helpMatchIndex = -1;
  function clearHelpHighlights(){
    const host = document.getElementById('helpContent');
    if(!host) return;
    host.querySelectorAll('mark[data-help-hit]').forEach(m=>{
      const txt = document.createTextNode(m.textContent || '');
      m.parentNode.replaceChild(txt, m);
    });
  }
  function findInNode(node, term){
    if(!term) return;
    if(node.nodeType === 3){
      const text = node.nodeValue;
      const idx = text.toLowerCase().indexOf(term);
      if(idx === -1) return;
      const span = document.createElement('mark');
      span.setAttribute('data-help-hit','1');
      const before = document.createTextNode(text.slice(0, idx));
      const match = document.createTextNode(text.slice(idx, idx+term.length));
      const after = document.createTextNode(text.slice(idx+term.length));
      span.appendChild(match);
      const parent = node.parentNode;
      parent.replaceChild(after, node);
      parent.insertBefore(span, after);
      parent.insertBefore(before, span);
      helpMatches.push(span);
    } else if(node.nodeType === 1 && node.childNodes && !['SCRIPT','STYLE'].includes(node.tagName)){
      const kids = Array.from(node.childNodes);
      kids.forEach(ch=>findInNode(ch, term));
    }
  }
  function runHelpSearch(){
    const input = document.getElementById('helpSearch');
    const host = document.getElementById('helpContent');
    const countLabel = document.getElementById('helpSearchCount');
    if(!input || !host) return;
    const raw = input.value || '';
    const term = raw.trim().toLowerCase();
    clearHelpHighlights();
    helpMatches = [];
    helpMatchIndex = -1;
    if(!term){ if(countLabel) countLabel.textContent = '0 matches'; return; }
    findInNode(host, term);
    if(countLabel){
      countLabel.textContent = helpMatches.length ? (helpMatches.length + ' matches') : '0 matches';
    }
    if(helpMatches.length){
      helpMatchIndex = 0;
      helpMatches[0].scrollIntoView({behavior:'smooth',block:'center'});
      helpMatches[0].style.backgroundColor = '#fde68a';
    }
  }
  function stepHelpMatch(dir){
    if(!helpMatches.length) return;
    helpMatchIndex = (helpMatchIndex + dir + helpMatches.length) % helpMatches.length;
    const el = helpMatches[helpMatchIndex];
    if(el && el.scrollIntoView){
      el.scrollIntoView({behavior:'smooth',block:'center'});
      helpMatches.forEach(m=>m.style.backgroundColor='');
      el.style.backgroundColor = '#fde68a';
    }
  }
  function setupHelpUI(){
    const search = document.getElementById('helpSearch');
    if(search){
      search.addEventListener('keydown', e=>{
        if(e.key === 'Enter'){ e.preventDefault(); runHelpSearch(); }
      });
      search.addEventListener('input', ()=>{ runHelpSearch(); });
    }
    const prevBtn = document.getElementById('helpSearchPrev');
    const nextBtn = document.getElementById('helpSearchNext');
    if(prevBtn) prevBtn.addEventListener('click', ()=>stepHelpMatch(-1));
    if(nextBtn) nextBtn.addEventListener('click', ()=>stepHelpMatch(1));
    document.querySelectorAll('[data-help-jump]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-help-jump');
        const target = document.getElementById(id);
        const host = document.getElementById('helpContent');
        if(target && host){
          target.scrollIntoView({behavior:'smooth',block:'start'});
        }
      });
    });
  }
  
  // Detect paper size preference (US = Letter, rest = A4)
  function getPreferredPaperSize(){
    const locale = navigator.language || navigator.userLanguage || 'en-US';
    // US, Canada, Mexico use Letter (8.5x11), rest of world uses A4 (210x297mm)
    return locale.startsWith('en-US') || locale.startsWith('en-CA') ? 'letter' : 'a4';
  }
  function getStageHTML(){
    const el=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
    return el ? el.outerHTML : '';
  }
  function deepCopySetlist(src){ try{ return JSON.parse(JSON.stringify(src||[])); }catch(_){ return []; } }
  function makeSnapshot(){ return { setlist: deepCopySetlist(setlist), stage: getStageHTML() }; }
  function snapshotSignature(s){ return JSON.stringify({s:s.setlist, h:(s.stage||'').length}); }
  function pushAppHistory(){ if(_restoring) return; const snap=makeSnapshot(); const sig=snapshotSignature(snap); const cur= appHistoryIndex>=0? appHistory[appHistoryIndex] : null; if(cur && cur.sig===sig) return; appHistory.splice(appHistoryIndex+1); appHistory.push({ ...snap, sig }); if(appHistory.length>25){ appHistory.shift(); } appHistoryIndex=appHistory.length-1; }
  function applySnapshot(snap){ if(!snap) return; _restoring=true; try{
      // Stage dimension constants
      const STAGE_DEFAULT_WIDTH = 1000;
      const STAGE_DEFAULT_HEIGHT = 600;
      const STAGE_MIN_SIZE = 300;
      const STAGE_MAX_SIZE = 1500;
      
      // restore setlist
      setlist = deepCopySetlist(snap.setlist||[]);
      try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(_){ }
      // restore stage
      const html = snap.stage||'';
      if(html){
        const modal=document.getElementById('stageModal');
        const frame=document.getElementById('stageFrame');
        if(modal && modal.classList.contains('open')){
          const full=document.getElementById('stageSvgFull');
          if(full){
            const parent=full.parentNode;
            const tmp=document.createElement('div');
            tmp.innerHTML=html;
            const fresh=tmp.querySelector('svg');
            if(fresh && parent){
              // Restore stage dimensions from snapshot
              let stageW = parseInt(fresh.dataset.stageWidth || '0', 10);
              let stageH = parseInt(fresh.dataset.stageHeight || '0', 10);
              if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
              if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
              
              parent.replaceChild(fresh, full);
              fresh.id='stageSvgFull';
              // viewBox matches size (no scaling)
              fresh.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
              fresh.dataset.stageWidth = String(stageW);
              fresh.dataset.stageHeight = String(stageH);
              fresh.style.width = stageW + 'px';
              fresh.style.height = stageH + 'px';
              
              // Update background rect
              const bgRect = fresh.querySelector('rect.stage-bg');
              if(bgRect){
                bgRect.setAttribute('width', String(stageW - 2));
                bgRect.setAttribute('height', String(stageH - 2));
              }
              
              if(frame){
                frame.style.width = stageW + 'px';
                frame.style.height = stageH + 'px';
              }
              
              Array.from(fresh.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
              ensureStageMarkers(fresh);
              refreshCables(fresh);
              bindSelection(fresh);
            }
          }
        } else {
          const store=document.getElementById('stageStore');
          if(store){
            store.innerHTML=html;
            const svg=store.querySelector('svg');
            if(svg){
              svg.id='stageSvg';
              svg.classList.add('bw');
              // viewBox matches stored size
              let stageW = parseInt(svg.dataset.stageWidth || '0', 10);
              let stageH = parseInt(svg.dataset.stageHeight || '0', 10);
              if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
              if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
              svg.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
              refreshCables(svg);
            }
          }
        }
      }
      saveAll();
    }finally{ _restoring=false; }
  }
  function undoApp(){ if(appHistoryIndex>0){ appHistoryIndex--; applySnapshot(appHistory[appHistoryIndex]); } }
  function redoApp(){ if(appHistoryIndex>=0 && appHistoryIndex<appHistory.length-1){ appHistoryIndex++; applySnapshot(appHistory[appHistoryIndex]); } }
  // Global undo/redo keybindings (Ctrl+Z / Ctrl+Y, Shift+Ctrl+Z)
  document.addEventListener('keydown', e=>{
    const key = e.key || '';
    const mod = e.ctrlKey || e.metaKey;
    const isUndo = mod && !e.shiftKey && (key==='z' || key==='Z');
    const isRedo = (mod && (key==='y' || key==='Y')) || (mod && e.shiftKey && (key==='z' || key==='Z'));
    if(!(isUndo || isRedo)) return;
    if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(isUndo) undoApp(); else redoApp();
  });
  const DEFAULT_MOODS = ['upbeat','happy','energetic','mellow','sad'];
  const moodLabel = (k)=> k.charAt(0).toUpperCase()+k.slice(1);
  const getAllMoods = ()=> [...DEFAULT_MOODS, ...((gig.customMoods||[]).filter(x=>!DEFAULT_MOODS.includes(x)))].slice(0,12);
  
  // Utility: Extract first lyric line (skip chords, section headers, tablature)
  const findFirstLyricLine=(txt)=>{ const lines=(txt||'').split('\n'); for(let l of lines){ const t=l.trim(); if(!t) continue; if(t.startsWith('[') && t.includes(']')) continue; if(t.startsWith('|')) continue; if(/^[A-G]([#b]?m?|add\d|maj|min|sus|dim|aug|\d)*[\s/]+/.test(t)) continue; return t; } return ''; };
  
  // Utility: Prompt with trim
  const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
  function renderAddMoodsUI(){
    const host=document.getElementById('addCustomMoods'); if(!host) return;
    host.innerHTML='';
    (gig.customMoods||[]).forEach(k=>{
      const lab=document.createElement('label'); lab.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id='cm-'+k;
      lab.appendChild(cb); lab.appendChild(document.createTextNode(' '+moodLabel(k)));
      host.appendChild(lab);
    });
  }

  // Storage
  const STORE_KEY='fastfast-setlist-v1';
  function saveAll(){
    try{
      // Prefer full editor SVG if open; fallback to stored small one
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      let stageHTML='';
      if(stageEl){
        const clone=stageEl.cloneNode(true);
        clone.querySelectorAll('g[data-draggable].selected').forEach(n=> n.classList.remove('selected'));
        stageHTML=clone.outerHTML;
        // Keep compact stored svg synchronized when full editor present
        const full=document.getElementById('stageSvgFull');
        const small=document.getElementById('stageSvg');
        if(full && small){
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
          Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
        }
      }
      
      // Save stage, setlist, gearSummary, and techNotes to current tour date if one is selected
      // Each date can have its own unique stage plot (including blank)
      if(typeof selectedTourDateId !== 'undefined' && selectedTourDateId && typeof tourDates !== 'undefined'){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(tourDate){
          // Always save current stage state to tour date (can be blank)
          tourDate.stage = stageHTML;
          tourDate.setlist = [...setlist];
          tourDate.gig = {...gig};
          if(typeof gearSummary !== 'undefined') tourDate.gearSummary = gearSummary;
          if(typeof techNotes !== 'undefined') tourDate.techNotes = techNotes;
        }
      }
      
      // Strip any embedded audioData before persisting to storage
      const dbOut = db.map(s=>{ const { audioData, ...rest } = s || {}; return rest; });
      // Track last used setlist if current setlist is non-empty
      if(setlist && setlist.length > 0){
        lastUsedSetlist = {setlist: JSON.parse(JSON.stringify(setlist)), gig: JSON.parse(JSON.stringify(gig)), date: new Date().toISOString()};
      }
      const payload={db:dbOut,setlist,gig,gearSummary,techNotes,stage:stageHTML,setlistColumns,pageLayout,tourDates,tourCustomSearchTerms,customSearchButtons,selectedTourDateId,activeTab:previousTab,bandPresets,currentBandPresetId,stagePresets,setlistPresets,lastUsedSetlist};
      localStorage.setItem(STORE_KEY, JSON.stringify(payload));
    }catch(e){ console.error('saveAll failed', e); }
  }

  function findSongById(id){ return db.find(x=> x.id===id); }
  function findSongByTitle(title){ return db.find(x=> (x.title||'').trim()===String(title||'').trim()); }
  function ensureLiveAudioEl(){ if(!_liveAudioEl){ _liveAudioEl=new Audio(); _liveAudioEl.preload='auto'; _liveAudioEl.crossOrigin='anonymous'; } return _liveAudioEl; }
  function stopSongAudio(){ try{ if(_liveAudioEl){ _liveAudioEl.pause(); _liveAudioEl.currentTime=0; } }catch(_){ }
    try{ if(_liveAudioWin && !(_liveAudioWin.closed)){ _liveAudioWin.close(); } }catch(_){ }
    _liveAudioWin=null;
  }
  function preloadSongAudioFor(setItem){
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return;
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    if(armed){ const a=ensureLiveAudioEl(); if(a.src!==armed){ a.src=armed; } try{ a.load(); }catch(_){ } return; }
    if(url){ const lower=url.toLowerCase(); const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream'); if(isStream){ const a=ensureLiveAudioEl(); if(a.src!==url){ a.src=url; } try{ a.load(); }catch(_){ } }
    }
  }
  function playSongAudioFor(setItem){
    // Prefer looking up canonical song in db to access latest audio fields
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return; // nothing to play
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    // Armed local file or URL (session)
    if(armed){
      // Always stop any other playback before starting
      stopSongAudio();
      // Check if armed value is a URL string (http/https) or blob URL
      const armedValue = armedAudio[song.id];
      const isExternalUrl = typeof armedValue==='string' && (armedValue.startsWith('http://') || armedValue.startsWith('https://'));
      if(isExternalUrl){
        // Armed URL - treat as external link
        const lower=armedValue.toLowerCase();
        const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
        if(isStream){
          const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
        } else {
          // External provider (YouTube/Spotify/etc.)
          if(_liveAudioWin && !_liveAudioWin.closed){
            if(_liveLastExternalUrl===armedValue){ return; }
            try{ _liveAudioWin.location.href=armedValue; _liveLastExternalUrl=armedValue; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
          }
          try{ _liveAudioWin = window.open(armedValue,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=armedValue; }catch(_){ _liveAudioWin=null; }
        }
      } else {
        // Armed local file (blob URL)
        const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
      }
      return;
    }
    if(url){
      const lower=url.toLowerCase();
      const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      if(isStream){
        // Stop any previous audio before starting this stream
        stopSongAudio();
        const a=ensureLiveAudioEl(); a.src=url; a.play().catch(()=>{}); return;
      }
      // External provider (YouTube/Spotify/etc.): reuse single popup and avoid re-opening if same URL
      if(_liveAudioWin && !_liveAudioWin.closed){
        if(_liveLastExternalUrl===url){ return; }
        try{ _liveAudioWin.location.href=url; _liveLastExternalUrl=url; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
      }
      try{ _liveAudioWin = window.open(url,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=url; }catch(_){ _liveAudioWin=null; }
      return;
    }
  }

  // Capture a snapshot of the current full stage SVG for undo/redo
  function snapshotStage(){
    try{ pushAppHistory('stage'); }catch(_){ }
  }
  // Throttled save for high-frequency drag updates
  let _savePending=false; let _lastSaveTs=0; const SAVE_MIN_INTERVAL=250; // ms
  function queueSave(){
    const now=Date.now();
    if(!_savePending && (now-_lastSaveTs)>=SAVE_MIN_INTERVAL){
      _savePending=true;
      requestAnimationFrame(()=>{
        _savePending=false; _lastSaveTs=Date.now(); saveAll();
        // Update calendar preview if we're in a tour date
        if(typeof selectedTourDateId !== 'undefined' && selectedTourDateId && typeof tourDates !== 'undefined' && typeof renderTourPreviews === 'function'){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate) renderTourPreviews(tourDate);
        }
      });
    }
  }
  // Track if there are unsaved changes worth prompting about
  let hasUnsavedChanges = false;
  function markUnsaved(){ hasUnsavedChanges = true; }
  
  // Persist on navigation away with save prompt
  window.addEventListener('beforeunload', (e)=>{
    try{ for(const k in armedAudio){ try{ URL.revokeObjectURL(armedAudio[k]); }catch(_){} } }catch(_){}
    saveAll();
    // Only prompt if there's meaningful data
    const hasData = (db && db.length > 0) || (setlist && setlist.length > 0) || (tourDates && tourDates.length > 0);
    if(hasData){
      // Browser will show native "Leave site?" prompt
      e.preventDefault();
      e.returnValue = 'You have unsaved work. Make sure to export your BAND or SET file!';
      return e.returnValue;
    }
  });

  // Run after everything is ready
  window.addEventListener('load', ()=>{
    setupHelpUI();
  });
    
    // Add custom column button
    const addCustomColumnBtn=document.getElementById('addCustomColumn');
    if(addCustomColumnBtn){ addCustomColumnBtn.addEventListener('click', ()=>{
      const name = prompt('Custom column name (e.g., Genre, Language, Tempo):');
      if(!name || name.trim().length === 0) return;
      const key = name.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if(!gig.customColumns) gig.customColumns = [];
      if(gig.customColumns.find(c => c.key === key)){
        alert('Column already exists.');
        return;
      }
      // Ask if they want to push this field to setlist
      const pushToSet = confirm('Push this field data to setlist display?\n\nClick OK to show this column in the printed setlist alongside song titles.\nClick Cancel to keep it database-only.');
      gig.customColumns.push({key, name: name.trim(), pushToSetlist: pushToSet});
      // Add to column order
      if(!gig.dbColumns.order) gig.dbColumns.order = ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      // Insert before actions
      const actionsIdx = gig.dbColumns.order.indexOf('actions');
      if(actionsIdx > -1){
        gig.dbColumns.order.splice(actionsIdx, 0, key);
      } else {
        gig.dbColumns.order.push(key);
      }
      saveAll();
      renderDB();
      buildSheet('sheetInline');
    }); }
    
    // Clear database
    const clearDBBtn=document.getElementById('clearDB');
    const clearDBLock=document.getElementById('clearDBLock');
    if(clearDBBtn){ clearDBBtn.addEventListener('click',()=>{
      if(!db.length) return;
      if(clearDBLock && !clearDBLock.checked){ alert('Please check the unlock checkbox first to enable clearing the database.'); return; }
      // Offer to save a .BAND backup first
      try{
        if(confirm('Download a .BAND backup before clearing the database? Click OK to Save, or Cancel to skip.')){
          var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
          const stage = stageEl ? stageEl.outerHTML : '';
          const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
          const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
          const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
        }
      }catch(_){ /* ignore */ }
      if(!confirm('Clear entire song database now? This cannot be undone (unless you reload a .BAND profile).')) return;
      db.splice(0,db.length); renderDB(); saveAll();
    }); }
    // Clear setlist
    const clearSetBtn=document.getElementById('clearSet');
    if(clearSetBtn){ clearSetBtn.addEventListener('click',()=>{ if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; } if(!setlist.length) return; if(!confirm('Clear current setlist?')) return; setlist=[]; buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll(); }); }
    
    // Save Setlist as Preset button - now shows menu with Load/Save/Cancel
    const saveSetlistPresetBtn=document.getElementById('saveSetlistPresetBtn');
    if(saveSetlistPresetBtn){ saveSetlistPresetBtn.addEventListener('click', showSetlistPresetMenu); }
    
    // New Setlist button
    const newSetBtn=document.getElementById('newSetBtn');
    if(newSetBtn){ newSetBtn.addEventListener('click',()=>{
      if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; }
      if(!setlist.length){
        alert('Setlist is already empty!');
        return;
      }
      const save = confirm('Save current setlist as a preset before starting fresh?\n\nOK = Save as preset\nCancel = Just clear (lose current setlist)');
      if(save){
        saveSetlistAsPreset();
      }
      setlist = [];
      buildSheet('sheetInline');
      attachPreviewInteractions();
      renderSongPool();
      saveAll();
    }); }
    // Help modal open/close and Gear panel
    const helpBtn=document.getElementById('helpBtn'); const helpModal=document.getElementById('helpModal'); const closeHelp=document.getElementById('closeHelp');
    if(helpBtn && helpModal){ helpBtn.addEventListener('click',()=>{ helpModal.style.display='flex'; helpModal.classList.add('open'); }); }
    if(closeHelp){ closeHelp.addEventListener('click',()=>{ helpModal.classList.remove('open'); helpModal.style.display='none'; }); }
    if(helpModal){
      helpModal.addEventListener('click',e=>{
        if(e.target===helpModal){ helpModal.classList.remove('open'); helpModal.style.display='none'; }
      });
    }
    
    // File menu dropdown
    const fileMenuBtn=document.getElementById('fileMenuBtn');
    const fileMenuDropdown=document.getElementById('fileMenuDropdown');
    if(fileMenuBtn && fileMenuDropdown){
      fileMenuBtn.addEventListener('click',(e)=>{
        e.stopPropagation();
        fileMenuDropdown.classList.toggle('open');
      });
      // Close menu when clicking outside
      document.addEventListener('click',(e)=>{
        if(!fileMenuDropdown.contains(e.target) && e.target !== fileMenuBtn){
          fileMenuDropdown.classList.remove('open');
        }
      });
      // Close menu when any menu item is clicked
      fileMenuDropdown.querySelectorAll('.file-menu-item').forEach(item=>{
        item.addEventListener('click',()=>{
          fileMenuDropdown.classList.remove('open');
        });
      });
    }

    // Page layout controls
    (function setupPageLayout(){
      const formatSel=document.getElementById('paperFormat');
      if(formatSel){
        formatSel.value = pageLayout.format || 'letter';
        formatSel.addEventListener('change',()=>{
          pageLayout.format = formatSel.value;
          saveAll();
          buildSheet('sheetInline');
        });
      }
    })();

    // Setlist display column checkboxes
    (function setupSetlistColumns(){
      ['artist','capo','key','notes','bpm','lyrics'].forEach(k=>{
        const cb=document.getElementById('setCol_'+k);
        if(!cb) return;
        cb.checked = !!setlistColumns[k];
        cb.addEventListener('change',()=>{
          setlistColumns[k] = cb.checked;
          saveAll();
          buildSheet('sheetInline');
        });
      });
      // Add custom column checkboxes
      const customHost=document.getElementById('setColCustom');
      if(customHost && gig.customColumns){
        gig.customColumns.forEach(cc=>{
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const cb=document.createElement('input');
          cb.type='checkbox';
          cb.id='setCol_custom_'+cc.key;
          if(!setlistColumns[cc.key]) setlistColumns[cc.key] = !!cc.pushToSetlist;
          cb.checked = !!setlistColumns[cc.key];
          cb.addEventListener('change',()=>{
            setlistColumns[cc.key] = cb.checked;
            saveAll();
            buildSheet('sheetInline');
          });
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(' '+cc.name));
          customHost.appendChild(lbl);
        });
      }
    })();

    // Lyrics helpers: search popup (user chooses source)
    (function setupLyricsHelpers(){
      const searchBtn=document.getElementById('searchLyricsBtn');
      if(searchBtn){
        searchBtn.addEventListener('click',()=>{
          const titleEl=document.getElementById('t');
          const artistEl=document.getElementById('a');
          const title=(titleEl && titleEl.value.trim())||'';
          const artist=(artistEl && artistEl.value.trim())||'';
          if(!title){ alert('Enter a song title first to build a search.'); return; }
          const q=encodeURIComponent([title, artist, 'lyrics chords'].filter(Boolean).join(' '));
          const url='https://www.google.com/search?q='+q;
          window.open(url,'lyricsSearch','noopener');
        });
      }
    })();
  function loadAll(){
    try{
      const raw=localStorage.getItem(STORE_KEY); if(!raw) return;
    const {db:dbIn,setlist:setIn,gig:gigIn,gearSummary:gearIn,techNotes:tnIn,stage,setlistColumns:setColIn,pageLayout:pageLayoutIn,tourDates:tourIn,tourCustomSearchTerms:tourSearchIn,selectedTourDateId:selectedIdIn,activeTab:activeTabIn,bandPresets:bandPresetsIn,currentBandPresetId:currentBandPresetIdIn,stagePresets:stagePresetsIn,setlistPresets:setlistPresetsIn,lastUsedSetlist:lastUsedSetlistIn}=JSON.parse(raw);
      if(Array.isArray(dbIn)) db.push(...dbIn);
      if(Array.isArray(setIn)) setlist=setIn;
      if(gigIn) gig=Object.assign(gig,gigIn);
      if(gearIn) { gearSummary = gearIn; }
  if(tnIn && typeof tnIn==='object') { techNotes = tnIn; }
  if(setColIn && typeof setColIn==='object') { 
    // Force new defaults for display columns
    setlistColumns = {artist:false, capo:true, key:true, notes:false, bpm:false, lyrics:false};
    // Preserve any custom column settings
    Object.keys(setColIn).forEach(k => {
      if(!['artist','capo','key','notes','bpm','lyrics'].includes(k)) {
        setlistColumns[k] = setColIn[k];
      }
    });
  }
  if(pageLayoutIn && typeof pageLayoutIn==='object') { pageLayout = Object.assign(pageLayout, pageLayoutIn); }
  if(Array.isArray(tourIn)) { tourDates = tourIn; }
  if(typeof tourSearchIn === 'string') { tourCustomSearchTerms = tourSearchIn; }
  if(selectedIdIn) { selectedTourDateId = selectedIdIn; }
  if(activeTabIn) { previousTab = activeTabIn; }
  if(Array.isArray(bandPresetsIn)) { bandPresets = bandPresetsIn; }
  if(currentBandPresetIdIn) { currentBandPresetId = currentBandPresetIdIn; }
  if(Array.isArray(stagePresetsIn)) { stagePresets = stagePresetsIn; }
  if(Array.isArray(setlistPresetsIn)) { setlistPresets = setlistPresetsIn; }
  if(lastUsedSetlistIn && lastUsedSetlistIn.setlist) { lastUsedSetlist = lastUsedSetlistIn; }
      // Gig info now edited directly on sheet header
      const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value = gearSummary || '';
      renderDB(); buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool();
      if(stage){
        // Stage dimension constants
        const STAGE_DEFAULT_WIDTH = 1000;
        const STAGE_DEFAULT_HEIGHT = 600;
        const STAGE_MIN_SIZE = 300;
        const STAGE_MAX_SIZE = 1500;
        
        const container=document.getElementById('stageStore');
        container.innerHTML=stage;
        const svg=container.querySelector('svg');
        if(svg){
          svg.id='stageSvg';
          svg.classList.add('bw');
          // Validate and apply stored dimensions
          let stageW = parseInt(svg.dataset.stageWidth || '0', 10);
          let stageH = parseInt(svg.dataset.stageHeight || '0', 10);
          if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
          if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
          svg.dataset.stageWidth = String(stageW);
          svg.dataset.stageHeight = String(stageH);
          svg.style.width = stageW + 'px';
          svg.style.height = stageH + 'px';
          // viewBox must match canvas size for 1:1 pixel mapping (no scaling)
          svg.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
          // Background rect matches stage size
          const bgRect = svg.querySelector('rect.stage-bg');
          if(bgRect){
            bgRect.setAttribute('x', '1');
            bgRect.setAttribute('y', '1');
            bgRect.setAttribute('width', String(stageW - 2));
            bgRect.setAttribute('height', String(stageH - 2));
          }
          refreshCables(svg);
        }
      }
    }catch(e){/* ignore */}
  }

    // Helpers
    const $ = s=>document.querySelector(s);
    const el = (t,cls,txt)=>{const n=document.createElement(t); if(cls) n.className=cls; if(txt!=null) n.textContent=txt; return n;}
    const shuffle = a=>{const r=[...a]; for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[r[i],r[j]]=[r[j],r[i]];} return r}

    // Title shortening: trims, collapses, removes parentheticals, limits words, ensures width via characters
    function shorten(title, maxChars=48){
      if(!title) return '';
      // Keep original wording; only trim whitespace and optional parentheticals for clutter
      let t=title.replace(/\s+/g,' ').trim();
      t=t.replace(/\s*\([^)]*\)\s*/g,' '); // remove (feat), (live), etc
      if(t.length>maxChars) t=t.slice(0,maxChars-1)+'‚Ä¶';
      return t;
    }

    // Tabs
    let previousTab = 'tour'; // Track previous tab
    document.querySelectorAll('.tab').forEach(btn=>btn.addEventListener('click',e=>{
      // Setlist tab: check if date has setlist
      if(btn.dataset.tab === 'set'){
        if(selectedTourDateId){
          const td = tourDates.find(t => t.id === selectedTourDateId);
          if(td && td.setlist && td.setlist.length > 0){
            // Has setlist: auto-edit mode
            window.setlistEditMode = 'edit';
            setlist = JSON.parse(JSON.stringify(td.setlist));
            buildSheet('sheetInline');
            attachPreviewInteractions();
            renderSongPool();
          } else {
            // No setlist: show 4-option dialog
            e.preventDefault();
            showSetlistOptionsDialog(td, btn);
            return;
          }
        } else {
          // No date selected: show 4-option dialog
          e.preventDefault();
          showSetlistOptionsDialog(null, btn);
          return;
        }
      }
      
      // Save Calendar data when leaving Calendar tab
      if(previousTab === 'tour' && btn.dataset.tab !== 'tour'){
        try { if(typeof saveTourDateData === 'function') saveTourDateData(); } catch(err) { console.log('Save tour data:', err); }
      }
      
      // Save Tech/Stage data when leaving Tech/Stage tab
      if(previousTab === 'adv' && btn.dataset.tab !== 'adv'){
        if(selectedTourDateId){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate){
            tourDate.stage = getStageHTML();
            tourDate.gearSummary = gearSummary;
            tourDate.techNotes = techNotes;
          }
        }
        const stageModal = document.getElementById('stageModal');
        if(stageModal && stageModal.classList.contains('open')){
          try{ closeStageModal(); }catch(_){ stageModal.classList.remove('open'); }
        }
        saveAll();
      }
      
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      const activePanel = document.getElementById(btn.dataset.tab);
      if(activePanel){
        activePanel.style.display='block';
        activePanel.classList.add('tab-panel-animate');
        setTimeout(()=>activePanel.classList.remove('tab-panel-animate'),220);
      }
      
      // Reload Calendar data when entering Calendar tab
      if(btn.dataset.tab === 'tour'){
        try { if(typeof window.reloadCalendarData === 'function') window.reloadCalendarData(); } catch(err) { console.log('Reload calendar data:', err); }
      }
      
      previousTab = btn.dataset.tab;
      // Only Tech/Stage tab should show stage or lighting sections
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      document.body.classList.toggle('live-mode', btn.dataset.tab==='live');
      if(btn.dataset.tab==='adv'){
        if(stageModal && !stageModal.classList.contains('open') && notesModal && !notesModal.classList.contains('open')){
          // Default to Stage Plot view when entering Tech/Stage
          toggleStageAndNotes();
        }
      } else if(btn.dataset.tab==='live'){
        // Closing any stage/notes modals for distraction-free live view
        if(stageModal && stageModal.classList.contains('open')){ try{ closeStageModal(); }catch(_){ stageModal.classList.remove('open'); } }
        if(notesModal && notesModal.classList.contains('open')){ notesModal.classList.remove('open'); }
        // Refresh live view when switching to Live tab
        try{ renderLive(); }catch(_){ }
        // Notify listeners we entered live to trigger auto-arm prompt
        try{ document.dispatchEvent(new Event('live-enter')); }catch(_){ }
      } else {
        // Leaving Tech/Stage: if stage editor open, perform full sync via closeStageModal (ensures compact svg updated)
        if(stageModal && stageModal.classList.contains('open')){
          closeStageModal();
        } else if(stageModal){
          saveAll(); stageModal.classList.remove('open');
        }
        if(notesModal) notesModal.classList.remove('open');
      }
    }));

    // Prefill date today
    (function prefill(){
      const d=$('#gDate'); if(d && !d.value){ const t=new Date(); const iso=new Date(t.getTime()-t.getTimezoneOffset()*60000).toISOString().slice(0,10); d.value=iso; }
      loadAll();
      // Build initial inline preview
      try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){ }
      try{ renderAddMoodsUI(); }catch(_){ }
      try{ renderLive(); }catch(_){ }
      // Apply saved live theme
      if(gig && gig.liveDark){ document.body.classList.add('live-dark'); }
      
      // Restore last active tab and selected tour date
      const restoreTab = previousTab || 'tour';
      document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
      const tabToActivate = document.querySelector(`.tab[data-tab="${restoreTab}"]`);
      if(tabToActivate) {
        tabToActivate.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id => {
          const el = document.getElementById(id);
          if(el) el.style.display = 'none';
        });
        const tabContent = document.getElementById(restoreTab);
        if(tabContent) tabContent.style.display = 'block';
      }
      
      // Smart date selection on load: prioritize today or future dates, never load past dates
      if(restoreTab === 'tour') {
        const today = new Date();
        today.setHours(0,0,0,0);
        const todayStr = today.toISOString().split('T')[0];
        
        let dateToSelect = null;
        
        // First, check if there's a date for today
        const todayDate = tourDates.find(td => td.date === todayStr);
        if(todayDate) {
          dateToSelect = todayDate;
        } else if(selectedTourDateId) {
          // Check if last selected date is today or in the future
          const lastTourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(lastTourDate) {
            const lastDate = new Date(lastTourDate.date);
            lastDate.setHours(0,0,0,0);
            if(lastDate >= today) {
              dateToSelect = lastTourDate;
            }
          }
        }
        
        // If no valid date yet, find the next incomplete future date
        if(!dateToSelect) {
          const futureDates = tourDates
            .filter(td => {
              const tdDate = new Date(td.date);
              tdDate.setHours(0,0,0,0);
              return tdDate >= today;
            })
            .sort((a, b) => new Date(a.date) - new Date(b.date));
          
          // Find first incomplete date (missing venue or setlist/stage)
          const incompleteDate = futureDates.find(td => {
            const hasVenue = td.venue && td.venue.trim() !== '';
            const hasSetlist = td.setlist && td.setlist.length > 0;
            const hasStagePlot = td.stage && td.stage.trim() !== '';
            return !hasVenue || (!hasSetlist && !hasStagePlot);
          });
          
          dateToSelect = incompleteDate || futureDates[0];
        }
        
        // Select the determined date
        if(dateToSelect) {
          try {
            if(typeof window.selectTourDate === 'function') {
              window.selectTourDate(dateToSelect);
            }
          } catch(e) {
            console.log('Could not restore tour date:', e);
          }
        }
      }
      
      // Prompt for band name if not set (new user or first launch)
      setTimeout(()=>{
        if(!gig.band || gig.band.trim() === '' || gig.band.trim() === 'Enter Band Name'){
          showBandPresetModal();
        }
      }, 300);
    })();
    
    // Setlist Options Dialog - shown when clicking Setlist tab with no existing setlist
    function showSetlistOptionsDialog(tourDate, tabBtn){
      let modal = document.getElementById('setlistOptionsModal');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistOptionsModal';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      const hasLastUsed = lastUsedSetlist && lastUsedSetlist.setlist && lastUsedSetlist.setlist.length > 0;
      const hasPresets = setlistPresets && setlistPresets.length > 0;
      
      modal.innerHTML = `
        <div style="background:#1f2937;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">Open Setlist</h3>
          <p style="margin:0 0 20px;color:#9ca3af;font-size:14px">Choose how to start your setlist:</p>
          <div style="display:flex;flex-direction:column;gap:12px">
            <button id="setOptNew" style="padding:14px 16px;background:#065f46;color:#fff;border:none;border-radius:8px;font-size:15px;cursor:pointer;text-align:left;display:flex;align-items:center;gap:12px">
              <span style="font-size:20px">üìù</span>
              <div><strong>New</strong><br><span style="font-size:12px;color:#d1fae5">Start fresh setlist with current date/venue</span></div>
            </button>
            <button id="setOptLastUsed" style="padding:14px 16px;background:${hasLastUsed ? '#1e40af' : '#374151'};color:${hasLastUsed ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasLastUsed ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasLastUsed ? '' : 'disabled'}>
              <span style="font-size:20px">üïê</span>
              <div><strong>Last Used</strong><br><span style="font-size:12px;color:${hasLastUsed ? '#bfdbfe' : '#6b7280'}">${hasLastUsed ? 'Load most recent setlist' : 'No previous setlist saved'}</span></div>
            </button>
            <button id="setOptLoad" style="padding:14px 16px;background:#7c3aed;color:#fff;border:none;border-radius:8px;font-size:15px;cursor:pointer;text-align:left;display:flex;align-items:center;gap:12px">
              <span style="font-size:20px">üìÇ</span>
              <div><strong>Load</strong><br><span style="font-size:12px;color:#e9d5ff">Import from .SET file</span></div>
            </button>
            <button id="setOptPreset" style="padding:14px 16px;background:${hasPresets ? '#c2410c' : '#374151'};color:${hasPresets ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasPresets ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasPresets ? '' : 'disabled'}>
              <span style="font-size:20px">‚≠ê</span>
              <div><strong>Preset</strong><br><span style="font-size:12px;color:${hasPresets ? '#fed7aa' : '#6b7280'}">${hasPresets ? setlistPresets.length + ' saved preset(s)' : 'No presets saved yet'}</span></div>
            </button>
          </div>
          <div style="margin-top:20px;text-align:right">
            <button id="setOptCancel" style="padding:10px 20px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      function proceedToTab(){
        document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
        tabBtn.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
        document.getElementById('set').style.display='block';
        previousTab = 'set';
        buildSheet('sheetInline');
        attachPreviewInteractions();
        renderSongPool();
      }
      
      // New - blank setlist with current date info
      modal.querySelector('#setOptNew').onclick = ()=>{
        closeModal();
        window.setlistEditMode = 'new';
        setlist = [];
        if(tourDate){
          gig.venue = tourDate.venue || '';
          gig.address = tourDate.address || '';
          gig.notes = tourDate.notes || '';
        }
        proceedToTab();
      };
      
      // Last Used
      if(hasLastUsed){
        modal.querySelector('#setOptLastUsed').onclick = ()=>{
          closeModal();
          window.setlistEditMode = 'new';
          setlist = JSON.parse(JSON.stringify(lastUsedSetlist.setlist));
          if(tourDate){
            gig.venue = tourDate.venue || gig.venue;
            gig.address = tourDate.address || gig.address;
          }
          proceedToTab();
        };
      }
      
      // Load from file
      modal.querySelector('#setOptLoad').onclick = ()=>{
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.set,.json';
        input.onchange = ev=>{
          const file = ev.target.files[0];
          if(!file) return;
          const reader = new FileReader();
          reader.onload = re=>{
            try{
              const data = JSON.parse(re.target.result);
              if(data.setlist && Array.isArray(data.setlist)){
                setlist = data.setlist;
                if(data.gig) Object.assign(gig, data.gig);
                window.setlistEditMode = 'new';
                closeModal();
                proceedToTab();
              } else {
                alert('Invalid .SET file format');
              }
            }catch(err){
              alert('Error reading file: ' + err.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };
      
      // Preset picker
      if(hasPresets){
        modal.querySelector('#setOptPreset').onclick = ()=>{
          closeModal();
          showSetlistPresetPicker(tourDate, tabBtn);
        };
      }
      
      // Cancel
      modal.querySelector('#setOptCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Setlist Preset Picker - shows saved presets with thumbnails
    function showSetlistPresetPicker(tourDate, tabBtn){
      let modal = document.getElementById('setlistPresetPicker');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetPicker';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      let presetsHTML = setlistPresets.map((p, idx)=>{
        const songCount = p.setlist ? p.setlist.length : 0;
        const preview = p.setlist ? p.setlist.slice(0,5).map(s=>s.title || 'Untitled').join(', ') : '';
        const dateStr = p.date ? new Date(p.date).toLocaleDateString() : '';
        return `
          <div class="preset-item" data-idx="${idx}" style="padding:12px;border:1px solid #374151;border-radius:8px;background:#1f2937;cursor:pointer;display:flex;flex-direction:column;gap:6px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong style="color:#fff">${p.name || 'Unnamed'}</strong>
              <button class="delete-preset" data-idx="${idx}" style="background:#991b1b;color:#fff;border:none;border-radius:4px;padding:4px 8px;font-size:11px;cursor:pointer">‚úï</button>
            </div>
            <div style="font-size:12px;color:#9ca3af">${songCount} songs ‚Ä¢ ${dateStr}</div>
            <div style="font-size:11px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${preview}...</div>
          </div>
        `;
      }).join('');
      
      modal.innerHTML = `
        <div style="background:#111827;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Setlist Presets</h3>
          <div style="display:flex;flex-direction:column;gap:10px">${presetsHTML || '<p style="color:#6b7280">No presets saved</p>'}</div>
          <div style="margin-top:20px;display:flex;gap:10px;justify-content:flex-end">
            <button id="presetPickerBack" style="padding:10px 16px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Back</button>
            <button id="presetPickerCancel" style="padding:10px 16px;background:#991b1b;color:#fff;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      function proceedToTab(){
        document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
        tabBtn.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
        document.getElementById('set').style.display='block';
        previousTab = 'set';
        buildSheet('sheetInline');
        attachPreviewInteractions();
        renderSongPool();
      }
      
      // Click on preset item to load
      modal.querySelectorAll('.preset-item').forEach(item=>{
        item.onclick = e=>{
          if(e.target.classList.contains('delete-preset')) return;
          const idx = parseInt(item.dataset.idx);
          const preset = setlistPresets[idx];
          if(preset && preset.setlist){
            setlist = JSON.parse(JSON.stringify(preset.setlist));
            window.setlistEditMode = 'new';
            if(tourDate){
              gig.venue = tourDate.venue || gig.venue;
              gig.address = tourDate.address || gig.address;
            }
            closeModal();
            proceedToTab();
          }
        };
      });
      
      // Delete preset
      modal.querySelectorAll('.delete-preset').forEach(btn=>{
        btn.onclick = e=>{
          e.stopPropagation();
          const idx = parseInt(btn.dataset.idx);
          if(confirm('Delete preset "' + (setlistPresets[idx]?.name || 'Unnamed') + '"?')){
            setlistPresets.splice(idx, 1);
            saveAll();
            closeModal();
            if(setlistPresets.length > 0){
              showSetlistPresetPicker(tourDate, tabBtn);
            } else {
              showSetlistOptionsDialog(tourDate, tabBtn);
            }
          }
        };
      });
      
      modal.querySelector('#presetPickerBack').onclick = ()=>{ closeModal(); showSetlistOptionsDialog(tourDate, tabBtn); };
      modal.querySelector('#presetPickerCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Show Preset menu with Load/Save/Cancel options
    function showSetlistPresetMenu(){
      let modal = document.getElementById('setlistPresetMenu');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetMenu';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      const hasPresets = setlistPresets && setlistPresets.length > 0;
      const hasSetlist = setlist && setlist.length > 0;
      
      modal.innerHTML = `
        <div style="background:#1f2937;color:#e5e7eb;border-radius:12px;padding:24px;max-width:400px;width:90%">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Setlist Presets</h3>
          <div style="display:flex;flex-direction:column;gap:12px">
            <button id="presetMenuSave" style="padding:14px 16px;background:${hasSetlist ? '#065f46' : '#374151'};color:${hasSetlist ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasSetlist ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasSetlist ? '' : 'disabled'}>
              <span style="font-size:20px">üíæ</span>
              <div><strong>Save Preset</strong><br><span style="font-size:12px;color:${hasSetlist ? '#d1fae5' : '#6b7280'}">Save current setlist as reusable preset</span></div>
            </button>
            <button id="presetMenuLoad" style="padding:14px 16px;background:${hasPresets ? '#c2410c' : '#374151'};color:${hasPresets ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasPresets ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasPresets ? '' : 'disabled'}>
              <span style="font-size:20px">üìÇ</span>
              <div><strong>Load Preset</strong><br><span style="font-size:12px;color:${hasPresets ? '#fed7aa' : '#6b7280'}">${hasPresets ? setlistPresets.length + ' preset(s) available' : 'No presets saved yet'}</span></div>
            </button>
          </div>
          <div style="margin-top:20px;text-align:right">
            <button id="presetMenuCancel" style="padding:10px 20px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      
      if(hasSetlist){
        modal.querySelector('#presetMenuSave').onclick = ()=>{
          closeModal();
          saveSetlistAsPreset();
        };
      }
      
      if(hasPresets){
        modal.querySelector('#presetMenuLoad').onclick = ()=>{
          closeModal();
          // Get current tab button for preset picker
          const tabBtn = document.querySelector('.tab[data-tab="set"]');
          showSetlistPresetPickerInline();
        };
      }
      
      modal.querySelector('#presetMenuCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Inline preset picker (for when already on setlist tab)
    function showSetlistPresetPickerInline(){
      let modal = document.getElementById('setlistPresetPicker');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetPicker';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      let presetsHTML = setlistPresets.map((p, idx)=>{
        const songCount = p.setlist ? p.setlist.length : 0;
        const preview = p.setlist ? p.setlist.slice(0,5).map(s=>s.title || 'Untitled').join(', ') : '';
        const dateStr = p.date ? new Date(p.date).toLocaleDateString() : '';
        return `
          <div class="preset-item" data-idx="${idx}" style="padding:12px;border:1px solid #374151;border-radius:8px;background:#1f2937;cursor:pointer;display:flex;flex-direction:column;gap:6px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong style="color:#fff">${p.name || 'Unnamed'}</strong>
              <button class="delete-preset" data-idx="${idx}" style="background:#991b1b;color:#fff;border:none;border-radius:4px;padding:4px 8px;font-size:11px;cursor:pointer">‚úï</button>
            </div>
            <div style="font-size:12px;color:#9ca3af">${songCount} songs ‚Ä¢ ${dateStr}</div>
            <div style="font-size:11px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${preview}...</div>
          </div>
        `;
      }).join('');
      
      modal.innerHTML = `
        <div style="background:#111827;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Load Setlist Preset</h3>
          <div style="display:flex;flex-direction:column;gap:10px">${presetsHTML || '<p style="color:#6b7280">No presets saved</p>'}</div>
          <div style="margin-top:20px;text-align:right">
            <button id="presetPickerCancelInline" style="padding:10px 16px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      
      // Click on preset item to load
      modal.querySelectorAll('.preset-item').forEach(item=>{
        item.onclick = e=>{
          if(e.target.classList.contains('delete-preset')) return;
          const idx = parseInt(item.dataset.idx);
          const preset = setlistPresets[idx];
          if(preset && preset.setlist){
            if(setlist && setlist.length > 0){
              if(!confirm('Replace current setlist with preset "' + preset.name + '"?')) return;
            }
            setlist = JSON.parse(JSON.stringify(preset.setlist));
            buildSheet('sheetInline');
            attachPreviewInteractions();
            renderSongPool();
            saveAll();
            closeModal();
          }
        };
      });
      
      // Delete preset
      modal.querySelectorAll('.delete-preset').forEach(btn=>{
        btn.onclick = e=>{
          e.stopPropagation();
          const idx = parseInt(btn.dataset.idx);
          if(confirm('Delete preset "' + (setlistPresets[idx]?.name || 'Unnamed') + '"?')){
            setlistPresets.splice(idx, 1);
            saveAll();
            closeModal();
            if(setlistPresets.length > 0){
              showSetlistPresetPickerInline();
            }
          }
        };
      });
      
      modal.querySelector('#presetPickerCancelInline').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Save current setlist as preset
    function saveSetlistAsPreset(){
      if(!setlist || setlist.length === 0){
        alert('Cannot save empty setlist as preset');
        return;
      }
      const name = prompt('Name this setlist preset:', gig.venue || 'Setlist ' + new Date().toLocaleDateString());
      if(name && name.trim()){
        setlistPresets.push({
          name: name.trim(),
          setlist: JSON.parse(JSON.stringify(setlist)),
          date: new Date().toISOString()
        });
        saveAll();
        alert('Setlist saved as preset: ' + name.trim());
      }
    }
    
    // Band Preset Modal - shows on first launch or when no band name is set
    function showBandPresetModal(){
      // Always remove and rebuild to ensure fresh event listeners
      let modal = document.getElementById('bandPresetModal');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'bandPresetModal';
      modal.className = 'modal open';
      modal.style.zIndex = '9999';
      modal.innerHTML = `
        <div class="modalbox" style="background:white;border-radius:12px;padding:24px;width:400px;max-width:90vw;box-shadow:0 10px 40px rgba(0,0,0,0.3);margin-top:60px;touch-action:manipulation">
          <h2 style="margin:0 0 16px;font-size:20px;font-weight:600">Hi. Please enter your artist / band / act name</h2>
          
          <div style="margin-bottom:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Band/Artist Name</label>
            <input type="text" id="bandPresetNameInput" placeholder="e.g., The Kildeers" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:16px;touch-action:manipulation;-webkit-appearance:none" />
          </div>
          
          ${bandPresets.length > 0 ? `
          <div style="margin-bottom:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Or Select Existing Band</label>
            <select id="bandPresetSelect" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:16px;touch-action:manipulation;-webkit-appearance:menulist">
              <option value="">-- New Band --</option>
              ${bandPresets.map(bp => `<option value="${bp.id}">${bp.name}</option>`).join('')}
            </select>
          </div>
          ` : ''}
          
          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button id="bandPresetSkip" type="button" class="btn" style="padding:12px 20px;font-size:14px;touch-action:manipulation;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0.1)">Skip for Now</button>
            <button id="bandPresetSave" type="button" class="btn primary" style="padding:12px 20px;font-size:14px;touch-action:manipulation;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0.1)">Save & Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Save handler function
      function saveBandPreset(){
        const nameInput = document.getElementById('bandPresetNameInput');
        const select = document.getElementById('bandPresetSelect');
        
        if(select && select.value){
          // Use existing preset
          const preset = bandPresets.find(bp => bp.id == select.value);
          if(preset){
            gig.band = preset.name;
            currentBandPresetId = preset.id;
          }
        } else if(nameInput && nameInput.value.trim()){
          // Create new preset
          const newName = nameInput.value.trim();
          gig.band = newName;
          const newPreset = {
            id: Date.now(),
            name: newName,
            defaultStage: '',
            logo: ''
          };
          bandPresets.push(newPreset);
          currentBandPresetId = newPreset.id;
        } else {
          alert('Please enter a band name or select an existing band.');
          return;
        }
        
        // Update UI and save
        const sheetBandEl = document.querySelector('.header .band');
        if(sheetBandEl) sheetBandEl.textContent = gig.band;
        const calBandInput = document.getElementById('tourBand');
        if(calBandInput) calBandInput.value = gig.band;
        // Update current tour date's band
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(tourDate) tourDate.band = gig.band;
        saveAll();
        if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
        if(typeof updateActDisplay === 'function') updateActDisplay();
        if(typeof refreshStageHeader === 'function') refreshStageHeader();
        modal.remove(); // Remove modal from DOM completely
        try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
      }
      
      // Event listeners - use both click and touchend for mobile compatibility
      const saveBtn = document.getElementById('bandPresetSave');
      const skipBtn = document.getElementById('bandPresetSkip');
      
      function handleSave(e){
        e.preventDefault();
        e.stopPropagation();
        saveBandPreset();
      }
      
      function handleSkip(e){
        e.preventDefault();
        e.stopPropagation();
        modal.remove();
      }
      
      saveBtn.addEventListener('click', handleSave);
      saveBtn.addEventListener('touchend', handleSave);
      skipBtn.addEventListener('click', handleSkip);
      skipBtn.addEventListener('touchend', handleSkip);
      
      // Prevent ghost clicks on touch
      saveBtn.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive: true});
      skipBtn.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive: true});
      
      // Enter key to save
      const nameInput = document.getElementById('bandPresetNameInput');
      if(nameInput){
        nameInput.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            saveBandPreset();
          }
        });
      }
      
      // If existing band selected, populate name field
      const selectEl = document.getElementById('bandPresetSelect');
      if(selectEl){
        selectEl.addEventListener('change', ()=>{
          if(selectEl.value){
            const preset = bandPresets.find(bp => bp.id == selectEl.value);
            if(preset && nameInput) nameInput.value = preset.name;
          }
        });
      }
      
      // Show modal and focus input
      setTimeout(()=>{ 
        if(nameInput) nameInput.focus(); 
      }, 150);
    }
    
    // Function to add/manage band presets (can be called from UI)
    function openBandPresetManager(){
      showBandPresetModal();
    }
    
    // Band Preset Manager Modal - for editing/deleting presets
    function showBandPresetManagerModal(){
      let modal = document.getElementById('bandPresetManagerModal');
      if(modal) modal.remove(); // Always rebuild to refresh list
      
      modal = document.createElement('div');
      modal.id = 'bandPresetManagerModal';
      modal.className = 'modal open';
      modal.style.zIndex = '9999';
      modal.innerHTML = `
        <div class="modalbox" style="background:white;border-radius:12px;padding:24px;width:450px;max-width:90vw;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:80vh;overflow-y:auto;margin-top:60px">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
            <h2 style="margin:0;font-size:18px;font-weight:600">üé∏ Manage Band Presets</h2>
            <button id="bandPresetManagerClose" style="background:none;border:none;font-size:18px;cursor:pointer">‚úï</button>
          </div>
          
          <p style="margin:0 0 16px;color:#666;font-size:13px">Switch between bands for multi-artist management. Each band can have its own setlists and stage plots on your calendar.</p>
          
          <div id="bandPresetList" style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px">
            ${bandPresets.length === 0 ? '<div style="color:#888;font-size:12px;text-align:center;padding:16px">No band presets saved yet</div>' : 
              bandPresets.map(bp => `
                <div class="band-preset-item" data-id="${bp.id}" style="display:flex;align-items:center;gap:8px;padding:10px;border:1px solid #e5e7eb;border-radius:6px;${currentBandPresetId === bp.id ? 'background:#e0f2fe;border-color:#0ea5e9' : 'background:#f9fafb'}">
                  <span style="flex:1;font-weight:500">${bp.name}</span>
                  <button class="band-preset-use btn primary" data-id="${bp.id}" style="padding:4px 10px;font-size:11px">Use</button>
                  <button class="band-preset-delete btn danger" data-id="${bp.id}" style="padding:4px 8px;font-size:11px">üóëÔ∏è</button>
                </div>
              `).join('')}
          </div>
          
          <div style="border-top:1px solid #e5e7eb;padding-top:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Add New Band</label>
            <div style="display:flex;gap:8px">
              <input type="text" id="newBandPresetName" placeholder="Band name" style="flex:1;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px" />
              <button id="addNewBandPreset" class="btn primary" style="padding:8px 16px;font-size:12px">Add</button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('bandPresetManagerClose').addEventListener('click', ()=>{
        modal.classList.remove('open');
      });
      
      // Use band buttons
      modal.querySelectorAll('.band-preset-use').forEach(btn => {
        btn.addEventListener('click', ()=>{
          const id = parseInt(btn.dataset.id);
          const preset = bandPresets.find(bp => bp.id === id);
          if(preset){
            gig.band = preset.name;
            currentBandPresetId = preset.id;
            const tourBandInput = document.getElementById('tourBand');
            if(tourBandInput) tourBandInput.value = preset.name;
            const sheetBandEl = document.querySelector('.header .band');
            if(sheetBandEl) sheetBandEl.textContent = preset.name;
            const tourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(tourDate) tourDate.band = preset.name;
            saveAll();
            // Refresh dropdown and act display
            if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
            if(typeof updateActDisplay === 'function') updateActDisplay();
            // Refresh stage header with new band
            try{ if(typeof refreshStageHeader === 'function') refreshStageHeader(); }catch(_){}
            modal.classList.remove('open');
            try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
          }
        });
      });
      
      // Delete band buttons
      modal.querySelectorAll('.band-preset-delete').forEach(btn => {
        btn.addEventListener('click', ()=>{
          const id = parseInt(btn.dataset.id);
          const preset = bandPresets.find(bp => bp.id === id);
          if(!preset) return;
          if(!confirm(`Delete band preset "${preset.name}"?`)) return;
          bandPresets = bandPresets.filter(bp => bp.id !== id);
          if(currentBandPresetId === id) currentBandPresetId = null;
          saveAll();
          if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
          showBandPresetManagerModal(); // Refresh
        });
      });
      
      // Add new band
      document.getElementById('addNewBandPreset').addEventListener('click', ()=>{
        const input = document.getElementById('newBandPresetName');
        const name = input?.value?.trim();
        if(!name){
          alert('Enter a band name');
          return;
        }
        if(bandPresets.find(bp => bp.name.toLowerCase() === name.toLowerCase())){
          alert(`"${name}" already exists`);
          return;
        }
        const newPreset = { id: Date.now(), name, defaultStage: '', logo: '' };
        bandPresets.push(newPreset);
        saveAll();
        if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
        showBandPresetManagerModal(); // Refresh
      });
      
      modal.classList.add('open');
    }

    // Add new song inline at top of database
    function addNewSongRow(){
      const newSong = {
        id: Date.now(),
        title: '',
        artist: 'Original',
        length: 3.5,
        key: '',
        capo: 0,
        bpm: 0,
        lyrics: '',
        audienceRating: 2,
        usageCount: 0,
        isCover: false,
        isUpbeat: false,
        isHappy: false,
        isMellow: false,
        isEnergetic: false,
        isSad: false,
        customMoods: []
      };
      db.unshift(newSong); // Add to start of array
      renderDB();
      saveAll();
      // Focus the title field of the new row
      setTimeout(() => {
        const list = document.getElementById('dbList');
        if(list) {
          const firstRow = list.querySelector('.db-row');
          if(firstRow) {
            const titleInput = firstRow.querySelector('input[placeholder="Title"]');
            if(titleInput) titleInput.focus();
          }
        }
      }, 50);
    }

    // DB Column configuration - persisted widths and order
    if(!gig.dbColumns){
      gig.dbColumns={
        order:['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'],
        widths:{add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120}
      };
    }

    function renderDB(){
      const list=$('#dbList'); list.innerHTML='';
      if(!db.length){ list.textContent='No songs yet.'; return; }
      
      // Ensure dbColumns exists (may have been lost during date switch)
      if(!gig.dbColumns){
        gig.dbColumns={
          order:['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'],
          widths:{add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120}
        };
      }
      
      // Column headers with resizing and reordering
      const hdrRow=document.createElement('div'); hdrRow.style.cssText='display:flex;gap:4px;align-items:center;padding:4px;background:#f3f4f6;font-weight:600;font-size:11px;border-bottom:2px solid #d1d5db;position:relative';
      
      const colOrder = gig.dbColumns.order || ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      const colWidths = gig.dbColumns.widths || {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
      const hiddenCols = gig.dbColumns.hidden || [];
      if(!gig.customColumns) gig.customColumns = [];
      
      const colDefs = {
        add: {text:'', isButton:true, sortKey:null},
        cover: {text:'Cover', sortKey:'cover'},
        title: {text:'Title', sortKey:'alpha'},
        artist: {text:'Artist', sortKey:'band'},
        len: {text:'Len', sortKey:'length'},
        key: {text:'Key', sortKey:'key'},
        capo: {text:'Capo', sortKey:'capo'},
        bpm: {text:'BPM', sortKey:'bpm'},
        mood: {text:'Moods', sortKey:'mood'},
        lyrics: {text:'Lyrics / Preview', sortKey:null, flex:true},
        audio: {text:'Audio / URL', sortKey:null, flex:true},
        rating: {text:'Rate', sortKey:'rating'},
        actions: {text:'', sortKey:null}
      };
      // Add custom columns to definitions
      gig.customColumns.forEach(cc=>{
        colDefs[cc.key] = {text:cc.name, sortKey:null, isCustom:true};
        if(!colWidths[cc.key]) colWidths[cc.key] = 100;
      });
      
      colOrder.forEach((colKey,colIndex)=>{
        const def = colDefs[colKey];
        if(!def || hiddenCols.includes(colKey)) return;
        const width = colWidths[colKey] || 100;
        
        const hdr = document.createElement('div');
        hdr.dataset.colKey = colKey;
        hdr.style.cssText = `position:relative;flex-shrink:0;text-align:center;cursor:${def.sortKey?'pointer':'default'};user-select:none;${def.flex?`flex:1 1 auto;min-width:${width}px;max-width:${width+100}px`:`width:${width}px`}`;
        
        // Add button special case
        if(colKey==='add'){
          const addBtn=document.createElement('button'); 
          addBtn.textContent='+'; 
          addBtn.type='button'; 
          addBtn.title='Add new song'; 
          addBtn.style.cssText='width:24px;height:24px;border:2px solid #374151;border-radius:4px;background:#fff;color:#374151;font-size:18px;font-weight:bold;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0';
          addBtn.addEventListener('click', addNewSongRow);
          hdr.appendChild(addBtn);
        } else {
          hdr.textContent = def.text;
        }
        
        // Triple-click to restore default width
        let clickCount = 0;
        let clickTimer = null;
        hdr.addEventListener('click', (e)=>{
          if(e.target.style.cursor==='col-resize' || e.target.classList.contains('resizer')) return;
          clickCount++;
          if(clickTimer) clearTimeout(clickTimer);
          if(clickCount === 3){
            // Triple click - restore default width
            const defaultWidths = {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
            if(defaultWidths[colKey]){
              colWidths[colKey] = defaultWidths[colKey];
              saveAll();
              renderDB();
            }
            clickCount = 0;
          } else if(clickCount === 2 && def.sortKey){
            // Double-click to sort
            const sortSel = document.getElementById('dbSort');
            if(sortSel){ sortSel.value = def.sortKey; renderDB(); }
            clickCount = 0;
          } else {
            clickTimer = setTimeout(()=>{ clickCount = 0; }, 500);
          }
        });
        hdr.title = (def.sortKey ? 'Double-click to sort by ' + def.text + ', ' : '') + 'Triple-click to restore default width';
        
        // Column reorder by dragging header (long-hold for touch)
        if(!def.isButton){
          let dragTimer = null;
          let isDraggingCol = false;
          let startY = 0;
          let startX = 0;
          let currentY = 0;
          let hasDraggedUp = false;
          const startColDrag = (clientY, clientX)=>{
            if(dragTimer) return;
            startY = clientY;
            startX = clientX;
            currentY = clientY;
            hasDraggedUp = false;
            dragTimer = setTimeout(()=>{
              isDraggingCol = true;
              hdr.style.opacity = '0.5';
              hdr.style.cursor = 'move';
            }, 400);
          };
          const trackMove = (clientY, clientX)=>{
            if(!isDraggingCol && !dragTimer) return;
            currentY = clientY;
            const deltaY = startY - currentY; // positive = dragging up
            const deltaX = Math.abs(startX - clientX);
            // If dragged up 50px or more, mark for hide
            if(deltaY >= 50 && deltaX < 30){
              hasDraggedUp = true;
              hdr.style.opacity = '0.3';
              hdr.style.transform = 'translateY(-10px)';
            }
          };
          const endColDrag = ()=>{
            if(dragTimer){ clearTimeout(dragTimer); dragTimer=null; }
            hdr.style.transform = '';
            if(isDraggingCol){
              hdr.style.opacity = '';
              hdr.style.cursor = '';
              isDraggingCol = false;
            }
            // Hide column if dragged up 50px
            if(hasDraggedUp){
              if(!gig.dbColumns.hidden) gig.dbColumns.hidden = [];
              if(!gig.dbColumns.hidden.includes(colKey)){
                gig.dbColumns.hidden.push(colKey);
                saveAll();
                renderDB();
              }
            }
            startY = 0;
            startX = 0;
            currentY = 0;
            hasDraggedUp = false;
          };
          
          // Mouse drag tracking
          hdr.addEventListener('mousedown',(e)=>{
            if(e.target.style.cursor==='col-resize') return; // Don't interfere with resize
            startColDrag(e.clientY, e.clientX);
            const onMouseMove = (e2)=>{
              trackMove(e2.clientY, e2.clientX);
            };
            const onMouseUp = ()=>{
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              endColDrag();
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
          
          // Touch drag tracking
          hdr.addEventListener('touchstart',(e)=>{
            const touch = e.touches[0];
            if(touch) startColDrag(touch.clientY, touch.clientX);
            const onTouchMove = (e2)=>{
              const t = e2.touches[0];
              if(t) trackMove(t.clientY, t.clientX);
            };
            const onTouchEnd = ()=>{
              document.removeEventListener('touchmove', onTouchMove);
              document.removeEventListener('touchend', onTouchEnd);
              endColDrag();
            };
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd);
          });
          
          // Drag events for reordering columns
          hdr.setAttribute('draggable', true);
          hdr.addEventListener('dragstart',(e)=>{
            if(!isDraggingCol) return e.preventDefault();
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', colKey);
            hdr.style.opacity = '0.4';
          });
          hdr.addEventListener('dragend',(e)=>{
            hdr.style.opacity = '';
            isDraggingCol = false;
          });
          hdr.addEventListener('dragover',(e)=>{
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          });
          hdr.addEventListener('drop',(e)=>{
            e.preventDefault();
            const draggedKey = e.dataTransfer.getData('text/plain');
            if(!draggedKey || draggedKey===colKey) return;
            const fromIndex = colOrder.indexOf(draggedKey);
            const toIndex = colOrder.indexOf(colKey);
            if(fromIndex===-1 || toIndex===-1) return;
            // Reorder array
            colOrder.splice(fromIndex, 1);
            colOrder.splice(toIndex, 0, draggedKey);
            gig.dbColumns.order = colOrder;
            saveAll();
            renderDB();
          });
        }
        
        // Resizer handle (right edge)
        if(!def.isButton && colKey!=='actions'){
          const resizer = document.createElement('div');
          resizer.style.cssText='position:absolute;right:-6px;top:-8px;bottom:-8px;width:12px;cursor:col-resize;z-index:10;background:rgba(209,213,219,0.5);touch-action:none';resizer.title='Drag to resize';
          resizer.classList.add('resizer');
          
          // Mouse resize
          resizer.addEventListener('mousedown',(e)=>{
            e.stopPropagation();
            const startX = e.clientX;
            const startWidth = width;
            const onMove = (e2)=>{
              const delta = e2.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              saveAll();
              renderDB();
            };
            const onUp = ()=>{
              document.removeEventListener('mousemove', onMove);
              document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          });
          
          // Touch resize
          resizer.addEventListener('touchstart',(e)=>{
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            if(!touch) return;
            const startX = touch.clientX;
            const startWidth = width;
            let isResizing = true;
            const onMove = (e2)=>{
              e2.preventDefault();
              if(!isResizing) return;
              const t = e2.touches[0];
              if(!t) return;
              const delta = t.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              hdr.style.width = newWidth + 'px';
            };
            const onUp = ()=>{
              isResizing = false;
              document.removeEventListener('touchmove', onMove, {passive:false});
              document.removeEventListener('touchend', onUp);
              document.removeEventListener('touchcancel', onUp);
              saveAll();
              renderDB();
            };
            document.addEventListener('touchmove', onMove, {passive:false});
            document.addEventListener('touchend', onUp);
            document.addEventListener('touchcancel', onUp);
          });
          
          hdr.appendChild(resizer);
        }
        
        hdrRow.appendChild(hdr);
      });
      
      // Hidden Columns eye emoji button on header row
      if(hiddenCols.length > 0){
        const eyeHdr = document.createElement('div');
        eyeHdr.style.cssText = 'position:relative;flex-shrink:0;width:40px;text-align:center;cursor:pointer;user-select:none';
        const restoreBtn = document.createElement('button');
        restoreBtn.textContent = 'üëÄ';
        restoreBtn.type = 'button';
        restoreBtn.title = `${hiddenCols.length} hidden column${hiddenCols.length>1?'s':''}`;
        restoreBtn.style.cssText = 'padding:2px 4px;border:none;background:transparent;font-size:20px;cursor:pointer;position:relative';
        const popup = document.createElement('div');
        popup.style.cssText = 'display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:240px;top:100%;right:0;margin-top:2px';
        hiddenCols.forEach(colKey=>{
          const def = colDefs[colKey];
          if(!def) return;
          const rowDiv = document.createElement('div');
          rowDiv.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0';
          const showBtn = document.createElement('button');
          showBtn.textContent = `Show ${def.text || colKey}`;
          showBtn.type = 'button';
          showBtn.style.cssText = 'flex:1;padding:4px 8px;border:1px solid #d1d5db;border-radius:3px;background:#f9fafb;cursor:pointer;text-align:left;font-size:12px';
          showBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            const idx = hiddenCols.indexOf(colKey);
            if(idx > -1){
              hiddenCols.splice(idx, 1);
              gig.dbColumns.hidden = hiddenCols;
              saveAll();
              renderDB();
            }
          });
          // Only show delete checkbox for custom columns
          const isCustom = def.isCustom || (gig.customColumns && gig.customColumns.find(c => c.key === colKey));
          if(isCustom){
            const delChk = document.createElement('input');
            delChk.type = 'checkbox';
            delChk.title = 'Delete column permanently';
            delChk.style.cssText = 'width:16px;height:16px;cursor:pointer';
            const delLbl = document.createElement('label');
            delLbl.textContent = 'üóëÔ∏è';
            delLbl.title = 'Delete permanently';
            delLbl.style.cssText = 'cursor:pointer;font-size:14px';
            delChk.addEventListener('change', ()=>{
              if(delChk.checked && confirm(`Permanently delete custom column "${def.text || colKey}"? This will remove all data in this column from all songs.`)){
                // Remove from hidden columns
                const hiddenIdx = hiddenCols.indexOf(colKey);
                if(hiddenIdx > -1){
                  hiddenCols.splice(hiddenIdx, 1);
                  gig.dbColumns.hidden = hiddenCols;
                }
                // Remove from column order
                const orderIdx = gig.dbColumns.order.indexOf(colKey);
                if(orderIdx > -1){
                  gig.dbColumns.order.splice(orderIdx, 1);
                }
                // Remove from custom columns
                if(gig.customColumns){
                  const customIdx = gig.customColumns.findIndex(c => c.key === colKey);
                  if(customIdx > -1){
                    gig.customColumns.splice(customIdx, 1);
                  }
                }
                // Remove column width
                if(gig.dbColumns.widths && gig.dbColumns.widths[colKey]){
                  delete gig.dbColumns.widths[colKey];
                }
                // Remove data from all songs
                db.forEach(song => {
                  if(song.customFields && song.customFields[colKey]){
                    delete song.customFields[colKey];
                  }
                });
                saveAll();
                renderDB();
              } else {
                delChk.checked = false;
              }
            });
            rowDiv.append(showBtn, delChk, delLbl);
          } else {
            rowDiv.appendChild(showBtn);
          }
          popup.appendChild(rowDiv);
        });
        restoreBtn.addEventListener('mouseenter', ()=>{ popup.style.display = 'block'; });
        restoreBtn.addEventListener('mouseleave', ()=>{ popup.style.display = 'none'; });
        restoreBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); popup.style.display = popup.style.display==='block'?'none':'block'; });
        popup.addEventListener('click', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchstart', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchend', (e)=>{ e.stopPropagation(); });
        restoreBtn.appendChild(popup);
        eyeHdr.appendChild(restoreBtn);
        hdrRow.appendChild(eyeHdr);
      }
      
      list.appendChild(hdrRow);
      // Filters / sort
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const sortVal=(sSel&&sSel.value)||'alpha';
      const searchTerm=(searchInput&&searchInput.value)||'';
      const filterCovers=document.getElementById('filterCovers')?.checked;
      const filterOriginals=document.getElementById('filterOriginals')?.checked;
      const filterHasLyrics=document.getElementById('filterHasLyrics')?.checked;
      const filterKaraoke=document.getElementById('filterKaraoke')?.checked;
      const filterHasAudio=document.getElementById('filterHasAudio')?.checked;
      const filterHasURL=document.getElementById('filterHasURL')?.checked;
      const filterInSet=document.getElementById('filterInSet')?.checked;
      const filterUpbeat=document.getElementById('filterUpbeat')?.checked;
      const filterHappy=document.getElementById('filterHappy')?.checked;
      const filterEnergetic=document.getElementById('filterEnergetic')?.checked;
      const filterMellow=document.getElementById('filterMellow')?.checked;
      const filterSad=document.getElementById('filterSad')?.checked;
      const used=(arr)=>arr.filter(Boolean);
      const hasMood=(song, key)=>{
        if(DEFAULT_MOODS.includes(key)){
          return (key==='upbeat'&&song.isUpbeat) || (key==='happy'&&song.isHappy) || (key==='energetic'&&song.isEnergetic) || (key==='mellow'&&song.isMellow) || (key==='sad'&&song.isSad);
        }
        const cm = song.customMoods||[]; return cm.includes(key);
      };
      const songMood=(song)=>{
        if(song.isUpbeat) return 'upbeat'; if(song.isHappy) return 'happy'; if(song.isEnergetic) return 'energetic'; if(song.isMellow) return 'mellow'; if(song.isSad) return 'sad';
        const cm=(song.customMoods||[])[0]; return cm||'none';
      };
      const rankMap={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:99};
      getAllMoods().forEach((m,i)=>{ if(!(m in rankMap)) rankMap[m]=50+i; });
      let rows=db.slice();
      if(filterCovers) rows = rows.filter(s=> s.isCover);
      if(filterOriginals) rows = rows.filter(s=> !s.isCover);
      if(filterHasLyrics) rows = rows.filter(s=> (s.lyrics||'').trim().length>0);
      if(filterKaraoke) rows = rows.filter(s=> (s.lyrics||'').toLowerCase().includes('karaoke'));
      if(filterHasAudio) rows = rows.filter(s=> (s.audioFileName||'').length>0 || (armedAudio[s.id]));
      if(filterHasURL) rows = rows.filter(s=> (s.audioUrl||'').trim().length>0);
      if(filterInSet) rows = rows.filter(s=> setlist.some(x=>x.id===s.id));
      if(filterUpbeat) rows = rows.filter(s=> s.isUpbeat);
      if(filterHappy) rows = rows.filter(s=> s.isHappy);
      if(filterEnergetic) rows = rows.filter(s=> s.isEnergetic);
      if(filterMellow) rows = rows.filter(s=> s.isMellow);
      if(filterSad) rows = rows.filter(s=> s.isSad);
      if(searchTerm){
        try{
          const regex = new RegExp(searchTerm, 'i');
          rows = rows.filter(s=> regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||''));
        }catch(e){ rows = rows.filter(s=> (s.title||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.artist||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.composer||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.lyrics||'').toLowerCase().includes(searchTerm.toLowerCase())); }
      }
      const byAdded=(a,b)=> a.id - b.id;
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (rankMap[songMood(a)] - rankMap[songMood(b)]) || a.title.localeCompare(b.title);
      const byRating=(a,b)=> (b.audienceRating||0) - (a.audienceRating||0) || a.title.localeCompare(b.title);
      const byMostUsed=(a,b)=> (b.usageCount||0) - (a.usageCount||0) || a.title.localeCompare(b.title);
      const byLeastUsed=(a,b)=> (a.usageCount||0) - (b.usageCount||0) || a.title.localeCompare(b.title);
      const sorter = sortVal==='added'? byAdded : sortVal==='band'? byBand : sortVal==='mood'? byMood : sortVal==='rating'? byRating : sortVal==='mostUsed'? byMostUsed : sortVal==='leastUsed'? byLeastUsed : byAlpha;
      rows.sort(sorter);
      rows.forEach(s=>{
        const row=document.createElement('div'); row.className='db-row'; row.style.display='flex'; row.style.gap='4px'; row.style.alignItems='center'; row.style.padding='4px'; row.style.border='1px solid #e5e7eb'; row.style.borderRadius='4px'; row.style.margin='4px 0';
        
        // Cover checkbox
        const coverChk=document.createElement('input'); coverChk.type='checkbox'; coverChk.checked=!!s.isCover; coverChk.title='Cover song'; coverChk.style.cssText='width:18px;height:18px;margin:0;cursor:pointer';
        coverChk.addEventListener('change',()=>{ 
          s.isCover=!!coverChk.checked; 
          if(!s.isCover){ s.artist='Original'; artist.value=''; artist.disabled=true; artist.style.opacity='0.5'; } 
          else { artist.disabled=false; artist.style.opacity='1'; } 
          saveAll(); renderSongPool(); 
        });
        
        // Title (reduced width)
        const title=document.createElement('input'); title.value=s.title||''; title.placeholder='Title'; title.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px';
        title.addEventListener('change',()=>{ s.title=title.value.trim()||s.title; saveAll(); buildSheet('sheetInline'); renderSongPool(); });
        
        // Artist (reduced width)
        const artist=document.createElement('input'); artist.placeholder='Artist'; artist.value=(s.isCover? (s.artist||'') : ''); artist.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px;opacity:'+(s.isCover?'1':'0.5'); artist.disabled=!s.isCover;
        artist.addEventListener('change',()=>{ s.artist = coverChk.checked ? (artist.value.trim()||s.artist||'') : 'Original'; saveAll(); });
        
        // Length (5 chars width)
        const len=document.createElement('input'); len.type='number'; len.step='0.5'; len.min='0.5'; len.value=String(s.length||3.5); len.title='Length (min)'; len.style.cssText='width:58px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center;color:#0f172a';
        len.addEventListener('change',()=>{ const v=parseFloat(len.value); if(v>0) s.length=v; saveAll(); buildSheet('sheetInline'); });
        
        // Key (3 chars width)
        const key=document.createElement('input'); key.placeholder='Key'; key.value=s.key||''; key.style.cssText='width:35px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        key.addEventListener('change',()=>{ s.key=key.value.trim(); saveAll(); buildSheet('sheetInline'); });
        
        // Capo (2 chars width)
        const capo=document.createElement('input'); capo.type='number'; capo.min='0'; capo.max='24'; capo.value=String(Number.isInteger(s.capo)? s.capo : 0); capo.title='Capo'; capo.style.cssText='width:30px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        capo.addEventListener('change',()=>{ let v=parseInt(capo.value,10); if(!Number.isInteger(v) || v<0) v=0; if(v>24) v=24; s.capo=v; capo.value=String(v); saveAll(); buildSheet('sheetInline'); });
        
        // BPM
        const bpm=document.createElement('input'); bpm.type='number'; bpm.min='30'; bpm.max='300'; bpm.value=String(Number.isInteger(s.bpm) && s.bpm>0 ? s.bpm : ''); bpm.placeholder='BPM'; bpm.title='Beats per minute'; bpm.style.cssText='width:40px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        bpm.addEventListener('change',()=>{ let v=parseInt(bpm.value,10); if(!Number.isInteger(v) || v<30) v=0; if(v>300) v=300; s.bpm=v||0; bpm.value=v>0?String(v):''; saveAll(); buildSheet('sheetInline'); });
        
        // Custom columns rendering
        const customColInputs = {};
        gig.customColumns.forEach(cc=>{
          const custInput = document.createElement('input');
          custInput.placeholder = cc.name;
          if(!s.customFields) s.customFields = {};
          custInput.value = s.customFields[cc.key] || '';
          custInput.style.cssText = `width:${colWidths[cc.key]||100}px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px`;
          custInput.addEventListener('change', ()=>{
            if(!s.customFields) s.customFields = {};
            s.customFields[cc.key] = custInput.value.trim();
            saveAll();
            buildSheet('sheetInline');
          });
          customColInputs[cc.key] = custInput;
        });
        
        // Mood submenu (hoverable)
        const moodEmojis = {upbeat:'‚ö°',happy:'üòä',energetic:'üî•',mellow:'üòå',sad:'üò¢'};
        let topMood = '';
        if(s.isUpbeat) topMood = '‚ö°';
        else if(s.isHappy) topMood = 'üòä';
        else if(s.isEnergetic) topMood = 'üî•';
        else if(s.isMellow) topMood = 'üòå';
        else if(s.isSad) topMood = 'üò¢';
        else if(s.customMoods && s.customMoods.length>0) topMood = 'üéµ';
        const moodBtn=document.createElement('button'); moodBtn.textContent=topMood||'‚ô´'; moodBtn.type='button'; moodBtn.title='Moods'; moodBtn.style.cssText='padding:2px 6px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;position:relative;font-size:14px;width:28px;height:24px';
        const moodMenu=document.createElement('div'); moodMenu.style.cssText='display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:140px;top:100%;left:0;margin-top:2px;text-align:left';
        const moodChecks=['upbeat','happy','energetic','mellow','sad'].map(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=s['is'+m.charAt(0).toUpperCase()+m.slice(1)]; chk.addEventListener('change',()=>{ s['is'+m.charAt(0).toUpperCase()+m.slice(1)]=chk.checked; saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); return lbl; });
        moodChecks.forEach(c=>moodMenu.appendChild(c));
        // Add custom moods
        (gig.customMoods||[]).forEach(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=(s.customMoods||[]).includes(m); chk.addEventListener('change',()=>{ if(!s.customMoods) s.customMoods=[]; const idx=s.customMoods.indexOf(m); if(chk.checked && idx===-1){ s.customMoods.push(m); } else if(!chk.checked && idx>-1){ s.customMoods.splice(idx,1); } saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); moodMenu.appendChild(lbl); });
        // Add "+ Add Mood" button at bottom of mood menu
        const addMoodDiv=document.createElement('div'); addMoodDiv.style.cssText='margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb';
        const addMoodBtn=document.createElement('button'); addMoodBtn.type='button'; addMoodBtn.textContent='+ Add Mood'; addMoodBtn.style.cssText='width:100%;padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;background:#f9fafb;cursor:pointer;font-size:12px;font-weight:500;color:#0f172a';
        addMoodBtn.addEventListener('click',(e)=>{
          e.stopPropagation();
          const name = prompt('New mood name (max 16 chars).'); 
          if(name==null) return; 
          const n=name.trim(); 
          if(!n){ return; }
          const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
          const DEFAULT_MOODS=['upbeat','happy','energetic','mellow','sad'];
          const all=[...DEFAULT_MOODS,...(gig.customMoods||[])];
          if(all.length>=12){ alert('Max 12 moods reached.'); return; }
          if(all.includes(key)){ alert('Mood already exists.'); return; }
          gig.customMoods = gig.customMoods || []; 
          gig.customMoods.push(key);
          saveAll();
          // Re-render database to show new mood in all menus
          renderDB(); 
          renderSongPool();
          // Add custom mood filter checkbox
          const filterContainer=document.getElementById('customMoodFilters');
          if(filterContainer){
            const lbl=document.createElement('label');
            lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
            const chk=document.createElement('input');
            chk.type='checkbox';
            chk.id='filter-'+key;
            chk.addEventListener('change', renderDB);
            lbl.appendChild(chk);
            const moodLabel=(k)=>{const caps=k.split('-').map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(' '); return caps;};
            lbl.appendChild(document.createTextNode(moodLabel(key)));
            filterContainer.appendChild(lbl);
          }
        });
        addMoodDiv.appendChild(addMoodBtn);
        moodMenu.appendChild(addMoodDiv);
        moodBtn.appendChild(moodMenu);
        moodBtn.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodBtn.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        moodMenu.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodMenu.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        // Lyrics / chords quick edit (collapsed textarea)
        const lyricsWrap=document.createElement('div'); lyricsWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const lyrBtn=document.createElement('button'); lyrBtn.textContent='Lyrics'; lyrBtn.className='btn'; lyrBtn.type='button'; lyrBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0;background:#3b82f6;color:#f9fafb;border-color:#2563eb'; lyrBtn.title='Edit lyrics / chords for this song';
        const lyricsPreview=document.createElement('div'); lyricsPreview.style.cssText='font-size:10px;color:#64748b;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1 1 auto';
        const firstLine=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=firstLine? (firstLine.length>25? firstLine.substring(0,25)+'...' : firstLine) : '';
        lyricsWrap.append(lyrBtn,lyricsPreview);
        const lyrBox=document.createElement('textarea'); lyrBox.rows=3; lyrBox.style.width='100%'; lyrBox.style.marginTop='4px'; lyrBox.style.display='none'; lyrBox.placeholder='Lyrics / chords'; lyrBox.value=s.lyrics||'';
        lyrBtn.addEventListener('click',()=>{
          const showing = lyrBox.style.display!=='none';
          // If cover song with no lyrics, search for them
          if(!showing && s.isCover && (!s.lyrics || s.lyrics.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' ' + (s.artist||'') + ' lyrics chords');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          lyrBox.style.display = showing ? 'none' : 'block';
        });
        lyrBox.addEventListener('change',()=>{ s.lyrics=lyrBox.value; const fl=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=fl? (fl.length>25? fl.substring(0,25)+'...' : fl) : ''; saveAll(); });
        // Audio attach / link with inline URL preview/edit
        const audioWrap=document.createElement('div'); audioWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const audioBtn=document.createElement('button'); audioBtn.textContent='Audio'; audioBtn.className='btn'; audioBtn.type='button'; audioBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0;background:#3b82f6;color:#f9fafb;border-color:#2563eb'; audioBtn.title='Attach MP3/WAV or link a URL (YouTube, Spotify, etc.)';
        const audioInline=document.createElement('input'); audioInline.type='url'; audioInline.placeholder='URL or file path...'; audioInline.value=s.audioUrl||s.audioFileName||''; audioInline.style.cssText='flex:1 1 auto;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:10px';
        audioInline.addEventListener('change',()=>{ s.audioUrl=audioInline.value.trim(); saveAll(); });
        audioWrap.append(audioBtn,audioInline);
        const audioBox=document.createElement('div'); audioBox.style.display='none'; audioBox.style.width='100%'; audioBox.style.marginTop='4px'; audioBox.style.padding='8px'; audioBox.style.border='1px solid #e5e7eb'; audioBox.style.borderRadius='6px';
        const audioUrlIn=document.createElement('input'); audioUrlIn.type='url'; audioUrlIn.placeholder='https:// link to audio, YouTube, or Spotify'; audioUrlIn.style.width='60%'; audioUrlIn.value = s.audioUrl||'';
        const saveUrlBtn=document.createElement('button'); saveUrlBtn.className='btn'; saveUrlBtn.textContent='Save URL'; saveUrlBtn.type='button'; saveUrlBtn.style.marginLeft='8px';
        const fileIn=document.createElement('input'); fileIn.type='file'; fileIn.accept='audio/*'; fileIn.style.marginLeft='12px'; fileIn.title='Choose local audio file (session only)';
        const fileRefIn=document.createElement('input'); fileRefIn.type='text'; fileRefIn.placeholder='Preferred filename for Arm All (e.g., 01 - Imagine.mp3)'; fileRefIn.style.marginLeft='12px'; fileRefIn.style.flex='1 1 220px'; fileRefIn.value = s.audioFileName||'';
        const saveRefBtn=document.createElement('button'); saveRefBtn.className='btn'; saveRefBtn.textContent='Save File Ref'; saveRefBtn.type='button';
        const infoSpan=document.createElement('span'); infoSpan.style.marginLeft='8px'; infoSpan.style.fontSize='12px'; infoSpan.style.color='#64748b';
        const clearBtn=document.createElement('button'); clearBtn.className='btn danger'; clearBtn.textContent='Remove Audio'; clearBtn.type='button'; clearBtn.style.marginLeft='auto';
        const rowCtl=document.createElement('div'); rowCtl.style.display='flex'; rowCtl.style.alignItems='center'; rowCtl.style.gap='8px';
        rowCtl.append(audioUrlIn, saveUrlBtn, fileIn, fileRefIn, saveRefBtn, clearBtn, infoSpan);
        audioBox.append(rowCtl);
        audioBtn.addEventListener('click',()=>{ 
          const showing = audioBox.style.display!=='none';
          if(!showing && s.isCover && (!s.audioUrl || s.audioUrl.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' by ' + (s.artist||'') + ' Karaoke Backing Track');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          audioBox.style.display = showing ? 'none' : 'block'; 
        });
        function updateAudioInfo(){
          const armed = (s.id!=null && armedAudio[s.id]);
          if(armed){ infoSpan.textContent = 'Armed file (session)'; return; }
          const linked = (s.audioUrl && s.audioUrl.trim());
          infoSpan.textContent = linked ? ('Linked: '+(s.audioUrl||'')) : '(no audio)';
        }
        updateAudioInfo();
        saveUrlBtn.addEventListener('click',()=>{ const v=(audioUrlIn.value||'').trim(); s.audioUrl = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved audio URL.' : 'Audio URL cleared.'); });
        saveRefBtn.addEventListener('click',()=>{ const v=(fileRefIn.value||'').trim(); s.audioFileName = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved file reference.' : 'File reference cleared.'); });
        clearBtn.addEventListener('click',()=>{ s.audioUrl=''; if(s.id!=null && armedAudio[s.id]){ try{ URL.revokeObjectURL(armedAudio[s.id]); }catch(_){} delete armedAudio[s.id]; } updateAudioInfo(); saveAll(); });
        fileIn.addEventListener('change',()=>{
          const f=fileIn.files && fileIn.files[0]; if(!f || s.id==null) return;
          try{ if(armedAudio[s.id]){ URL.revokeObjectURL(armedAudio[s.id]); } }catch(_){ }
          const objUrl = URL.createObjectURL(f);
          armedAudio[s.id] = objUrl;
          s.audioName = f.name||'audio'; s.audioFileName = f.name||s.audioFileName||'';
          // do not embed or persist the file; session only
          updateAudioInfo();
          alert('Audio armed for this session: '+(s.title||'song'));
        });
        
        // Audience rating (0-3: thumbs down, sideways, up, double up) - click to cycle, default 2
        if(s.audienceRating===undefined || s.audienceRating===null) s.audienceRating=2;
        const rating = s.audienceRating;
        const ratingIcons = ['üëé','üëà','üëç','üëç‚Ääüëç'];
        const ratingBtn=document.createElement('button'); ratingBtn.type='button'; ratingBtn.textContent=ratingIcons[rating]; ratingBtn.style.cssText='padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;font-size:14px;min-width:32px;height:24px'; ratingBtn.title='Rating: '+rating+' (click to cycle)';
        ratingBtn.addEventListener('click',()=>{ s.audienceRating=((s.audienceRating||0)+1)%4; saveAll(); renderDB(); });
        
        const toSetBtn=document.createElement('button'); toSetBtn.className='btn'; toSetBtn.textContent='To Set'; toSetBtn.style.cssText='margin-left:auto;padding:2px 8px;font-size:11px;border-radius:3px;min-width:56px;background:#065f46;border-color:#064e3b;color:#f9fafb'; toSetBtn.title='Add this song to the end of the current setlist';
        toSetBtn.addEventListener('click',()=>{ 
          if(setlist.some(x=>x.type==='song' && x.id===s.id)){ 
            alert('Song already in setlist.'); 
            return; 
          } 
          setlist.push({...s,type:'song',notes:''}); 
          currentDateDirty = true;
          saveAll(); 
          buildSheet('sheetInline'); 
          attachPreviewInteractions();
          renderSongPool(); 
          alert('Added "'+s.title+'" to setlist.'); 
        });
        const del=document.createElement('button'); del.className='btn danger'; del.textContent='Del'; del.style.cssText='padding:2px 8px;font-size:11px;border-radius:3px;min-width:50px;background:#dc2626;border-color:#b91c1c;color:#f9fafb'; del.addEventListener('click',()=>{ const i=db.findIndex(x=>x.id===s.id); if(i>-1){ db.splice(i,1); renderDB(); renderSongPool(); saveAll(); } });
        
        // Append in column order, applying widths
        const cellMap = {
          add: (() => {
            const addPlaceholder = document.createElement('div');
            addPlaceholder.style.cssText='width:24px;height:24px;flex-shrink:0';
            return addPlaceholder;
          })(),
          cover: coverChk,
          title: title,
          artist: artist,
          len: len,
          key: key,
          capo: capo,
          bpm: bpm,
          mood: moodBtn,
          lyrics: lyricsWrap,
          audio: audioWrap,
          rating: ratingBtn,
          actions: (() => {
            const actionsWrap = document.createElement('div');
            actionsWrap.style.cssText='display:flex;gap:4px;margin-left:auto;width:'+colWidths.actions+'px';
            actionsWrap.append(toSetBtn,del);
            return actionsWrap;
          })()
        };
        // Add custom column cells to cellMap
        gig.customColumns.forEach(cc=>{
          cellMap[cc.key] = customColInputs[cc.key];
        });
        
        colOrder.forEach(colKey=>{
          if(hiddenCols.includes(colKey)) return; // Skip hidden columns
          const cell = cellMap[colKey];
          if(!cell) return;
          const width = colWidths[colKey];
          // Apply width to cell if fixed-width column
          if(colKey!=='lyrics' && colKey!=='audio' && colKey!=='actions'){
            cell.style.width = width+'px';
            cell.style.flexShrink = '0';
          } else if(colKey==='lyrics' || colKey==='audio'){
            cell.style.flex = `1 1 auto`;
            cell.style.minWidth = width+'px';
            cell.style.maxWidth = (width+100)+'px';
          }
          row.appendChild(cell);
        });
        
        list.appendChild(row);
        list.appendChild(lyrBox);
        list.appendChild(audioBox);
      });
      try{ renderSongPool(); }catch(_){ }
    }

    // Generate fresh set each click (ignores current setlist)
    $('#genBtn').addEventListener('click', ()=>{
      if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; }
      const setLen = parseFloat($('#gLen').value || '60') || 60;
      const coverRatio=parseInt($('#gCover').value)||0;
      const breaks=parseInt($('#gBreaks').value)||0; // retained in gig but not auto-inserted
      const breakLen=parseFloat($('#gBreakLen').value)||15;
      const encore=$('#gEncore').checked;
      const mood=$('#gMood').value;

      // Update gig settings (band/venue/address/notes now edited directly on sheet header)
      gig.breaks = breaks;
      gig.breakLen = breakLen;
      gig.encore = encore;
      if(!db.length){ alert('Add some songs first.'); return; }

      // Filter pool by mood
      let pool=[...db];
      if(mood!=='mixed'){
        const keyMap={upbeat:'isUpbeat',happy:'isHappy',mellow:'isMellow',energetic:'isEnergetic',sad:'isSad'};
        pool=pool.filter(s=>s[keyMap[mood]]);
        if(!pool.length){ alert('No songs match this mood.'); return; }
      }

      const totalBreakTime = (breaks>0 ? (breaks * breakLen) : 0);
      const musicTime = Math.max(0, setLen - totalBreakTime);
      if(musicTime<=0){ alert('Set length must exceed total break time.'); return; }
      const covers=pool.filter(s=>s.isCover);
      const originals=pool.filter(s=>!s.isCover);
      let plan=[]; let total=0; const targetCover=(musicTime*coverRatio)/100;
      let coverSum=0, origSum=0;
      for(const s of shuffle(covers)){
        if(coverSum + s.length <= targetCover && total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); coverSum+=s.length; total+=s.length; }
      }
      for(const s of shuffle(originals)){
        if(total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); origSum+=s.length; total+=s.length; }
      }
      plan=shuffle(plan);
      // Apply optional grouping rules
      const keepCovers = (document.getElementById('gKeepCovers') && document.getElementById('gKeepCovers').checked) || false;
      const keepKeys   = (document.getElementById('gKeepKeys') && document.getElementById('gKeepKeys').checked) || false;
      const keepMoods  = (document.getElementById('gKeepMoods') && document.getElementById('gKeepMoods').checked) || false;
      if(keepCovers || keepKeys || keepMoods){
        const songMoodOf=(s)=>{ if(s.isUpbeat) return 'upbeat'; if(s.isHappy) return 'happy'; if(s.isEnergetic) return 'energetic'; if(s.isMellow) return 'mellow'; if(s.isSad) return 'sad'; const cm=(s.customMoods||[])[0]; return cm||'none'; };
        const applyGrouping=(arr)=>{
          const songs=arr.filter(x=>x.type==='song');
          const others=arr.filter(x=>x.type!=='song');
          if(songs.length){
            songs.sort((a,b)=>{
              if(keepCovers){ const ca=(a.isCover?1:0), cb=(b.isCover?1:0); if(ca!==cb) return ca-cb; }
              if(keepKeys){ const ka=(a.key||''), kb=(b.key||''); if(ka!==kb) return ka.localeCompare(kb); }
              if(keepMoods){ const ma=songMoodOf(a), mb=songMoodOf(b); if(ma!==mb) return ma.localeCompare(mb); }
              return 0;
            });
          }
          // Rebuild segment by replacing song slots with sorted songs in order, preserving non-song positions
          let si=0; return arr.map(x=> x.type==='song' ? songs[si++] : x);
        };
        const encIdx=plan.findIndex(x=>x.type==='encore');
        if(encIdx>-1){
          const before=applyGrouping(plan.slice(0,encIdx));
          const after=applyGrouping(plan.slice(encIdx+1));
          const hdr=plan[encIdx];
          plan=[...before, hdr, ...after];
        }else{
          plan=applyGrouping(plan);
        }
      }
      if(encore){
        // Insert Encore break before last 3 songs
        const songIndices = [];
        plan.forEach((item, idx) => {
          if(item.type === 'song') songIndices.push(idx);
        });
        
        if(songIndices.length >= 3){
          // Get position of 3rd-to-last song
          const encorePosition = songIndices[songIndices.length - 3];
          plan.splice(encorePosition, 0, {type:'encore', title:'Encore'});
        }
      }
      // Trim overflow if any
      while(total>musicTime){ const last=plan.map((x,i)=>({x,i})).filter(y=>y.x.type==='song').map(y=>y.i).pop(); if(last==null) break; total-=plan[last].length; plan.splice(last,1); }

      // Automatic break insertion based on requested count (by cumulative music time)
      (function autoBreaks(){
        if(!breaks || breakLen<=0) return;
        const encoreIdx=plan.findIndex(x=>x.type==='encore');
        const songIndices=[]; let cum=0; const songLengths=[];
        plan.forEach((p,i)=>{ if(p.type==='song' && (encoreIdx===-1 || i<encoreIdx)){ cum += (p.length||0); songIndices.push(i); songLengths.push(cum); } });
        const totalSongLen=songLengths[songLengths.length-1]||0;
        if(totalSongLen < breakLen*0.75) return; // too short to bother
        let fracs=[];
        if(breaks===1) fracs=[0.5];
        else if(breaks===2) fracs=[0.5, 2/3];
        else if(breaks>=3) fracs=[0.25,0.5,0.75];
        const targets=fracs.map(f=> totalSongLen*f);
        const inserted=new Set();
        for(let tIdx=0; tIdx<targets.length; tIdx++){
          const tgt=targets[tIdx]; if(tgt<=0) continue;
          // Find first song index with cumulative >= target
          let songPos=-1;
          for(let j=0;j<songLengths.length;j++){ if(songLengths[j] >= tgt){ songPos=songIndices[j]; break; } }
          if(songPos===-1) continue;
          // Avoid duplicate insertion near previous breaks
          if(inserted.has(songPos)) continue;
          // Do not insert at very beginning
          if(songPos<=0) continue;
          // If previous element already a break, skip
          if(plan[songPos-1] && plan[songPos-1].type==='break') continue;
          plan.splice(songPos,0,{type:'break',title:'Break',length:breakLen});
          inserted.add(songPos);
          // Shift later songPositions automatically due to splice; recalc cumulative references minimal by adding length to later songLengths
          for(let k=0;k<songLengths.length;k++){ if(songIndices[k] >= songPos){ songIndices[k] += 1; } }
        }
      })();

      setlist=plan;
      
      // Update current tour date if in edit mode
      if(selectedTourDateId && window.setlistEditMode === 'edit'){
        const td = tourDates.find(t => t.id === selectedTourDateId);
        if(td){
          td.setlist = JSON.parse(JSON.stringify(setlist));
          td.setlistType = 'custom';
        }
      }
      
      const actualMusic = setlist.filter(x=>x.type==='song').reduce((a,b)=>a+(b.length||0),0);
      const breakCount=setlist.filter(x=>x.type==='break').length;
      $('#genStats').textContent=`Songs: ${setlist.filter(x=>x.type==='song').length} ‚Ä¢ Music: ${actualMusic.toFixed(1)}m (‚â§ target ${musicTime.toFixed(1)}m) ‚Ä¢ Covers ${coverSum.toFixed(1)}m / Originals ${origSum.toFixed(1)}m${breakCount? ' ‚Ä¢ Breaks '+breakCount+' √ó '+breakLen+'m':''}${encore? ' ‚Ä¢ Encore':''}`;
      rebuildPreview(); renderSongPool();
    });

    // renderSet removed - element #setList does not exist, using inline preview only
    

    // Preview (guarded if button exists)
    (function(){ const pb=document.getElementById('previewBtn'); if(pb){ pb.addEventListener('click', ()=>{ 
      // Build inline first to ensure layout is calculated, then copy to print modal
      buildSheet('sheetInline');
      buildSheet('sheet'); 
      document.getElementById('modal').classList.add('open'); 
    }); } })();
  $('#closeModal').addEventListener('click', ()=> $('#modal').classList.remove('open'));
    $('#paperSel').addEventListener('change', ()=>{
      const sheet=$('#sheet');
      if($('#paperSel').value==='a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
    });
  // Setlist modal print opens print chooser for consistency
  document.getElementById('printSheet').addEventListener('click',()=> openPrintChooser('set'));

    // Live Mode rendering
    let _pendingArmSongId=null;
    function renderLive(){
      const listEl=document.getElementById('liveList'); if(!listEl) return;
      const titleEl=document.getElementById('liveLyricsTitle');
      const bodyEl=document.getElementById('liveLyricsBody');
      const themeBtn=document.getElementById('liveThemeToggle');
      const songArmInput=document.getElementById('armSongFile');
      // Wire per-song arm input once
      if(songArmInput && !songArmInput._wired){
        songArmInput.addEventListener('change',()=>{
          if(!_pendingArmSongId) return;
          const file = songArmInput.files && songArmInput.files[0];
            if(!file){ _pendingArmSongId=null; songArmInput.value=''; return; }
            const song=findSongById(_pendingArmSongId);
            if(song){
              try{ if(armedAudio[song.id]) URL.revokeObjectURL(armedAudio[song.id]); }catch(_){ }
              armedAudio[song.id]=URL.createObjectURL(file);
              song.audioFileName=file.name;
              saveAll();
              try{ renderLive(); }catch(_){ }
            }
            _pendingArmSongId=null; songArmInput.value='';
        });
        songArmInput._wired=true;
      }
      if(themeBtn){
        const dark=!!gig.liveDark;
        document.body.classList.toggle('live-dark', dark);
        themeBtn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
        themeBtn.style.background = dark ? '#fef3c7' : '#0f172a';
        themeBtn.style.color = dark ? '#92400e' : '#fbbf24';
      }
      listEl.innerHTML='';
      if(!setlist.length){ listEl.textContent='No setlist yet.'; if(titleEl) titleEl.textContent=''; if(bodyEl) bodyEl.textContent=''; return; }
      let songNum=0;
      let liveHoldTimer=null;
      let liveDragIndex=null;
      setlist.forEach((it,i)=>{
        const row=document.createElement('div');
        row.className='live-row';
        row.dataset.index=i;
        row.dataset.type=it.type;
        row.style.padding='10px 8px';
        row.style.borderBottom='1px solid #e5e7eb';
        row.style.display='flex';
        row.style.alignItems='center';
        row.style.gap='8px';
        row.style.cursor='pointer';
        row.style.transition='background 0.2s, transform 0.2s';
        
        // Handle breaks and encores as buttons
        if(it.type==='break'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚è∏'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=it.title||'Break'; ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#374151';
          const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280'; meta.textContent=it.length+'m';
          main.append(ttl,meta);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        if(it.type==='encore'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚≠ê'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=(it.title||'ENCORE').toUpperCase(); ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#1f2937';
          main.append(ttl);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        
        // Song rows
        const numSpan=document.createElement('span'); numSpan.textContent=String(++songNum)+'.'; numSpan.style.minWidth='24px';
        const main=document.createElement('div'); main.style.flex='1 1 auto';
        const ttl=document.createElement('div'); ttl.textContent=it.title||''; ttl.style.fontWeight='600'; ttl.style.fontSize='16px';
        const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280';
        const keyBits=[]; if(it.artist) keyBits.push(it.artist); if(it.key) keyBits.push(it.key); if(Number.isInteger(it.capo) && it.capo>0) keyBits.push('Capo '+it.capo); if(Number.isInteger(it.bpm) && it.bpm>0) keyBits.push(it.bpm+' BPM');
        meta.textContent=keyBits.join(' ‚Ä¢ ');
        // audio badge + per-song arm (show Arm button for any URL or file reference)
        try{
          const baseSong = findSongById(it.id) || findSongByTitle(it.title);
          const hasFileRef = baseSong && ((baseSong.audioFileName||'').trim());
          const hasUrl = baseSong && ((baseSong.audioUrl||'').trim());
          const isArmed = baseSong && armedAudio[baseSong.id];
          if(baseSong && (isArmed || hasUrl || hasFileRef)){
            const badge=document.createElement('span'); badge.textContent='üîä'; badge.title=isArmed? 'Audio armed' : (hasUrl? 'Audio URL linked' : 'Audio file referenced'); badge.style.marginLeft='6px'; ttl.appendChild(badge);
          }
          // Show Arm button: if URL exists, just arm it; if file ref exists, prompt for file
          if(baseSong && (hasFileRef || hasUrl) && !isArmed){
            const armBtn=document.createElement('button'); armBtn.type='button'; armBtn.textContent='Arm'; 
            if(hasUrl && !hasFileRef){
              // URL only - just arm it without file prompt
              armBtn.title='Arm this URL for playback';
              armBtn.addEventListener('click',e=>{ 
                e.stopPropagation(); 
                if(baseSong.id!=null){
                  try{ if(armedAudio[baseSong.id]) URL.revokeObjectURL(armedAudio[baseSong.id]); }catch(_){ }
                  armedAudio[baseSong.id]=baseSong.audioUrl;
                  armBtn.textContent='Armed';
                  armBtn.disabled=true;
                  armBtn.style.opacity='0.5';
                  saveAll();
                  renderLive();
                }
              });
            } else {
              // Has file reference - prompt for file selection
              armBtn.title='Select local audio file for this song';
              armBtn.addEventListener('click',e=>{ e.stopPropagation(); _pendingArmSongId=baseSong.id; songArmInput.click(); });
            }
            armBtn.style.fontSize='11px'; armBtn.style.padding='4px 8px'; armBtn.style.border='1px solid #d1d5db'; armBtn.style.background='#fff'; armBtn.style.borderRadius='4px'; armBtn.style.cursor='pointer';
            row.appendChild(armBtn);
          }
        }catch(_){ }
        main.append(ttl,meta);
        row.append(numSpan,main);
        // Track if we're dragging to prevent click during drag
        let clickAllowed=true;
        let clickTimer=null;
        row.addEventListener('touchstart',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('mousedown',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('touchend',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('mouseup',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('click',()=>{
          if(!clickAllowed) return; // Prevent click during long-hold drag
          document.querySelectorAll('#liveList .live-row').forEach(r=> r.style.background='');
          const dark = document.body.classList.contains('live-dark');
          row.style.background = dark ? '#0b3a59' : '#e0f2fe';
          if(titleEl) titleEl.textContent=it.title||'';
          if(bodyEl){
            // Get fresh lyrics from database
            const baseSong = findSongById(it.id) || findSongByTitle(it.title);
            const freshLyrics = baseSong ? baseSong.lyrics : it.lyrics;
            bodyEl.textContent=freshLyrics || '';
            bodyEl.style.paddingTop='50vh';
            // Add rating UI at bottom
            const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
            const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:18px';
            const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:10px';
            const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
            const updateRatingButtons=()=>{
              ratingBtns.innerHTML='';
              [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:8px 16px;border:2px solid '+(it.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(it.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:24px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(it.id)||findSongByTitle(it.title); if(baseSong){ baseSong.audienceRating=r; it.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
            };
            updateRatingButtons();
            ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
          }
          const lyrMain=document.getElementById('liveLyrics'); if(lyrMain){ lyrMain.scrollTop=0; }
          const zoom=document.getElementById('liveInlineZoom'); if(zoom){ zoom.value=String(liveZoomPx); }
          const body=document.getElementById('liveLyricsBody'); if(body){ body.style.fontSize=liveZoomPx+'px'; }
          
          // Load song's saved LPM or estimate
          liveScrollLpm = getSongLpm(it);
          liveCurrentSongId = it.id;
          const speedDisplay=document.getElementById('liveInlineSpeedDisplay');
          if(speedDisplay) speedDisplay.textContent = liveScrollLpm === 0 ? 'OFF' : liveScrollLpm + ' LPM';
          
          try{ stopLiveInlineAutoScroll(); }catch(_){ }
          try{ preloadSongAudioFor(it); }catch(_){ }
          // Show Play button again for new selection; keep Stop hidden until audio/scroll actions
          const pBtn=document.getElementById('liveInlinePlay'); const sBtn=document.getElementById('liveInlineStop');
          if(pBtn){ pBtn.style.display=''; }
          if(sBtn){ sBtn.style.display='none'; }
          // On phones/tablets, single tap opens fullscreen. Desktop uses double‚Äëclick.
          const isNarrow = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;
          if(isNarrow){ openLiveLyricsOverlay(it); }
        });
        // Desktop: double‚Äëclick to open fullscreen lyrics
        // Mobile: handle double-tap gesture
        let lastTap = 0;
        row.addEventListener('touchend', (e) => {
          const now = Date.now();
          const DOUBLE_TAP_DELAY = 300;
          if (now - lastTap < DOUBLE_TAP_DELAY) {
            e.preventDefault();
            openLiveLyricsOverlay(it);
            lastTap = 0;
          } else {
            lastTap = now;
          }
        });
        row.addEventListener('dblclick',()=>{ openLiveLyricsOverlay(it); });
        // Setup long-hold reorder for songs
        setupLiveRowReorder(row,i);
        listEl.appendChild(row);
      });
      
      // Setup long-hold reordering for all rows
      function setupLiveRowReorder(row,index){
        let holdTimer=null;
        let isDragging=false;
        let dragReady=false; // Hold completed, ready to drag
        let startY=0;
        let currentY=0;
        let placeholder=null;
        
        const startHold=(e)=>{
          if(holdTimer) return;
          dragReady=false;
          holdTimer=setTimeout(()=>{
            dragReady=true; // Hold completed - now ready to activate drag on move
          }, 500);
        };
        
        const activateDrag=()=>{
          if(isDragging) return;
          isDragging=true;
          row.style.opacity='0.7';
          row.style.transform='scale(1.05)';
          row.style.zIndex='1000';
          row.style.position='relative';
          // Create placeholder
          placeholder=document.createElement('div');
          placeholder.style.height=row.offsetHeight+'px';
          placeholder.style.background='#dbeafe';
          placeholder.style.border='2px dashed #374151';
          placeholder.style.borderRadius='4px';
          placeholder.style.margin='4px 0';
          row.parentNode.insertBefore(placeholder, row.nextSibling);
        };
        
        const endHold=()=>{
          if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }
          dragReady=false;
          if(isDragging){
            // Get the current index from the dataset (in case it changed)
            const currentIndex = parseInt(row.dataset.index, 10);
            if(!isFinite(currentIndex) || currentIndex<0){ 
              // Cleanup and bail
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
              isDragging=false;
              return;
            }
            
            // Find where the placeholder is positioned
            const allChildren=Array.from(listEl.children);
            let placeholderPos=-1;
            for(let i=0; i<allChildren.length; i++){
              if(allChildren[i]===placeholder){
                placeholderPos=i;
                break;
              }
            }
            
            // Map DOM position back to setlist index by counting rows before placeholder
            let targetSetlistIndex=0;
            for(let i=0; i<placeholderPos; i++){
              const child=allChildren[i];
              if(child.classList && child.classList.contains('live-row')){
                targetSetlistIndex++;
              }
            }
            
            if(targetSetlistIndex!==currentIndex){
              // Move in setlist array
              const item=setlist.splice(currentIndex,1)[0];
              const finalIndex = targetSetlistIndex > currentIndex ? targetSetlistIndex-1 : targetSetlistIndex;
              setlist.splice(finalIndex,0,item);
              saveAll();
              rebuildPreview();
              renderLive();
            } else {
              // No change, just cleanup
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
            }
            isDragging=false;
          }
        };
        
        const moveWhileDragging=(e)=>{
          // Only activate drag if hold completed AND user is moving
          if(dragReady && !isDragging){
            activateDrag();
          }
          if(!isDragging) return;
          e.preventDefault();
          const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
          const deltaY = clientY - startY;
          row.style.transform=`translateY(${deltaY}px) scale(1.05)`;
          // Move placeholder based on position
          const rows=Array.from(listEl.querySelectorAll('.live-row')).filter(r=>r!==placeholder);
          let insertBefore=null;
          rows.forEach(r=>{
            const rect=r.getBoundingClientRect();
            const mid=rect.top+rect.height/2;
            if(clientY < mid && !insertBefore){ insertBefore=r; }
          });
          if(insertBefore && placeholder){
            listEl.insertBefore(placeholder, insertBefore);
          } else if(placeholder && !insertBefore){
            listEl.appendChild(placeholder);
          }
        };
        
        // Touch events
        row.addEventListener('touchstart',(e)=>{
          startY = e.touches[0].clientY;
          startHold(e);
        });
        row.addEventListener('touchmove',(e)=>{
          moveWhileDragging(e);
        });
        row.addEventListener('touchend',(e)=>{
          endHold();
        });
        row.addEventListener('touchcancel',(e)=>{
          endHold();
        });
        
        // Mouse events for desktop - attach move/up to document to prevent losing grip
        const onMouseMove=(e)=>{
          moveWhileDragging(e);
        };
        const onMouseUp=(e)=>{
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          endHold();
        };
        row.addEventListener('mousedown',(e)=>{
          startY = e.clientY;
          startHold(e);
          // Attach global listeners when drag starts
          setTimeout(()=>{
            if(isDragging){
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            }
          }, 510); // Just after the 500ms hold timer
        });
      }
    }

    // Initialize dark mode from saved preference
    (function initDarkMode(){
      const dark=!!gig.liveDark;
      document.body.classList.toggle('live-dark', dark);
    })();

    // Live theme toggle wiring (only in Live mode)
    (function wireLiveThemeToggle(){
      const btn=document.getElementById('liveThemeToggle');
      if(!btn) return;
      
      // Initialize button state
      const dark=!!gig.liveDark;
      btn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
      btn.style.background = dark ? '#fef3c7' : '#0f172a';
      btn.style.color = dark ? '#92400e' : '#fbbf24';
      
      btn.addEventListener('click',()=>{
        gig.liveDark = !gig.liveDark;
        document.body.classList.toggle('live-dark', gig.liveDark);
        btn.textContent = gig.liveDark ? '‚òÄÔ∏è' : 'üåô';
        btn.style.background = gig.liveDark ? '#fef3c7' : '#0f172a';
        btn.style.color = gig.liveDark ? '#92400e' : '#fbbf24';
        // Re-render live to refresh colors and icon
        try{ renderLive(); }catch(_){ }
        saveAll();
      });
    })();

    // Arm All: batch-arm audio by selecting a folder and matching filenames
    (function wireArmAll(){
      const armBtn=document.getElementById('armAllBtn');
      const armDir=document.getElementById('armAllDir');
      if(!armBtn || !armDir) return;
      const matchAndArm=(fileList)=>{
        if(!fileList || !fileList.length) return 0;
        const map=new Map();
        for(const f of fileList){ map.set((f.name||'').toLowerCase(), f); }
        let armed=0;
        const targetSongs = setlist.filter(x=>x.type==='song');
        targetSongs.forEach(it=>{
          const base = (findSongById(it.id) || findSongByTitle(it.title)); if(!base) return;
          // Try to match by filename first
          const want=(base.audioFileName||'').toLowerCase().trim();
          let file=null;
          if(want){ file = map.get(want) || null; }
          if(!file){
            // heuristic: try title match
            const t=(base.title||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
            if(t){ for(const [nm,f] of map){ if(nm.replace(/[^a-z0-9]+/g,' ').includes(t)){ file=f; break; } }
            }
          }
          // If file found OR has URL, arm it
          if(base.id!=null){
            if(file){
              // Arm with local file
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=URL.createObjectURL(file);
              armed++;
            } else if((base.audioUrl||'').trim()){
              // Arm with URL (mark as armed by setting a flag)
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=base.audioUrl; // store URL directly
              armed++;
            }
          }
        });
        return armed;
      };
      armBtn.addEventListener('click',()=> armDir.click());
      armDir.addEventListener('change',()=>{
        const n=matchAndArm(armDir.files||[]);
        alert(n? ('Armed '+n+' audio track'+(n===1?'':'s')+' (files and URLs) for this set.') : 'No matching files found. Add audio files or URLs to songs in Database.');
      });
    })();

    // Live fullscreen lyrics: timed auto-scroll based on Lines Per Minute (LPM)
    let liveScrollTimer=null;
    let liveScrollStart=null;
    let liveScrollDurationMs=0;
    let liveZoomPx=20; // inline lyrics zoom (desktop pane)
    let liveOverlayZoomPx=20; // fullscreen overlay zoom
    let liveScrollLpm=20; // current scroll speed in Lines Per Minute (0=stopped, 1-60)
    let liveCurrentSongId=null; // track which song is currently displayed for saving LPM
    let liveManualScrollOffset=0; // manual scroll adjustment during playback
    
    // Count actual lines in lyrics text
    function countLyricsLines(lyrics){
      if(!lyrics) return 0;
      return lyrics.split('\n').filter(line => line.trim().length > 0).length;
    }
    
    // Estimate LPM based on song length (minutes) and number of lyrics lines
    // Goal: scroll through all lines in ~90% of song duration
    function estimateLpm(song){
      if(!song) return 20; // default
      const lyrics = song.lyrics || '';
      const lineCount = countLyricsLines(lyrics);
      if(lineCount <= 1) return 20; // not enough lines to estimate
      
      // Parse song length (format: "3:45" or "3" for minutes)
      let durationMin = 3.5; // default 3.5 minutes
      const lengthStr = String(song.length || '').trim();
      if(lengthStr){
        if(lengthStr.includes(':')){
          const [m, s] = lengthStr.split(':').map(x => parseInt(x, 10) || 0);
          durationMin = m + s / 60;
        } else {
          durationMin = parseFloat(lengthStr) || 3.5;
        }
      }
      if(durationMin < 0.5) durationMin = 3.5;
      
      // Calculate LPM to scroll through all lines in 90% of song duration
      const scrollTime = durationMin * 0.9; // 90% of song length
      const lpm = Math.round(lineCount / scrollTime);
      // Clamp to valid range 1-200
      return Math.max(1, Math.min(200, lpm));
    }
    
    // Get LPM for a song (saved or estimated)
    function getSongLpm(song){
      if(!song) return 20;
      if(typeof song.lyricsLpm === 'number' && song.lyricsLpm >= 0 && song.lyricsLpm <= 200){
        return song.lyricsLpm;
      }
      return estimateLpm(song);
    }
    
    // Save LPM to song
    function saveSongLpm(song, lpm){
      if(!song) return;
      song.lyricsLpm = lpm;
      // Also save to base song in database
      const baseSong = findSongById(song.id) || findSongByTitle(song.title);
      if(baseSong) baseSong.lyricsLpm = lpm;
      saveAll();
    }
    
    // Compute scroll duration based on LPM and actual content
    function computeScrollDuration(container, bodyEl, zoomPx, lpm){
      try{
        if(!container || !bodyEl) return 0;
        if(lpm <= 0) return 0; // stopped
        const lineHeightPx = zoomPx * 1.4; // approximate line-height factor
        const totalLines = Math.max(1, Math.round(bodyEl.scrollHeight / lineHeightPx));
        const visibleLines = Math.max(1, Math.round(container.clientHeight / lineHeightPx));
        const linesToScroll = Math.max(1, totalLines - visibleLines);
        const durationMs = (linesToScroll / lpm) * 60000;
        return durationMs;
      }catch(e){ return 0; }
    }
    // Inline (desktop) auto-scroll
    let liveInlineScrollTimer=null;
    let liveInlineScrollStart=null;
    let liveInlineScrollDurationMs=0;
    let liveInlineManualScrollOffset=0;
    function stopLiveAutoScroll(){
      if(liveScrollTimer){ cancelAnimationFrame(liveScrollTimer); liveScrollTimer=null; }
      liveScrollStart=null; liveScrollDurationMs=0;
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function stopLiveInlineAutoScroll(){
      if(liveInlineScrollTimer){ cancelAnimationFrame(liveInlineScrollTimer); liveInlineScrollTimer=null; }
      liveInlineScrollStart=null; liveInlineScrollDurationMs=0;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function openLiveLyricsOverlay(item){
      const overlay=document.getElementById('liveLyricsOverlay');
      const titleEl=document.getElementById('liveLyricsOverlayTitle');
      const bodyEl=document.getElementById('liveLyricsOverlayBody');
      if(!overlay || !titleEl || !bodyEl) return;
      stopLiveAutoScroll();
      overlay.classList.add('open');
      titleEl.textContent=item.title || '';
      // Get fresh lyrics from database
      const baseSong = findSongById(item.id) || findSongByTitle(item.title);
      const freshLyrics = baseSong ? baseSong.lyrics : item.lyrics;
      bodyEl.textContent=freshLyrics || '';
      bodyEl.style.paddingTop='50vh';
      
      // Load song's saved LPM or estimate from song length
      liveScrollLpm = getSongLpm(item);
      liveCurrentSongId = item.id;
      const speedDisplay=document.getElementById('liveSpeedDisplay');
      if(speedDisplay) speedDisplay.textContent = liveScrollLpm === 0 ? 'OFF' : liveScrollLpm + ' LPM';
      
      // Add rating UI at bottom
      const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
      const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:24px';
      const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:12px';
      const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
      const updateRatingButtons=()=>{
        ratingBtns.innerHTML='';
        [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:10px 20px;border:2px solid '+(item.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(item.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:32px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(item.id)||findSongByTitle(item.title); if(baseSong){ baseSong.audienceRating=r; item.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
      };
      updateRatingButtons();
      ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
      const main=document.getElementById('liveLyricsOverlayMain');
      if(main){ main.scrollTop=0; }
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(zoomSlider){
        zoomSlider.value=String(liveOverlayZoomPx);
      }
      const body=document.getElementById('liveLyricsOverlayBody');
      if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
      // Reset play visibility for new overlay song
      const pBtn=document.getElementById('liveLyricsPlay'); const sBtn=document.getElementById('liveLyricsStop');
      if(pBtn){ pBtn.style.display=''; }
      if(sBtn){ sBtn.style.display='none'; }
    }
    function closeLiveLyricsOverlay(){
      const overlay=document.getElementById('liveLyricsOverlay');
      if(overlay){ overlay.classList.remove('open'); }
      stopLiveAutoScroll();
    }
    function startLiveAutoScroll(){
      const overlay=document.getElementById('liveLyricsOverlay');
      const main=document.getElementById('liveLyricsOverlayMain');
      if(!overlay || !main || !overlay.classList.contains('open')) return;
      const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsOverlayBody');
      liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollLpm);
      if(liveScrollDurationMs<=0) liveScrollDurationMs=15000; // fallback
      let maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveScrollStart = performance.now();
      liveManualScrollOffset = 0; // reset manual offset for new scroll
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      let lastComputedTop = startTop;
      let lastManualAdjustTime = 0; // track when user last touched scroll
      function step(now){
        if(!liveScrollStart){ return; }
        // Recalculate maxTop each frame in case zoom changed
        const currentMaxTop = main.scrollHeight - main.clientHeight;
        if(currentMaxTop <= 0){ stopLiveAutoScroll(); return; }
        
        const elapsed = now - liveScrollStart;
        const t = Math.min(1, elapsed / liveScrollDurationMs);
        // Compute target position for this frame (as percentage of total)
        const targetTop = startTop + (currentMaxTop - startTop) * t;
        // Detect user manual scroll: if actual position differs from last computed, update offset
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){ 
          // User manually scrolled - calculate new offset and recalibrate
          liveManualScrollOffset = actualTop - targetTop;
          lastManualAdjustTime = now;
        }
        
        // Calculate final position with offset, but clamp to valid range
        let finalTop = targetTop + liveManualScrollOffset;
        
        // If user scrolled ahead, they might be past the "end" based on old timing
        // Keep scrolling until we actually reach the real current end
        finalTop = Math.max(0, Math.min(currentMaxTop, finalTop));
        
        lastComputedTop = finalTop;
        main.scrollTop = finalTop;
        
        // Continue until we reach the actual bottom (with small tolerance)
        const atBottom = actualTop >= currentMaxTop - 2;
        if(t < 1 || !atBottom){ 
          liveScrollTimer = requestAnimationFrame(step); 
        } else { 
          stopLiveAutoScroll(); 
        }
      }
      liveScrollTimer = requestAnimationFrame(step);
    }
    // Schedule scroll start after Play; immediate for armed/local or stream, delayed for external popup providers
    function scheduleOverlayScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200; // small delay for direct audio, longer for external to allow manual play
      setTimeout(()=>{ try{ startLiveAutoScroll(); }catch(_){ } }, delay);
    }
    function startLiveInlineAutoScroll(){
      const main=document.getElementById('liveLyrics');
      if(!main) return;
      const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsBody');
      liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollLpm);
      if(liveInlineScrollDurationMs<=0) liveInlineScrollDurationMs=15000;
      let maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveInlineScrollStart = performance.now();
      liveInlineManualScrollOffset = 0;
      let lastComputedTop = startTop;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      function step(now){
        if(!liveInlineScrollStart){ return; }
        // Recalculate maxTop each frame in case zoom changed
        const currentMaxTop = main.scrollHeight - main.clientHeight;
        if(currentMaxTop <= 0){ stopLiveInlineAutoScroll(); return; }
        
        const elapsed = now - liveInlineScrollStart;
        const t = Math.min(1, elapsed / liveInlineScrollDurationMs);
        const targetTop = startTop + (currentMaxTop - startTop) * t;
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){
          liveInlineManualScrollOffset = actualTop - targetTop;
        }
        
        // Calculate final position with offset, but clamp to valid range
        let finalTop = targetTop + liveInlineManualScrollOffset;
        finalTop = Math.max(0, Math.min(currentMaxTop, finalTop));
        
        lastComputedTop = finalTop;
        main.scrollTop = finalTop;
        
        // Continue until we reach the actual bottom
        const atBottom = actualTop >= currentMaxTop - 2;
        if(t < 1 || !atBottom){ 
          liveInlineScrollTimer = requestAnimationFrame(step); 
        } else { 
          stopLiveInlineAutoScroll(); 
        }
      }
      liveInlineScrollTimer = requestAnimationFrame(step);
    }
    function scheduleInlineScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200;
      setTimeout(()=>{ try{ startLiveInlineAutoScroll(); }catch(_){ } }, delay);
    }
    (function wireLiveOverlayControls(){
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      const scrollBtn=document.getElementById('liveLyricsScroll');
      const exitBtn=document.getElementById('liveLyricsExit');
      const main=document.getElementById('liveLyricsOverlayMain');
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleOverlayScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveAutoScroll); }
      if(exitBtn){ exitBtn.addEventListener('click',closeLiveLyricsOverlay); }
      
      // Previous and Next song navigation
      const prevBtn=document.getElementById('liveLyricsPrev');
      const nextBtn=document.getElementById('liveLyricsNext');
      if(prevBtn){
        prevBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
          const currentIdx=setlist.findIndex(x=> x.type==='song' && x.title===titleText);
          if(currentIdx > 0){
            // Find previous song (skip breaks/encores)
            for(let i=currentIdx-1; i>=0; i--){
              if(setlist[i].type==='song'){
                openLiveLyricsOverlay(setlist[i]);
                break;
              }
            }
          }
        });
      }
      if(nextBtn){
        nextBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
          const currentIdx=setlist.findIndex(x=> x.type==='song' && x.title===titleText);
          if(currentIdx >= 0 && currentIdx < setlist.length - 1){
            // Find next song (skip breaks/encores)
            for(let i=currentIdx+1; i<setlist.length; i++){
              if(setlist[i].type==='song'){
                openLiveLyricsOverlay(setlist[i]);
                break;
              }
            }
          }
        });
      }
      
      if(main){ main.addEventListener('click',closeLiveLyricsOverlay); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveOverlayZoomPx=Math.min(96, Math.max(16, v));
          const body=document.getElementById('liveLyricsOverlayBody');
          if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
          // Zoom change should not restart scrolling or audio
        });
      }
      const speedDownBtn=document.getElementById('liveSpeedDown');
      const speedUpBtn=document.getElementById('liveSpeedUp');
      const speedDisplay=document.getElementById('liveSpeedDisplay');
      
      // Helper to update speed display and save to current song
      const updateSpeedDisplay = () => {
        if(speedDisplay) speedDisplay.textContent = liveScrollLpm === 0 ? 'OFF' : liveScrollLpm + ' LPM';
      };
      const saveCurrentSongLpm = () => {
        const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
        const song=setlist.find(x=> x.type==='song' && x.title===titleText);
        if(song) saveSongLpm(song, liveScrollLpm);
      };
      const recalcScrollTiming = () => {
        if(liveScrollTimer && liveScrollStart && liveScrollLpm > 0){
          const elapsed = performance.now() - liveScrollStart;
          const oldT = Math.min(1, elapsed / liveScrollDurationMs);
          const main=document.getElementById('liveLyricsOverlayMain');
          const body=document.getElementById('liveLyricsOverlayBody');
          liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollLpm);
          liveScrollStart = performance.now() - (oldT * liveScrollDurationMs);
        }
      };
      
      // Hold-to-repeat for speed buttons
      let speedHoldTimer = null;
      let speedHoldInterval = null;
      const startSpeedHold = (delta) => {
        const doChange = () => {
          const newVal = liveScrollLpm + delta;
          if(newVal >= 0 && newVal <= 200){
            liveScrollLpm = newVal;
            updateSpeedDisplay();
            recalcScrollTiming();
          }
        };
        doChange(); // immediate first change
        speedHoldTimer = setTimeout(() => {
          speedHoldInterval = setInterval(doChange, 50); // fast repeat after hold
        }, 400); // start repeating after 400ms hold
      };
      const stopSpeedHold = () => {
        if(speedHoldTimer){ clearTimeout(speedHoldTimer); speedHoldTimer = null; }
        if(speedHoldInterval){ clearInterval(speedHoldInterval); speedHoldInterval = null; }
        saveCurrentSongLpm(); // save when released
      };
      
      if(speedDownBtn){
        speedDownBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startSpeedHold(-1); });
        speedDownBtn.addEventListener('mouseup', stopSpeedHold);
        speedDownBtn.addEventListener('mouseleave', stopSpeedHold);
        speedDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startSpeedHold(-1); }, {passive:false});
        speedDownBtn.addEventListener('touchend', stopSpeedHold);
        speedDownBtn.addEventListener('touchcancel', stopSpeedHold);
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startSpeedHold(1); });
        speedUpBtn.addEventListener('mouseup', stopSpeedHold);
        speedUpBtn.addEventListener('mouseleave', stopSpeedHold);
        speedUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startSpeedHold(1); }, {passive:false});
        speedUpBtn.addEventListener('touchend', stopSpeedHold);
        speedUpBtn.addEventListener('touchcancel', stopSpeedHold);
      }
    })();

    // Desktop inline Live controls
    (function wireLiveInlineControls(){
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      const scrollBtn=document.getElementById('liveInlineScroll');
      const zoomSlider=document.getElementById('liveInlineZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleInlineScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveInlineAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveInlineAutoScroll); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveZoomPx=Math.min(32, Math.max(16, v));
          const body=document.getElementById('liveLyricsBody');
          if(body){ body.style.fontSize=liveZoomPx+'px'; }
          // Zoom change should not restart scrolling or touch audio
        });
        // initialize to current zoom
        try{ zoomSlider.value=String(liveZoomPx); }catch(_){ }
      }
      const speedDownBtn=document.getElementById('liveInlineSpeedDown');
      const speedUpBtn=document.getElementById('liveInlineSpeedUp');
      const speedDisplay=document.getElementById('liveInlineSpeedDisplay');
      
      // Helper to update speed display and save to current song
      const updateSpeedDisplay = () => {
        if(speedDisplay) speedDisplay.textContent = liveScrollLpm === 0 ? 'OFF' : liveScrollLpm + ' LPM';
      };
      const saveCurrentSongLpm = () => {
        const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
        const song=setlist.find(x=> x.type==='song' && x.title===titleText);
        if(song) saveSongLpm(song, liveScrollLpm);
      };
      const recalcScrollTiming = () => {
        if(liveInlineScrollTimer && liveInlineScrollStart && liveScrollLpm > 0){
          const elapsed = performance.now() - liveInlineScrollStart;
          const oldT = Math.min(1, elapsed / liveInlineScrollDurationMs);
          const main=document.getElementById('liveLyrics');
          const body=document.getElementById('liveLyricsBody');
          liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollLpm);
          liveInlineScrollStart = performance.now() - (oldT * liveInlineScrollDurationMs);
        }
      };
      
      // Hold-to-repeat for speed buttons
      let speedHoldTimer = null;
      let speedHoldInterval = null;
      const startSpeedHold = (delta) => {
        const doChange = () => {
          const newVal = liveScrollLpm + delta;
          if(newVal >= 0 && newVal <= 200){
            liveScrollLpm = newVal;
            updateSpeedDisplay();
            recalcScrollTiming();
          }
        };
        doChange(); // immediate first change
        speedHoldTimer = setTimeout(() => {
          speedHoldInterval = setInterval(doChange, 50); // fast repeat after hold
        }, 400); // start repeating after 400ms hold
      };
      const stopSpeedHold = () => {
        if(speedHoldTimer){ clearTimeout(speedHoldTimer); speedHoldTimer = null; }
        if(speedHoldInterval){ clearInterval(speedHoldInterval); speedHoldInterval = null; }
        saveCurrentSongLpm(); // save when released
      };
      
      if(speedDownBtn){
        speedDownBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startSpeedHold(-1); });
        speedDownBtn.addEventListener('mouseup', stopSpeedHold);
        speedDownBtn.addEventListener('mouseleave', stopSpeedHold);
        speedDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startSpeedHold(-1); }, {passive:false});
        speedDownBtn.addEventListener('touchend', stopSpeedHold);
        speedDownBtn.addEventListener('touchcancel', stopSpeedHold);
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('mousedown', (e) => { e.preventDefault(); startSpeedHold(1); });
        speedUpBtn.addEventListener('mouseup', stopSpeedHold);
        speedUpBtn.addEventListener('mouseleave', stopSpeedHold);
        speedUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startSpeedHold(1); }, {passive:false});
        speedUpBtn.addEventListener('touchend', stopSpeedHold);
        speedUpBtn.addEventListener('touchcancel', stopSpeedHold);
      }
    })();

    // Live lyrics inline editing on double-click (WYSIWYG - edit in place)
    (function wireLiveLyricsEdit(){
      const bodyEl = document.getElementById('liveLyricsBody');
      const titleEl = document.getElementById('liveLyricsTitle');
      if(!bodyEl) return;
      
      let isEditing = false;
      let currentSong = null;
      
      bodyEl.addEventListener('dblclick', (e) => {
        if(isEditing) return;
        
        const songTitle = titleEl?.textContent || '';
        if(!songTitle) return;
        
        const song = setlist.find(x => x.type === 'song' && x.title === songTitle);
        if(!song) return;
        
        isEditing = true;
        currentSong = song;
        
        // Remove rating div while editing
        const ratingDiv = bodyEl.querySelector('div');
        if(ratingDiv) ratingDiv.remove();
        
        // Just make it editable - no visual changes
        bodyEl.contentEditable = 'true';
        bodyEl.focus();
      });
      
      // Save on blur
      bodyEl.addEventListener('blur', () => {
        if(!isEditing || !currentSong) return;
        
        // Get the edited text
        const newLyrics = bodyEl.innerText || '';
        
        // Save to song and database
        currentSong.lyrics = newLyrics;
        const baseSong = findSongById(currentSong.id) || findSongByTitle(currentSong.title);
        if(baseSong) baseSong.lyrics = newLyrics;
        saveAll();
        
        // Exit edit mode
        bodyEl.contentEditable = 'false';
        
        // Re-add rating UI
        const ratingDiv = document.createElement('div');
        ratingDiv.style.cssText = 'margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
        const ratingLabel = document.createElement('div');
        ratingLabel.textContent = 'Rate this performance:';
        ratingLabel.style.cssText = 'font-weight:600;margin-bottom:12px;font-size:18px';
        const ratingBtns = document.createElement('div');
        ratingBtns.style.cssText = 'display:flex;justify-content:center;gap:10px';
        const ratingIcons = ['üëé','üëà','üëç','üëç üëç'];
        [0,1,2,3].forEach(r => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = ratingIcons[r];
          btn.style.cssText = 'padding:8px 16px;border:2px solid ' + (currentSong.audienceRating === r ? '#374151' : '#d1d5db') + ';border-radius:8px;background:' + (currentSong.audienceRating === r ? '#e5e7eb' : '#fff') + ';cursor:pointer;font-size:24px;touch-action:manipulation';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const baseSong2 = findSongById(currentSong.id) || findSongByTitle(currentSong.title);
            if(baseSong2) { baseSong2.audienceRating = r; currentSong.audienceRating = r; saveAll(); }
          });
          ratingBtns.appendChild(btn);
        });
        ratingDiv.append(ratingLabel, ratingBtns);
        bodyEl.appendChild(ratingDiv);
        
        isEditing = false;
        currentSong = null;
      });
    })();

    // Metronome functionality with tap tempo (4+ taps) & overlay support
    (function(){
      let metronomeState = 0; // 0=off, 1=flash, 2=flash+click
      let metronomeInterval = null;
      let metronomeBPM = 120;
      let metronomeHoldTimer = null;
      let tapTimes=[]; let lastClickTime=0;
      const btns=[document.getElementById('metronomeBtn'), document.getElementById('metronomeBtnOverlay')].filter(Boolean);
      if(!btns.length) return;

      // Create audio context for click sound
      let audioCtx = null;
      const getAudioContext = () => {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      };
      const playClick = () => {
        try {
          const ctx = getAudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.value = 1000;
          gain.gain.value = 0.3;
          osc.start();
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
          osc.stop(ctx.currentTime + 0.05);
        } catch(e) {}
      };

      const flashButtons = () => {
        btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#fbbf24':'#fbbf24'; b.style.transform='scale(1.12)'; });
        setTimeout(()=>{ btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#1f2937':'#fff'; b.style.transform='scale(1)'; }); },110);
      };

      const updateTitles=()=>{
        btns.forEach(b=>{
          if(metronomeState===0){ b.title='Metronome OFF - Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM.'; b.style.border=b.id==='metronomeBtnOverlay'?'2px solid #444':'2px solid #d1d5db'; }
          else { b.title=metronomeBPM+' BPM - '+(metronomeState===1?'Flash':'Flash + Click'); b.style.border='2px solid #065f46'; }
        });
      };
      const startMetronome=()=>{
        if(metronomeInterval) clearInterval(metronomeInterval);
        const intervalMs=60000/metronomeBPM;
        metronomeInterval=setInterval(()=>{ flashButtons(); if(metronomeState===2) playClick(); }, intervalMs);
        updateTitles();
      };

      const stopMetronome=()=>{ if(metronomeInterval) clearInterval(metronomeInterval); metronomeInterval=null; updateTitles(); };

      const persistSongBPM=(bpm)=>{
        const titleEl=document.getElementById('liveLyricsTitle');
        if(titleEl && titleEl.textContent){
          const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
          const baseSong=song?(findSongById(song.id)||findSongByTitle(song.title)):null;
          if(baseSong){ baseSong.bpm=bpm; song.bpm=bpm; saveAll(); }
        }
      };
      const handleTap=(e)=>{
        // Cancel hold timer immediately on quick tap
        if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; }
        
        const now=performance.now();
        const gap=now-lastClickTime;
        lastClickTime=now;
        
        // Long pause (>1200ms) = mode cycle
        if(gap>1200){
          tapTimes=[];
          metronomeState=(metronomeState+1)%3;
          if(metronomeState===0){ stopMetronome(); }
          else {
            // adopt song bpm if exists
            const titleEl=document.getElementById('liveLyricsTitle');
            if(titleEl && titleEl.textContent){
              const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
              if(song && song.bpm && song.bpm>0) metronomeBPM=song.bpm;
            }
            startMetronome();
          }
          updateTitles();
          return;
        }
        
        // Tap tempo: collect tap times
        tapTimes.push(now);
        
        // After 4+ taps, calculate BPM from intervals
        if(tapTimes.length>=4){
          const intervals=[];
          for(let i=1;i<tapTimes.length;i++){ 
            const dt=tapTimes[i]-tapTimes[i-1]; 
            if(dt>0 && dt<2000) intervals.push(dt); 
          }
          if(intervals.length>=3){
            const recent=intervals.slice(-Math.min(8, intervals.length)); // use last 8 intervals max
            const avg=recent.reduce((a,b)=>a+b,0)/recent.length;
            let bpm=Math.round(60000/avg); 
            if(bpm<30)bpm=30; 
            if(bpm>300)bpm=300;
            metronomeBPM=bpm;
            persistSongBPM(bpm);
            // Start metronome with new BPM immediately
            if(metronomeState===0){ metronomeState=1; }
            stopMetronome();
            startMetronome();
          }
        }
        updateTitles();
      };
      
      btns.forEach(btn=>{
        btn.addEventListener('click', handleTap);
        btn.addEventListener('mousedown', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0; // reset tap state
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('mouseup', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('mouseleave', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('touchstart', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0;
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('touchend', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
      });
      updateTitles();
    })();

    // ============================================================================
    // TOUR MANAGER
    // ============================================================================
    (function initTourManager(){
      const tourViewModeSelect = document.getElementById('tourViewMode');
      const tourTodayBtn = document.getElementById('tourTodayBtn');
      const tourPrevBtn = document.getElementById('tourPrev');
      const tourNextBtn = document.getElementById('tourNext');
      const tourAddDateBtn = document.getElementById('tourAddDate');
      const tourPeriodLabel = document.getElementById('tourPeriodLabel');
      const tourTimeline = document.getElementById('tourTimeline');
      const tourNoSelection = document.getElementById('tourNoSelection');
      const tourDateDetails = document.getElementById('tourDateDetails');
      const tourItineraryContent = document.getElementById('tourItineraryContent');
      
      // Date form fields
      const tourDateInput = document.getElementById('tourDate');
      const tourVenueInput = document.getElementById('tourVenue');
      const tourAddressInput = document.getElementById('tourAddress');
      const tourLoadInInput = document.getElementById('tourLoadIn');
      const tourShowTimeInput = document.getElementById('tourShowTime');
      const tourBandInput = document.getElementById('tourBand');
      const tourSetlistSelect = document.getElementById('tourSetlistSelect');
      const tourStagePlotSelect = document.getElementById('tourStagePlotSelect');
      const tourSaveDateBtn = document.getElementById('tourSaveDate');
      const tourDeleteDateBtn = document.getElementById('tourDeleteDate');
      
      // Band preset dropdown removed - now using header Act selector
      // Keep updateBandPresetDropdown as a no-op for backward compatibility
      window.updateBandPresetDropdown = function(){};
      
      // Map & services
      const tourSearchLocationBtn = document.getElementById('tourSearchLocation');
      const tourMapPlaceholder = document.getElementById('tourMapPlaceholder');
      const tourMapContainer = document.getElementById('tourMapContainer');
      const tourCustomSearchBtn = document.getElementById('tourCustomSearchBtn');
      const tourCustomSearchInput = document.getElementById('tourCustomSearch');
      const tourExpediaLink = document.getElementById('tourExpediaLink');
      const tourGoogleMapsLink = document.getElementById('tourGoogleMapsLink');
      const tourGoogleTrafficLink = document.getElementById('tourGoogleTrafficLink');
      
      // Itinerary
      const tourAddItineraryBtn = document.getElementById('tourAddItineraryItem');
      const tourItineraryTimeline = document.getElementById('tourItineraryTimeline');
      
      // Global date header
      const dateBoxesContainer = document.getElementById('dateBoxesContainer');
      let currentDateView = 14; // Always show 14 days or until first gig
      
      // Utility: Generate unique ID
      function generateId(){ return 'tour_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); }
      
      // Helper: Parse time string (e.g. "4pm", "16:00", "4:30pm") to 24h format
      function parseTimeToHHMM(timeStr){
        if(!timeStr) return null;
        const cleaned = timeStr.toLowerCase().replace(/\s/g, '');
        let hours, minutes;
        
        const match1 = cleaned.match(/^(\d{1,2}):(\d{2})(am|pm)?$/);
        const match2 = cleaned.match(/^(\d{1,4})(am|pm)?$/);
        
        if(match1){
          hours = parseInt(match1[1]);
          minutes = parseInt(match1[2]);
          if(match1[3] === 'pm' && hours < 12) hours += 12;
          if(match1[3] === 'am' && hours === 12) hours = 0;
        } else if(match2){
          const num = match2[1];
          if(num.length <= 2){
            hours = parseInt(num);
            minutes = 0;
          } else {
            hours = parseInt(num.slice(0, -2));
            minutes = parseInt(num.slice(-2));
          }
          if(match2[2] === 'pm' && hours < 12) hours += 12;
          if(match2[2] === 'am' && hours === 12) hours = 0;
        } else {
          return null;
        }
        
        if(hours >= 24) hours = hours % 24;
        return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
      }
      
      // Helper: Sync times to itinerary - creates/updates itinerary entries for load-in, soundcheck, showtime
      function syncTimesToItinerary(tourDate){
        if(!tourDate) return;
        if(!tourDate.itinerary) tourDate.itinerary = [];
        
        // Remove existing auto-generated entries (we'll recreate them)
        tourDate.itinerary = tourDate.itinerary.filter(item => !item.autoGenerated);
        
        // Add load-in time
        if(tourDate.loadIn){
          const time = parseTimeToHHMM(tourDate.loadIn);
          if(time){
            tourDate.itinerary.push({
              time: time,
              title: 'üì¶ Load-In',
              notes: '',
              duration: 45,
              color: '#6366f1',
              autoGenerated: true
            });
          }
        }
        
        // Add showtime
        if(tourDate.showTime){
          const time = parseTimeToHHMM(tourDate.showTime);
          if(time){
            tourDate.itinerary.push({
              time: time,
              title: 'üé∏ Show Time',
              notes: '',
              duration: 90,
              color: '#22c55e',
              autoGenerated: true
            });
          }
        }
        
        // Parse soundcheck from gig notes if present (pattern: "Soundcheck 5pm" or "SC 5pm")
        if(tourDate.gig && tourDate.gig.notes){
          const scMatch = tourDate.gig.notes.match(/sound\s*check\s*[@:]?\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)/i);
          if(scMatch){
            const time = parseTimeToHHMM(scMatch[1]);
            if(time){
              tourDate.itinerary.push({
                time: time,
                title: 'üé§ Soundcheck',
                notes: '',
                duration: 60,
                color: '#f59e0b',
                autoGenerated: true
              });
            }
          }
          
          // Parse load-out (pattern: "Load-out 11pm" or "LO 11pm")
          const loMatch = tourDate.gig.notes.match(/load[\s-]*out\s*[@:]?\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)/i);
          if(loMatch){
            const time = parseTimeToHHMM(loMatch[1]);
            if(time){
              tourDate.itinerary.push({
                time: time,
                title: 'üì¶ Load-Out',
                notes: '',
                duration: 45,
                color: '#dc2626',
                autoGenerated: true
              });
            }
          }
        }
        
        // Sort itinerary by time
        tourDate.itinerary.sort((a, b) => (a.time || '').localeCompare(b.time || ''));
      }
      
      // Helper: Prompt for time in 30-minute increments
      function promptForTime(defaultTime){
        const timeStr = prompt('Enter time (e.g., 2:30pm, 14:30, or just 230)\nUses 30-minute increments:', defaultTime || '');
        if(!timeStr) return null;
        
        // Parse various time formats
        let hours, minutes;
        const cleaned = timeStr.toLowerCase().replace(/\s/g, '');
        
        // Handle formats like "2:30pm", "14:30", "230", "2pm"
        const match1 = cleaned.match(/^(\d{1,2}):(\d{2})(am|pm)?$/);
        const match2 = cleaned.match(/^(\d{1,4})(am|pm)?$/);
        
        if(match1){
          hours = parseInt(match1[1]);
          minutes = parseInt(match1[2]);
          if(match1[3] === 'pm' && hours < 12) hours += 12;
          if(match1[3] === 'am' && hours === 12) hours = 0;
        } else if(match2){
          const num = match2[1];
          if(num.length <= 2){
            hours = parseInt(num);
            minutes = 0;
          } else {
            hours = parseInt(num.slice(0, -2));
            minutes = parseInt(num.slice(-2));
          }
          if(match2[2] === 'pm' && hours < 12) hours += 12;
          if(match2[2] === 'am' && hours === 12) hours = 0;
        } else {
          alert('Invalid time format. Try: 2:30pm, 14:30, or 230');
          return null;
        }
        
        // Round to nearest 30 minutes
        if(minutes < 15) minutes = 0;
        else if(minutes < 45) minutes = 30;
        else { minutes = 0; hours += 1; }
        
        if(hours >= 24) hours = hours % 24;
        
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
      }
      
      // Helper: Estimate drive time between two locations using coordinates
      function estimateDriveTime(fromLat, fromLon, toLat, toLon){
        if(!fromLat || !fromLon || !toLat || !toLon) return null;
        
        // Calculate straight-line distance (Haversine formula)
        const R = 6371; // Earth's radius in km
        const dLat = (toLat - fromLat) * Math.PI / 180;
        const dLon = (toLon - fromLon) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(fromLat * Math.PI / 180) * Math.cos(toLat * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distanceKm = R * c;
        
        // Estimate driving time: assume 1.4x straight-line distance for roads, average 80 km/h
        const drivingDistanceKm = distanceKm * 1.4;
        const hours = drivingDistanceKm / 80;
        
        // Round to nearest 30 minutes
        const roundedHours = Math.round(hours * 2) / 2;
        return roundedHours;
      }
      
      // Helper: Add hours to a time string
      function addHoursToTime(timeStr, hoursToAdd){
        if(!timeStr) return null;
        const [h, m] = timeStr.split(':').map(Number);
        let newHours = h + Math.floor(hoursToAdd);
        let newMinutes = m + ((hoursToAdd % 1) * 60);
        
        if(newMinutes >= 60){
          newHours += 1;
          newMinutes -= 60;
        }
        
        newHours = newHours % 24;
        return `${String(newHours).padStart(2, '0')}:${String(Math.round(newMinutes)).padStart(2, '0')}`;
      }
      
      // Save current date data before switching
      function saveCurrentDateData(){
        if(!selectedTourDateId) return;
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        // Save current setlist, stage, gig, gear, and tech notes to tour date
        tourDate.setlist = [...setlist];
        // Get stage from full editor if open, otherwise from stored SVG
        // SAFETY: Only save if has content - never overwrite existing data with blank
        const stageHTML = getStageHTML();
        if(stageHTML && stageHTML.length > 0){
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = stageHTML;
          const svg = tempDiv.querySelector('svg');
          const hasItems = svg ? svg.querySelectorAll('g[data-draggable]').length > 0 : false;
          if(hasItems || !tourDate.stage){
            tourDate.stage = stageHTML;
          }
        }
        // Sync gig details to tour date AND calendar fields
        tourDate.gig = {...gig};
        tourDate.venue = gig.venue || '';
        tourDate.address = gig.address || '';
        tourDate.band = gig.band || '';
        tourDate.loadIn = gig.loadIn || '';
        tourDate.showTime = gig.showTime || '';
        tourDate.gearSummary = gearSummary;
        tourDate.techNotes = techNotes;
        currentDateDirty = false;
      }
      
      // Load date data into current context
      function loadDateData(tourDate){
        if(!tourDate) return;
        
        // Restore setlist
        if(tourDate.setlist && Array.isArray(tourDate.setlist)){
          setlist = [...tourDate.setlist];
        } else {
          setlist = [];
        }
        
        // Stage dimension constants
        const STAGE_DEFAULT_WIDTH = 1000;
        const STAGE_DEFAULT_HEIGHT = 600;
        const STAGE_MIN_SIZE = 300;
        const STAGE_MAX_SIZE = 1500;
        
        // Restore stage - always load the date's stage (blank if no stage)
        const container = document.getElementById('stageStore');
        const fullSvg = document.getElementById('stageSvgFull');
        const frame = document.getElementById('stageFrame');
        
        if(tourDate.stage && tourDate.stage.length > 0){
          // Has stage data - load it
          if(container){
            container.innerHTML = tourDate.stage;
            const svg = container.querySelector('svg');
            if(svg){
              svg.id = 'stageSvg';
              svg.classList.add('bw');
              // Validate and restore dimensions
              let stageW = parseInt(svg.dataset.stageWidth || '0', 10);
              let stageH = parseInt(svg.dataset.stageHeight || '0', 10);
              if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
              if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
              svg.dataset.stageWidth = String(stageW);
              svg.dataset.stageHeight = String(stageH);
              // viewBox must match canvas for 1:1 pixel mapping
              svg.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
              // Background rect matches
              const bgRect = svg.querySelector('rect.stage-bg');
              if(bgRect){
                bgRect.setAttribute('x', '1');
                bgRect.setAttribute('y', '1');
                bgRect.setAttribute('width', String(stageW - 2));
                bgRect.setAttribute('height', String(stageH - 2));
              }
              try{ refreshCables(svg); }catch(e){}
            }
          }
          if(fullSvg){
            // Also update full editor if open
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tourDate.stage;
            const srcSvg = tempDiv.querySelector('svg');
            if(srcSvg){
              // Restore stage canvas dimensions from stored data
              let stageW = parseInt(srcSvg.dataset.stageWidth || '0', 10);
              let stageH = parseInt(srcSvg.dataset.stageHeight || '0', 10);
              if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
              if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
              
              // Apply dimensions to full editor
              fullSvg.dataset.stageWidth = String(stageW);
              fullSvg.dataset.stageHeight = String(stageH);
              fullSvg.style.width = stageW + 'px';
              fullSvg.style.height = stageH + 'px';
              // viewBox must match canvas for 1:1 pixel mapping
              fullSvg.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
              // Update background rect
              const bgRect = fullSvg.querySelector('rect.stage-bg');
              if(bgRect){
                bgRect.setAttribute('x', '1');
                bgRect.setAttribute('y', '1');
                bgRect.setAttribute('width', String(stageW - 2));
                bgRect.setAttribute('height', String(stageH - 2));
              }
              
              // Update frame size
              if(frame){
                frame.style.width = stageW + 'px';
                frame.style.height = stageH + 'px';
              }
              
              // Clear existing draggables
              fullSvg.querySelectorAll('g[data-draggable]').forEach(n => n.remove());
              // Copy draggables from stored stage and enable drag
              srcSvg.querySelectorAll('g[data-draggable]').forEach(g => {
                const clone = g.cloneNode(true);
                fullSvg.appendChild(clone);
                if(typeof enableSvgDrag === 'function') enableSvgDrag(clone);
              });
              try{ refreshCables(fullSvg); }catch(e){}
              // Bind selection to the full SVG
              if(typeof bindSelection === 'function') bindSelection(fullSvg);
            }
          }
        } else {
          // No stage data - show blank stage with default dimensions
          if(container){
            container.innerHTML = '<svg id="stageSvg" class="bw" viewBox="0 0 ' + STAGE_DEFAULT_WIDTH + ' ' + STAGE_DEFAULT_HEIGHT + '" data-stage-width="' + STAGE_DEFAULT_WIDTH + '" data-stage-height="' + STAGE_DEFAULT_HEIGHT + '" xmlns="http://www.w3.org/2000/svg"><rect class="stage-bg" x="1" y="1" width="' + (STAGE_DEFAULT_WIDTH-2) + '" height="' + (STAGE_DEFAULT_HEIGHT-2) + '"/><text x="' + (STAGE_DEFAULT_WIDTH/2) + '" y="40" text-anchor="middle" font-size="16" font-weight="bold" id="stageTitle">Band ‚Ä¢ Date</text></svg>';
          }
          if(fullSvg){
            // Clear all draggables from full editor and reset to default size
            fullSvg.querySelectorAll('g[data-draggable]').forEach(n => n.remove());
            fullSvg.dataset.stageWidth = String(STAGE_DEFAULT_WIDTH);
            fullSvg.dataset.stageHeight = String(STAGE_DEFAULT_HEIGHT);
            fullSvg.style.width = STAGE_DEFAULT_WIDTH + 'px';
            fullSvg.style.height = STAGE_DEFAULT_HEIGHT + 'px';
            // viewBox must match canvas for 1:1 pixel mapping
            fullSvg.setAttribute('viewBox', '0 0 ' + STAGE_DEFAULT_WIDTH + ' ' + STAGE_DEFAULT_HEIGHT);
            // Reset background rect
            const bgRect = fullSvg.querySelector('rect.stage-bg');
            if(bgRect){
              bgRect.setAttribute('x', '1');
              bgRect.setAttribute('y', '1');
              bgRect.setAttribute('width', String(STAGE_DEFAULT_WIDTH - 2));
              bgRect.setAttribute('height', String(STAGE_DEFAULT_HEIGHT - 2));
            }
            if(frame){
              frame.style.width = STAGE_DEFAULT_WIDTH + 'px';
              frame.style.height = STAGE_DEFAULT_HEIGHT + 'px';
            }
          }
        }
        
        // Restore gig data - but PRESERVE settings that should persist across all dates
        const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band) : gig.band;
        // Save settings that should persist across date changes (not per-date)
        const persistentSettings = {
          dbColumns: gig.dbColumns,
          customColumns: gig.customColumns,
          customMoods: gig.customMoods,
          customImages: gig.customImages,
          hiddenIcons: gig.hiddenIcons,
          font: gig.font,
          logo: gig.logo,
          headerFlags: gig.headerFlags,
          liveDark: gig.liveDark
        };
        if(tourDate.gig){
          gig = {...tourDate.gig};
        } else {
          gig.venue = tourDate.venue || '';
          gig.address = tourDate.address || '';
          gig.band = tourDate.band || '';
          gig.date = tourDate.date || '';
        }
        // CRITICAL: Force gig.date to match the tourDate we're viewing (not the stale date in tourDate.gig)
        gig.date = tourDate.date || gig.date;
        
        // Restore persistent settings that should NOT change per date
        Object.keys(persistentSettings).forEach(key => {
          if(persistentSettings[key] !== undefined) gig[key] = persistentSettings[key];
        });
        // Always use the Act selector band as authoritative source
        if(currentBandName) gig.band = currentBandName;
        
        // Restore gear and tech notes
        if(tourDate.gearSummary !== undefined){
          gearSummary = tourDate.gearSummary;
          const gearEl = document.getElementById('gear');
          if(gearEl) gearEl.value = gearSummary;
        } else {
          gearSummary = '';
          const gearEl = document.getElementById('gear');
          if(gearEl) gearEl.value = '';
        }
        
        if(tourDate.techNotes !== undefined){
          techNotes = typeof tourDate.techNotes === 'object' ? tourDate.techNotes : {};
        } else {
          techNotes = {};
        }
        
        // Update displays
        try{ renderDB(); buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(e){}
      }
      
      // Prompt for new tour date details
      function promptNewTourDate(dateStr){
        const typePrompt = 'What kind of day?\n\n1. Gig\n2. Drive\n3. Rest\n4. Home\n5. Rehearse\n6. Party\n7. Record\n8. Radio\n9. TV\n10. DJ\n11. Audition\n12. Dress Rehearsal\n13. Custom\n\nEnter number or name:';
        const typeInput = prompt(typePrompt, '1');
        if(!typeInput) return null;
        
        const typeMap = {
          '1': 'gig', 'gig': 'gig',
          '2': 'drive', 'drive': 'drive',
          '3': 'rest', 'rest': 'rest',
          '4': 'home', 'home': 'home',
          '5': 'rehearse', 'rehearse': 'rehearse',
          '6': 'party', 'party': 'party',
          '7': 'record', 'record': 'record',
          '8': 'radio', 'radio': 'radio',
          '9': 'tv', 'tv': 'tv',
          '10': 'dj', 'dj': 'dj',
          '11': 'audition', 'audition': 'audition',
          '12': 'dressrehearsal', 'dress rehearsal': 'dressrehearsal',
          '13': 'custom', 'custom': 'custom'
        };
        
        let finalType = typeMap[typeInput.toLowerCase()] || 'custom';
        let customLabel = '';
        
        if(finalType === 'custom'){
          customLabel = prompt('Enter custom day type:', '');
          if(!customLabel) return null;
        }
        
        let venue = '';
        let address = '';
        
        if(finalType === 'gig'){
          venue = prompt('Enter venue name:', '');
          if(!venue) return null;
          address = prompt('Enter venue address/city:', '');
        } else if(finalType === 'drive'){
          venue = 'Travel Day';
          address = prompt('Destination city:', '');
        } else if(finalType === 'rest'){
          venue = 'Rest Day';
          address = prompt('Hotel/Location:', '');
        } else if(finalType === 'home'){
          venue = 'Home';
          address = 'Home';
        } else {
          venue = customLabel || finalType.charAt(0).toUpperCase() + finalType.slice(1);
          address = prompt('Location:', '') || '';
        }
        
        const copyData = confirm('Copy current setlist and stage plot?\n\nOK = Copy current data\nCancel = Start fresh');
        
        const newDate = {
          id: generateId(),
          date: dateStr,
          venue: venue,
          address: address,
          city: address.split(',')[0].trim(), // Extract city from address
          loadIn: '',
          showTime: '',
          band: gig.band || '',
          setlist: copyData ? [...setlist] : [],
          stage: copyData ? getStageHTML() : '',
          gig: copyData ? {...gig, venue, address, date:dateStr} : {band:gig.band||'', venue, address, date:dateStr, contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[], hiddenIcons:[], liveDark:false},
          itinerary: [],
          tourType: finalType
        };
        
        return newDate;
      }
      
      // Drag state for date boxes
      let dragSourceBox = null;
      let dragSourceDate = null;
      let dragStartTime = 0;
      let dragHoldTimer = null;
      let isDragCopy = false;
      let dateHeaderInitialized = false; // Track if we've done initial scroll
      let renderDateHeaderScheduled = false;
      let renderDateHeaderLast = 0;
      let renderDateHeaderLastDate = '';

      // Render global date header strip (throttled per frame)
      renderDateHeader = function(preserveScroll = true){
        const now = Date.now();
        const targetDateStr = gig.date || '';
        if(targetDateStr && renderDateHeaderLastDate === targetDateStr && now - renderDateHeaderLast < 800) return;
        if(renderDateHeaderScheduled || now - renderDateHeaderLast < 400) return;
        renderDateHeaderLast = now;
        renderDateHeaderLastDate = targetDateStr;
        renderDateHeaderScheduled = true;
        requestAnimationFrame(()=>{
          renderDateHeaderScheduled = false;
          if(!dateBoxesContainer) return;
          
          // Save current scroll position before re-rendering
          const savedScrollLeft = preserveScroll ? dateBoxesContainer.scrollLeft : 0;
          
          dateBoxesContainer.innerHTML = '';
          const today = new Date();
          today.setHours(0,0,0,0);
          
          // Always generate 120 days for scrolling (30 days before today, 90 after)
          // But only 14 are visible at a time
          const daysToShow = 120;
          const daysBefore = 30; // Days to show before today
          
          // Calculate box width so exactly 14 fit in the container
          const containerWidth = dateBoxesContainer.offsetWidth || dateBoxesContainer.parentElement.offsetWidth || 1000;
          const gap = 4; // Gap between boxes
          const boxWidth = Math.floor((containerWidth - (13 * gap)) / 14); // 13 gaps between 14 boxes
          const finalBoxWidth = Math.max(boxWidth, 50); // Minimum 50px
          
          // Generate date range starting from daysBefore days ago
          const startDate = new Date(today);
          startDate.setDate(startDate.getDate() - daysBefore);
          
          for(let i = 0; i < daysToShow; i++){
            const date = new Date(startDate);
            date.setDate(date.getDate() + i);
            
            const dateStr = date.toISOString().split('T')[0];
            const tourDate = tourDates.find(td => td.date === dateStr);
            const isToday = date.getTime() === today.getTime();
            
            const box = document.createElement('div');
            box.className = 'date-box';
            box.style.width = finalBoxWidth + 'px';
            box.style.minWidth = finalBoxWidth + 'px';
            box.draggable = true;
            box.dataset.date = dateStr;
            
            // Dragstart: allow dragging date to another date
            box.addEventListener('dragstart', (e) => {
              if(tourDate){
                e.dataTransfer.setData('text/plain', 'dateTransfer');
                e.dataTransfer.setData('sourceDateStr', dateStr);
                e.dataTransfer.effectAllowed = 'copy';
                box.style.opacity = '0.5';
              } else {
                e.preventDefault();
              }
            });
            
            box.addEventListener('dragend', (e) => {
              box.style.opacity = '1';
            });
          
          // Drop handlers for setlist/stage plot assignment AND date transfer
          box.addEventListener('dragover', (e) => {
            const hasAssignType = e.dataTransfer.types.includes('assigntype') || e.dataTransfer.types.includes('text/plain');
            if(hasAssignType){
              e.preventDefault();
              e.dataTransfer.dropEffect = 'copy';
              box.style.outline = '3px solid #f59e0b';
              box.style.outlineOffset = '2px';
            }
          });
          
          box.addEventListener('dragleave', (e) => {
            box.style.outline = '';
            box.style.outlineOffset = '';
          });
          
          box.addEventListener('drop', (e) => {
            let assignType = e.dataTransfer.getData('assignType');
            if(!assignType) assignType = e.dataTransfer.getData('text/plain');
            
            // Handle date-to-date transfer
            if(assignType === 'dateTransfer'){
              const sourceDateStr = e.dataTransfer.getData('sourceDateStr');
              if(!sourceDateStr || sourceDateStr === dateStr) return;
              
              e.preventDefault();
              box.style.outline = '';
              box.style.outlineOffset = '';
              
              const sourceTd = tourDates.find(t => t.date === sourceDateStr);
              if(!sourceTd) return;
              
              // Prompt for what to copy
              const copyPrompt = prompt(
                'Copy from ' + new Date(sourceDateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + 
                ' to ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + 
                '\n\nEnter what to copy (comma-separated):\n' +
                '  set = Setlist\n' +
                '  plot = Stage Plot\n' +
                '  venue = Venue & Address\n' +
                '  times = Load-in & Show Time\n' +
                '  notes = Gear & Tech Notes\n' +
                '  all = Everything\n\n' +
                'Example: set, plot, times',
                'all'
              );
              if(!copyPrompt) return;
              
              const copyParts = copyPrompt.toLowerCase().split(',').map(s => s.trim());
              const copyAll = copyParts.includes('all');
              const copySet = copyAll || copyParts.includes('set') || copyParts.includes('setlist');
              const copyPlot = copyAll || copyParts.includes('plot') || copyParts.includes('stage');
              const copyVenue = copyAll || copyParts.includes('venue');
              const copyTimes = copyAll || copyParts.includes('times') || copyParts.includes('loadin') || copyParts.includes('load-in');
              const copyNotes = copyAll || copyParts.includes('notes') || copyParts.includes('gear') || copyParts.includes('tech');
              
              // Find or create target date
              let targetTd = tourDates.find(t => t.date === dateStr);
              if(!targetTd){
                targetTd = {
                  id: generateId(),
                  date: dateStr,
                  venue: '',
                  address: '',
                  loadIn: '',
                  showTime: '',
                  band: sourceTd.band || gig.band || '',
                  setlistType: 'custom',
                  stagePlotType: 'custom',
                  itinerary: [],
                  interests: [],
                  setlist: [],
                  stage: '',
                  gearSummary: '',
                  techNotes: {},
                  gig: {venue: '', address: '', band: sourceTd.band || '', date: dateStr}
                };
                tourDates.push(targetTd);
                tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
              }
              
              // Copy selected data
              if(copySet && sourceTd.setlist){
                targetTd.setlist = JSON.parse(JSON.stringify(sourceTd.setlist));
                targetTd.setlistType = 'custom';
              }
              if(copyPlot && sourceTd.stage){
                targetTd.stage = sourceTd.stage;
                targetTd.stagePlotType = 'custom';
              }
              if(copyVenue){
                targetTd.venue = sourceTd.venue || '';
                targetTd.address = sourceTd.address || '';
                if(targetTd.gig){
                  targetTd.gig.venue = targetTd.venue;
                  targetTd.gig.address = targetTd.address;
                }
              }
              if(copyTimes){
                targetTd.loadIn = sourceTd.loadIn || '';
                targetTd.showTime = sourceTd.showTime || '';
              }
              if(copyNotes){
                targetTd.gearSummary = sourceTd.gearSummary || '';
                targetTd.techNotes = JSON.parse(JSON.stringify(sourceTd.techNotes || {}));
              }
              
              // If venue not copied, prompt for it
              if(!copyVenue){
                const venueInput = prompt('Enter venue name for ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + ' (or leave blank):', '');
                if(venueInput && venueInput.trim()){
                  targetTd.venue = venueInput.trim();
                  if(targetTd.gig) targetTd.gig.venue = venueInput.trim();
                }
                
                const addressInput = prompt('Enter venue address (optional):', '');
                if(addressInput && addressInput.trim()){
                  targetTd.address = addressInput.trim();
                  if(targetTd.gig) targetTd.gig.address = addressInput.trim();
                }
              }
              
              const copied = [];
              if(copySet) copied.push('Setlist');
              if(copyPlot) copied.push('Stage Plot');
              if(copyVenue) copied.push('Venue');
              if(copyTimes) copied.push('Times');
              if(copyNotes) copied.push('Notes');
              
              saveAll();
              renderDateHeader();
              alert('‚úì Copied ' + copied.join(', ') + ' to ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric'}));
              return;
            }
            
            if(!assignType || (assignType !== 'setlist' && assignType !== 'stagePlot')) return;
            
            e.preventDefault();
            box.style.outline = '';
            box.style.outlineOffset = '';
            
            console.log('‚úì Drop detected:', assignType, 'on date:', dateStr);
            
            // Find or create tour date for this dateStr
            let td = tourDates.find(t => t.date === dateStr);
            const isNew = !td;
            
            if(!td){
              // Create new tour date
              td = {
                id: generateId(),
                date: dateStr,
                venue: '',
                address: '',
                loadIn: '',
                showTime: '',
                band: gig.band || '',
                setlistType: 'custom',
                stagePlotType: 'custom',
                itinerary: [],
                interests: [],
                setlist: [],
                stage: '',
                gearSummary: '',
                techNotes: {},
                gig: {venue: '', address: '', band: gig.band || '', date: dateStr}
              };
              tourDates.push(td);
              tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
            }
            
            // Assign setlist or stage plot (copy songs only)
            if(assignType === 'setlist'){
              td.setlist = JSON.parse(JSON.stringify(setlist));
              td.setlistType = 'custom';
            } else if(assignType === 'stagePlot'){
              // Get current stage plot HTML from the editor
              const currentStageHTML = getStageHTML();
              if(currentStageHTML && currentStageHTML.length > 0){
                td.stage = currentStageHTML;
                td.stagePlotType = 'custom';
              } else {
                alert('No stage plot to copy. Create a stage plot first.');
                return;
              }
            }
            
            // Save immediately
            saveAll();
            
            // Wizard: Prompt for gig details
            if(!td.venue || td.venue.trim() === ''){
              const venueInput = prompt('Step 1/5: Enter venue name:', '');
              if(venueInput && venueInput.trim()){
                td.venue = venueInput.trim();
                if(td.gig) td.gig.venue = venueInput.trim();
              }
            }
            
            if(!td.address || td.address.trim() === ''){
              const addressInput = prompt('Step 2/5: Enter venue address (optional):', '');
              if(addressInput && addressInput.trim()){
                td.address = addressInput.trim();
                if(td.gig) td.gig.address = addressInput.trim();
              }
            }
            
            if(!td.loadIn || td.loadIn.trim() === ''){
              const loadInInput = prompt('Step 3/5: Enter load-in time (e.g., 4pm):', '');
              if(loadInInput && loadInInput.trim()){
                td.loadIn = loadInInput.trim();
                if(td.gig) td.gig.loadIn = loadInInput.trim();
              }
            }
            
            if(!td.showTime || td.showTime.trim() === ''){
              const showTimeInput = prompt('Step 4/5: Enter start time (e.g., 7pm):', '');
              if(showTimeInput && showTimeInput.trim()){
                td.showTime = showTimeInput.trim();
                if(td.gig) td.gig.showTime = showTimeInput.trim();
              }
            }
            
            // Optional: Soundcheck/Load-out in notes or itinerary
            const additionalTimes = prompt('Step 5/5: Add soundcheck/load-out times? (e.g., "Soundcheck 5pm, Load-out 11pm") Leave blank to skip:', '');
            if(additionalTimes && additionalTimes.trim()){
              if(!td.gig) td.gig = {};
              if(!td.gig.notes) td.gig.notes = '';
              td.gig.notes += (td.gig.notes ? '\n' : '') + additionalTimes.trim();
            }
            
            // Sync times to itinerary
            syncTimesToItinerary(td);
            
            // Switch to this date and load it
            gig.date = dateStr;
            saveAll();
            
            // Load the date data (which will populate form fields and memory from td)
            selectTourDate(td, false);
            
            // Stay on current tab and update display
            const currentTab = document.querySelector('.tab.active');
            if(currentTab && currentTab.dataset.tab === 'set'){
              // Rebuild sheet with updated gig info
              buildSheet('sheetInline');
              attachPreviewInteractions();
            }
            
            const dateDisplay = new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric'});
            alert(`‚úì ${assignType === 'setlist' ? 'Setlist' : 'Stage plot'} assigned to ${dateDisplay}\n\nVenue: ${td.venue || 'Not set'}\nAddress: ${td.address || 'Not set'}\nLoad-in: ${td.loadIn || 'Not set'}\nStart: ${td.showTime || 'Not set'}`);
            console.log(`‚úì ${assignType} assigned to ${dateDisplay}`);
          });
          
          // Mark active if matches gig.date
          if(gig.date && dateStr === gig.date){
            box.classList.add('active');
          }
          
          // Check if this is today (isToday already defined above)
          const isPast = date < today && !isToday;
          
          // Apply status-based coloring for dates with data
          if(tourDate){
            if(tourDate.tourType === 'cancelled'){
              box.classList.add('status-cancelled');
            } else if(isToday){
              box.classList.add('status-today');
            } else if(isPast){
              box.classList.add('status-past');
            } else {
              // Check completion: has venue AND (has setlist OR has stage plot)
              const hasVenue = tourDate.venue && tourDate.venue.trim() !== '';
              const hasSetlist = tourDate.setlist && tourDate.setlist.length > 0;
              const hasStagePlot = tourDate.stage && tourDate.stage.trim() !== '';
              
              if(hasVenue && (hasSetlist || hasStagePlot)){
                box.classList.add('status-complete');
              } else if(hasVenue || hasSetlist || hasStagePlot){
                box.classList.add('status-incomplete');
              }
            }
            
            // Apply tour type styling (for non-gig types)
            if(tourDate.tourType && tourDate.tourType !== 'gig'){
              box.classList.add(`tour-${tourDate.tourType}`);
            }
          }
          
          const dayNum = date.getDate();
          const monthAbbr = date.toLocaleDateString('en-US', {month:'short'});
          
          let contentHtml = '';
          if(tourDate && tourDate.tourType){
            const tourType = tourDate.tourType;
            const iconMap = {
              'gig': '',
              'drive': 'üöö',
              'rest': 'üõèÔ∏è',
              'home': 'üè†',
              'rehearse': 'üéµ',
              'party': 'üéâ',
              'record': 'üéôÔ∏è',
              'radio': 'üìª',
              'tv': 'üì∫',
              'dj': 'üéß',
              'audition': 'üé≠',
              'dressrehearsal': 'üëî',
              'custom': '‚≠ê'
            };
            
            const icon = iconMap[tourType] || '';
            
            if(tourType === 'gig' && tourDate.venue){
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-city">${tourDate.venue.substring(0, 8)}</span>`;
            } else if(tourType === 'drive' || tourType === 'rest' || tourType === 'home'){
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-icon">${icon}</span>`;
            } else {
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-city">${tourDate.venue || tourType}</span>`;
            }
          } else {
            contentHtml = `<span class="date-num">${dayNum}</span><span class="date-month">${monthAbbr}</span>`;
          }
          
          box.innerHTML = contentHtml;
          
          // Single click: preview only and center on selected date
          box.addEventListener('click', (e) => {
            if(e.defaultPrevented) return;
            
            const td = tourDates.find(t => t.date === dateStr);
            
            if(td){
              // Preview existing date
              if(currentDateDirty && selectedTourDateId){
                if(confirm('You have unsaved changes. Save before switching dates?')){
                  saveCurrentDateData();
                  saveAll();
                }
              }
              
              if(selectedTourDateId){
                saveCurrentDateData();
              }
              
              selectTourDate(td, false);
              
              // selectTourDate handles centering the selected date
              saveAll();
              
              // Reload current tab's data for this date
              const currentTab = document.querySelector('.tab.active');
              if(currentTab){
                const tabName = currentTab.dataset.tab;
                if(tabName === 'set'){
                  // Reload setlist preview
                  buildSheet('sheetInline');
                  attachPreviewInteractions();
                  renderSongPool();
                } else if(tabName === 'adv'){
                  // Reload stage plot if in stage view
                  const stageModal = document.getElementById('stageModal');
                  if(stageModal && stageModal.classList.contains('open')){
                    try{ closeStageModal(); openStageModal(); }catch(e){ console.log('Stage reload:', e); }
                  }
                } else if(tabName === 'live'){
                  // Reload Live Mode with new day's setlist
                  try{ if(typeof renderLive === 'function') renderLive(); }catch(e){ console.log('Live reload:', e); }
                }
                // For other tabs, data is already loaded by loadDateData
              }
            } else {
              // Blank date - prompt to create new entry
              const td = promptNewTourDate(dateStr);
              if(!td) {
                // User cancelled - just preview as FREE day without creating
                gig.date = dateStr;
                selectedTourDateId = null;
                gig.venue = '';
                gig.address = '';
                gig.loadIn = '';
                gig.showTime = '';
                gig.notes = '';
                try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(e){}
                renderDateHeader(false);
                return;
              }
              
              // Create the new tour date
              tourDates.push(td);
              tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
              
              selectTourDate(td, false);
              
              saveAll();
              
              // Update current tab
              const currentTab = document.querySelector('.tab.active');
              if(currentTab){
                const tabName = currentTab.dataset.tab;
                if(tabName === 'set'){
                  buildSheet('sheetInline');
                  attachPreviewInteractions();
                  renderSongPool();
                } else if(tabName === 'live'){
                  // Reload Live Mode with new day's setlist
                  try{ if(typeof renderLive === 'function') renderLive(); }catch(e){ console.log('Live reload:', e); }
                }
              }
            }
          });
          
          // Double click: edit existing date (same as click for blank)
          box.addEventListener('dblclick', (e) => {
            e.preventDefault();
            
            let td = tourDates.find(t => t.date === dateStr);
            
            if(!td){
              // Already handled by click - create new date
              return;
            }
            
            // Edit existing date - just select it (click already does this)
            selectTourDate(td, false);
            saveAll();
          });
          
          // Long press for context menu
          let longPressTimer = null;
          let longPressTriggered = false;
          
          box.addEventListener('mousedown', (e) => {
            if(e.button !== 0) return; // Only left click
            longPressTriggered = false;
            longPressTimer = setTimeout(() => {
              longPressTriggered = true;
              showDateContextMenu(e.clientX, e.clientY, dateStr, box);
            }, 600); // 600ms hold
          });
          
          box.addEventListener('mouseup', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          box.addEventListener('mouseleave', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          box.addEventListener('touchstart', (e) => {
            longPressTriggered = false;
            longPressTimer = setTimeout(() => {
              longPressTriggered = true;
              const touch = e.touches[0];
              showDateContextMenu(touch.clientX, touch.clientY, dateStr, box);
            }, 600);
          }, {passive:true});
          
          box.addEventListener('touchend', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          }, {passive:true});
          
          box.addEventListener('touchmove', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          }, {passive:true});
          
          dateBoxesContainer.appendChild(box);
        }
        
        const centerBox = (box)=>{
          if(!box) return;
          const containerWidth = dateBoxesContainer.offsetWidth;
          const scrollTo = box.offsetLeft - (containerWidth/2) + (box.offsetWidth/2);
          dateBoxesContainer.scrollLeft = Math.max(0, scrollTo);
        };
        
        setTimeout(() => {
          if(preserveScroll && savedScrollLeft > 0){
            dateBoxesContainer.scrollLeft = savedScrollLeft;
          } else if(gig.date){
            centerBox(dateBoxesContainer.querySelector('.date-box.active'));
            dateHeaderInitialized = true;
          } else if(!dateHeaderInitialized){
            centerBox(dateBoxesContainer.querySelector(`[data-date="${today.toISOString().split('T')[0]}"]`));
            dateHeaderInitialized = true;
          }
        }, 50);
      });
      }
      
      // Context menu for date boxes
      function showDateContextMenu(x, y, dateStr, box){
        // Remove any existing menu
        const existing = document.querySelector('.date-context-menu');
        if(existing) existing.remove();
        
        const menu = document.createElement('div');
        menu.className = 'date-context-menu';
        
        const td = tourDates.find(t => t.date === dateStr);
        const [year, month, day] = dateStr.split('-');
        const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
        const displayDate = dateObj.toLocaleDateString('en-US', {weekday:'long', month:'long', day:'numeric', year:'numeric'});
        
        // Create/Edit Event
        const createBtn = document.createElement('button');
        createBtn.innerHTML = td ? '‚úèÔ∏è Edit Event' : '‚ûï Create Event';
        createBtn.onclick = () => {
          menu.remove();
          if(!td){
            const newTd = promptNewTourDate(dateStr);
            if(!newTd) return;
            tourDates.push(newTd);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
          }
          const tourDate = tourDates.find(t => t.date === dateStr);
          if(tourDate){
            selectTourDate(tourDate, false);
            saveAll();
          }
        };
        menu.appendChild(createBtn);
        
        if(td){
          // Duplicate
          const dupBtn = document.createElement('button');
          dupBtn.innerHTML = 'üìã Duplicate to...';
          dupBtn.onclick = () => {
            menu.remove();
            const targetDate = prompt('Enter target date (YYYY-MM-DD):');
            if(!targetDate) return;
            
            const copiedDate = {
              id: generateId(),
              date: targetDate,
              venue: td.venue,
              address: td.address,
              city: td.city || '',
              tourType: td.tourType || 'gig',
              loadIn: td.loadIn || '',
              showTime: td.showTime || '',
              band: td.band || '',
              setlistType: td.setlistType || 'current',
              stagePlotType: td.stagePlotType || 'current',
              setlist: td.setlist ? JSON.parse(JSON.stringify(td.setlist)) : [],
              stage: td.stage || '',
              gig: td.gig ? JSON.parse(JSON.stringify(td.gig)) : null,
              itinerary: td.itinerary ? JSON.parse(JSON.stringify(td.itinerary)) : [],
              interests: td.interests ? JSON.parse(JSON.stringify(td.interests)) : [],
              chipData: td.chipData || null
            };
            
            if(copiedDate.gig) copiedDate.gig.date = targetDate;
            tourDates.push(copiedDate);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
            renderDateHeader();
            saveAll();
            alert(`Duplicated to ${targetDate}`);
          };
          menu.appendChild(dupBtn);
          
          // Cancel (mark as cancelled)
          const cancelBtn = document.createElement('button');
          const isCancelled = td.tourType === 'cancelled';
          cancelBtn.innerHTML = isCancelled ? '‚úÖ Restore Show' : '‚ùå Cancel Show';
          cancelBtn.onclick = () => {
            menu.remove();
            if(isCancelled){
              td.tourType = 'gig';
            } else {
              if(confirm(`Mark ${displayDate} as CANCELLED?\n\nThe date will remain in your calendar but marked as cancelled.`)){
                td.tourType = 'cancelled';
              }
            }
            renderDateHeader();
            saveAll();
          };
          menu.appendChild(cancelBtn);
          
          // Print
          const printBtn = document.createElement('button');
          printBtn.innerHTML = 'üñ®Ô∏è Print';
          printBtn.onclick = () => {
            menu.remove();
            // Load this date's data and trigger print
            selectTourDate(td, false);
            saveAll();
            // Trigger print after a brief delay to ensure rendering
            setTimeout(() => {
              window.print();
            }, 100);
          };
          menu.appendChild(printBtn);
          
          // Delete
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.innerHTML = 'üóëÔ∏è Delete';
          delBtn.onclick = () => {
            menu.remove();
            if(confirm(`Delete tour date ${displayDate}?`)){
              const idx = tourDates.findIndex(t => t.date === dateStr);
              if(idx !== -1){
                tourDates.splice(idx, 1);
                if(selectedTourDateId === td.id){
                  selectedTourDateId = null;
                  selectTourDate(null);
                }
                saveAll();
                renderDateHeader();
                renderTimeline();
              }
            }
          };
          menu.appendChild(delBtn);
        }
        
        // Cancel button
        const cancelMenuBtn = document.createElement('button');
        cancelMenuBtn.innerHTML = '‚ùå Cancel';
        cancelMenuBtn.onclick = () => menu.remove();
        menu.appendChild(cancelMenuBtn);
        
        // Position menu
        document.body.appendChild(menu);
        const rect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        let left = x;
        let top = y;
        
        // Adjust if menu goes off-screen
        if(left + rect.width > viewportWidth) left = viewportWidth - rect.width - 10;
        if(top + rect.height > viewportHeight) top = viewportHeight - rect.height - 10;
        if(left < 10) left = 10;
        if(top < 10) top = 10;
        
        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
        
        // Close menu when clicking outside (after 3s delay so users can tap)
        setTimeout(() => {
          const closeHandler = (e) => {
            if(!menu.contains(e.target)){
              menu.remove();
              document.removeEventListener('click', closeHandler);
            }
          };
          document.addEventListener('click', closeHandler);
        }, 3000);
      }
      
      // Act selector - click to show band preset dropdown
      const actSelector = document.getElementById('actSelector');
      if(actSelector){
        // Update display with current band
        updateActDisplay = function(){
          const bandName = gig.band && gig.band.trim() && gig.band.trim() !== 'Enter Band Name' ? gig.band : null;
          if(bandName){
            actSelector.textContent = bandName;
            actSelector.style.color = '#60a5fa'; // Bright blue
          } else {
            actSelector.textContent = 'Select Band...';
            actSelector.style.color = '#94a3b8'; // Gray
          }
        };
        updateActDisplay();
        
        // Make globally accessible
        window.updateActDisplay = updateActDisplay;
        
        actSelector.addEventListener('click', (e)=>{
          e.stopPropagation();
          // Show dropdown of band presets
          let dropdown = document.getElementById('actDropdown');
          if(dropdown){
            dropdown.remove();
            return;
          }
          
          // Get position of selector for dropdown placement
          const rect = actSelector.getBoundingClientRect();
          
          dropdown = document.createElement('div');
          dropdown.id = 'actDropdown';
          dropdown.style.cssText = `position:fixed;top:${rect.bottom + 4}px;left:${rect.left}px;background:white;border:1px solid #d1d5db;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:99999;min-width:180px;max-height:300px;overflow-y:auto`;
          
          // Add "New Band" option
          const newOpt = document.createElement('div');
          newOpt.textContent = '‚ûï Add New Band...';
          newOpt.style.cssText = 'padding:10px 14px;cursor:pointer;font-size:13px;border-bottom:1px solid #e5e7eb;color:#059669;font-weight:500';
          newOpt.addEventListener('mouseenter', ()=> newOpt.style.background = '#f0fdf4');
          newOpt.addEventListener('mouseleave', ()=> newOpt.style.background = '');
          newOpt.addEventListener('click', ()=>{
            dropdown.remove();
            showBandPresetModal();
          });
          dropdown.appendChild(newOpt);
          
          // List existing presets
          if(bandPresets.length > 0){
            bandPresets.forEach(bp => {
              const opt = document.createElement('div');
              opt.textContent = bp.name;
              opt.style.cssText = 'padding:10px 14px;cursor:pointer;font-size:13px;' + (currentBandPresetId === bp.id ? 'background:#e0f2fe;font-weight:600' : '');
              opt.addEventListener('mouseenter', ()=> opt.style.background = currentBandPresetId === bp.id ? '#bae6fd' : '#f1f5f9');
              opt.addEventListener('mouseleave', ()=> opt.style.background = currentBandPresetId === bp.id ? '#e0f2fe' : '');
              opt.addEventListener('click', ()=>{
                gig.band = bp.name;
                currentBandPresetId = bp.id;
                updateActDisplay();
                // Update ALL UI elements with band name
                const sheetBandEl = document.querySelector('.header .band');
                if(sheetBandEl) sheetBandEl.textContent = bp.name;
                const calBandInput = document.getElementById('tourBand');
                if(calBandInput) calBandInput.value = bp.name;
                const tourDate = tourDates.find(td => td.id === selectedTourDateId);
                if(tourDate) tourDate.band = bp.name;
                if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
                // Refresh stage plot header
                if(typeof refreshStageHeader === 'function') refreshStageHeader();
                saveAll();
                dropdown.remove();
                try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
              });
              dropdown.appendChild(opt);
            });
          } else {
            const empty = document.createElement('div');
            empty.textContent = 'No bands saved yet';
            empty.style.cssText = 'padding:10px 14px;color:#94a3b8;font-size:12px;font-style:italic';
            dropdown.appendChild(empty);
          }
          
          document.body.appendChild(dropdown);
          
          // Close on outside click
          setTimeout(()=>{
            document.addEventListener('click', function closeDropdown(e){
              if(!dropdown.contains(e.target) && e.target !== actSelector){
                dropdown.remove();
                document.removeEventListener('click', closeDropdown);
              }
            });
          }, 10);
        });
      }
      
      // Render timeline based on view mode
      function renderTimeline(){
        if(!tourTimeline) return;
        tourTimeline.innerHTML = '';
        
        const today = new Date();
        today.setHours(0,0,0,0);
        
        let dates = [];
        const anchor = new Date(tourViewDate);
        anchor.setHours(0,0,0,0);
        
        if(tourViewMode === 'week'){
          // Show 7 days starting from anchor (Monday-Sunday)
          const dayOfWeek = anchor.getDay();
          const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
          anchor.setDate(anchor.getDate() + mondayOffset);
          
          for(let i=0; i<7; i++){
            const d = new Date(anchor);
            d.setDate(d.getDate() + i);
            dates.push(d);
          }
          
          const weekStart = dates[0].toLocaleDateString('en-US', {month:'short', day:'numeric'});
          const weekEnd = dates[6].toLocaleDateString('en-US', {month:'short', day:'numeric', year:'numeric'});
          if(tourPeriodLabel) tourPeriodLabel.textContent = `${weekStart} - ${weekEnd}`;
          
        } else if(tourViewMode === 'month'){
          // Show all days in month
          const year = anchor.getFullYear();
          const month = anchor.getMonth();
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          
          for(let i=1; i<=daysInMonth; i++){
            dates.push(new Date(year, month, i));
          }
          
          if(tourPeriodLabel) tourPeriodLabel.textContent = anchor.toLocaleDateString('en-US', {month:'long', year:'numeric'});
          
        } else if(tourViewMode === 'year'){
          // Show 12 months
          const year = anchor.getFullYear();
          for(let m=0; m<12; m++){
            dates.push(new Date(year, m, 1));
          }
          
          if(tourPeriodLabel) tourPeriodLabel.textContent = year.toString();
        }
        
        // Render date tabs
        dates.forEach(date => {
          const dateStr = date.toISOString().split('T')[0];
          const hasGig = tourDates.some(td => td.date === dateStr);
          const isSelected = selectedTourDateId && tourDates.find(td => td.id === selectedTourDateId && td.date === dateStr);
          const isToday = date.getTime() === today.getTime();
          
          const tab = document.createElement('button');
          tab.className = 'tour-date-tab';
          tab.style.cssText = 'min-width:60px;padding:8px 12px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:2px;font-size:12px;transition:all 0.2s';
          
          if(isSelected){
            tab.style.background = '#0ea5e9';
            tab.style.color = '#fff';
            tab.style.borderColor = '#0284c7';
          } else if(hasGig){
            tab.style.background = '#f0f9ff';
            tab.style.borderColor = '#0ea5e9';
          }
          
          if(isToday){
            tab.style.fontWeight = 'bold';
            tab.style.boxShadow = '0 0 0 2px #fbbf24';
          }
          
          const dayName = tourViewMode === 'year' ? date.toLocaleDateString('en-US', {month:'short'}) : date.toLocaleDateString('en-US', {weekday:'short'});
          const dayNum = tourViewMode === 'year' ? '' : date.getDate();
          
          tab.innerHTML = `<span style="font-size:10px;color:${isSelected?'#fff':'#64748b'}">${dayName}</span>${dayNum ? `<span style="font-size:14px;font-weight:600">${dayNum}</span>` : ''}${hasGig ? '<span style="font-size:16px">üéµ</span>' : ''}`;
          
          tab.addEventListener('click', () => {
            const existing = tourDates.find(td => td.date === dateStr);
            if(existing){
              selectTourDate(existing);
            } else {
              // Save current date before creating new one
              if(selectedTourDateId){
                saveCurrentDateData();
              }
              
              // Get current band from Act selector (authoritative source)
              const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || '') : (gig.band || '');
              
              // Create new BLANK date - user will fill in details
              const newDate = {
                id: generateId(),
                date: dateStr,
                venue: '',
                address: '',
                loadIn: '',
                showTime: '',
                band: currentBandName,
                setlistType: 'current',
                stagePlotType: 'current',
                itinerary: [],
                interests: [],
                setlist: [],
                stage: '',
                gearSummary: '',
                techNotes: {},
                gig: {venue:'', address:'', band: currentBandName, date:dateStr}
              };
              
              tourDates.push(newDate);
              selectTourDate(newDate);
              saveAll();
              renderTimeline();
            }
          });
          
          tourTimeline.appendChild(tab);
        });
      }
      
      // Select a tour date
      function selectTourDate(tourDate, preserveHeaderScroll = true){
        // Save current date data before switching
        if(selectedTourDateId){
          saveCurrentDateData();
        }
        
        if(!tourDate || !tourDate.id){
          selectedTourDateId = null;
          if(tourNoSelection) tourNoSelection.style.display = '';
          if(tourDateDetails) tourDateDetails.style.display = 'none';
          if(tourItineraryContent) tourItineraryContent.style.display = 'none';
          return;
        }
        
        selectedTourDateId = tourDate.id;
          gig.date = tourDate.date || gig.date;
        
        // Load the new date's data
        loadDateData(tourDate);
        
        // Rebuild sheet with new date's gig data (band name, venue, etc.)
        try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
        
        if(tourNoSelection) tourNoSelection.style.display = 'none';
        if(tourDateDetails) tourDateDetails.style.display = '';
        if(tourItineraryContent) tourItineraryContent.style.display = '';
        
        // Populate form
        if(tourDateInput) tourDateInput.value = tourDate.date || '';
        if(tourVenueInput) tourVenueInput.value = tourDate.venue || '';
        if(tourAddressInput) tourAddressInput.value = tourDate.address || '';
        // Only set time inputs if value is valid HH:mm format (prevents console warnings)
        const validTimeFormat = /^\d{2}:\d{2}$/;
        if(tourLoadInInput) tourLoadInInput.value = (tourDate.loadIn && validTimeFormat.test(tourDate.loadIn)) ? tourDate.loadIn : '';
        if(tourShowTimeInput) tourShowTimeInput.value = (tourDate.showTime && validTimeFormat.test(tourDate.showTime)) ? tourDate.showTime : '';
        if(tourBandInput) tourBandInput.value = tourDate.band || gig.band || '';
        if(tourSetlistSelect) tourSetlistSelect.value = tourDate.setlistType || 'current';
        if(tourStagePlotSelect) tourStagePlotSelect.value = tourDate.stagePlotType || 'current';
        
        renderItinerary(tourDate);
        renderTimeline();
        renderDateHeader(preserveHeaderScroll);
        renderTourPreviews(tourDate);
        renderAdjacentDays(tourDate);
        
        // Update large header display
        const headerDate = document.getElementById('tourHeaderDate');
        const headerVenue = document.getElementById('tourHeaderVenue');
        if(headerDate && tourDate.date){
          const dateObj = new Date(tourDate.date + 'T12:00:00');
          headerDate.textContent = dateObj.toLocaleDateString('en-US', {weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'});
        }
        if(headerVenue){
          headerVenue.textContent = tourDate.venue || 'No venue set';
        }
        
        // Map is now manual: placeholder shows last loaded map until user reloads
      }
      
      // Render setlist and stage previews - shows tour date specific data
      renderTourPreviews = function(tourDate){
        const setlistPreview = document.getElementById('tourSetlistPreview');
        const stagePreview = document.getElementById('tourStagePreview');
        
        // Setlist preview - show tour date's setlist (or current if selected)
        if(setlistPreview){
          const dateSetlist = (tourDate && tourDate.id === selectedTourDateId) ? setlist : (tourDate?.setlist || []);
          if(dateSetlist && dateSetlist.length){
            setlistPreview.innerHTML = dateSetlist.map((song, idx) => 
              `<div style="padding:4px 0;border-bottom:1px solid #f3f4f6">${idx + 1}. <strong>${song.title || 'Untitled'}</strong> ${song.band ? `<span style="color:#64748b;font-size:10px">‚Äî ${song.band}</span>` : ''}</div>`
            ).join('');
          } else {
            setlistPreview.innerHTML = '<div style="color:#64748b;font-size:11px">No setlist</div>';
          }
          
          // Double-click to edit
          setlistPreview.parentElement.ondblclick = () => {
            document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
            const setTab = document.querySelector('.tab[data-tab="set"]');
            if(setTab) setTab.classList.add('active');
            ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
            const setEl = document.getElementById('set');
            if(setEl) setEl.style.display='block';
          };
        }
        
        // Stage preview - show tour date's stage plot
        if(stagePreview){
          // Get stage from tour date or current DOM if selected
          let stageHTML = null;
          if(tourDate && tourDate.id === selectedTourDateId){
            const storedSvg = document.getElementById('stageSvg') || document.getElementById('stageSvgFull');
            stageHTML = storedSvg ? storedSvg.outerHTML : tourDate.stage;
          } else {
            stageHTML = tourDate?.stage;
          }
          
          if(stageHTML){
            // Parse and scale it down for preview
            try {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = stageHTML;
              const svg = tempDiv.querySelector('svg');
              if(svg){
                svg.style.width = '100%';
                svg.style.maxWidth = '100%';
                svg.style.height = 'auto';
                svg.removeAttribute('id');
                stagePreview.innerHTML = svg.outerHTML;
              } else {
                stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
              }
            } catch(err) {
              console.error('Error rendering stage:', err);
              stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
            }
          } else {
            stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
          }
          
          // Double-click to edit
          stagePreview.parentElement.ondblclick = () => {
            document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
            const stageTab = document.querySelector('.tab[data-tab="adv"]');
            if(stageTab) stageTab.classList.add('active');
            ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
            const advEl = document.getElementById('adv');
            if(advEl) advEl.style.display='block';
            // Open stage modal
            const stageModal = document.getElementById('stageModal');
            if(stageModal && !stageModal.classList.contains('open')){
              toggleStageAndNotes();
            }
          };
        }
      }
      
      // Render yesterday and tomorrow cards
      function renderAdjacentDays(tourDate){
        if(!tourDate) return;
        
        const yesterdayDiv = document.getElementById('tourYesterday');
        const tomorrowDiv = document.getElementById('tourTomorrow');
        
        if(!yesterdayDiv || !tomorrowDiv) return;
        
        const currentDate = new Date(tourDate.date + 'T12:00:00');
        
        // Yesterday
        const yesterday = new Date(currentDate);
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        const yesterdayTour = tourDates.find(td => td.date === yesterdayStr);
        
        const yesterdayDateEl = document.getElementById('tourYesterdayDate');
        const yesterdayVenueEl = document.getElementById('tourYesterdayVenue');
        if(yesterdayDateEl) yesterdayDateEl.textContent = yesterday.toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'});
        if(yesterdayVenueEl) yesterdayVenueEl.textContent = yesterdayTour ? (yesterdayTour.venue || 'No venue') : 'No event';
        
        yesterdayDiv.onclick = () => {
          if(yesterdayTour){
            // Save current before switching
            if(selectedTourDateId && selectedTourDateId !== yesterdayTour.id){
              saveCurrentDateData();
            }
            selectTourDate(yesterdayTour, false);
            gig.date = yesterdayStr;
            renderTourPreviews(yesterdayTour);
          }
        };
        
        // Tomorrow
        const tomorrow = new Date(currentDate);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const tomorrowStr = tomorrow.toISOString().split('T')[0];
        const tomorrowTour = tourDates.find(td => td.date === tomorrowStr);
        
        const tomorrowDateEl = document.getElementById('tourTomorrowDate');
        const tomorrowVenueEl = document.getElementById('tourTomorrowVenue');
        if(tomorrowDateEl) tomorrowDateEl.textContent = tomorrow.toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'});
        if(tomorrowVenueEl) tomorrowVenueEl.textContent = tomorrowTour ? (tomorrowTour.venue || 'No venue') : 'No event';
        
        tomorrowDiv.onclick = () => {
          if(tomorrowTour){
            // Save current before switching
            if(selectedTourDateId && selectedTourDateId !== tomorrowTour.id){
              saveCurrentDateData();
            }
            selectTourDate(tomorrowTour, false);
            gig.date = tomorrowStr;
            renderTourPreviews(tomorrowTour);
          }
        };
      }
      
      // Mark form inputs as dirty on change and update map with delay
      let mapLoadTimer = null;
      let autoSaveTimer = null;
      [tourVenueInput, tourAddressInput, tourLoadInInput, tourShowTimeInput, tourBandInput].forEach(input => {
        if(input){
          input.addEventListener('input', () => {
            currentDateDirty = true;
            
            // Auto-save after 1 second of inactivity
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
              if(selectedTourDateId && typeof saveTourDateData === 'function'){
                saveTourDateData();
              }
            }, 1000);
            
            // Don't auto-load maps; user must click to load to avoid extra API calls
          });
        }
      });
      
      // Map loading function using OpenStreetMap for better search results
      let lastLoadedMapAddress = '';
      function loadMap(address, {force=false} = {}){
        const mapContainer = document.getElementById('tourMapPlaceholder');
        if(!mapContainer || !address) return;
        const normalized = address.trim().toLowerCase();
        const alreadyLoaded = mapContainer.dataset.mapLoaded === 'true' && mapContainer.dataset.mapAddress === normalized;
        if(alreadyLoaded && !force) return; // Keep current map until user forces reload
        mapContainer.dataset.mapAddress = normalized;
        
        // Show loading state
        mapContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#64748b;font-size:12px">Loading map...</div>';
        mapContainer.dataset.mapLoaded = 'pending';

        // Check if viewing today's gig
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        const now = new Date();
        const isToday = tourDate && tourDate.date === now.toISOString().split('T')[0];
        
        // Use OpenStreetMap Nominatim to search for address (includes AirBnB, rehearsal spaces, hideouts)
        const encodedAddress = encodeURIComponent(address);
        
        const setMap = (src, badge='') => {
          mapContainer.innerHTML = `<iframe width="100%" height="100%" style="border:0;border-radius:4px" loading="lazy" src="${src}"></iframe>${badge}`;
          mapContainer.dataset.mapLoaded = 'true';
          lastLoadedMapAddress = normalized;
        };
        const gm = (q)=>`https://www.google.com/maps/embed/v1/place?key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&q=${q}`;
        const gmTraffic = `${gm(encodedAddress)}&zoom=14&maptype=roadmap`;
        fetch(`https://nominatim.openstreetmap.org/search?q=${encodedAddress}&format=json&limit=1&addressdetails=1`)
          .then(res => res.json())
          .then(data => {
            if(data && data.length > 0){
              const { lat, lon } = data[0];
              if(isToday){
                setMap(gmTraffic, '<div style="position:absolute;top:4px;right:4px;background:#dc2626;color:white;padding:2px 6px;border-radius:3px;font-size:9px;font-weight:600;pointer-events:none">LIVE TRAFFIC</div>');
              } else {
                setMap(`https://www.openstreetmap.org/export/embed.html?bbox=${parseFloat(lon)-0.01},${parseFloat(lat)-0.01},${parseFloat(lon)+0.01},${parseFloat(lat)+0.01}&layer=mapnik&marker=${lat},${lon}`);
              }
            } else {
              setMap(gm(encodedAddress));
            }
          })
          .catch(err => {
            console.error('Map loading error:', err);
            setMap(gm(encodedAddress));
          });
      }

      // Manual map loader: click-to-load, optional force reload
      function requestMapLoad(force=false){
        const mapContainer = document.getElementById('tourMapPlaceholder');
        const currentTour = tourDates.find(td => td.id === selectedTourDateId);
        const address = (tourAddressInput?.value || currentTour?.address || gig.address || '').trim();
        if(!mapContainer) return;
        if(!address){
          mapContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#64748b;font-size:12px">Add an address to load a map</div>';
          return;
        }
        loadMap(address, {force});
      }
      if(tourMapPlaceholder){
        tourMapPlaceholder.addEventListener('click', ()=> requestMapLoad());
      }
      
      // Save current tour date data (make globally accessible)
      saveTourDateData = function(){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        tourDate.venue = tourVenueInput?.value || '';
        tourDate.address = tourAddressInput?.value || '';
        tourDate.loadIn = tourLoadInInput?.value || '';
        tourDate.showTime = tourShowTimeInput?.value || '';
        tourDate.band = tourBandInput?.value || '';
        tourDate.setlistType = tourSetlistSelect?.value || 'current';
        tourDate.stagePlotType = tourStagePlotSelect?.value || 'current';
        tourDate.gearSummary = gearSummary;
        tourDate.techNotes = techNotes;
        
        // Sync times to itinerary
        syncTimesToItinerary(tourDate);
        
        // Also update gig object to maintain consistency (including band!)
        gig.venue = tourDate.venue;
        gig.address = tourDate.address;
        gig.band = tourDate.band;
        
        // Sync band name to sheet header if visible
        const sheetBandEl = document.querySelector('.header .band');
        if(sheetBandEl && gig.band) {
          sheetBandEl.textContent = gig.band;
        }
        
        // Update Act display in header
        if(typeof updateActDisplay === 'function') updateActDisplay();
        
        saveAll();
      };
      window.saveTourDateData = saveTourDateData;
      
      // Reload calendar data (map, stage, setlist) when tab is opened (make globally accessible)
      window.reloadCalendarData = function(){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        // Refresh stage and setlist previews (force reload from global data)
        renderTourPreviews(tourDate);
      };
      
      // Track setlist modifications
      const originalAddToSet = window.addToSet;
      if(originalAddToSet){
        window.addToSet = function(){
          currentDateDirty = true;
          return originalAddToSet.apply(this, arguments);
        };
      }
      
      // Render itinerary as 24-hour timeline (5am to 5am next day) with 15-minute slots
      function renderItinerary(tourDate){
        if(!tourItineraryTimeline) return;
        tourItineraryTimeline.innerHTML = '';
        
        // Create 24-hour grid (5am to 5am next day = 96 slots √ó 15min = 24h)
        const gridContainer = document.createElement('div');
        gridContainer.style.cssText = 'display:grid;grid-template-columns:50px 1fr;gap:0;position:relative';
        
        // 5am to 5am next day (24 hours)
        const startHour = 5;
        const endHour = 29; // 5am next day = hour 29
        
        // Generate time slots for 24-hour window (5am to 5am)
        for(let h = startHour; h < endHour; h++){
          for(let m = 0; m < 60; m += 15){
            const displayHour = h >= 24 ? h - 24 : h;
            const timeStr = `${String(displayHour).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
            const slotIdx = (h - startHour) * 4 + m / 15;
            
            // Time label (every hour)
            const labelEl = document.createElement('div');
            labelEl.style.cssText = `
              grid-column:1;
              grid-row:${slotIdx + 1};
              font-size:10px;
              color:${m === 0 ? '#374151' : '#9ca3af'};
              font-weight:${m === 0 ? '600' : '400'};
              padding:2px 4px;
              text-align:right;
              border-right:1px solid #e5e7eb;
              background:${m === 0 ? '#f9fafb' : 'transparent'};
            `;
            labelEl.textContent = m === 0 ? timeStr : '';
            
            // Check if this is the current time slot (for highlighting)
            const now = new Date();
            const isToday = tourDate && tourDate.date === now.toISOString().split('T')[0];
            const currentHourNow = now.getHours();
            const currentMinNow = now.getMinutes();
            const isCurrentSlot = isToday && h === currentHourNow && m <= currentMinNow && (m + 15) > currentMinNow;
            
            // Time slot (drop zone)
            const slotEl = document.createElement('div');
            slotEl.className = 'timeline-slot';
            slotEl.dataset.time = timeStr;
            slotEl.style.cssText = `
              grid-column:2;
              grid-row:${slotIdx + 1};
              min-height:20px;
              border-bottom:1px solid ${m === 0 ? '#d1d5db' : '#f3f4f6'};
              background:${isCurrentSlot ? '#fef3c7' : 'white'};
              position:relative;
              cursor:pointer;
              ${isCurrentSlot ? 'box-shadow: inset 0 0 0 2px #fbbf24;' : ''}
            `;
            
            // Drop handlers for place chips and existing item reordering
            // (Activity chip drops now handled by unified drag-stretch system)
            slotEl.addEventListener('dragover', (e) => {
              e.preventDefault();
              slotEl.style.background = '#eff6ff';
            });
            slotEl.addEventListener('dragleave', () => {
              slotEl.style.background = 'white';
            });
            slotEl.addEventListener('drop', (e) => {
              e.preventDefault();
              slotEl.style.background = 'white';
              
              const draggedIdx = e.dataTransfer.getData('itemIndex');
              const jsonData = e.dataTransfer.getData('application/json');
              
              if(jsonData){
                // Place chip dropped (hotel, restaurant, etc.) - 30 min default
                try {
                  const chipData = JSON.parse(jsonData);
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: chipData.name,
                    duration: 30, // 30 minutes default
                    notes: '',
                    chipData: chipData
                  });
                  
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                } catch(err) {
                  console.error('Error parsing place chip data:', err);
                }
              } else if(draggedIdx !== ''){
                // Existing item dragged to new time
                const idx = parseInt(draggedIdx);
                if(tourDate.itinerary[idx]){
                  tourDate.itinerary[idx].time = timeStr;
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                }
              }
            });
            
            // Click/tap empty slot to add note/item directly (inline editing)
            function openSlotEditor(){
              // Create inline input for quick note entry
              const input = document.createElement('input');
              input.type = 'text';
              input.placeholder = 'Type note or event...';
              input.style.cssText = 'width:100%;padding:8px;border:2px solid #3b82f6;border-radius:4px;font-size:16px;box-sizing:border-box;touch-action:manipulation';
              
              slotEl.innerHTML = '';
              slotEl.appendChild(input);
              input.focus();
              
              const saveNote = () => {
                const text = input.value.trim();
                if(text){
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: text,
                    duration: 30,
                    notes: ''
                  });
                  saveAll();
                }
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveNote);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveNote();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            slotEl.addEventListener('click', openSlotEditor);
            
            // Touch tap support for slots
            let slotTapTime = 0;
            slotEl.addEventListener('touchend', (e) => {
              // Only trigger if it wasn't a drag
              if(!e.target.closest('.touch-drop-target') && (Date.now() - slotTapTime) < 300){
                e.preventDefault();
                openSlotEditor();
              }
            });
            slotEl.addEventListener('touchstart', () => {
              slotTapTime = Date.now();
            }, {passive: true});
            
            gridContainer.appendChild(labelEl);
            gridContainer.appendChild(slotEl);
          }
        }
        
        // Overlay itinerary items on timeline
        if(tourDate.itinerary && tourDate.itinerary.length > 0){
          tourDate.itinerary.forEach((item, idx) => {
            const itemTime = item.time || '00:00';
            let [h, m] = itemTime.split(':').map(Number);
            
            // Adjust for 5am start (if hour < 5, it's next day)
            if(h < 5) h += 24;
            
            // Only show items within the 24-hour window (5am to 5am)
            if(h < startHour || h >= endHour) return;
            
            const slotIdx = (h - startHour) * 4 + Math.floor(m / 15);
            const duration = item.duration || 30;
            const numSlots = Math.ceil(duration / 15);
            
            const borderColor = item.chipData?.color || '#3b82f6';
            
            const itemEl = document.createElement('div');
            itemEl.className = 'itinerary-item';
            itemEl.dataset.idx = idx;
            itemEl.draggable = true;
            itemEl.style.cssText = `
              grid-column:2;
              grid-row:${slotIdx + 1} / span ${numSlots};
              border:2px solid ${borderColor};
              border-radius:6px;
              padding:6px;
              background:linear-gradient(to bottom, ${borderColor}15, ${borderColor}05);
              margin:2px;
              cursor:move;
              position:relative;
              z-index:10;
              box-shadow:0 1px 3px rgba(0,0,0,0.1);
              transition:all 0.2s;
              touch-action:none;
            `;
            
            // Drag handlers for moving items (mouse)
            itemEl.addEventListener('dragstart', (e) => {
              e.dataTransfer.setData('itemIndex', idx.toString());
              e.dataTransfer.effectAllowed = 'move';
              itemEl.style.opacity = '0.5';
            });
            
            itemEl.addEventListener('dragend', (e) => {
              itemEl.style.opacity = '1';
            });
            
            // UNIFIED Touch system for itinerary items
            // - Touch TOP edge: adjust start time (and duration)
            // - Touch BOTTOM edge: adjust end time (duration only)
            // - Touch MIDDLE: move entire event to new time (keep duration)
            const itemIdx = idx;
            let itemTouchState = null;
            
            itemEl.addEventListener('touchstart', (e) => {
              // Don't interfere with delete button
              if(e.target.closest('.itinerary-delete')) return;
              
              e.preventDefault();
              const touch = e.touches[0];
              const rect = itemEl.getBoundingClientRect();
              const touchYInItem = touch.clientY - rect.top;
              const itemHeight = rect.height;
              
              // Determine zone: top 25%, middle 50%, bottom 25%
              let zone = 'middle';
              if(touchYInItem < itemHeight * 0.25) zone = 'top';
              else if(touchYInItem > itemHeight * 0.75) zone = 'bottom';
              
              const [startH, startM] = (item.time || '00:00').split(':').map(Number);
              
              itemTouchState = {
                zone,
                startY: touch.clientY,
                startX: touch.clientX,
                originalTime: item.time,
                originalDuration: item.duration || 30,
                originalStartMinutes: startH * 60 + startM,
                isDragging: false
              };
              
              // Visual feedback based on zone
              if(zone === 'top'){
                itemEl.style.boxShadow = '0 -4px 0 0 #22c55e, 0 4px 8px rgba(0,0,0,0.2)';
              } else if(zone === 'bottom'){
                itemEl.style.boxShadow = '0 4px 0 0 #22c55e, 0 4px 8px rgba(0,0,0,0.2)';
              } else {
                itemEl.style.boxShadow = '0 0 0 3px #3b82f6, 0 4px 8px rgba(0,0,0,0.2)';
              }
              itemEl.style.opacity = '0.8';
              itemEl.style.zIndex = '100';
            }, {passive: false});
            
            itemEl.addEventListener('touchmove', (e) => {
              if(!itemTouchState) return;
              e.preventDefault();
              const touch = e.touches[0];
              const deltaY = touch.clientY - itemTouchState.startY;
              
              // Mark as dragging once moved significantly
              if(Math.abs(deltaY) > 5) itemTouchState.isDragging = true;
              if(!itemTouchState.isDragging) return;
              
              const pixelsPerSlot = 20; // ~20px per 15-min slot
              const deltaSlots = Math.round(deltaY / pixelsPerSlot);
              const deltaMinutes = deltaSlots * 15;
              
              if(itemTouchState.zone === 'top'){
                // Adjust start time: move start, adjust duration inversely
                const newStartMinutes = itemTouchState.originalStartMinutes + deltaMinutes;
                const newDuration = Math.max(15, itemTouchState.originalDuration - deltaMinutes);
                const newH = Math.floor(Math.max(0, newStartMinutes) / 60) % 24;
                const newM = Math.max(0, newStartMinutes) % 60;
                
                // Live preview
                const titleEl = itemEl.querySelector('.item-title');
                if(titleEl){
                  const newTimeStr = `${String(newH).padStart(2,'0')}:${String(newM).padStart(2,'0')}`;
                  titleEl.textContent = `${newTimeStr} - ${item.title} (${newDuration}m)`;
                }
                
                // Update grid visual
                let adjH = newH < 5 ? newH + 24 : newH;
                const newSlotIdx = (adjH - 5) * 4 + Math.floor(newM / 15);
                const newNumSlots = Math.ceil(newDuration / 15);
                itemEl.style.gridRow = `${newSlotIdx + 1} / span ${newNumSlots}`;
                
              } else if(itemTouchState.zone === 'bottom'){
                // Adjust end time: keep start, change duration
                const newDuration = Math.max(15, itemTouchState.originalDuration + deltaMinutes);
                
                // Live preview
                const titleEl = itemEl.querySelector('.item-title');
                if(titleEl){
                  titleEl.textContent = `${item.time} - ${item.title} (${newDuration}m)`;
                }
                
                // Update grid visual
                const newNumSlots = Math.ceil(newDuration / 15);
                itemEl.style.gridRow = `${slotIdx + 1} / span ${newNumSlots}`;
                
              } else {
                // Move entire event: highlight target slots
                document.querySelectorAll('.timeline-slot').forEach(slot => {
                  const rect = slot.getBoundingClientRect();
                  if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                     touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                    slot.classList.add('touch-drop-target');
                  } else {
                    slot.classList.remove('touch-drop-target');
                  }
                });
                itemEl.style.opacity = '0.4';
              }
            }, {passive: false});
            
            itemEl.addEventListener('touchend', (e) => {
              if(!itemTouchState) return;
              const touch = e.changedTouches[0];
              const deltaY = touch.clientY - itemTouchState.startY;
              const pixelsPerSlot = 20;
              const deltaSlots = Math.round(deltaY / pixelsPerSlot);
              const deltaMinutes = deltaSlots * 15;
              
              if(itemTouchState.isDragging){
                if(itemTouchState.zone === 'top'){
                  // Save new start time and duration
                  const newStartMinutes = itemTouchState.originalStartMinutes + deltaMinutes;
                  const newDuration = Math.max(15, itemTouchState.originalDuration - deltaMinutes);
                  const newH = Math.floor(Math.max(0, newStartMinutes) / 60) % 24;
                  const newM = Math.max(0, newStartMinutes) % 60;
                  
                  tourDate.itinerary[itemIdx].time = `${String(newH).padStart(2,'0')}:${String(newM).padStart(2,'0')}`;
                  tourDate.itinerary[itemIdx].duration = newDuration;
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                  
                } else if(itemTouchState.zone === 'bottom'){
                  // Save new duration
                  const newDuration = Math.max(15, itemTouchState.originalDuration + deltaMinutes);
                  tourDate.itinerary[itemIdx].duration = newDuration;
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                  
                } else {
                  // Move: find drop target
                  let dropSlot = null;
                  document.querySelectorAll('.timeline-slot').forEach(slot => {
                    const rect = slot.getBoundingClientRect();
                    if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                       touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                      dropSlot = slot;
                    }
                  });
                  
                  if(dropSlot){
                    tourDate.itinerary[itemIdx].time = dropSlot.dataset.time;
                    // Keep same duration
                    saveAll();
                    renderItinerary(tourDate);
                    renderDateHeader();
                  }
                }
              }
              
              // Cleanup
              itemEl.style.opacity = '1';
              itemEl.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
              itemEl.style.zIndex = '10';
              document.querySelectorAll('.timeline-slot').forEach(slot => {
                slot.classList.remove('touch-drop-target');
              });
              itemTouchState = null;
            });
            
            // Resize handles
            const topHandle = document.createElement('div');
            topHandle.className = 'resize-handle-top';
            topHandle.style.cssText = 'position:absolute;top:0;left:0;right:0;height:6px;cursor:ns-resize;background:rgba(0,0,0,0.1);opacity:0;transition:opacity 0.2s';
            
            const bottomHandle = document.createElement('div');
            bottomHandle.className = 'resize-handle-bottom';
            bottomHandle.style.cssText = 'position:absolute;bottom:0;left:0;right:0;height:6px;cursor:ns-resize;background:rgba(0,0,0,0.1);opacity:0;transition:opacity 0.2s';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'item-content';
            contentDiv.style.cssText = 'height:100%;overflow:hidden;padding:2px';
            contentDiv.innerHTML = `
              <div style="display:flex;align-items:center;gap:4px;margin-bottom:2px">
                <div class="item-title" style="font-weight:600;font-size:11px;color:#111827;flex:1">${itemTime} - ${item.title}</div>
                <button class="itinerary-delete" style="padding:2px 6px;font-size:10px;background:#ef4444;color:white;border:none;border-radius:3px;cursor:pointer">√ó</button>
              </div>
              ${item.chipData?.address ? `<div style="font-size:10px;color:#64748b">${item.chipData.address}</div>` : ''}
              <div class="item-notes" style="font-size:10px;color:#64748b;margin-top:2px;min-height:14px;cursor:text">${item.notes || ''}</div>
            `;
            
            itemEl.appendChild(topHandle);
            itemEl.appendChild(contentDiv);
            itemEl.appendChild(bottomHandle);
            
            // Show resize handles on hover/touch
            function showHandles(){
              itemEl.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
              itemEl.style.zIndex = '20';
              topHandle.style.opacity = '1';
              bottomHandle.style.opacity = '1';
            }
            function hideHandles(){
              itemEl.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
              itemEl.style.zIndex = '10';
              topHandle.style.opacity = '0';
              bottomHandle.style.opacity = '0';
            }
            itemEl.addEventListener('mouseenter', showHandles);
            itemEl.addEventListener('mouseleave', hideHandles);
            
            // Resize from top handle (MOUSE ONLY - touch handled by unified system)
            let resizing = false;
            topHandle.addEventListener('mousedown', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const startY = e.clientY;
              const startDuration = item.duration || 30;
              const startTime = item.time;
              const [startH, startM] = startTime.split(':').map(Number);
              
              const onMouseMove = (e2) => {
                if(!resizing) return;
                const deltaY = e2.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20); // ~20px per slot
                const deltaMinutes = deltaSlots * 15;
                
                // When dragging top DOWN (positive deltaY): start time moves forward, duration decreases
                // When dragging top UP (negative deltaY): start time moves backward, duration increases
                const newStartMinutes = (startH * 60 + startM) + deltaMinutes;
                const newDuration = Math.max(15, startDuration - deltaMinutes);
                const newH = Math.floor(newStartMinutes / 60);
                const newM = newStartMinutes % 60;
                
                item.time = `${String(newH).padStart(2,'0')}:${String(Math.max(0, newM)).padStart(2,'0')}`;
                item.duration = newDuration;
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onMouseUp = () => {
                resizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
              };
              
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            });
            
            // Resize from bottom handle (MOUSE ONLY - touch handled by unified system)
            bottomHandle.addEventListener('mousedown', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const startY = e.clientY;
              const startDuration = item.duration || 30;
              
              const onMouseMove = (e2) => {
                if(!resizing) return;
                const deltaY = e2.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20); // ~20px per slot
                const deltaMinutes = deltaSlots * 15;
                
                item.duration = Math.max(15, startDuration + deltaMinutes);
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onMouseUp = () => {
                resizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
              };
              
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            });
            
            // Double-click/double-tap title to edit
            const titleEl = contentDiv.querySelector('.item-title');
            let titleLastTap = 0;
            
            function editTitle(){
              const currentText = item.title;
              titleEl.innerHTML = `<input type="text" value="${currentText}" style="width:100%;padding:4px;border:1px solid #3b82f6;border-radius:3px;font-size:14px;font-weight:600;touch-action:manipulation" />`;
              const input = titleEl.querySelector('input');
              input.focus();
              input.select();
              
              const saveEdit = () => {
                item.title = input.value.trim() || currentText;
                saveAll();
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveEdit);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveEdit();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            titleEl.addEventListener('dblclick', (e) => {
              e.stopPropagation();
              editTitle();
            });
            
            titleEl.addEventListener('touchend', (e) => {
              const now = Date.now();
              if(now - titleLastTap < 400){
                e.preventDefault();
                e.stopPropagation();
                editTitle();
              }
              titleLastTap = now;
            });
            
            // Double-click/double-tap notes area to edit
            const notesEl = contentDiv.querySelector('.item-notes');
            let notesLastTap = 0;
            
            function editNotes(){
              const currentNotes = item.notes || '';
              notesEl.innerHTML = `<input type="text" placeholder="Add notes..." value="${currentNotes}" style="width:100%;padding:4px;border:1px solid #3b82f6;border-radius:3px;font-size:14px;box-sizing:border-box;touch-action:manipulation" />`;
              const input = notesEl.querySelector('input');
              input.focus();
              input.select();
              
              const saveNotes = () => {
                item.notes = input.value.trim();
                saveAll();
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveNotes);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveNotes();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            notesEl.addEventListener('dblclick', (e) => {
              e.stopPropagation();
              editNotes();
            });
            
            notesEl.addEventListener('touchend', (e) => {
              const now = Date.now();
              if(now - notesLastTap < 400){
                e.preventDefault();
                e.stopPropagation();
                editNotes();
              }
              notesLastTap = now;
            });
            
            // Delete handler (click + touch)
            const deleteBtn = contentDiv.querySelector('.itinerary-delete');
            function handleDelete(e){
              e.stopPropagation();
              e.preventDefault();
              if(confirm('Delete this itinerary item?')){
                tourDate.itinerary.splice(idx, 1);
                saveAll();
                renderItinerary(tourDate);
                renderDateHeader();
              }
            }
            deleteBtn.addEventListener('click', handleDelete);
            deleteBtn.addEventListener('touchend', handleDelete);
            
            gridContainer.appendChild(itemEl);
          });
        }
        
        tourItineraryTimeline.appendChild(gridContainer);
      }
      
      // Show itinerary item details modal
      function showItineraryDetails(tourDate, idx){
        const item = tourDate.itinerary[idx];
        if(!item) return;
        
        const modal = document.createElement('div');
        modal.className = 'modal open';
        modal.innerHTML = `
          <div class="modalbox" style="max-width:500px;width:90%">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
              <h3 style="margin:0">${item.title || 'Itinerary Item'}</h3>
              <button class="close-modal" style="border:none;background:none;font-size:24px;cursor:pointer;color:#64748b">√ó</button>
            </div>
            
            <div style="display:flex;flex-direction:column;gap:12px">
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Time (30-min increments)</label>
                <input type="text" value="${item.time||''}" class="modal-time" placeholder="e.g., 2:30pm, 14:30, 230" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px" />
                <button class="btn modal-time-helper" style="margin-top:4px;padding:4px 8px;font-size:11px">Change Time</button>
              </div>
              
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Title</label>
                <input type="text" value="${item.title||''}" class="modal-title" placeholder="Event title" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px" />
              </div>
              
              ${item.chipData ? `
                <div style="padding:12px;background:#f9fafb;border-radius:6px;border-left:3px solid ${item.chipData.color || '#3b82f6'}">
                  <div style="font-weight:600;margin-bottom:4px">${item.chipData.name}</div>
                  <div style="font-size:12px;color:#64748b">${item.chipData.address || ''}</div>
                  ${item.chipData.phone ? `<div style="font-size:12px;color:#0ea5e9;margin-top:4px">üìû ${item.chipData.phone}</div>` : ''}
                  ${item.chipData.website ? `<a href="${item.chipData.website}" target="_blank" style="font-size:12px;color:#3b82f6;margin-top:4px;display:inline-block">üåê Website</a>` : ''}
                </div>
              ` : ''}
              
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Notes</label>
                <textarea class="modal-notes" placeholder="Additional notes, directions, contact info..." style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px;min-height:80px;resize:vertical">${item.notes||''}</textarea>
              </div>
              
              <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn primary save-modal" style="flex:1">Save Changes</button>
                <button class="btn cancel-modal" style="flex:1">Cancel</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Close handlers
        modal.querySelector('.close-modal').addEventListener('click', () => modal.remove());
        modal.querySelector('.cancel-modal').addEventListener('click', () => modal.remove());
        modal.addEventListener('click', (e) => {
          if(e.target === modal) modal.remove();
        });
        
        // Time helper button
        modal.querySelector('.modal-time-helper').addEventListener('click', (e) => {
          e.preventDefault();
          const currentTime = modal.querySelector('.modal-time').value;
          const newTime = promptForTime(currentTime);
          if(newTime){
            modal.querySelector('.modal-time').value = newTime;
          }
        });
        
        // Save handler
        modal.querySelector('.save-modal').addEventListener('click', () => {
          item.time = modal.querySelector('.modal-time').value;
          item.title = modal.querySelector('.modal-title').value;
          item.notes = modal.querySelector('.modal-notes').value;
          saveAll();
          renderItinerary(tourDate);
          renderDateHeader();
          modal.remove();
        });
      }
      
      // Timeline drop handlers are now in renderItinerary() function
      // Each time slot handles its own drops without prompting for time
      
      // View mode change
      if(tourViewModeSelect){
        tourViewModeSelect.addEventListener('change', () => {
          tourViewMode = tourViewModeSelect.value;
          renderTimeline();
        });
      }
      
      // Navigation
      if(tourTodayBtn){
        tourTodayBtn.addEventListener('click', () => {
          const today = new Date();
          const todayStr = today.toISOString().split('T')[0];
          let todayTour = tourDates.find(td => td.date === todayStr);
          if(!todayTour){
            // Create a new empty date for today
            todayTour = {
              id: generateId(),
              date: todayStr,
              venue: '',
              address: '',
              loadIn: '',
              showTime: '',
              band: gig.band || '',
              setlistType: 'current',
              stagePlotType: 'current',
              itinerary: [],
              interests: []
            };
            tourDates.push(todayTour);
          }
          if(typeof saveTourDateData === 'function') saveTourDateData();
          selectTourDate(todayTour, false);
          saveAll();
        });
      }
      
      // Yesterday/Tomorrow button handlers with long-press for week jumps
      const tourYesterdayBtn = document.getElementById('tourYesterdayBtn');
      const tourTomorrowBtn = document.getElementById('tourTomorrowBtn');
      
      let longPressTimer = null;
      let isLongPress = false;
      
      if(tourYesterdayBtn){
        tourYesterdayBtn.addEventListener('mousedown', () => {
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Long press: jump to previous show with any gig/drive/event
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const earlier = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() < currentTime)
                .sort((a,b)=> new Date(b.date).getTime() - new Date(a.date).getTime());
              const target = earlier[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }, 600);
        });
        
        tourYesterdayBtn.addEventListener('mouseup', () => {
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Normal click: previous show (closest earlier tour date)
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const earlier = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() < currentTime)
                .sort((a,b)=> new Date(b.date).getTime() - new Date(a.date).getTime());
              const target = earlier[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }
        });
        
        tourYesterdayBtn.addEventListener('mouseleave', () => {
          clearTimeout(longPressTimer);
        });
        
        // Touch support
        tourYesterdayBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const earlier = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() < currentTime)
                .sort((a,b)=> new Date(b.date).getTime() - new Date(a.date).getTime());
              const target = earlier[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }, 600);
        });
        
        tourYesterdayBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const earlier = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() < currentTime)
                .sort((a,b)=> new Date(b.date).getTime() - new Date(a.date).getTime());
              const target = earlier[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }
        });
      }
      
      if(tourTomorrowBtn){
        tourTomorrowBtn.addEventListener('mousedown', () => {
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Long press: jump to next show with any gig/drive/event
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const later = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() > currentTime)
                .sort((a,b)=> new Date(a.date).getTime() - new Date(b.date).getTime());
              const target = later[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }, 600);
        });
        
        tourTomorrowBtn.addEventListener('mouseup', () => {
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Normal click: next show (closest later tour date)
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const later = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() > currentTime)
                .sort((a,b)=> new Date(a.date).getTime() - new Date(b.date).getTime());
              const target = later[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }
        });
        
        tourTomorrowBtn.addEventListener('mouseleave', () => {
          clearTimeout(longPressTimer);
        });
        
        // Touch support
        tourTomorrowBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const later = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() > currentTime)
                .sort((a,b)=> new Date(a.date).getTime() - new Date(b.date).getTime());
              const target = later[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }, 600);
        });
        
        tourTomorrowBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentTime = new Date(currentTourDate.date + 'T12:00:00').getTime();
              const later = tourDates
                .filter(td => new Date(td.date + 'T12:00:00').getTime() > currentTime)
                .sort((a,b)=> new Date(a.date).getTime() - new Date(b.date).getTime());
              const target = later[0];
              if(target){
                selectTourDate(target, false);
                saveAll();
              }
            }
          }
        });
      }
      
      if(tourPrevBtn){
        tourPrevBtn.addEventListener('click', () => {
          if(tourViewMode === 'week'){
            tourViewDate.setDate(tourViewDate.getDate() - 7);
          } else if(tourViewMode === 'month'){
            tourViewDate.setMonth(tourViewDate.getMonth() - 1);
          } else if(tourViewMode === 'year'){
            tourViewDate.setFullYear(tourViewDate.getFullYear() - 1);
          }
          renderTimeline();
        });
      }
      
      if(tourNextBtn){
        tourNextBtn.addEventListener('click', () => {
          if(tourViewMode === 'week'){
            tourViewDate.setDate(tourViewDate.getDate() + 7);
          } else if(tourViewMode === 'month'){
            tourViewDate.setMonth(tourViewDate.getMonth() + 1);
          } else if(tourViewMode === 'year'){
            tourViewDate.setFullYear(tourViewDate.getFullYear() + 1);
          }
          renderTimeline();
        });
      }
      
      // Add new date logic now lives on Today button
      
      // Save date changes
      if(tourSaveDateBtn){
        tourSaveDateBtn.addEventListener('click', () => {
          saveTourDateData();
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(!tourDate) return;
          
          tourDate.date = tourDateInput?.value || tourDate.date;
          tourDate.venue = tourVenueInput?.value || '';
          tourDate.address = tourAddressInput?.value || '';
          tourDate.loadIn = tourLoadInInput?.value || '';
          tourDate.showTime = tourShowTimeInput?.value || '';
          tourDate.band = tourBandInput?.value || '';
          tourDate.setlistType = tourSetlistSelect?.value || 'current';
          tourDate.stagePlotType = tourStagePlotSelect?.value || 'current';
          
          saveAll();
          renderTimeline();
          renderDateHeader();
          alert('Date saved!');
        });
      }
      
      // Delete date
      if(tourDeleteDateBtn){
        tourDeleteDateBtn.addEventListener('click', () => {
          if(!confirm('Delete this tour date and all its details?')) return;
          const idx = tourDates.findIndex(td => td.id === selectedTourDateId);
          if(idx !== -1){
            tourDates.splice(idx, 1);
            selectedTourDateId = null;
            selectTourDate(null);
            saveAll();
            renderTimeline();
            renderDateHeader();
          }
        });
      }
      
      // Lock Calendar checkbox
      const tourLockCalendar = document.getElementById('tourLockCalendar');
      if(tourLockCalendar){
        tourLockCalendar.addEventListener('change', () => {
          const isLocked = tourLockCalendar.checked;
          // Disable all form inputs when locked
          [tourDateInput, tourVenueInput, tourAddressInput, tourLoadInInput, tourShowTimeInput, tourBandInput, tourSetlistSelect, tourStagePlotSelect].forEach(input => {
            if(input) input.disabled = isLocked;
          });
          if(tourSaveDateBtn) tourSaveDateBtn.disabled = isLocked;
          if(tourDeleteDateBtn) tourDeleteDateBtn.disabled = isLocked;
          if(tourAddItineraryItem) tourAddItineraryItem.disabled = isLocked;
        });
      }
      
      // Clear Calendar button
      const tourClearCalendar = document.getElementById('tourClearCalendar');
      if(tourClearCalendar){
        tourClearCalendar.addEventListener('click', () => {
          if(!confirm('Clear ALL tour dates from calendar?\n\nThis will delete all tour dates and their data. You should save a .BAND file first!\n\nProceed?')) return;
          
          // Offer to save first
          if(confirm('Would you like to save a .BAND file before clearing?')){
            // Trigger save profile
            const saveProfileBtn = document.getElementById('saveProfile');
            if(saveProfileBtn) saveProfileBtn.click();
            
            // Wait a moment for save dialog
            setTimeout(() => {
              if(confirm('Ready to clear calendar now?')){
                tourDates = [];
                selectedTourDateId = null;
                selectTourDate(null);
                saveAll();
                renderTimeline();
                renderDateHeader();
                alert('Calendar cleared!');
              }
            }, 500);
          } else {
            // Clear without saving
            tourDates = [];
            selectedTourDateId = null;
            selectTourDate(null);
            saveAll();
            renderTimeline();
            renderDateHeader();
            alert('Calendar cleared!');
          }
        });
      }
      
      // Add itinerary item
      if(tourAddItineraryBtn){
        tourAddItineraryBtn.addEventListener('click', () => {
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(!tourDate) return;
          
          if(!tourDate.itinerary) tourDate.itinerary = [];
          tourDate.itinerary.push({
            time: '',
            title: '',
            notes: ''
          });
          
          saveAll();
          renderItinerary(tourDate);
          renderDateHeader();
        });
      }
      
      // Custom search button handler
      if (tourCustomSearchBtn) {
        tourCustomSearchBtn.addEventListener('click', () => {
          const searchTerm = tourCustomSearchInput?.value?.trim();
          if (!searchTerm) {
            alert('Please enter a search term');
            return;
          }
          
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
      }
      
      // Allow Enter key in custom search
      if (tourCustomSearchInput) {
        tourCustomSearchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            tourCustomSearchBtn?.click();
          }
        });
      }
      
      // ========================================================================
      // SEARCH POPUP & DRAGGABLE CHIPS SYSTEM
      // ========================================================================
      
      const searchResults = document.getElementById('tourSearchResults');
      const interestsDropZone = document.getElementById('tourInterestsDropZone');
      const interestsPlaceholder = document.getElementById('tourInterestsPlaceholder');
      const clearInterestsBtn = document.getElementById('tourClearInterests');
      
      // Chip factory: creates draggable chips with full business info
      function createInterestChip(data) {
        const { name, address, phone, url, rating, type, color, distance } = data;
        
        const chip = document.createElement('div');
        chip.className = 'tour-interest-chip';
        chip.draggable = true;
        chip.style.borderLeftColor = color || '#0ea5e9';
        chip.style.borderLeftWidth = '4px';
        chip.style.borderLeftStyle = 'solid';
        
        const ratingStars = rating ? '‚≠ê'.repeat(Math.round(rating)) : '';
        
        // Format distance display
        let distanceText = '';
        if (distance !== null && distance !== undefined) {
          if (distance < 1) {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#dcfce7;color:#166534;border-radius:3px;font-weight:600">${Math.round(distance * 1000)}m away</span>`;
          } else if (distance < 5) {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#fef9c3;color:#854d0e;border-radius:3px;font-weight:600">${distance.toFixed(1)}km away</span>`;
          } else {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#fed7aa;color:#9a3412;border-radius:3px;font-weight:600">${Math.round(distance)}km away</span>`;
          }
        }
        
        chip.innerHTML = `
          <div style="display:flex;flex-direction:column;gap:4px;flex:1;min-width:0">
            <div style="display:flex;align-items:center;gap:6px">
              <div style="font-weight:600;font-size:14px;color:#111827;flex:1">${name}</div>
              ${distanceText}
            </div>
            ${address ? `<div style="font-size:11px;color:#64748b;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${address}</div>` : ''}
            ${phone ? `<div style="font-size:11px;color:#0ea5e9;font-weight:500">üìû ${phone}</div>` : ''}
            ${ratingStars ? `<div style="font-size:11px">${ratingStars} ${rating}</div>` : ''}
          </div>
          <button class="chip-remove" title="Remove">√ó</button>
        `;
        
        // Store data on element
        chip.dataset.chipData = JSON.stringify(data);
        chip.style.touchAction = 'none';
        
        // Drag handlers (mouse/desktop)
        chip.addEventListener('dragstart', (e) => {
          chip.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'copy';
          e.dataTransfer.setData('application/json', chip.dataset.chipData);
          e.dataTransfer.setData('text/plain', name); // Fallback
        });
        
        chip.addEventListener('dragend', () => {
          chip.classList.remove('dragging');
        });
        
        // Touch drag support for place chips
        let touchDragActive = false;
        let touchClone = null;
        let touchStartTime = 0;
        
        chip.addEventListener('touchstart', (e) => {
          // Don't interfere with remove button
          if(e.target.closest('.chip-remove')) return;
          
          touchStartTime = Date.now();
          const touch = e.touches[0];
          
          // Short delay before starting drag to differentiate from tap
          setTimeout(() => {
            if(touchDragActive === 'pending'){
              touchDragActive = true;
              chip.classList.add('dragging');
              
              // Create visual clone
              touchClone = document.createElement('div');
              touchClone.className = 'tour-interest-chip touch-dragging';
              touchClone.style.cssText = `
                position:fixed;
                z-index:99999;
                pointer-events:none;
                opacity:0.9;
                transform:scale(1.05);
                box-shadow:0 8px 24px rgba(0,0,0,0.3);
                padding:8px 12px;
                background:white;
                border-radius:8px;
                border-left:4px solid ${color || '#0ea5e9'};
                max-width:200px;
                left:${touch.clientX - 50}px;
                top:${touch.clientY - 20}px;
              `;
              touchClone.innerHTML = `<div style="font-weight:600;font-size:12px">${name}</div>`;
              document.body.appendChild(touchClone);
              
              chip.style.opacity = '0.3';
            }
          }, 150);
          
          touchDragActive = 'pending';
        }, {passive: true});
        
        chip.addEventListener('touchmove', (e) => {
          if(touchDragActive !== true) return;
          e.preventDefault();
          const touch = e.touches[0];
          
          if(touchClone){
            touchClone.style.left = (touch.clientX - 50) + 'px';
            touchClone.style.top = (touch.clientY - 20) + 'px';
          }
          
          // Highlight timeline drop targets
          document.querySelectorAll('.timeline-slot').forEach(slot => {
            const rect = slot.getBoundingClientRect();
            if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
               touch.clientY >= rect.top && touch.clientY <= rect.bottom){
              slot.classList.add('touch-drop-target');
            } else {
              slot.classList.remove('touch-drop-target');
            }
          });
          
          // Also highlight interests drop zone
          const interestsZone = document.getElementById('tourInterestsDropZone');
          if(interestsZone){
            const rect = interestsZone.getBoundingClientRect();
            if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
               touch.clientY >= rect.top && touch.clientY <= rect.bottom){
              interestsZone.style.background = '#eff6ff';
              interestsZone.style.borderColor = '#3b82f6';
            } else {
              interestsZone.style.background = '';
              interestsZone.style.borderColor = '';
            }
          }
        }, {passive: false});
        
        chip.addEventListener('touchend', (e) => {
          const wasDragging = touchDragActive === true;
          const touch = e.changedTouches[0];
          
          // Cleanup
          if(touchClone){
            touchClone.remove();
            touchClone = null;
          }
          chip.classList.remove('dragging');
          chip.style.opacity = '1';
          document.querySelectorAll('.timeline-slot').forEach(slot => {
            slot.classList.remove('touch-drop-target');
          });
          const interestsZone = document.getElementById('tourInterestsDropZone');
          if(interestsZone){
            interestsZone.style.background = '';
            interestsZone.style.borderColor = '';
          }
          
          if(wasDragging){
            // Find drop target - timeline slot
            let dropSlot = null;
            document.querySelectorAll('.timeline-slot').forEach(slot => {
              const rect = slot.getBoundingClientRect();
              if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                 touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                dropSlot = slot;
              }
            });
            
            if(dropSlot){
              // Add to itinerary
              const timeStr = dropSlot.dataset.time;
              const tourDate = tourDates.find(td => td.id === selectedTourDateId);
              if(tourDate && timeStr){
                try {
                  const chipData = JSON.parse(chip.dataset.chipData);
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: chipData.name,
                    duration: 30,
                    notes: '',
                    chipData: chipData
                  });
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                } catch(err) {
                  console.error('Error adding chip to itinerary:', err);
                }
              }
            } else {
              // Check interests drop zone
              if(interestsZone){
                const rect = interestsZone.getBoundingClientRect();
                if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                   touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                  // Add to interests
                  try {
                    const chipData = JSON.parse(chip.dataset.chipData);
                    const newChip = createInterestChip(chipData);
                    interestsZone.appendChild(newChip);
                    saveInterests();
                    updateInterestsPlaceholder();
                  } catch(err) {
                    console.error('Error adding to interests:', err);
                  }
                }
              }
            }
          } else if(touchDragActive === 'pending' && (Date.now() - touchStartTime) < 300){
            // Was a tap, not a drag - open URL
            if(!e.target.closest('.chip-remove')){
              try {
                const chipData = JSON.parse(chip.dataset.chipData);
                const targetUrl = chipData.website || chipData.url;
                if (targetUrl && targetUrl !== '#' && targetUrl.startsWith('http')) {
                  window.open(targetUrl, '_blank');
                }
              } catch (err) {
                console.error('Error opening chip URL:', err);
              }
            }
          }
          
          touchDragActive = false;
        });
        
        // Click to open URL or remove (mouse)
        chip.addEventListener('click', (e) => {
          if (e.target.closest('.chip-remove')) {
            chip.remove();
            const parentIsDropZone = chip.closest('#tourInterestsDropZone');
            if (parentIsDropZone) {
              saveInterests();
              updateInterestsPlaceholder();
            }
          } else if (!chip.classList.contains('dragging')) {
            // Open website - prefer real website over map URL
            try {
              const chipData = JSON.parse(chip.dataset.chipData);
              const targetUrl = chipData.website || chipData.url;
              console.log('Chip click - website:', chipData.website, 'url:', chipData.url, 'opening:', targetUrl);
              if (targetUrl && targetUrl !== '#' && targetUrl.startsWith('http')) {
                window.open(targetUrl, '_blank');
              }
            } catch (e) {
              console.error('Error opening chip URL:', e);
            }
          }
        });
        
        return chip;
      }
      
      // Load search results inline (no popup)
      function loadSearchInline(searchTerm, addressToUse) {
        const searchResults = document.getElementById('tourSearchResults');
        if (!searchResults) return;
        
        searchResults.innerHTML = '<div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">üîç Searching for ' + searchTerm + '...</div>';
        
        // Fetch real business data from OpenStreetMap
        fetchRealBusinessData(searchTerm, addressToUse).then(results => {
          searchResults.innerHTML = '';
          
          if (results.length === 0) {
            searchResults.innerHTML = '<div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">No results found for "' + searchTerm + '"</div>';
            return;
          }
          
          results.forEach(result => {
            const chip = createInterestChip(result);
            searchResults.appendChild(chip);
          });
        }).catch(error => {
          console.error('Search error:', error);
          const errorMsg = error.message.includes('Rate limit') 
            ? '‚è±Ô∏è Rate limit reached. Please wait 10 seconds and try again.'
            : 'Error loading results. Please try again.';
          searchResults.innerHTML = `<div style="width:100%;text-align:center;color:#dc2626;padding:20px;font-size:13px">${errorMsg}</div>`;
        });
      }
      
      // Fetch REAL business data using Overpass Turbo (OpenStreetMap)
      async function fetchRealBusinessData(searchTerm, address) {
        const colorMap = {
          'hotels': '#9333ea',
          'music stores': '#dc2626',
          'rehearsal studios': '#ea580c',
          'bars': '#ca8a04',
          'restaurants': '#16a34a',
          'cafes': '#0891b2',
          'gas stations': '#2563eb',
          'print shops': '#7c3aed',
          'guitar repair': '#db2777',
          'pharmacies': '#059669'
        };
        
        const color = colorMap[searchTerm.toLowerCase()] || '#0ea5e9';
        
        // Show loading state
        const mapEmbed = document.getElementById('tourMapEmbed');
        if (mapEmbed) {
          mapEmbed.innerHTML = `
            <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#f3f4f6;border-radius:6px">
              <div style="text-align:center;color:#64748b">
                <div class="spinner" style="width:24px;height:24px;border:3px solid #e5e7eb;border-top-color:#667eea;border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 12px"></div>
                <div style="font-size:13px">Searching REAL ${searchTerm} near ${address}...</div>
              </div>
            </div>
            <style>
              @keyframes spin {
                to { transform: rotate(360deg); }
              }
            </style>
          `;
        }
        
        try {
          // Geocode the address first
          const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
          const geoResponse = await fetch(geocodeUrl, {
            headers: { 'User-Agent': 'FASTFAST-Setlist-App' }
          });
          const geoData = await geoResponse.json();
          
          if (!geoData || geoData.length === 0) {
            throw new Error('Location not found');
          }
          
          const lat = parseFloat(geoData[0].lat);
          const lon = parseFloat(geoData[0].lon);
          const country = geoData[0].address?.country_code?.toUpperCase() || '';
          
          console.log(`Location: ${lat}, ${lon} in ${country}`);
          
          // Embed OpenStreetMap instead of Bing for better rendering
          const osmMapUrl = `https://www.openstreetmap.org/export/embed.html?bbox=${lon-0.05},${lat-0.05},${lon+0.05},${lat+0.05}&layer=mapnik&marker=${lat},${lon}`;
          
          if (mapEmbed) {
            mapEmbed.innerHTML = `
              <iframe 
                width="100%" 
                height="100%" 
                frameborder="0" 
                scrolling="no" 
                marginheight="0" 
                marginwidth="0" 
                src="${osmMapUrl}" 
                style="border:none;border-radius:6px">
              </iframe>
            `;
          }
          
          // Search query templates for OSM tags with progressive radius
          const osmQueries = {
            'hotels': '(node["tourism"="hotel"](around:{radius},{lat},{lon});way["tourism"="hotel"](around:{radius},{lat},{lon});node["tourism"="motel"](around:{radius},{lat},{lon});way["tourism"="motel"](around:{radius},{lat},{lon});node["tourism"="hostel"](around:{radius},{lat},{lon});way["tourism"="hostel"](around:{radius},{lat},{lon});)',
            'music stores': '(node["shop"="music"](around:{radius},{lat},{lon});way["shop"="music"](around:{radius},{lat},{lon});node["shop"="musical_instrument"](around:{radius},{lat},{lon});way["shop"="musical_instrument"](around:{radius},{lat},{lon});)',
            'rehearsal studios': '(node["amenity"="studio"](around:{radius},{lat},{lon});way["amenity"="studio"](around:{radius},{lat},{lon});node["amenity"="music_venue"]["rehearsal"="yes"](around:{radius},{lat},{lon});way["amenity"="music_venue"]["rehearsal"="yes"](around:{radius},{lat},{lon});node[~"name"~"[Rr]ehearsal|[Pp]ractice|[Ss]tudio|[Jj]am [Ss]pace|[Ll]ockup|[Mm]usic [Rr]oom",i](around:{radius},{lat},{lon});way[~"name"~"[Rr]ehearsal|[Pp]ractice|[Ss]tudio|[Jj]am [Ss]pace|[Ll]ockup|[Mm]usic [Rr]oom",i](around:{radius},{lat},{lon});)',
            'bars': '(node["amenity"="bar"](around:{radius},{lat},{lon});way["amenity"="bar"](around:{radius},{lat},{lon});node["amenity"="pub"](around:{radius},{lat},{lon});way["amenity"="pub"](around:{radius},{lat},{lon});)',
            'restaurants': '(node["amenity"="restaurant"](around:{radius},{lat},{lon});way["amenity"="restaurant"](around:{radius},{lat},{lon});node["amenity"="fast_food"](around:{radius},{lat},{lon});way["amenity"="fast_food"](around:{radius},{lat},{lon});)',
            'cafes': '(node["amenity"="cafe"](around:{radius},{lat},{lon});way["amenity"="cafe"](around:{radius},{lat},{lon});node["shop"="coffee"](around:{radius},{lat},{lon});)',
            'gas stations': '(node["amenity"="fuel"](around:{radius},{lat},{lon});way["amenity"="fuel"](around:{radius},{lat},{lon});)',
            'print shops': '(node["shop"="copyshop"](around:{radius},{lat},{lon});way["shop"="copyshop"](around:{radius},{lat},{lon});node["shop"="printer"](around:{radius},{lat},{lon});node["shop"="print"](around:{radius},{lat},{lon});)',
            'guitar repair': '(node["craft"="musical_instrument"](around:{radius},{lat},{lon});way["craft"="musical_instrument"](around:{radius},{lat},{lon});node["shop"="music"]["service"="repair"](around:{radius},{lat},{lon});)',
            'pharmacies': '(node["amenity"="pharmacy"](around:{radius},{lat},{lon});way["amenity"="pharmacy"](around:{radius},{lat},{lon});)'
          };
          
          const queryTemplate = osmQueries[searchTerm.toLowerCase()] || `(node[~"name"~"${searchTerm}",i](around:{radius},{lat},{lon});way[~"name"~"${searchTerm}",i](around:{radius},{lat},{lon});)`;
          
          // Single smart search with 10km radius (balance between coverage and API limits)
          const searchRadius = 10000; // 10km
          const osmQuery = queryTemplate.replace(/{radius}/g, searchRadius).replace(/{lat}/g, lat).replace(/{lon}/g, lon);
          const overpassQuery = `[out:json][timeout:30];${osmQuery};out body 50;`;
          const overpassUrl = 'https://overpass-api.de/api/interpreter';
          
          console.log(`Searching within ${searchRadius/1000}km radius...`);
          
          // Add delay to avoid rate limiting (wait 1 second between searches)
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          const response = await fetch(overpassUrl, {
            method: 'POST',
            body: overpassQuery,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
          });
          
          if (!response.ok) {
            if (response.status === 429) {
              throw new Error('Rate limit reached. Please wait a moment and try again.');
            }
            throw new Error(`Overpass API error: ${response.status}`);
          }
          
          const data = await response.json();
          console.log(`Found ${data.elements.length} results within ${searchRadius/1000}km`);
          
          // Store elements with their search radius
          const allBusinesses = data.elements.map(el => {
            el._searchRadius = searchRadius;
            return el;
          });
          
          // Calculate distance helper function
          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
          }
          
          // Convert OSM data to business chips, filtering by country
          const businesses = allBusinesses
            .filter(element => {
              if (!element.tags || !element.tags.name) return false;
              
              // Filter by country if available
              const elemCountry = element.tags['addr:country']?.toUpperCase();
              if (country && elemCountry && elemCountry !== country) {
                console.log(`Filtering out ${element.tags.name} - wrong country: ${elemCountry} != ${country}`);
                return false;
              }
              
              return true;
            })
            .map(element => {
              const tags = element.tags;
              const name = tags.name;
              
              // Build address
              const parts = [];
              if (tags['addr:housenumber']) parts.push(tags['addr:housenumber']);
              if (tags['addr:street']) parts.push(tags['addr:street']);
              if (tags['addr:city']) parts.push(tags['addr:city']);
              const addressLine = parts.length > 0 ? parts.join(' ') : 'Address unavailable';
              
              // Get contact info
              const phone = tags.phone || tags['contact:phone'] || tags['contact:mobile'] || '';
              const website = tags.website || tags['contact:website'] || '';
              
              // Build map URL
              const elLat = element.lat || (element.center && element.center.lat);
              const elLon = element.lon || (element.center && element.center.lon);
              const mapUrl = elLat && elLon 
                ? `https://www.openstreetmap.org/?mlat=${elLat}&mlon=${elLon}#map=19/${elLat}/${elLon}`
                : '#';
              
              // Calculate actual distance from venue
              const distance = elLat && elLon ? calculateDistance(lat, lon, elLat, elLon) : null;
              
              return {
                name: name,
                address: addressLine,
                phone: phone,
                url: mapUrl,
                website: website,
                rating: null,
                type: searchTerm,
                color: color,
                lat: elLat,
                lon: elLon,
                distance: distance
              };
            });
          
          console.log(`Processed ${businesses.length} businesses with names`);
          
          if (businesses.length === 0) {
            // Return empty array instead of throwing error - let UI handle gracefully
            return [];
          }
          
          // Update map to zoom to first result if available
          if (businesses.length > 0 && businesses[0].lat && businesses[0].lon && mapEmbed) {
            const topLat = businesses[0].lat;
            const topLon = businesses[0].lon;
            const zoomedMapUrl = `https://www.openstreetmap.org/export/embed.html?bbox=${topLon-0.01},${topLat-0.01},${topLon+0.01},${topLat+0.01}&layer=mapnik&marker=${topLat},${topLon}`;
            
            mapEmbed.innerHTML = `
              <iframe 
                width="100%" 
                height="100%" 
                frameborder="0" 
                scrolling="no" 
                marginheight="0" 
                marginwidth="0" 
                src="${zoomedMapUrl}" 
                style="border:none;border-radius:6px">
              </iframe>
            `;
          }
          
          return businesses;
          
        } catch (error) {
          console.error('Error fetching REAL business data:', error);
          throw error; // Re-throw to show error to user
        }
      }
      
      // Generate realistic mock search results with business details
      function generateMockResults(searchTerm, address) {
        const colorMap = {
          'hotels': '#9333ea',
          'music stores': '#dc2626',
          'rehearsal studios': '#ea580c',
          'bars': '#ca8a04',
          'restaurants': '#16a34a',
          'cafes': '#0891b2',
          'gas stations': '#2563eb',
          'print shops': '#7c3aed',
          'guitar repair': '#db2777',
          'pharmacies': '#059669'
        };
        
        const businessNames = {
          'hotels': ['Comfort Inn', 'Holiday Express', 'Hampton Inn', 'Best Western', 'Marriott', 'Hilton Garden', 'La Quinta', 'Courtyard'],
          'music stores': ['Guitar Center', 'Sam Ash', 'Long & McQuade', 'Music & Arts', 'Sweetwater', 'Local Music Shop', 'The Music Store', 'Sound House'],
          'rehearsal studios': ['Studio One Rehearsal', 'Band Practice Space', 'The Jam Room', 'Sound Studio', 'Rehearsal Factory', 'Music Lab', 'Practice HQ'],
          'bars': ['Irish Pub', 'Sports Bar & Grill', 'Craft Beer Hall', 'The Tavern', 'Downtown Bar', 'Ale House', 'Brewery Taproom'],
          'restaurants': ['Italian Bistro', 'Steakhouse', 'Sushi Bar', 'Mexican Cantina', 'Pizza Kitchen', 'Asian Fusion', 'BBQ Joint'],
          'cafes': ['Starbucks', 'Local Coffee Co.', 'Espresso Bar', 'The Daily Grind', 'Bean & Brew', 'Coffee House', 'Artisan Caf√©'],
          'gas stations': ['Shell', 'Chevron', 'BP', 'Exxon', 'Mobil', '7-Eleven', 'Circle K'],
          'print shops': ['FedEx Office', 'Staples', 'Office Depot', 'UPS Store', 'Kinko\'s', 'Local Print Shop'],
          'guitar repair': ['Guitar Tech Shop', 'Luthier Workshop', 'String & Fret', 'Guitar Hospital', 'Repair Station'],
          'pharmacies': ['Walgreens', 'CVS', 'Rite Aid', 'Local Pharmacy', 'HealthMart']
        };
        
        const streetSuffixes = ['Street', 'Avenue', 'Boulevard', 'Drive', 'Lane', 'Road', 'Way'];
        const streetNames = ['Main', 'Oak', 'Maple', 'Cedar', 'Pine', 'Washington', 'Lincoln', 'Jefferson', 'Madison', 'Park'];
        
        const color = colorMap[searchTerm.toLowerCase()] || '#0ea5e9';
        const names = businessNames[searchTerm.toLowerCase()] || ['Local Business'];
        
        // Generate realistic results
        const results = [];
        const count = Math.floor(Math.random() * 6) + 5; // 5-10 results
        
        for (let i = 0; i < count; i++) {
          const name = names[Math.floor(Math.random() * names.length)] + (names.length > 1 ? ` #${i + 1}` : ` ${i + 1}`);
          const streetNum = Math.floor(Math.random() * 9000) + 100;
          const street = streetNames[Math.floor(Math.random() * streetNames.length)];
          const suffix = streetSuffixes[Math.floor(Math.random() * streetSuffixes.length)];
          const addressLine = `${streetNum} ${street} ${suffix}`;
          
          // Generate phone number
          const areaCode = Math.floor(Math.random() * 900) + 100;
          const prefix = Math.floor(Math.random() * 900) + 100;
          const lineNum = Math.floor(Math.random() * 9000) + 1000;
          const phone = `(${areaCode}) ${prefix}-${lineNum}`;
          
          // Random rating
          const rating = (Math.random() * 2 + 3).toFixed(1); // 3.0 - 5.0
          
          const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(name + ' ' + addressLine + ' ' + address)}`;
          
          results.push({
            name: name,
            address: addressLine,
            phone: phone,
            url: searchUrl,
            rating: parseFloat(rating),
            type: searchTerm,
            color: color
          });
        }
        
        return results;
      }
      
      // Drop zone handlers
      if (interestsDropZone) {
        interestsDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'copy';
          interestsDropZone.classList.add('drag-over');
        });
        
        interestsDropZone.addEventListener('dragleave', () => {
          interestsDropZone.classList.remove('drag-over');
        });
        
        interestsDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          interestsDropZone.classList.remove('drag-over');
          
          try {
            // Try to get JSON data first
            let data = null;
            const jsonData = e.dataTransfer.getData('application/json');
            if (jsonData) {
              data = JSON.parse(jsonData);
            } else {
              // Fallback to text/plain
              const textData = e.dataTransfer.getData('text/plain');
              if (textData) {
                try {
                  data = JSON.parse(textData);
                } catch (e) {
                  console.log('Could not parse text data as JSON');
                  return;
                }
              }
            }
            
            if (data && data.name) {
              // Check for duplicates
              const existing = Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip'));
              const isDuplicate = existing.some(chip => {
                try {
                  const chipData = JSON.parse(chip.dataset.chipData);
                  return chipData.name === data.name && chipData.address === data.address;
                } catch (e) {
                  return false;
                }
              });
              
              if (!isDuplicate) {
                const chip = createInterestChip(data);
                if (interestsPlaceholder) interestsPlaceholder.style.display = 'none';
                interestsDropZone.appendChild(chip);
                saveInterests();
                updateInterestsPlaceholder();
              }
            }
          } catch (err) {
            console.error('Drop error:', err);
          }
        });
      }
      
      // Save interests to tour date
      function saveInterests() {
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if (!tourDate) return;
        
        const chips = Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip'));
        tourDate.interests = chips.map(chip => {
          try {
            return JSON.parse(chip.dataset.chipData);
          } catch (e) {
            return null;
          }
        }).filter(x => x !== null);
        
        saveAll();
      }
      
      // Load interests for selected tour date
      function loadInterests() {
        if (!interestsDropZone) return;
        
        // Clear existing chips (except placeholder)
        Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip')).forEach(chip => chip.remove());
        
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if (!tourDate || !tourDate.interests || tourDate.interests.length === 0) {
          updateInterestsPlaceholder();
          return;
        }
        
        tourDate.interests.forEach(interestData => {
          const chip = createInterestChip(interestData);
          interestsDropZone.appendChild(chip);
        });
        
        updateInterestsPlaceholder();
      }
      
      // Update placeholder visibility
      function updateInterestsPlaceholder() {
        if (!interestsPlaceholder) return;
        const hasChips = interestsDropZone.querySelectorAll('.tour-interest-chip').length > 0;
        interestsPlaceholder.style.display = hasChips ? 'none' : '';
      }
      
      // Clear all interests
      if (clearInterestsBtn) {
        clearInterestsBtn.addEventListener('click', () => {
          if (!confirm('Clear all saved places for this date?')) return;
          
          Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip')).forEach(chip => chip.remove());
          saveInterests();
          updateInterestsPlaceholder();
        });
      }
      
      // Custom search buttons storage (reuse global)
      try {
        const stored = localStorage.getItem(STORE_KEY);
        if(stored){
          const data = JSON.parse(stored);
          customSearchButtons = Array.isArray(data.customSearchButtons) ? data.customSearchButtons : [];
        }
      } catch(e) {
        customSearchButtons = [];
      }
      
      // Ensure it's always an array before rendering
      if(!Array.isArray(customSearchButtons)) customSearchButtons = [];
      
      // Render custom search buttons
      function renderCustomSearchButtons() {
        const container = document.getElementById('customSearchButtons');
        if(!container) return;
        
        container.innerHTML = '';
        if(!Array.isArray(customSearchButtons)) customSearchButtons = [];
        customSearchButtons.forEach((term, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.style.cssText = 'padding:3px 6px;font-size:9px;position:relative;padding-right:18px';
          btn.textContent = term;
          btn.dataset.search = term;
          
          // Remove button
          const removeBtn = document.createElement('span');
          removeBtn.textContent = '√ó';
          removeBtn.style.cssText = 'position:absolute;right:4px;top:50%;transform:translateY(-50%);cursor:pointer;font-weight:bold;color:#ef4444';
          removeBtn.onclick = (e) => {
            e.stopPropagation();
            if(confirm(`Remove "${term}" button?`)){
              customSearchButtons.splice(idx, 1);
              saveAll();
              renderCustomSearchButtons();
            }
          };
          
          btn.appendChild(removeBtn);
          container.appendChild(btn);
          
          // Add click handler
          btn.addEventListener('click', () => {
            const tourDate = tourDates.find(td => td.id === selectedTourDateId);
            let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
            
            if (!addressToUse) {
              alert('Please enter a venue address in the Tour date details above');
              return;
            }
            
            loadSearchInline(term, addressToUse);
          });
        });
      }
      
      // Add custom search button
      const tourAddCustomBtn = document.getElementById('tourAddCustomBtn');
      if(tourAddCustomBtn){
        tourAddCustomBtn.addEventListener('click', () => {
          const term = prompt('Enter search term (e.g., "Laundromat", "Bike Shops", etc.):');
          if(term && term.trim()){
            customSearchButtons.push(term.trim());
            saveAll();
            renderCustomSearchButtons();
          }
        });
      }
      
      // Custom search from input field
      const tourSearchBtn = document.getElementById('tourSearchBtn');
      const tourSearchInput = document.getElementById('tourSearchLocation');
      if(tourSearchBtn && tourSearchInput){
        tourSearchBtn.addEventListener('click', () => {
          const searchTerm = tourSearchInput.value.trim();
          if(!searchTerm){
            alert('Please enter a search term');
            return;
          }
          
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
        
        // Enter key to search
        tourSearchInput.addEventListener('keydown', (e) => {
          if(e.key === 'Enter'){
            tourSearchBtn.click();
          }
        });
      }
      
      // Quick service search buttons
      document.querySelectorAll('[data-search]').forEach(btn => {
        btn.addEventListener('click', () => {
          const searchTerm = btn.dataset.search;
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          
          // Get address from: 1) current form input, 2) tour date, 3) main gig
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
      });
      
      // Initialize custom buttons
      renderCustomSearchButtons();
      

      
      // Update selectTourDate to load interests while preserving scroll flag
      const originalSelectTourDate = window.selectTourDate;
      window.selectTourDate = function(tourDate, preserveHeaderScroll = true) {
        if(typeof originalSelectTourDate === 'function') originalSelectTourDate(tourDate, preserveHeaderScroll);
        loadInterests();
      };
      
      // Auto-sync: when gig.date changes, switch to matching tour date (event-driven)
      let lastGigDate = gig.date || '';
      function checkGigDateChange(){
        const currentGigDate = gig.date || '';
        if(!currentGigDate || currentGigDate === lastGigDate) return;
        lastGigDate = currentGigDate;
        console.log(`Gig date changed to ${currentGigDate}, checking for matching tour date...`);
        
        // Find or create matching tour date
        let matchingTourDate = tourDates.find(td => td.date === currentGigDate);
        
        if(!matchingTourDate){
          console.log(`Creating new tour date for ${currentGigDate}`);
          matchingTourDate = {
            id: generateId(),
            date: currentGigDate,
            venue: gig.venue || '',
            address: gig.address || '',
            loadIn: '',
            showTime: '',
            band: gig.band || '',
            setlistType: 'current',
            stagePlotType: 'current',
            itinerary: [],
            interests: []
          };
          tourDates.push(matchingTourDate);
          saveAll();
        }
        
        // Avoid redundant re-select if already on this date
        if(selectedTourDateId === matchingTourDate.id) return;
        console.log(`Switching to tour date: ${matchingTourDate.id}`);
        selectTourDate(matchingTourDate, false);
        renderTimeline();
      }
      
      // React to manual gig date edits instead of polling
      const gigDateInput = document.getElementById('gDate');
      if(gigDateInput){
        gigDateInput.addEventListener('change', ()=>{
          gig.date = gigDateInput.value || '';
          checkGigDateChange();
        });
      }
      
      // Initialize
      renderTimeline();
      renderDateHeader(); // Render global date strip
      checkGigDateChange(); // Initial check
      
      // Load first tour date or today on startup
      if(tourDates && tourDates.length > 0){
        // Find first upcoming or current tour date
        const today = new Date();
        today.setHours(0,0,0,0);
        const upcomingDate = tourDates.find(td => {
          const d = new Date(td.date);
          d.setHours(0,0,0,0);
          return d >= today;
        });
        const firstDate = upcomingDate || tourDates[0];
        if(firstDate){
          selectTourDate(firstDate);
          renderDateHeader();
        }
      }
      
      // Show Calendar tab on load
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      const calTab = document.querySelector('.tab[data-tab="tour"]');
      if(calTab) calTab.classList.add('active');
      ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      const tourEl = document.getElementById('tour');
      if(tourEl) tourEl.style.display='block';
      
      // UNIFIED Activity Chip Drag-to-Itinerary System
      // User drags chip to timeline slot (start time), pauses to stick, then stretches downward to set end time
      
      let chipDragState = null; // {type: 'mouse'|'touch', chipData: {...}, phase: 'dragging'|'stuck'|'stretching', startSlot: element, startTime: string, endSlot: element, endTime: string, visualClone: element, previewBlock: element}
      
      function initActivityChips(){
        const chips = document.querySelectorAll('.activity-chip');
        chips.forEach(chip => {
          
          // === MOUSE DRAG SYSTEM ===
          chip.addEventListener('mousedown', (e) => {
            e.preventDefault();
            
            const chipData = {
              activity: chip.dataset.activity,
              color: chip.dataset.color,
              text: chip.textContent.trim()
            };
            
            // Create visual clone
            const clone = chip.cloneNode(true);
            clone.classList.add('touch-dragging');
            clone.style.cssText = `
              position:fixed;
              z-index:99999;
              pointer-events:none;
              opacity:0.9;
              transform:scale(1.05);
              box-shadow:0 8px 24px rgba(0,0,0,0.3);
              left:${e.clientX - 40}px;
              top:${e.clientY - 15}px;
            `;
            document.body.appendChild(clone);
            chip.style.opacity = '0.3';
            
            chipDragState = {
              type: 'mouse',
              chipData,
              phase: 'dragging',
              visualClone: clone,
              sourceChip: chip
            };
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          });
          
          // === TOUCH DRAG SYSTEM ===
          chip.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            
            const chipData = {
              activity: chip.dataset.activity,
              color: chip.dataset.color,
              text: chip.textContent.trim()
            };
            
            // Create visual clone
            const clone = chip.cloneNode(true);
            clone.classList.add('touch-dragging');
            clone.style.cssText = `
              position:fixed;
              z-index:99999;
              pointer-events:none;
              opacity:0.9;
              transform:scale(1.05);
              box-shadow:0 8px 24px rgba(0,0,0,0.3);
              left:${touch.clientX - 40}px;
              top:${touch.clientY - 15}px;
            `;
            document.body.appendChild(clone);
            chip.style.opacity = '0.3';
            
            chipDragState = {
              type: 'touch',
              chipData,
              phase: 'dragging',
              visualClone: clone,
              sourceChip: chip
            };
            
            document.addEventListener('touchmove', handleTouchMove, {passive: false});
            document.addEventListener('touchend', handleTouchEnd);
          }, {passive: false});
        });
      }
      
      function handleMouseMove(e){
        if(!chipDragState || chipDragState.type !== 'mouse') return;
        
        // Update clone position
        chipDragState.visualClone.style.left = (e.clientX - 40) + 'px';
        chipDragState.visualClone.style.top = (e.clientY - 15) + 'px';
        
        updateDragPhase(e.clientX, e.clientY);
      }
      
      function handleTouchMove(e){
        if(!chipDragState || chipDragState.type !== 'touch') return;
        e.preventDefault();
        const touch = e.touches[0];
        
        // Update clone position
        chipDragState.visualClone.style.left = (touch.clientX - 40) + 'px';
        chipDragState.visualClone.style.top = (touch.clientY - 15) + 'px';
        
        updateDragPhase(touch.clientX, touch.clientY);
      }
      
      function updateDragPhase(x, y){
        const slot = findSlotAtPosition(x, y);
        
        if(chipDragState.phase === 'dragging'){
          // Phase 1: Dragging chip - highlight hovered slot
          document.querySelectorAll('.timeline-slot').forEach(s => s.classList.remove('touch-drop-target'));
          if(slot){
            slot.classList.add('touch-drop-target');
            
            // Check if mouse/touch has paused over this slot for 300ms
            if(chipDragState.pauseSlot !== slot){
              chipDragState.pauseSlot = slot;
              chipDragState.pauseTime = Date.now();
            } else if(Date.now() - chipDragState.pauseTime > 300){
              // Stick! Transition to stuck phase
              stickToSlot(slot);
            }
          } else {
            chipDragState.pauseSlot = null;
          }
        } else if(chipDragState.phase === 'stuck' || chipDragState.phase === 'stretching'){
          // Phase 2/3: Stuck or stretching - allow dragging down to extend duration
          if(slot && slot !== chipDragState.startSlot){
            chipDragState.phase = 'stretching';
            chipDragState.endSlot = slot;
            chipDragState.endTime = slot.dataset.time;
            updatePreviewBlock();
          }
        }
      }
      
      function stickToSlot(slot){
        chipDragState.phase = 'stuck';
        chipDragState.startSlot = slot;
        chipDragState.startTime = slot.dataset.time;
        chipDragState.endSlot = slot;
        chipDragState.endTime = slot.dataset.time;
        
        // Create preview block
        createPreviewBlock();
        
        // Visual feedback
        slot.classList.remove('touch-drop-target');
        slot.classList.add('stuck-slot');
      }
      
      function createPreviewBlock(){
        const preview = document.createElement('div');
        preview.className = 'itinerary-preview-block';
        preview.style.cssText = `
          position:absolute;
          left:0;
          right:0;
          background:${chipDragState.chipData.color || '#3b82f6'}40;
          border:2px dashed ${chipDragState.chipData.color || '#3b82f6'};
          border-radius:6px;
          pointer-events:none;
          z-index:1000;
          padding:4px;
          font-size:11px;
          font-weight:600;
          color:#1f2937;
        `;
        preview.textContent = chipDragState.chipData.text;
        
        chipDragState.startSlot.style.position = 'relative';
        chipDragState.startSlot.appendChild(preview);
        chipDragState.previewBlock = preview;
      }
      
      function updatePreviewBlock(){
        if(!chipDragState.previewBlock || !chipDragState.startSlot || !chipDragState.endSlot) return;
        
        // Calculate duration in 15-min slots
        const startIdx = getSlotIndex(chipDragState.startSlot);
        const endIdx = getSlotIndex(chipDragState.endSlot);
        const numSlots = Math.max(1, endIdx - startIdx + 1);
        const durationMin = numSlots * 15;
        
        // Update preview visual span
        const startRect = chipDragState.startSlot.getBoundingClientRect();
        const endRect = chipDragState.endSlot.getBoundingClientRect();
        const height = endRect.bottom - startRect.top;
        
        chipDragState.previewBlock.style.height = height + 'px';
        chipDragState.previewBlock.textContent = `${chipDragState.chipData.text} (${durationMin}m)`;
      }
      
      function handleMouseUp(e){
        if(!chipDragState || chipDragState.type !== 'mouse') return;
        
        finalizeChipDrop();
        cleanupChipDrag();
        
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
      
      function handleTouchEnd(e){
        if(!chipDragState || chipDragState.type !== 'touch') return;
        
        finalizeChipDrop();
        cleanupChipDrag();
        
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
      }
      
      function finalizeChipDrop(){
        if(chipDragState.phase === 'stuck' || chipDragState.phase === 'stretching'){
          // Create event on itinerary
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate && chipDragState.startTime){
            const startIdx = getSlotIndex(chipDragState.startSlot);
            const endIdx = getSlotIndex(chipDragState.endSlot);
            const durationMin = Math.max(15, (endIdx - startIdx + 1) * 15);
            
            let title = chipDragState.chipData.activity.charAt(0).toUpperCase() + chipDragState.chipData.activity.slice(1);
            
            if(!tourDate.itinerary) tourDate.itinerary = [];
            tourDate.itinerary.push({
              time: chipDragState.startTime,
              title: title,
              activity: chipDragState.chipData.activity,
              duration: durationMin,
              chipData: { color: chipDragState.chipData.color },
              notes: ''
            });
            
            saveAll();
            renderItinerary(tourDate);
            renderDateHeader();
          }
        }
      }
      
      function cleanupChipDrag(){
        if(chipDragState){
          if(chipDragState.visualClone) chipDragState.visualClone.remove();
          if(chipDragState.previewBlock) chipDragState.previewBlock.remove();
          if(chipDragState.sourceChip) chipDragState.sourceChip.style.opacity = '1';
          
          document.querySelectorAll('.timeline-slot').forEach(s => {
            s.classList.remove('touch-drop-target', 'stuck-slot');
          });
        }
        chipDragState = null;
      }
      
      function findSlotAtPosition(x, y){
        let foundSlot = null;
        document.querySelectorAll('.timeline-slot').forEach(slot => {
          const rect = slot.getBoundingClientRect();
          if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom){
            foundSlot = slot;
          }
        });
        return foundSlot;
      }
      
      function getSlotIndex(slot){
        if(!slot || !slot.dataset.time) return 0;
        const [h, m] = slot.dataset.time.split(':').map(Number);
        const startHour = 5;
        let adjH = h < 5 ? h + 24 : h;
        return (adjH - startHour) * 4 + Math.floor(m / 15);
      }
      
      // Initialize chip drag handlers
      initActivityChips();
      
      // Drag-to-assign handlers for setlist and stage plot
      initDragAssignHandles = function(){
        const setlistHandle = document.getElementById('setlistDragHandle');
        const stageHandle = document.getElementById('stageDragHandle');
        
        // Remove old listeners by cloning
        if(setlistHandle){
          const newSetlistHandle = setlistHandle.cloneNode(true);
          setlistHandle.parentNode.replaceChild(newSetlistHandle, setlistHandle);
          
          newSetlistHandle.draggable = true;
          
          // Use capture phase to block events before they reach other handlers
          newSetlistHandle.addEventListener('mousedown', (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, {capture: true});
          newSetlistHandle.addEventListener('touchstart', (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, {capture: true});
          
          newSetlistHandle.addEventListener('dragstart', (e) => {
            e.stopPropagation();
            e.dataTransfer.setData('text/plain', 'setlist');
            e.dataTransfer.setData('assignType', 'setlist');
            e.dataTransfer.effectAllowed = 'copy';
            newSetlistHandle.style.cursor = 'grabbing';
            console.log('‚úì Drag started: setlist');
          });
          
          newSetlistHandle.addEventListener('dragend', (e) => {
            newSetlistHandle.style.cursor = 'grab';
          });
        }
        
        // Stage plot drag handle
        if(stageHandle){
          const newStageHandle = stageHandle.cloneNode(true);
          stageHandle.parentNode.replaceChild(newStageHandle, stageHandle);
          
          newStageHandle.draggable = true;
          
          // Stop propagation to prevent stage plot interactions, but DON'T preventDefault for drag to work
          newStageHandle.addEventListener('mousedown', (e) => { 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('touchstart', (e) => { 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('click', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('dragstart', (e) => {
            e.stopPropagation();
            e.dataTransfer.setData('text/plain', 'stagePlot');
            e.dataTransfer.setData('assignType', 'stagePlot');
            e.dataTransfer.effectAllowed = 'copy';
            newStageHandle.style.cursor = 'grabbing';
            console.log('‚úì Drag started: stagePlot');
          });
          
          newStageHandle.addEventListener('dragend', (e) => {
            newStageHandle.style.cursor = 'grab';
          });
        }
      }
      
      // Initialize drag-assign handles
      initDragAssignHandles();
      
      // Make globally accessible
      window.initDragAssignHandles = initDragAssignHandles;
      
    })();

    function buildSheet(target='sheet'){
      const isInline = (target!=='sheet');
      const sheet = document.getElementById(target);
      if(!sheet) return;
      
      // Apply paper format
      const format = pageLayout.format || 'letter';
      if(format === 'a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
      
      // For preview (inline), always single page with auto-fit
      // For print, use multipage only if explicitly set
      const songCount = setlist.filter(x => x.title).length;
      const breakCount = setlist.filter(x => x.type === 'break' || x.type === 'encore').length;
      const totalItems = songCount + breakCount;
      
      // Preview always single page; Print can be multipage
      const multiPage = !isInline && (pageLayout.pageCount || 1) > 1;
      
      // Clear and setup sheet structure
      sheet.innerHTML = '';
      sheet.classList.remove('multipage');
      
      // Always use single page structure for preview
      const hdrEl = document.createElement('div');
      hdrEl.className = 'hdr';
      hdrEl.id = isInline ? 'hdrInline' : 'hdr';
      const songsEl = document.createElement('div');
      songsEl.className = 'songs';
      songsEl.id = isInline ? 'songsInline' : 'songs';
      sheet.appendChild(hdrEl);
      sheet.appendChild(songsEl);
      
      const hdr = document.getElementById(isInline? 'hdrInline' : 'hdr');
      const songs = document.getElementById(isInline? 'songsInline' : 'songs');
      if(!hdr || !songs) return;
      
      // Get current band from Act selector (authoritative source)
      const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || '') : (gig.band || '');
      
      // Header - directly editable
      hdr.innerHTML='';
      const b = el('div','band',currentBandName.trim()||'Enter Band Name');
      b.contentEditable = 'true';
      b.setAttribute('data-placeholder', 'Enter Band Name');
      b.addEventListener('blur', ()=>{
        gig.band = b.textContent.trim();
        // Sync to calendar band input
        const calBandInput = document.getElementById('tourBand');
        if(calBandInput) calBandInput.value = gig.band;
        // Also update current tour date's band
        const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(currentTourDate) currentTourDate.band = gig.band;
        // Update Act display in header
        if(typeof updateActDisplay === 'function') updateActDisplay();
        saveAll();
      });
      b.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          b.blur();
        }
      });
      
      const v = el('div','venue',gig.venue||'Enter Venue');
      v.contentEditable = 'true';
      v.setAttribute('data-placeholder', 'Enter Venue');
      v.addEventListener('blur', ()=>{
        gig.venue = v.textContent.trim();
        saveAll();
      });
      v.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          v.blur();
        }
      });
      
      const sub = el('div','sub', gig.address||'Enter Address');
      sub.contentEditable = 'true';
      sub.setAttribute('data-placeholder', 'Enter Address');
      sub.addEventListener('blur', ()=>{
        gig.address = sub.textContent.trim();
        saveAll();
      });
      sub.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          sub.blur();
        }
      });
      
      const n = el('div','notes', gig.notes||'Enter Notes');
      n.contentEditable = 'true';
      n.setAttribute('data-placeholder', 'Enter Notes');
      n.addEventListener('blur', ()=>{
        gig.notes = n.textContent.trim();
        saveAll();
      });
      n.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          n.blur();
        }
      });
      
      hdr.appendChild(b);
      hdr.appendChild(v);
      
      // Add date display if exists
      if(gig.date){
        // Parse YYYY-MM-DD as local date (not UTC) to avoid timezone shift
        const [y, m, d] = gig.date.split('-').map(Number);
        const localDate = new Date(y, m - 1, d);
        const dateEl = el('div','sub', localDate.toLocaleDateString('en-US', {weekday:'long', year:'numeric', month:'long', day:'numeric'}));
        dateEl.style.fontWeight = '700';
        dateEl.style.color = '#111';
        hdr.appendChild(dateEl);
      }
      
      hdr.appendChild(sub);
      hdr.appendChild(n);

      // Apply font selection
      const fontMap={
        'default':'Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif',
        'helvetica':'Helvetica, Arial, sans-serif',
        'georgia':'Georgia, Times, serif',
        'roboto-condensed':'"Roboto Condensed", Roboto, Arial, sans-serif',
        'courier':'"Courier New", Courier, monospace'
      };
      sheet.style.fontFamily = fontMap[gig.font||'default']||fontMap.default;

      // Songs
      songs.innerHTML='';
      // dynamic font scaling to fit one page
      // Start with base sizes and try to fit, shrink if overflow
  const base = { title:14, lineGap:3 };

      const lines=[];
      let sinceBreak=0;
      let songCounter=0;
      setlist.forEach((it, idx)=>{
        if(it.type==='break'){
          const br=el('div','break',`${it.title} ‚Äî ${it.length}m`);
          if(sinceBreak>=15) br.classList.add('pagebreak');
          lines.push(br); sinceBreak=0; return;
        }
        if(it.type==='encore'){ const label=(it.title||'Encore'); const enc=el('div','break',label.toUpperCase()); if(sinceBreak>=15) enc.classList.add('pagebreak'); lines.push(enc); sinceBreak=0; return; }
        if(it.type==='blankrow'){ const blank=el('div','line'); blank.style.height='1.5em'; blank.innerHTML='&nbsp;'; lines.push(blank); return; }
        if(it.type==='separator'){ const sep=el('div','separator'); sep.style.borderBottom='2px solid #333'; sep.style.margin='4px 0'; sep.style.height='0'; lines.push(sep); return; }
        const row=el('div','line');
        row.append(el('div','no', String(++songCounter)));
        
        // Build display: Number, Title, Artist, Key, Capo, BPM, Notes, Lyrics, Time
        const title=el('div','title', shorten(it.title));
        const displayParts = [];
        
        // Artist (if checkbox checked)
        if(setlistColumns.artist && it.artist){
          displayParts.push(it.artist);
        }
        
        // Only show these if checkboxes are checked
        if(setlistColumns.key && it.key){
          displayParts.push(it.key);
        }
        if(setlistColumns.capo && Number.isInteger(it.capo) && it.capo>0){
          displayParts.push('Capo '+it.capo);
        }
        if(setlistColumns.bpm && it.bpm){
          displayParts.push(it.bpm+' BPM');
        }
        if(setlistColumns.notes && it.notes){
          displayParts.push(it.notes);
        }
        if(setlistColumns.lyrics && it.lyrics){
          const firstLine = findFirstLyricLine(it.lyrics);
          if(firstLine){
            displayParts.push(firstLine.length>40 ? firstLine.substring(0,40)+'...' : firstLine);
          }
        }
        // Custom columns from setlistColumns
        if(gig.customColumns && it.customFields){
          gig.customColumns.forEach(cc=>{
            if(setlistColumns[cc.key] && it.customFields[cc.key]){
              displayParts.push(it.customFields[cc.key]);
            }
          });
        }
        
        if(displayParts.length > 0){
          const detailSpan = el('span','notePrint',' ‚Äì ' + displayParts.join(' ‚Äì '));
          title.appendChild(detailSpan);
        }
        
        row.append(title);
        // Right side no longer shows key/capo/bpm - empty for now
        row.append(el('div','key', ''));
        row.append(el('div','time', `${it.length}m`));
        lines.push(row); sinceBreak++;
      });

      // Single page: append all songs and fit to available space
      // Add data-setlist-index to track position
      lines.forEach((line, idx) => {
        line.dataset.setlistIndex = idx;
      });
      songs.append(...lines);
      
      // Add total time inside songs container before fitting
      const totalMin = setlist.reduce((acc,it)=> acc + ((it.type==='song'||it.type==='break') ? (parseFloat(it.length)||0) : 0), 0);
      let totalEl = songs.querySelector('.total-time');
      if(!totalEl){ 
        totalEl=document.createElement('div'); 
        totalEl.className='total-time'; 
      }
      totalEl.textContent = `Total: ${totalMin.toFixed(0)}m`;
      totalEl.style.textAlign='right'; totalEl.style.marginTop='4px'; totalEl.style.fontWeight='600'; totalEl.style.fontSize='9pt';
      songs.appendChild(totalEl);
      
      fitToPage();

      function fitToPage(songsContainer){
        const songs = songsContainer || document.getElementById(isInline ? 'songsInline' : 'songs');
        if(!songs) return;
        const container = songs.closest('.sheet-page') || songs.closest('.sheet') || sheet;
        const totalEl = songs.querySelector('.total-time');
        const allItems = Array.from(songs.querySelectorAll('.line, .break'));
        const lineCount = allItems.length;
        if(lineCount === 0) return;
        
        songs.style.transform = 'none';
        songs.style.width = '100%';
        
        const isPrintMode = !isInline;
        
        if(isPrintMode){
          // PRINT MODE: Fill the entire page with songs evenly distributed
          // Letter paper usable area for songs: ~620pt (accounting for header, margins, total)
          const TOTAL_HEIGHT = 620;
          
          // Include +1 for the Total line at bottom
          const totalItems = lineCount + 1;
          
          // Each item (song + total) gets equal slot
          const slotHeight = TOTAL_HEIGHT / totalItems;
          
          // Font is 65% of slot - BIGGER text
          const baseFontSize = Math.min(28, Math.max(11, slotHeight * 0.65));
          
          // Line content height
          const lineHeight = baseFontSize * 1.15;
          
          // Gap is remaining space in each slot
          const gapPerItem = Math.max(2, slotHeight - lineHeight);
          
          // Apply font sizes - BIGGER
          const titleSize = baseFontSize + 'pt';
          const numSize = Math.max(9, baseFontSize * 0.65) + 'pt';
          const timeSize = Math.max(9, baseFontSize * 0.6) + 'pt';
          const noteSize = Math.max(8, baseFontSize * 0.55) + 'pt';
          
          Array.from(songs.querySelectorAll('.title')).forEach(d => d.style.fontSize = titleSize);
          Array.from(songs.querySelectorAll('.no')).forEach(d => d.style.fontSize = numSize);
          Array.from(songs.querySelectorAll('.time')).forEach(d => d.style.fontSize = timeSize);
          Array.from(songs.querySelectorAll('.key')).forEach(d => d.style.fontSize = timeSize);
          Array.from(songs.querySelectorAll('.notePrint')).forEach(d => d.style.fontSize = noteSize);
          
          // Apply margin-bottom to each item
          allItems.forEach(item => {
            item.style.padding = '0';
            item.style.margin = '0';
            item.style.marginBottom = gapPerItem + 'pt';
            item.style.lineHeight = '1.15';
            if(item.classList.contains('break')){
              item.style.fontSize = Math.max(10, baseFontSize * 0.8) + 'pt';
              item.style.padding = '2pt 6pt';
            }
          });
          
          // Container - simple block flow
          songs.style.display = 'block';
          songs.style.height = 'auto';
          
          // Total time - same gap above it
          if(totalEl){
            totalEl.style.fontSize = timeSize;
            totalEl.style.marginTop = '0';
            totalEl.style.paddingTop = '0';
          }
        } else {
          // PREVIEW MODE - match print proportions exactly
          const totalItems = lineCount + 1; // +1 for Total line
          const MAX_SONGS_ONE_PAGE = 35;
          
          // Show/hide warning for large setlists
          let warning = document.getElementById('largeSetlistWarning');
          if(lineCount > MAX_SONGS_ONE_PAGE){
            if(!warning){
              warning = document.createElement('div');
              warning.id = 'largeSetlistWarning';
              warning.style.cssText = 'background:#fef3c7;border:1px solid #f59e0b;color:#92400e;padding:8px 12px;border-radius:6px;font-size:12px;margin-bottom:8px;text-align:center';
              warning.innerHTML = '‚ö†Ô∏è Large setlist (' + lineCount + ' songs). You may need to scale down in printer settings to fit on one page, or it will print on multiple pages.';
              container.parentNode.insertBefore(warning, container);
            } else {
              warning.innerHTML = '‚ö†Ô∏è Large setlist (' + lineCount + ' songs). You may need to scale down in printer settings to fit on one page, or it will print on multiple pages.';
            }
          } else if(warning){
            warning.remove();
          }
          
          // Use SAME font calculation as print mode for consistency
          // Print uses: 620pt height / totalItems * 0.65
          // Preview uses a slightly smaller virtual height so the whole page fits on screen
          const PREVIEW_HEIGHT = 500;
          const slotHeight = PREVIEW_HEIGHT / totalItems;
          const baseFontSize = Math.min(28, Math.max(10, slotHeight * 0.65));
          
          const titleSize = baseFontSize + 'pt';
          const numSize = Math.max(9, baseFontSize * 0.65) + 'pt';
          const noteSize = Math.max(8, baseFontSize * 0.55) + 'pt';
          
          Array.from(songs.querySelectorAll('.title')).forEach(d => d.style.fontSize = titleSize);
          Array.from(songs.querySelectorAll('.no')).forEach(d => d.style.fontSize = numSize);
          Array.from(songs.querySelectorAll('.time,.key')).forEach(d => d.style.fontSize = numSize);
          Array.from(songs.querySelectorAll('.notePrint')).forEach(d => d.style.fontSize = noteSize);
          
          // Calculate gap to distribute evenly
          const lineHeight = baseFontSize * 1.15;
          const gapPerItem = Math.max(2, slotHeight - lineHeight);
          
          allItems.forEach(item => {
            item.style.padding = '0';
            item.style.margin = '0';
            item.style.marginBottom = gapPerItem + 'pt';
            item.style.lineHeight = '1.15';
            if(item.classList.contains('break')){
              item.style.fontSize = Math.max(10, baseFontSize * 0.8) + 'pt';
              item.style.padding = '2pt 6pt';
            }
          });
          
          // Use block layout with margins (same as print)
          songs.style.display = 'block';
          songs.style.justifyContent = '';
          songs.style.gap = '';
          
          // Total time styling
          if(totalEl){
            totalEl.style.fontSize = numSize;
            totalEl.style.padding = '0';
            totalEl.style.margin = '0';
          }
        }
      }
      
      // Attach drag/touch interactions for inline preview
      if(isInline){
        // Always attach drop handlers so we can receive items from pool
        setupPreviewDropHandlers();
        // Only attach row interactions if there are items
        if(setlist.length > 0){
          attachPreviewInteractions();
        }
      }
    }
    // Embedded song pool chips (Originals vs Covers) for direct drag into preview
    function renderSongPool(){
      const pO=document.getElementById('poolOriginals');
      const pC=document.getElementById('poolCovers');
      const pB=document.getElementById('poolBreaks');
      const covHdr=document.getElementById('poolCoversHdr');
      const brHdr=document.getElementById('poolBreaksHdr');
      const typeSel=document.getElementById('poolType');
      const sortSel=document.getElementById('poolSort');
      const moodSel=document.getElementById('poolMood');
      const searchInput=document.getElementById('poolSearch');
      if(!pO || !pC) return;
      
      // Allow dropping items from set back into the pool to remove them
      // Only add listeners once per element to prevent duplicate event handlers
      [pO,pC,pB].forEach(el=>{ 
        if(!el) return;
        if(!el.dataset.dropListenerAdded){
          el.dataset.dropListenerAdded = 'true';
          el.addEventListener('dragover',e=> e.preventDefault());
          el.addEventListener('drop',e=>{ 
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to parent handlers
            const idxRaw=e.dataTransfer.getData('text/x-set-index');
            if(idxRaw){
              const idx=parseInt(idxRaw,10);
              if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
                setlist.splice(idx,1); // Remove only the one item
                rebuildPreview();
                saveAll();
              }
            }
          });
        }
      });
      
      pO.innerHTML=''; pC.innerHTML=''; if(pB) pB.innerHTML='';
      if(!db.length){ pO.textContent='No songs.'; pC.textContent=''; return; }
      const usedIds=new Set(setlist.filter(x=>x.type==='song').map(x=>x.id));
      const typeVal=(typeSel && typeSel.value) || 'all';
      const sortVal=(sortSel && sortSel.value) || 'alpha';
      const moodVal=(moodSel && moodSel.value) || 'all';
      const searchTerm=(searchInput && searchInput.value) || '';

      const songMood=(s)=> s.isUpbeat? 'upbeat' : s.isHappy? 'happy' : s.isEnergetic? 'energetic' : s.isMellow? 'mellow' : s.isSad? 'sad' : ((s.customMoods||[])[0] || 'none');
      const moodRank={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:5}; getAllMoods().forEach((m,i)=>{ if(!(m in moodRank)) moodRank[m]=6+i; });
      const moodMatch=(s)=> moodVal==='all' || songMood(s)===moodVal;
      const searchMatch=(s)=>{
        if(!searchTerm) return true;
        try{
          const regex = new RegExp(searchTerm, 'i');
          return regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||'');
        }catch(e){
          const term=searchTerm.toLowerCase();
          return (s.title||'').toLowerCase().includes(term) || (s.artist||'').toLowerCase().includes(term) || (s.composer||'').toLowerCase().includes(term) || (s.lyrics||'').toLowerCase().includes(term);
        }
      };
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (moodRank[songMood(a)] - moodRank[songMood(b)]) || a.title.localeCompare(b.title);
      const applySort=(arr,isCover)=>{
        if(sortVal==='band') return (isCover? arr.sort(byBand) : arr.sort(byAlpha));
        if(sortVal==='mood') return arr.sort(byMood);
        return arr.sort(byAlpha);
      };

      let originals=db.filter(s=>!s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      let covers=db.filter(s=>s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      originals=applySort(originals,false);
      covers=applySort(covers,true);

      // Toggle visibility based on type filter
      const showOriginals = typeVal==='all' || typeVal==='originals';
      const showCovers    = typeVal==='all' || typeVal==='covers';
      pO.style.display = showOriginals? 'flex':'none';
      if(covHdr) covHdr.style.display = showCovers? '' : 'none';
      pC.style.display = showCovers? 'flex':'none';
      if(brHdr) brHdr.style.display=''; if(pB) pB.style.display='flex'; // always show break section

      const hueFromStr=(str)=>{ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h%360; };
      const makeChip=(s)=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.setAttribute('draggable','true'); chip.style.cursor='grab'; chip.dataset.id=s.id;
        const moodClass = s.isUpbeat ? 'mood-upbeat'
          : s.isHappy ? 'mood-happy'
          : s.isEnergetic ? 'mood-energetic'
          : s.isMellow ? 'mood-mellow'
          : s.isSad ? 'mood-sad'
          : ((s.customMoods||[]).length ? 'mood-custom' : '');
        if(moodClass) chip.classList.add(moodClass);
        // Custom mood color (use first custom mood)
        if(!s.isUpbeat && !s.isHappy && !s.isEnergetic && !s.isMellow && !s.isSad && (s.customMoods||[]).length){
          const key=(s.customMoods||[])[0]; const h=hueFromStr(key);
          chip.style.backgroundColor = `hsl(${h} 90% 95%)`;
          chip.style.borderColor = `hsl(${h} 60% 80%)`;
          chip.style.color = '#0f172a';
        }
        const showArtist = s.isCover && s.artist && s.artist!=='Original';
        chip.textContent = showArtist ? `${s.artist} - ${s.title}` : s.title;
        chip.title=`${s.artist} ‚Ä¢ ${s.length}m${s.key? ' ‚Ä¢ '+s.key:''}`;
        chip.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/plain', String(s.id)); });
        chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; activePoolTouch={kind:'song', id:s.id, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
        chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
        return chip;
      };
      if(showOriginals){
        if(!originals.length) pO.textContent = 'No songs.'; else originals.forEach(s=> pO.appendChild(makeChip(s)));
      }
      if(showCovers){
        if(!covers.length) pC.textContent = showOriginals? '' : 'No songs.'; else covers.forEach(s=> pC.appendChild(makeChip(s)));
      }
      if(pB){
        const len = parseFloat((document.getElementById('gBreakLen') && document.getElementById('gBreakLen').value) || gig.breakLen || 15);
        const makeEventChip=(label, kind, hint='')=>{
          const chip=document.createElement('div'); chip.className='pill'; chip.style.cursor='grab'; chip.setAttribute('draggable','true'); chip.textContent= hint? `${label} (${hint})` : label;
          chip.addEventListener('dragstart',e=>{ if(kind==='break'){ e.dataTransfer.setData('text/x-break', String(len)); } else { e.dataTransfer.setData('text/x-event', JSON.stringify({kind})); } });
          chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; const payload=(kind==='break')? {kind:'break', length:len} : {kind:'event', event:{kind}}; activePoolTouch={...payload, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
          chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
          return chip;
        };
        pB.appendChild(makeEventChip(`Break (${len}m)`, 'break'));
        pB.appendChild(makeEventChip('SOUNDCHECK', 'soundcheck'));
        pB.appendChild(makeEventChip('ENCORE', 'encore'));
        pB.appendChild(makeEventChip('INTERMISSION', 'intermission'));
        pB.appendChild(makeEventChip('ANNOUNCEMENT', 'announcement'));
        pB.appendChild(makeEventChip('BLANK ROW', 'blankrow'));
        pB.appendChild(makeEventChip('SEPARATOR LINE', 'separator'));
        pB.appendChild(makeEventChip('CUSTOM‚Ä¶', 'custom'));
      }
    }
    // renderEncore removed - element #encoreList does not exist
    
    // New drop handling directly on preview songs area
    const previewSongs=document.getElementById('songsInline');
    function rebuildPreview(){ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll(); try{ pushAppHistory('rebuildPreview'); }catch(_){ } initDragAssignHandles(); }
    function attachPreviewInteractions(){
      const sheet=document.getElementById('sheetInline');
      if(!sheet) return;
      
      // Get all song containers (either single songs div or multiple across pages)
      const allSongsContainers = sheet.querySelectorAll('.songs');
      
      // Mark all lines and breaks draggable across all pages
      allSongsContainers.forEach(songsContainer => {
        songsContainer.querySelectorAll('.line, .break').forEach((row)=>{
          const setlistIdx = parseInt(row.dataset.setlistIndex, 10);
          if(!Number.isInteger(setlistIdx)) return;
          
          // Only allow dragging when grabbing text elements, not whitespace
          let dragTargets;
          if(row.classList.contains('break')){
            // Breaks have text directly in the element
            dragTargets = [row];
            row.setAttribute('draggable','true');
            row.style.cursor = 'grab';
          } else {
            // Lines have .title, .no, .time sub-elements
            dragTargets = [row.querySelector('.title'), row.querySelector('.no'), row.querySelector('.time')].filter(Boolean);
            dragTargets.forEach(target => {
              target.setAttribute('draggable','true');
              target.style.cursor = 'grab';
            });
          }
          
          row.addEventListener('dragstart',e=>{ 
            // Only allow drag if started from a text element
            const isDragTarget = dragTargets.some(t => t.contains(e.target));
            if(!isDragTarget) {
              e.preventDefault();
              return;
            }
            // Check if setlist is locked
            if(isSetlistLocked()) {
              e.preventDefault();
              return;
            }
            e.dataTransfer.setData('text/x-set-index', String(setlistIdx));
            row.classList.add('dragging');
          });
          row.addEventListener('dragend',()=> row.classList.remove('dragging'));
          
          // Add dragover handlers to show blue line indicator
          row.addEventListener('dragover', e => {
            if(isSetlistLocked()) return;
            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            // Remove all indicators first (check all pages if multi-page)
            const allRows = sheet.querySelectorAll('.sheet-page .line, .sheet-page .break, .songs > .line, .songs > .break');
            allRows.forEach(r => {
              r.classList.remove('drop-before', 'drop-after');
            });
            
            // Add indicator based on cursor position
            if(e.clientY < midpoint) {
              row.classList.add('drop-before');
            } else {
              row.classList.add('drop-after');
            }
          });
          
          row.addEventListener('dragleave', () => {
            row.classList.remove('drop-before', 'drop-after');
          });
          
          // Double-click to edit notes (only songs)
          if(row.classList.contains('line')){
            const titleDiv=row.querySelector('.title');
            if(titleDiv){ titleDiv.addEventListener('dblclick',()=>{
              if(isSetlistLocked()) return;
              const entry=setlist[setlistIdx]; if(!entry || entry.type!=='song') return; const val=prompt('Notes for '+entry.title, entry.notes||''); if(val!=null){ entry.notes=val.trim(); rebuildPreview(); }
            }); }
          }
          
          // Touch drag - use same dragTargets from above
          dragTargets.forEach(target => {
            target.style.touchAction='none';
            target.addEventListener('touchstart',ev=>{
              if(isSetlistLocked()){ ev.preventDefault(); return; }
              const t=ev.touches[0]; if(!t) return; 
              window._activeSetTouch={ 
                idx:setlistIdx, 
                startX:t.clientX, 
                startY:t.clientY, 
                x:t.clientX, 
                y:t.clientY, 
                removed:false, 
                reorderTarget:setlistIdx 
              }; 
              row.classList.add('drag-touch'); 
              ev.preventDefault();
            }, {passive:false});
          });
          
          row.addEventListener('touchmove',ev=>{
            if(isSetlistLocked()) return;
            const act=window._activeSetTouch; if(!act) return; 
            for(const t of ev.touches){ 
              if(t.identifier!=null){ 
                act.x=t.clientX; 
                act.y=t.clientY; 
                break; 
              } 
            }
            
            // Determine potential reorder target across all pages
            const sheetRect=sheet.getBoundingClientRect();
            if(act.x>=sheetRect.left && act.x<=sheetRect.right && act.y>=sheetRect.top && act.y<=sheetRect.bottom){
              const allRows=[...sheet.querySelectorAll('.line, .break')];
              let targetIndex=allRows.length; 
              for(let k=0;k<allRows.length;k++){ 
                const r=allRows[k].getBoundingClientRect(); 
                if(act.y < (r.top + r.height/2)){ 
                  const targetSetlistIdx = parseInt(allRows[k].dataset.setlistIndex, 10);
                  targetIndex = Number.isInteger(targetSetlistIdx) ? targetSetlistIdx : k;
                  break; 
                } else if(k===allRows.length-1 && act.y >= (r.top + r.height/2)){ 
                  const lastSetlistIdx = parseInt(allRows[k].dataset.setlistIndex, 10);
                  targetIndex = Number.isInteger(lastSetlistIdx) ? lastSetlistIdx + 1 : allRows.length;
                  break; 
                } 
              }
              act.reorderTarget=targetIndex;
              const showBefore=targetIndex<setlist.length;
              allRows.forEach((rEl)=>{ 
                const rIdx = parseInt(rEl.dataset.setlistIndex, 10);
                rEl.classList.toggle('drop-before', showBefore && rIdx===targetIndex); 
                rEl.classList.toggle('drop-after', !showBefore && rIdx===setlist.length-1); 
              });
            } else {
              // outside: clear indicators
              [...sheet.querySelectorAll('.line, .break')].forEach(rEl=> rEl.classList.remove('drop-before','drop-after'));
            }
            ev.preventDefault();
          }, {passive:false});
          
          row.addEventListener('touchend',()=> row.classList.remove('drag-touch'));
        });
      });
    }
    // Setup drop handlers on all preview song containers (called from buildSheet)
    function setupPreviewDropHandlers(){
      const sheet=document.getElementById('sheetInline');
      if(!sheet) return;
      
      // Get all song containers
      const allSongsContainers = sheet.querySelectorAll('.songs');
      
      allSongsContainers.forEach(songsContainer => {
        // Skip if already has listeners
        if(songsContainer.dataset.dropListenerAdded) return;
        songsContainer.dataset.dropListenerAdded = 'true';
        
        songsContainer.addEventListener('dragover',e=> {
          if(isSetlistLocked()) return;
          e.preventDefault();
          
          // Show blue line indicator when dragging from pool
          const allRows=[...sheet.querySelectorAll('.line, .break')];
          if(allRows.length === 0) return;
          
          // Check if dragging from pool (not internal reorder)
          const isInternalDrag = e.dataTransfer.types.includes('text/x-set-index');
          if(isInternalDrag) return; // Internal drag handlers manage their own indicators
          
          // Find closest row based on Y coordinate
          let closestRow = null;
          let minDistance = Infinity;
          let insertBefore = true;
          
          for(const row of allRows) {
            const rect = row.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const distance = Math.abs(e.clientY - midpoint);
            
            if(distance < minDistance) {
              minDistance = distance;
              closestRow = row;
              insertBefore = e.clientY < midpoint;
            }
          }
          
          // Clear all indicators first
          allRows.forEach(r => {
            r.classList.remove('drop-before', 'drop-after');
          });
          
          // Set indicator on closest row
          if(closestRow) {
            if(insertBefore) {
              closestRow.classList.add('drop-before');
            } else {
              closestRow.classList.add('drop-after');
            }
          }
        });
        
        songsContainer.addEventListener('drop',e=>{
          e.preventDefault(); e.stopPropagation(); 
          
          // Check if setlist is locked
          if(isSetlistLocked()) return;
          
          // Clear all drop indicators
          const allRows=[...sheet.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
          
          const br=e.dataTransfer.getData('text/x-break');
          const getInsertIndex=(clientY)=>{ 
            if(allRows.length===0) return 0; 
            for(let i=0;i<allRows.length;i++){ 
              const r=allRows[i].getBoundingClientRect(); 
              if(clientY < (r.top + r.height/2)){
                const idx = parseInt(allRows[i].dataset.setlistIndex, 10);
                return Number.isInteger(idx) ? idx : i;
              }
            }
            const lastIdx = parseInt(allRows[allRows.length-1].dataset.setlistIndex, 10);
            return Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
          };
          const insertAt=getInsertIndex(e.clientY);
          
          if(br){ 
            const lenInput=document.getElementById('gBreakLen'); 
            const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; 
            setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); 
            rebuildPreview(); 
            return; 
          }
          
          const evJson=e.dataTransfer.getData('text/x-event');
          if(evJson){
            try{
              const payload=JSON.parse(evJson);
              const kind=payload.kind;
              if(kind==='encore'){
                const count=setlist.filter(x=>x.type==='encore').length;
                const title = count>=1? `Encore ${count+1}` : 'Encore';
                setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
              }
              if(kind==='blankrow'){
                setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
              }
              if(kind==='separator'){
                setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
              }
              if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
                let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
                if(kind==='custom'){
                  const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
                }
                const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
                const defDur = (kind==='announcement')? '5' : '30';
                const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
                setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
                rebuildPreview(); return;
              }
            }catch(_){ /* ignore malformed */ }
          }
          
          const idRaw=e.dataTransfer.getData('text/plain'); 
          const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
          
          if(fromIdxRaw){ // reorder existing
            const fromIdx=parseInt(fromIdxRaw,10); 
            if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ 
              const item=setlist.splice(fromIdx,1)[0]; 
              const adj= fromIdx<insertAt? insertAt-1 : insertAt; 
              setlist.splice(adj,0,item); 
              rebuildPreview(); 
            }
            return;
          }
          
          if(!idRaw) return; 
          if(idRaw==='__break__') return; 
          const id=parseFloat(idRaw); 
          const song=db.find(s=>s.id===id); 
          if(!song) return; 
          if(setlist.some(x=>x.id===song.id)) return; 
          setlist.splice(insertAt,0,{...song,type:'song',notes:''}); 
          rebuildPreview();
        });
      });
    }

    // Global touchend listener for removing rows by dragging them out of sheet
    window.addEventListener('touchend',()=>{
      const act=window._activeSetTouch; 
      if(!act) return; 
      const sheet=document.getElementById('sheetInline'); 
      if(!sheet){ 
        window._activeSetTouch=null; 
        return; 
      }
      const rect=sheet.getBoundingClientRect(); 
      const outside = act.x < rect.left-30 || act.x > rect.right+30 || act.y < rect.top-30 || act.y > rect.bottom+30;
      
      if(outside){ 
        // Remove only the dragged item
        const idx=act.idx; 
        if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ 
          setlist.splice(idx,1); 
          currentDateDirty = true;
          rebuildPreview(); 
          saveAll(); 
        } 
      } else {
        // inside: perform reorder if target different
        const from=act.idx; 
        const to=act.reorderTarget; 
        if(Number.isInteger(from) && Number.isInteger(to) && from!==to && from>=0 && to>=0 && from<setlist.length && to<=setlist.length){ 
          const item=setlist.splice(from,1)[0]; 
          const adj = (from<to) ? to-1 : to; 
          setlist.splice(adj,0,item); 
          rebuildPreview(); 
          saveAll(); 
        }
      }
      window._activeSetTouch=null;
    }, {passive:true});
    // Allow dropping anywhere on the sheet area (including whitespace and between pages)
    const sheetInline=document.getElementById('sheetInline');
    if(sheetInline){
      sheetInline.addEventListener('dragover',e=> {
        e.preventDefault();
        
        // Show blue line indicator when dragging from pool
        const allRows=[...sheetInline.querySelectorAll('.line, .break')];
        if(allRows.length === 0) return;
        
        // Check if dragging from pool (not internal reorder)
        const isInternalDrag = e.dataTransfer.types.includes('text/x-set-index');
        if(isInternalDrag) return; // Internal drag handlers manage their own indicators
        
        // Find closest row based on Y coordinate
        let closestRow = null;
        let minDistance = Infinity;
        let insertBefore = true;
        
        for(const row of allRows) {
          const rect = row.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const distance = Math.abs(e.clientY - midpoint);
          
          if(distance < minDistance) {
            minDistance = distance;
            closestRow = row;
            insertBefore = e.clientY < midpoint;
          }
        }
        
        // Clear all indicators first
        allRows.forEach(r => {
          r.classList.remove('drop-before', 'drop-after');
        });
        
        // Set indicator on closest row
        if(closestRow) {
          if(insertBefore) {
            closestRow.classList.add('drop-before');
          } else {
            closestRow.classList.add('drop-after');
          }
        }
      });
      
      // Clear indicators when drag leaves the sheet
      sheetInline.addEventListener('dragleave',e=> {
        // Only clear if actually leaving the sheet container
        const rect = sheetInline.getBoundingClientRect();
        if(e.clientX < rect.left || e.clientX > rect.right || 
           e.clientY < rect.top || e.clientY > rect.bottom) {
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
        }
      });
      
      // Add dragover and drop handlers to individual pages for better hit detection
      sheetInline.querySelectorAll('.sheet-page').forEach((page, pageIdx) => {
        page.addEventListener('dragover',e=> e.preventDefault());
        page.addEventListener('drop',e=>{
          // Only handle if dropped on page background (not on a song)
          if(e.target.closest('.line, .break')) return;
          
          e.preventDefault();
          e.stopPropagation();
          
          // Clear all drop indicators
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
          let insertAt = 0;
          
          // Find the last song on this page
          const pageRows = [...page.querySelectorAll('.line, .break')];
          if(pageRows.length > 0){
            const lastRowOnPage = pageRows[pageRows.length - 1];
            const lastIdx = parseInt(lastRowOnPage.dataset.setlistIndex, 10);
            insertAt = Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
          } else {
            // Empty page - check if it's page 1 or later
            const firstRowOfNextPage = allRows.find(r => {
              const pageEl = r.closest('.sheet-page');
              const pIdx = pageEl ? parseInt(pageEl.dataset.pageIndex, 10) : -1;
              return pIdx > pageIdx;
            });
            if(firstRowOfNextPage){
              const firstIdx = parseInt(firstRowOfNextPage.dataset.setlistIndex, 10);
              insertAt = Number.isInteger(firstIdx) ? firstIdx : allRows.length;
            } else {
              insertAt = allRows.length;
            }
          }
          
          // Handle different drop types
          const br=e.dataTransfer.getData('text/x-break');
          if(br){ 
            const lenInput=document.getElementById('gBreakLen'); 
            const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; 
            setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); 
            rebuildPreview(); 
            return; 
          }
          
          const evJson=e.dataTransfer.getData('text/x-event');
          if(evJson){
            try{
              const payload=JSON.parse(evJson);
              const kind=payload.kind;
              if(kind==='encore'){
                const count=setlist.filter(x=>x.type==='encore').length;
                const title = count>=1? `Encore ${count+1}` : 'Encore';
                setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
              }
              if(kind==='blankrow'){
                setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
              }
              if(kind==='separator'){
                setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
              }
              if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
                let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
                if(kind==='custom'){
                  const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
                }
                const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
                const defDur = (kind==='announcement')? '5' : '30';
                const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
                setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
                rebuildPreview(); return;
              }
            }catch(_){ /* ignore malformed */ }
          }
          
          const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
          if(fromIdxRaw){
            const fromIdx=parseInt(fromIdxRaw,10); 
            if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ 
              const item=setlist.splice(fromIdx,1)[0]; 
              const adj= fromIdx<insertAt? insertAt-1 : insertAt; 
              setlist.splice(adj,0,item); 
              rebuildPreview(); 
            }
            return;
          }
          
          const idRaw=e.dataTransfer.getData('text/plain'); 
          if(!idRaw || idRaw==='__break__') return;
          const id=parseFloat(idRaw); 
          const song=db.find(s=>s.id===id); 
          if(!song) return; 
          if(setlist.some(x=>x.id===song.id)) return; 
          setlist.splice(insertAt,0,{...song,type:'song',notes:''}); 
          rebuildPreview();
        });
      });
      
      sheetInline.addEventListener('drop',e=>{
        e.preventDefault();
        
        // Clear all drop indicators
        const allRows=[...sheetInline.querySelectorAll('.line, .break')];
        allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
        
        // If drop hit a page or songs container directly, those handlers processed it
        // This handles drops in any remaining whitespace
        const getInsertIndex=(clientY)=>{ 
          if(allRows.length===0) return 0; 
          for(let i=0;i<allRows.length;i++){ 
            const r=allRows[i].getBoundingClientRect(); 
            if(clientY < (r.top + r.height/2)){
              const idx = parseInt(allRows[i].dataset.setlistIndex, 10);
              return Number.isInteger(idx) ? idx : i;
            }
          }
          const lastIdx = parseInt(allRows[allRows.length-1].dataset.setlistIndex, 10);
          return Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
        };
        const insertAt=getInsertIndex(e.clientY);
        const br=e.dataTransfer.getData('text/x-break');
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            if(kind==='blankrow'){
              setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
            }
            if(kind==='separator'){
              setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
            }
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= (fromIdx<insertAt) ? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); } return; }
        const idRaw=e.dataTransfer.getData('text/plain'); if(!idRaw || idRaw==='__break__') return; const id=parseFloat(idRaw); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    }
    // Pool open/close and drop-to-remove
    const openPoolBtn=document.getElementById('openPool');
    const closePoolBtn=document.getElementById('closePool');
    const poolFly=document.getElementById('songPoolFlyout');
    const poolCol=document.getElementById('poolCol');
    function positionPool(){
      if(!poolFly) return;
      const setCard=document.getElementById('set'); if(!setCard) return;
      const rect=setCard.getBoundingClientRect();
      const left=Math.min(window.innerWidth - poolFly.offsetWidth - 12, rect.right + 12);
      const top=Math.max(12, rect.top);
      poolFly.style.left=left+"px"; poolFly.style.top=top+"px";
      poolFly.style.right=""; // ensure left-based positioning
      poolFly.style.height = Math.min(window.innerHeight - top - 20, 720) + 'px';
    }
    // Removed openPool button usage (embedded pool); keep flyout logic if still present elsewhere
    if(closePoolBtn && poolFly){ closePoolBtn.addEventListener('click',()=> poolFly.classList.remove('open')); }
    window.addEventListener('scroll',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); }, {passive:true});
    window.addEventListener('resize',()=>{ 
      if(poolFly && poolFly.classList.contains('open')) positionPool(); 
      // Recalculate date box widths on resize
      if(typeof renderDateHeader === 'function') renderDateHeader();
    });
    if(poolFly && !poolFly.dataset.dropListenerAdded){
      poolFly.dataset.dropListenerAdded = 'true';
      poolFly.addEventListener('dragover',e=> e.preventDefault());
      poolFly.addEventListener('drop',e=>{ 
        e.preventDefault();
        e.stopPropagation(); // Prevent event bubbling
        const idxRaw=e.dataTransfer.getData('text/x-set-index');
        if(idxRaw){
          const idx=parseInt(idxRaw,10);
          if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
            setlist.splice(idx,1); // remove ONLY dragged item
            // If encore header now orphaned (no songs after it) remove header only
            const encIdx=setlist.findIndex(x=>x.type==='encore');
            if(encIdx>-1){
              const anyAfter=setlist.slice(encIdx+1).some(x=>x.type==='song');
              if(!anyAfter){ setlist.splice(encIdx,1); }
            }
            rebuildPreview();
            saveAll();
          }
        }
      });
    }
    // Also allow dropping onto the embedded pool column to remove from set
    if(poolCol && !poolCol.dataset.dropListenerAdded){
      poolCol.dataset.dropListenerAdded = 'true';
      poolCol.addEventListener('dragover',e=> e.preventDefault());
      poolCol.addEventListener('drop',e=>{ 
        e.preventDefault();
        e.stopPropagation(); // Prevent event bubbling
        const idxRaw=e.dataTransfer.getData('text/x-set-index');
        if(idxRaw){
          const idx=parseInt(idxRaw,10);
          if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
            setlist.splice(idx,1); // Remove only the one item
            rebuildPreview();
            saveAll();
          }
        }
      });
    }
    // Initial pool render (kept ready; open with button)
    // Hook pool controls if present
    const poolType=document.getElementById('poolType');
    const poolSort=document.getElementById('poolSort');
    const poolMood=document.getElementById('poolMood');
    const poolSearch=document.getElementById('poolSearch');
    if(poolType) poolType.addEventListener('change', renderSongPool);
    if(poolSort) poolSort.addEventListener('change', renderSongPool);
    if(poolMood) poolMood.addEventListener('change', renderSongPool);
    if(poolSearch) poolSearch.addEventListener('input', renderSongPool);
    renderSongPool();

    // Hook DB controls
    (function(){
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const addBtn=document.getElementById('addMoodBtn');
      if(sSel) sSel.addEventListener('change', renderDB);
      if(searchInput) searchInput.addEventListener('input', renderDB);
      // Hook all filter checkboxes
      ['filterCovers','filterOriginals','filterHasLyrics','filterKaraoke','filterHasAudio','filterHasURL','filterInSet','filterUpbeat','filterHappy','filterEnergetic','filterMellow','filterSad'].forEach(id=>{
        const el=document.getElementById(id);
        if(el) el.addEventListener('change', renderDB);
      });
      if(addBtn) addBtn.addEventListener('click', ()=>{
        const name = prompt('New mood name (max 16 chars).'); if(name==null) return; const n=name.trim(); if(!n){ return; }
        const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
        const all=getAllMoods(); if(all.length>=12){ alert('Max 12 moods reached.'); return; }
        if(DEFAULT_MOODS.includes(key) || (gig.customMoods||[]).includes(key)){ alert('Mood already exists.'); return; }
        gig.customMoods = gig.customMoods || []; gig.customMoods.push(key);
        saveAll();
        renderAddMoodsUI();
        // Add custom mood filter checkbox
        const filterContainer=document.getElementById('customMoodFilters');
        if(filterContainer){
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        }
        renderDB(); renderSongPool();
      });
      // Hydrate custom mood filter checkboxes
      const filterContainer=document.getElementById('customMoodFilters');
      if(filterContainer && gig.customMoods){
        gig.customMoods.forEach(key=>{
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        });
      }
    })();
      // Simplified touch drag for preview-only interface (song/break/event chips)
      let activePoolTouch=null;
      window.addEventListener('touchmove',ev=>{ 
        if(!activePoolTouch) return; 
        const t=ev.touches[0]; 
        if(!t) return; 
        activePoolTouch.x=t.clientX; 
        activePoolTouch.y=t.clientY; 
        // Show visual drop indicator
        const sheetInline=document.getElementById('sheetInline');
        if(sheetInline){
          // Query all rows across all pages
          const rows=[...sheetInline.querySelectorAll('.line, .break')];
          const sheetRect=sheetInline.getBoundingClientRect();
          const inDropZone = (activePoolTouch.x>=sheetRect.left && activePoolTouch.x<=sheetRect.right && activePoolTouch.y>=sheetRect.top && activePoolTouch.y<=sheetRect.bottom);
          
          if(inDropZone && rows.length>0){
            // Find closest row based on Y coordinate (works across all pages)
            let closestRow = null;
            let minDistance = Infinity;
            let insertBefore = true;
            
            for(const row of rows) {
              const rect = row.getBoundingClientRect();
              const midpoint = rect.top + rect.height / 2;
              const distance = Math.abs(activePoolTouch.y - midpoint);
              
              if(distance < minDistance) {
                minDistance = distance;
                closestRow = row;
                insertBefore = activePoolTouch.y < midpoint;
              }
            }
            
            // Clear all indicators first
            rows.forEach(r => {
              r.classList.remove('drop-before', 'drop-after');
            });
            
            // Set indicator on closest row
            if(closestRow) {
              if(insertBefore) {
                closestRow.classList.add('drop-before');
              } else {
                closestRow.classList.add('drop-after');
              }
            }
          } else if(inDropZone && rows.length===0){
            // Empty setlist - highlight sheet itself
            sheetInline.style.boxShadow='inset 0 0 0 3px #60a5fa';
          } else {
            rows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
            sheetInline.style.boxShadow='';
          }
        }
        ev.preventDefault(); 
      }, {passive:false});
      window.addEventListener('touchend',ev=>{
        if(!activePoolTouch) return; 
        const x=activePoolTouch.x, y=activePoolTouch.y; 
        const sheetInline=document.getElementById('sheetInline');
        
        // Clear drop indicators
        if(sheetInline){ 
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
          sheetInline.style.boxShadow='';
        }
        
        // Check if dropped on sheet (expand boundaries for easier mobile drops)
        if(sheetInline){ 
          const rect=sheetInline.getBoundingClientRect(); 
          const margin=50; 
          if(x>=rect.left-margin && x<=rect.right+margin && y>=rect.top-margin && y<=rect.bottom+margin){
            // Query all rows across all pages
            const rows=[...sheetInline.querySelectorAll('.line, .break')];
            
            // Calculate insert position based on Y coordinate across all pages
            const getInsertIndex=(clientY)=>{ 
              if(rows.length===0) return 0; 
              for(let i=0;i<rows.length;i++){ 
                const r=rows[i].getBoundingClientRect(); 
                if(clientY < (r.top + r.height/2)){
                  const idx = parseInt(rows[i].dataset.setlistIndex, 10);
                  return Number.isInteger(idx) ? idx : i;
                }
              }
              const lastIdx = parseInt(rows[rows.length-1].dataset.setlistIndex, 10);
              return Number.isInteger(lastIdx) ? lastIdx + 1 : rows.length;
            };
            const insertAt=getInsertIndex(y);
          if(activePoolTouch.kind==='song'){ const song=db.find(s=>s.id===activePoolTouch.id); if(song && !setlist.some(sl=>sl.id===song.id)){ setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview(); } }
          else if(activePoolTouch.kind==='break'){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); }
          else if(activePoolTouch.kind==='event'){
            const kind = activePoolTouch.event && activePoolTouch.event.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length; const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview();
            }else if(kind==='blankrow'){
              setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview();
            }else if(kind==='separator'){
              setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview();
            }else if(kind){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview();
            }
          }
          }
        }
        activePoolTouch=null;
      });
      // Touch reorder legacy removed ‚Äì interactions handled via standard drag & drop in preview.

  // Tech / Stage: Tech Rider table generation synced to setlist (populates inline or fullscreen as available)
    // buildTechTable removed - element #techBody does not exist, only buildTechTableFull is used

    function buildTechTableFull(){
      const body=document.getElementById('techBodyFull'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    // Stage Plot: simple B&W draggable glyphs
    const TOOLBOX=[
  {key:'mic', label:'Vocal Mic', svg:'M0 0 h16 v48 h-16z M8 48 a8 8 0 1 0 0.01 0'},
  {key:'monitor', label:'Monitor', svg:'M0 44 l36 -18 v18 l-36 18z'},
  {key:'guitar', label:'Electric Guitar', svg:'M0 0 h16 v32 h-16z M16 10 l30 -8 l3 10 l-30 8z'},
  {key:'bassamp', label:'Bass Amp', svg:'M0 0 h34 v44 h-34z'},
  {key:'keyboard', label:'Keyboard', svg:'M0 0 h60 v16 h-60z M3 2 v12 M8 2 v12 M13 2 v12 M18 2 v12 M23 2 v12 M28 2 v12 M33 2 v12 M38 2 v12 M43 2 v12 M48 2 v12 M53 2 v12 M58 2 v12'},
  {key:'drums', label:'Drums', svg:'M15 20 a14 10 0 1 0 0.01 0 M42 20 a14 10 0 1 0 0.01 0 M28 34 a10 7 0 1 0 0.01 0'},
  {key:'di', label:'DI Box', svg:'M0 0 h40 v18 h-40z'},
      {key:'gtramp', label:'Guitar Amp', svg:'M0 0 h34 v44 h-34z'},
      {key:'label', label:'Custom Label', custom:'label'},
      {key:'rect', label:'Rectangle', custom:'rect'},
    ];

    // Image-based toolbox items (replace emojis)
    // Files must exist alongside index.html
    const ICON_ITEMS=[
      {key:'kick', label:'Kick', src:'Kick.png'},
      {key:'snare', label:'Snare', src:'Snare.png'},
      {key:'hihat', label:'Hat', src:'Hihat.png'},
      {key:'tom', label:'Tom', src:'Tom.png'},
      {key:'floor', label:'Floor Tom', src:'Floor.png'},
      {key:'overhead', label:'Instrument Mic', src:'Overhead.png'},
      {key:'crash', label:'Crash', src:'Crash.png'},
      {key:'cymbal1', label:'Crash 2', src:'Cymbal_1.png'},
      {key:'cymbal2', label:'Crash 3', src:'Cymbal_2.png'},
      // Gap then guitars
      {key:'bass', label:'Bass Guitar', src:'Bass.png'},
      {key:'bassamp', label:'Bass Amp', src:'Bassamp.png'},
      {key:'electric', label:'Electric Guitar', src:'Electric.png'},
      {key:'combo', label:'Gtr Combo', src:'Combo.png'},
      {key:'stack', label:'Gtr Stack', src:'Stack.png'},
      // Gap then vocal/stereo/DI
      {key:'vocal', label:'Vocal Mic', src:'Vocal%20Mic.png'},
      {key:'stereoPair', label:'Stereo Pair', src:'Stereo%20Pair.png'},
      {key:'di', label:'DI', src:'DI.png'},
      // Gap then sampler/laptop/power
      {key:'sampler', label:'Sampler', src:'Sampler.png'},
      {key:'laptop', label:'Laptop', src:'Laptop.png'},
      {key:'power', label:'Power', src:'Power.png'},
      // Gap then other instruments
      {key:'acoustic', label:'Acoustic', src:'Acoustic.png'},
      {key:'violin', label:'Violin', src:'Violin.png'},
      {key:'banjo', label:'Banjo', src:'Banjo.png'},
      {key:'clarinet', label:'Clarinet', src:'Clarinet.png'},
      {key:'bongoes', label:'Bongoes', src:'Bongoes.png'},
      {key:'congas', label:'Congas', src:'Congas.png'},
      {key:'deck', label:'Deck', src:'Deck.png'},
      {key:'keys', label:'Keys', src:'keys.png'},
      {key:'sax', label:'Sax', src:'sax.png'},
      {key:'fxpedal', label:'FX Pedal', src:'FXpedal.png'},
      {key:'fxboard', label:'FX Board', src:'FXboard.png'},
      // Gap then props
      {key:'tipjar', label:'Tip Jar', src:'Tipjar.png'},
      {key:'table', label:'Table', src:'Table.png'},
      {key:'stool', label:'Stool', src:'Stool.png'},
      {key:'fan', label:'Fan', src:'Fan.png'},
      // Gap then monitors
      {key:'monitor', label:'Monitor', src:'Monitor.png'},
    ];
    // Sequence with explicit gaps using special token '__gap__'
    const TOOL_ORDER=[
      'kick','snare','hihat','tom','floor','overhead','crash','cymbal1','cymbal2','__gap__',
      'bass','bassamp','electric','combo','stack','__gap__',
      'vocal','stereoPair','di','__gap__',
      'sampler','laptop','power','__gap__',
      'acoustic','violin','banjo','clarinet','bongoes','congas','deck','keys','sax','fxpedal','fxboard','__gap__',
      'tipjar','table','stool','fan','__gap__',
      'monitor'
    ];

    // Type mapping for routing logic
    const TYPE_MAP={
      acoustic:'acoustic', banjo:'acoustic', violin:'acoustic',
      electric:'electric', combo:'amp', stack:'amp', bassamp:'amp', bass:'electric',
      vocal:'mic', overhead:'mic', stereoPair:'mic', hihat:'drum', hihat2:'drum', kick:'drum', snare:'drum', tom:'drum', floor:'drum',
      crash:'cymbal', cymbal1:'cymbal', cymbal2:'cymbal', bongoes:'drum', congas:'drum',
      deck:'deck', sampler:'sampler', laptop:'sampler',
      keys:'keys', sax:'sax', fxpedal:'fx', fxboard:'fx',
      di:'di',
      monitor:'monitor',
      power:'utility', fan:'utility', table:'utility', stool:'utility', tipjar:'utility'
    };

    // ========================= CONNECTION VALIDATION SYSTEM =========================
    // Signal chain order: SOURCE > [MIC] > [DI] > [FX] > [DI] > CHANNEL
    // Categories for connection validation
    const SIGNAL_CATEGORIES = {
      source: ['acoustic', 'electric', 'drum', 'cymbal', 'deck', 'keys', 'sax', 'sampler'], // instruments/sources
      mic: ['mic'],
      di: ['di'],
      fx: ['fx'],
      amp: ['amp'],
      endpoint: ['channel', 'monitor'],
      utility: ['label', 'arrow'] // display-only items, no routing
    };
    
    // Get category for a type
    function getCategory(type) {
      for (const [cat, types] of Object.entries(SIGNAL_CATEGORIES)) {
        if (types.includes(type)) return cat;
      }
      return 'other';
    }
    
    // Signal chain order (lower = earlier in chain)
    function getChainPosition(type) {
      const cat = getCategory(type);
      switch(cat) {
        case 'source': return 0;  // instruments first
        case 'amp': return 1;     // amps after instruments (guitar/bass amp)
        case 'mic': return 2;     // mics capture sound from sources/amps
        case 'di': return 3;      // DI boxes for impedance matching
        case 'fx': return 4;      // FX processing
        case 'endpoint': return 5; // channels/monitors are endpoints
        default: return 3;        // other items treated like DI
      }
    }
    
    // Check if connection is allowed: source -> target
    // Rules:
    // 1. No mic-to-mic connections
    // 2. No mic-to-electric-instrument connections (mics can only connect TO acoustics as sources)
    // 3. No instrument-to-same-instrument-type (guitar to guitar, drum to drum)
    // 4. No backwards connections (if A->B exists, B->A is disallowed)
    // 5. No duplicate connections
    // 6. Must follow signal chain order
    function canConnect(sourceNode, targetNode, svg) {
      if (!sourceNode || !targetNode || sourceNode === targetNode) return false;
      
      const srcType = sourceNode.dataset.type || 'other';
      const tgtType = targetNode.dataset.type || 'other';
      const srcCat = getCategory(srcType);
      const tgtCat = getCategory(tgtType);
      const srcPos = getChainPosition(srcType);
      const tgtPos = getChainPosition(tgtType);
      
      // Utility types (labels, arrows) cannot connect to anything
      const srcKey = sourceNode.dataset.key || '';
      const tgtKey = targetNode.dataset.key || '';
      if (srcCat === 'utility' || tgtCat === 'utility') return false;
      if (srcKey === 'label' || srcKey === 'arrow' || tgtKey === 'label' || tgtKey === 'arrow') return false;
      
      // Rule 1: No mic-to-mic
      if (srcCat === 'mic' && tgtCat === 'mic') return false;
      
      // Rule 2: Mics cannot connect to electric instruments (mics are only for capturing acoustic sound)
      // But mics CAN connect to acoustic instruments (as the source being mic'd)
      if (srcCat === 'mic' && tgtCat === 'source') {
        // Mics can only "point at" acoustic sources, not connect TO them in the signal chain
        // Actually, mics receive from acoustics - so acoustic -> mic is valid, not mic -> acoustic
        return false; // mic cannot route TO an instrument
      }
      
      // Rule 3: No same-category connections for sources (guitar to guitar, drum to drum, etc.)
      if (srcCat === 'source' && tgtCat === 'source') return false;
      
      // Rule 3b: No amp-to-amp
      if (srcCat === 'amp' && tgtCat === 'amp') return false;
      
      // Rule 4: No backwards connections (check if target already routes to source)
      if (targetNode.dataset.routeTo === sourceNode.dataset.id) return false;
      
      // Rule 5: No duplicate connections (source already routes to target)
      if (sourceNode.dataset.routeTo === targetNode.dataset.id) return false;
      
      // Rule 6: Must follow signal chain order (source position should be <= target position)
      // Special case: DI can go to another DI (DI -> FX -> DI is valid for re-amping etc.)
      if (srcCat === 'di' && tgtCat === 'di') return true; // DI chaining allowed
      if (srcCat === 'fx' && tgtCat === 'di') return true; // FX back to DI allowed
      
      // Electric instruments go to amps first (guitar -> amp -> mic -> channel)
      if (srcType === 'electric' && tgtCat === 'amp') return true;
      
      // Amps can only go to mics (amp -> mic -> channel)
      if (srcCat === 'amp' && tgtCat !== 'mic') {
        // Exception: bass amp can go direct to DI or channel
        const srcKey = sourceNode.dataset.key || '';
        if (srcKey === 'bassamp' && (tgtCat === 'di' || tgtCat === 'endpoint')) return true;
        return false;
      }
      
      // General rule: must flow forward in chain
      if (srcPos > tgtPos) return false;
      
      return true;
    }
    
    // Determine which direction the connection should go (returns {from, to} or null if invalid)
    function determineConnectionDirection(nodeA, nodeB, svg) {
      const canAtoB = canConnect(nodeA, nodeB, svg);
      const canBtoA = canConnect(nodeB, nodeA, svg);
      
      if (canAtoB && !canBtoA) return { from: nodeA, to: nodeB };
      if (canBtoA && !canAtoB) return { from: nodeB, to: nodeA };
      if (canAtoB && canBtoA) {
        // Both directions valid - choose based on signal chain position
        const posA = getChainPosition(nodeA.dataset.type || 'other');
        const posB = getChainPosition(nodeB.dataset.type || 'other');
        if (posA <= posB) return { from: nodeA, to: nodeB };
        return { from: nodeB, to: nodeA };
      }
      return null; // Neither direction is valid
    }
    // ========================= END CONNECTION VALIDATION =========================
    
    // Allowed routing targets by source type (for legacy compatibility and UI hints)
    const ROUTE_TARGETS={
      drum:['mic','di','channel','monitor'], // drums go to mic or direct to DI/channel
      cymbal:['mic','di','channel','monitor'], // cymbals same as drums
      mic:['di','fx','channel','monitor'], // mics go forward to DI/FX/channel only
      di:['di','fx','channel','monitor'], // DI can chain to another DI, FX, or endpoint
      fx:['di','fx','channel','monitor'], // FX can go to DI, another FX, or endpoint
      amp:['mic'], // guitar amps ONLY go to mics (bass amp handled in effectiveTargets)
      acoustic:['mic','di','fx','channel','monitor'], // acoustic instruments can go to mic, DI, or direct
      electric:['amp','di','fx'], // electric instruments go to amp, DI, or FX (not direct to channel typically)
      deck:['di','fx','channel','monitor'], // DJ decks go to DI/FX/channel
      sampler:['di','fx','channel','monitor'], // samplers like decks
      keys:['di','fx','amp','channel','monitor'], // keys can go to amp or direct
      sax:['mic','di','channel','monitor'], // sax like acoustic
      monitor:['channel'], // monitors are endpoints
      label:[], // display-only, no routing
      arrow:[], // display-only, no routing
      other:['di','fx','channel','monitor','mic'], // custom items flexible
    };

    // Effective per-node targets (adds key-specific rules, e.g., bass amp can go direct to channel)
    function effectiveTargets(node){
      const base=(ROUTE_TARGETS[node.dataset.type||'other']||[]).slice();
      const key=node.dataset.key||'';
      if((node.dataset.type||'')==='amp'){
        if(key==='bassamp'){ // bass amps can feed DI or mic or direct channel (via built-in DI out)
          if(!base.includes('di')) base.push('di');
          if(!base.includes('mic')) base.push('mic');
          if(!base.includes('channel')) base.push('channel');
        } else { // guitar amps must only go to mics
          return ['mic'];
        }
      }
      return base;
    }

    // Items considered processors (appear prioritized at top of legend)
    const PRIORITY_TYPES=new Set(['di','fx','amp','sampler']);

    function buildTools(){
      ['stageTools','stageToolsFull'].forEach(cid=>{
        const tools=document.getElementById(cid);
        if(!tools) return;
        tools.innerHTML='';
        const byKey=new Map(ICON_ITEMS.map(i=>[i.key,i]));
        // Show All button if any hidden
        const hidden=(gig.hiddenIcons||[]);
        const actions=document.createElement('div'); actions.className='toolbox-actions';
        if(hidden.length){
          const showAllBtn=document.createElement('button'); showAllBtn.className='tool'; showAllBtn.textContent='Show All Icons';
          showAllBtn.addEventListener('click',()=>{ gig.hiddenIcons=[]; saveAll(); buildTools(); });
          actions.appendChild(showAllBtn);
        }
        if(cid==='stageToolsFull') tools.appendChild(actions);
        TOOL_ORDER.forEach(k=>{
          if(k==='__gap__'){ const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='8px'; gap.style.borderTop='1px solid #e5e7eb'; gap.style.margin='4px 0'; tools.appendChild(gap); return; }
          const t=byKey.get(k); if(!t) return;
          if((gig.hiddenIcons||[]).includes(k)) return; // skip hidden
          const b=document.createElement('button');
          b.className='tool';
          b.innerHTML=`<img src="${t.src}" alt="${t.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${t.label}`;
          // Don't use HTML5 draggable - we use custom mouse/touch handlers instead to avoid duplicates
          b.dataset.key = t.key;
          b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:t.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
          // Long press (~1s) to hide icon: only when cursor/finger stays put
          let lpTimer=null; let startPos=null; const cancel=()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } startPos=null; };
          const arm=(sx,sy)=>{ cancel(); startPos={x:sx,y:sy}; lpTimer=setTimeout(()=>{
            if(!startPos) return; // was cancelled by movement or release
            if(!confirm('Hide this tool from the toolbox?')) return;
            if((gig.hiddenIcons||[]).indexOf(t.key)===-1){ gig.hiddenIcons.push(t.key); saveAll(); buildTools(); }
          },1000); };
          b.addEventListener('mousedown',e=>{ if(e.button!==0) return; arm(e.clientX,e.clientY); });
          b.addEventListener('mousemove',e=>{ if(!lpTimer||!startPos) return; const dx=Math.abs(e.clientX-startPos.x), dy=Math.abs(e.clientY-startPos.y); if(dx>2||dy>2) cancel(); });
          b.addEventListener('mouseup',cancel);
          b.addEventListener('mouseleave',cancel);
          b.addEventListener('touchstart',e=>{ const tTouch=e.touches[0]; if(!tTouch) return; arm(tTouch.clientX,tTouch.clientY); }, {passive:true});
          b.addEventListener('touchmove',e=>{ if(!lpTimer||!startPos) return; const tTouch=e.touches[0]; if(!tTouch) return; const dx=Math.abs(tTouch.clientX-startPos.x), dy=Math.abs(tTouch.clientY-startPos.y); if(dx>4||dy>4) cancel(); }, {passive:true});
          b.addEventListener('touchend',cancel);
          b.addEventListener('touchcancel',cancel);
          tools.appendChild(b);
        });
        // Custom images always at bottom of full toolbox
        if(cid==='stageToolsFull'){
          if((gig.customImages||[]).length){
            const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='10px'; gap.style.borderTop='2px dashed #d1d5db'; gap.style.margin='6px 0'; tools.appendChild(gap);
          }
          (gig.customImages||[]).forEach(imgObj=>{
            const wrap=document.createElement('div'); wrap.style.position='relative';
            const b=document.createElement('button'); b.className='tool'; b.style.paddingRight='26px';
            b.innerHTML=`<img src="${imgObj.data}" alt="${imgObj.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${imgObj.label}`;
            // Don't use HTML5 draggable - we use custom mouse/touch handlers instead
            b.dataset.key=imgObj.key;
            b.style.touchAction='none';
            b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:imgObj.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
            const del=document.createElement('button'); del.textContent='√ó'; del.title='Remove'; del.style.position='absolute'; del.style.top='2px'; del.style.right='2px'; del.style.width='20px'; del.style.height='20px'; del.style.lineHeight='16px'; del.style.padding='0'; del.style.fontSize='14px'; del.style.background='#374151'; del.style.color='#fff'; del.style.border='none'; del.style.borderRadius='4px'; del.style.cursor='pointer';
            del.addEventListener('click',()=>{ if(!confirm('Delete custom icon?')) return; gig.customImages = (gig.customImages||[]).filter(ci=>ci.key!==imgObj.key); saveAll(); buildTools(); rebuildCustomImages(); });
            wrap.appendChild(b); wrap.appendChild(del); tools.appendChild(wrap);
          });
        }
      });
    }
    buildTools();

    let _suppressBgClick=false;
    // Ensure arrow marker exists in SVG for arrow drawing
    function ensureStageMarkers(svg){ if(!svg) return; let defs=svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
      if(!svg.querySelector('marker#arrowHead')){
        const m=document.createElementNS('http://www.w3.org/2000/svg','marker'); m.setAttribute('id','arrowHead'); m.setAttribute('markerWidth','8'); m.setAttribute('markerHeight','8'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto');
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d','M0,0 L8,3 L0,6 Z'); p.setAttribute('fill','#000'); m.appendChild(p); defs.appendChild(m);
      }
    }

    function refreshStageHeader(){
      // Get current band from Act selector (authoritative source)
      const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || 'Band') : (gig.band || 'Band');
      const text=`${currentBandName.trim()} ‚Ä¢ ${(gig.date||'Date')}`;
      const elT=document.getElementById('stageTitle'); if(elT) elT.textContent=text;
      const elTF=document.getElementById('stageTitleFull'); if(elTF) elTF.textContent=text;
      
      // Update the header bar above stage canvas
      const headerDate = document.getElementById('stageHeaderDate');
      const headerBand = document.getElementById('stageHeaderBand');
      const headerVenue = document.getElementById('stageHeaderVenue');
      
      if(headerDate){
        if(selectedTourDateId){
          const td = tourDates.find(t => t.id === selectedTourDateId);
          if(td && td.date){
            const d = new Date(td.date + 'T12:00:00');
            headerDate.textContent = d.toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric', year:'numeric'});
          } else {
            headerDate.textContent = gig.date || 'No date selected';
          }
        } else {
          headerDate.textContent = gig.date || 'No date selected';
        }
      }
      if(headerBand) headerBand.textContent = gig.band || 'Band';
      if(headerVenue) headerVenue.textContent = gig.venue || 'Venue';
    }
    
    // Lock state for setlist and stage plot
    window.setlistLocked = false;
    window.stageLocked = false;
    
    function isSetlistLocked(){
      return window.setlistLocked || (document.getElementById('setlistLockCheckbox') && document.getElementById('setlistLockCheckbox').checked);
    }
    
    function isStageLocked(){
      return window.stageLocked || (document.getElementById('stageLockCheckbox') && document.getElementById('stageLockCheckbox').checked);
    }

    // Note: small stage removed; glyphs are added via fullscreen only

    let _nextStageId=1;
    function addGlyphFull(key, at){
      const iconSpec=ICON_ITEMS.find(x=>x.key===key);
      const customSpec=(gig.customImages||[]).find(ci=>ci.key===key);
      const svg=document.getElementById('stageSvgFull');
      const g=document.createElementNS('http://www.w3.org/2000/svg','g');
      const x = (at && typeof at.x==='number') ? at.x : 100, y = (at && typeof at.y==='number') ? at.y : 120;
      // Compute initial scale so the visible icon is ~100px wide on screen
      const vbw = (svg && svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) ? svg.viewBox.baseVal.width : 1500;
      const pxPerUnit = svg ? (svg.getBoundingClientRect().width / vbw) : (1000/1500);
      const targetPx = (key==='tom' ? 50 : 100); const baseUnits = 60; // image width set below; toms default to 50% size
      let initScale = targetPx / (baseUnits * Math.max(0.01, pxPerUnit));
      initScale = Math.max(0.3, Math.min(5, initScale));
      g.dataset.x=String(x); g.dataset.y=String(y); g.dataset.scale=String(initScale);
      g.dataset.key=key; g.dataset.channel=g.dataset.channel||'';
      g.dataset.id=String(_nextStageId++);
      const type=TYPE_MAP[key]||'other';
      g.dataset.type=type;
      g.dataset.showLabel='0'; // default hidden
      g.setAttribute('data-draggable','1');
      // Auto-assign next channel for common sources (drums, mics)
      const autoTypes=new Set(['drum','mic']);
      const canChannel=(ROUTE_TARGETS[type]||[]).includes('channel');
      if(autoTypes.has(type) && canChannel){
        const existing=getStageGroups();
        const assigned=existing.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
        const next=(assigned.length? Math.max(...assigned):0)+1;
        g.dataset.channel=String(next);
      }
      if(customSpec){
        const img=document.createElementNS('http://www.w3.org/2000/svg','image');
        img.setAttribute('href', customSpec.data);
        img.setAttributeNS('http://www.w3.org/1999/xlink','href', customSpec.data);
        img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=customSpec.label; label.style.display='none'; g.appendChild(label);
        // Removed intrinsic autoscale override; initial scale already targets ~100px visual size.
      } else if(iconSpec){
        // Place icon image centered; no background rectangle (transparent icons expected)
  const img=document.createElementNS('http://www.w3.org/2000/svg','image');
  // set both href and xlink:href for compatibility
  img.setAttribute('href', iconSpec.src);
  img.setAttributeNS('http://www.w3.org/1999/xlink','href', iconSpec.src);
  img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=iconSpec.label;
        label.style.display='none';
        g.appendChild(label);
      }else{
        const spec=TOOLBOX.find(x=>x.key===key); if(!spec) return;
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', toPath(spec.svg));
        path.setAttribute('fill','none');
        path.setAttribute('stroke','#000');
        path.setAttribute('stroke-width','2');
        g.appendChild(path);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','58'); label.setAttribute('font-size','14'); label.setAttribute('data-role','label'); label.textContent=spec.label;
        label.style.display='none';
        g.appendChild(label);
      }
      applyTransform(g);
      svg.appendChild(g);
      enableSvgDrag(g);
      selectNode(g); // immediately select newly added item for quick edits
      // focus name field so user can rename right away (skip on mobile to avoid keyboard popup)
      const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
      if(!isMobile){
        const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); if(nameInp.select) nameInp.select(); }
      }
      refreshStageLegend(); saveAll(); snapshotStage();
      return g;
    }

    function toPath(simple){
      // simple mini-language passthrough for small glyphs (already path commands)
      return simple;
    }

    // Helper: connect source->target using strict validation rules
    function connectEitherDirection(source, target){
      if(!source || !target || source===target) return false;
      
      const svg = source.closest('svg');
      
      // Use the new validation system
      const direction = determineConnectionDirection(source, target, svg);
      if (!direction) return false; // Connection not allowed in either direction
      
      // Make the connection
      direction.from.dataset.routeTo = direction.to.dataset.id;
      return true;
    }
    // Helper: find chain endpoint (following valid routeTo)
    function resolveEndpoint(start){
      const svg=start && start.closest && start.closest('svg'); if(!svg) return start;
      const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      let cur=start; const seen=new Set();
      while(cur && !seen.has(cur)){
        seen.add(cur);
        const nid=cur.dataset.routeTo||''; if(!nid) break;
        const nxt=nodes.find(n=> n.dataset.id===nid); if(!nxt) break;
        cur=nxt;
      }
      return cur||start;
    }
    function nameOf(node){ const t=findText(node); return (t && t.textContent) || (node.dataset.key||'Item'); }
    function maybePromptChannel(endNode){
      try{
        if(!endNode) return;
        const targets=effectiveTargets(endNode);
        if(!targets.includes('channel')) return;
        if(endNode.dataset.channel && String(endNode.dataset.channel).trim()!=='') return;
        const label=nameOf(endNode);
        const ans=prompt('Assign channel for '+label+'? (number)','');
        if(ans==null) return; const v=parseInt(String(ans).trim(),10);
        if(Number.isFinite(v) && v>=1){ endNode.dataset.channel=String(v); saveAll(); refreshStageLegend(); }
      }catch(_){ /* ignore prompt issues */ }
    }
    function autoConnectOnPoint(sourceNode, clientX, clientY){
      if(!sourceNode) return false;
      const prevPE=sourceNode.style.pointerEvents;
      sourceNode.style.pointerEvents='none';
      const el=document.elementFromPoint(clientX, clientY);
      sourceNode.style.pointerEvents=prevPE;
      const target= el && el.closest && el.closest('g[data-draggable]');
      if(!target || target===sourceNode) return false;
      const did=connectEitherDirection(sourceNode, target);
      if(did){ const end=resolveEndpoint(sourceNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); const svg=sourceNode.closest('svg'); if(svg) refreshCables(svg); return true; }
      return false;
    }
    function enableSvgDrag(node){
      function isBottomLayer(node){
        const k=node.dataset.key||'';
        return k==='kick' || k==='gtramp' || k==='bassamp' || k==='stack' || k==='combo';
      }
      function bringToFront(node){
        if(isBottomLayer(node)) return;
        const parent=node.parentNode; if(!parent) return;
        parent.appendChild(node);
      }
      // initialize dataset from existing transform if missing
      initDatasetFromTransform(node);
      let start=null; let orig=null;
      // Long-press cable drag state
      let lpTimer=null; let lpActive=false; let lpLine=null; let lpSource=null; let lpTouchId=null;
        node.addEventListener('mousedown',e=>{ if(e.button===2){ return; } if(isStageLocked()){ e.preventDefault(); return; } bringToFront(node); start={x:e.clientX,y:e.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); e.preventDefault(); selectNode(node); });
      function move(e){ if(!start || isStageLocked()) return; var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(e.clientX-start.x)/zoom, dy=(e.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); }
        function up(e){ start=null; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); if(e && typeof e.clientX==='number' && !isStageLocked()){ autoConnectOnPoint(node, e.clientX, e.clientY); } saveAll(); snapshotStage(); }
      // rename on double click (desktop only - avoid on mobile to prevent keyboard popup after drag)
      node.addEventListener('dblclick',()=>{
        if(isStageLocked()) return;
        const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
        if(isMobile) return; // skip on mobile/tablet
        const txt=findText(node); if(!txt) return; const nv=prompt('Rename item:', txt.textContent||''); if(nv!=null){ txt.textContent=nv; syncInspectorFrom(node); saveAll(); }
      });
      // Touch drag + long-press cable gesture OR disconnect gesture
      let touchId=null;
      node.addEventListener('touchstart',e=>{
        if(isStageLocked()){ e.preventDefault(); return; }
        if(touchId!=null) return; const t=e.touches[0]; if(!t) return; touchId=t.identifier; lpTouchId=touchId; start={x:t.clientX,y:t.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; selectNode(node); e.preventDefault();
        lpTimer=setTimeout(()=>{
          if(isStageLocked()) return;
          if(lpTouchId===touchId){ 
            // Check if item has any connections - if so, disconnect; otherwise start cable drag
            const hasConnection = node.dataset.routeTo || Array.from(node.closest('svg').querySelectorAll('g[data-draggable]')).some(g => g.dataset.routeTo === node.dataset.id);
            if(hasConnection){
              // Disconnect: clear this node's routeTo and any incoming connections
              if(node.dataset.routeTo){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); }
              const svg=node.closest('svg'); if(svg){
                Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(g=>{ if(g.dataset.routeTo===node.dataset.id){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); } });
              }
              saveAll(); refreshStageLegend(); if(svg) refreshCables(svg);
              lpActive=false; lpTimer=null;
            } else {
              // No connection, start cable drag
              const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=start.x; pt.y=start.y; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine=document.createElementNS('http://www.w3.org/2000/svg','line'); lpLine.setAttribute('x1',p.x); lpLine.setAttribute('y1',p.y); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); lpLine.setAttribute('stroke','#000'); lpLine.setAttribute('stroke-width','2'); lpLine.setAttribute('stroke-dasharray','6,4'); lpLine.setAttribute('data-temp','cable'); svg.appendChild(lpLine); lpActive=true; lpSource=node; }
            }
          }
        },300);
      }, {passive:false});
      node.addEventListener('touchmove',e=>{
        if(isStageLocked()) return;
        if(touchId==null) return; for(const t of e.touches){ if(t.identifier===touchId){
            // cancel long-press if user moves significantly before it triggers
            if(!lpActive && lpTimer){ const dx=Math.abs(t.clientX-start.x), dy=Math.abs(t.clientY-start.y); if(dx>8 || dy>8){ clearTimeout(lpTimer); lpTimer=null; }
            }
            if(lpActive && lpLine){ const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=t.clientX; pt.y=t.clientY; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); } e.preventDefault(); break; }
            var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(t.clientX-start.x)/zoom, dy=(t.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); e.preventDefault(); break; } }
      }, {passive:false});
      node.addEventListener('touchend',e=>{
        if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; }
        if(lpActive){ // finalize cable connection
          if(lpLine){ lpLine.remove(); }
          const touch=e.changedTouches && e.changedTouches[0]; 
          if(touch){ 
            const targetEl=document.elementFromPoint(touch.clientX,touch.clientY); 
            const tgt= targetEl && targetEl.closest && targetEl.closest('g[data-draggable]'); 
            if(tgt && tgt!==lpSource){ 
              // Use new validation system
              const svg = lpSource.closest('svg');
              const direction = determineConnectionDirection(lpSource, tgt, svg);
              if(direction) {
                direction.from.dataset.routeTo = direction.to.dataset.id;
                // Easter egg: Fan connected to vocal mic
                if((lpSource.dataset.key==='fan' && tgt.dataset.key==='vocal') || (tgt.dataset.key==='fan' && lpSource.dataset.key==='vocal')){
                  const fanNode = lpSource.dataset.key==='fan' ? lpSource : tgt;
                  const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
                }
                saveAll(); refreshStageLegend(); 
                if(svg) refreshCables(svg);
              }
            } 
          }
          lpActive=false; lpLine=null; lpSource=null; lpTouchId=null;
        }
        // Auto-connect on drop if released over another component
        const ct=(e.changedTouches && e.changedTouches[0])||null; if(ct){ autoConnectOnPoint(node, ct.clientX, ct.clientY); }
        if(touchId==null) return; let still=false; for(const t of e.touches){ if(t.identifier===touchId){ still=true; break; } } if(!still){ touchId=null; saveAll(); snapshotStage(); }
      });
      node.addEventListener('touchcancel',()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } if(lpLine){ lpLine.remove(); lpLine=null; } lpActive=false; lpSource=null; lpTouchId=null; if(touchId!=null){ touchId=null; saveAll(); }});
      
      // Multi-touch pinch to scale and rotate
      let initialPinchDist = null;
      let initialPinchAngle = null;
      let initialScale = null;
      let initialRotation = null;
      let isPinching = false;
      
      node.addEventListener('touchstart', (e) => {
        if(e.touches.length === 2) {
          isPinching = true;
          touchId = null; // Cancel single-touch drag
          if(lpTimer) { clearTimeout(lpTimer); lpTimer = null; }
          if(lpLine) { lpLine.remove(); lpLine = null; }
          lpActive = false;
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchAngle = Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX) * (180 / Math.PI);
          initialScale = parseFloat(node.dataset.scale || '1');
          initialRotation = parseFloat(node.dataset.rotation || '0');
          e.preventDefault();
        }
      }, {passive: false});
      
      node.addEventListener('touchmove', (e) => {
        if(isPinching && e.touches.length === 2) {
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          const currentAngle = Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX) * (180 / Math.PI);
          
          // Scale
          const scaleChange = currentDist / initialPinchDist;
          const newScale = Math.max(0.2, Math.min(5, initialScale * scaleChange));
          node.dataset.scale = String(newScale);
          
          // Rotate
          let angleDiff = currentAngle - initialPinchAngle;
          const newRotation = initialRotation + angleDiff;
          node.dataset.rotation = String(newRotation);
          
          applyTransform(node);
          const svg = node.closest('svg');
          if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
          queueSave();
          e.preventDefault();
        }
      }, {passive: false});
      
      node.addEventListener('touchend', (e) => {
        if(e.touches.length < 2) {
          if(isPinching) {
            saveAll();
            snapshotStage();
          }
          isPinching = false;
          initialPinchDist = null;
          initialPinchAngle = null;
        }
      });
      
      // Mousewheel: scale on wheel, rotate on Ctrl+wheel
      node.addEventListener('wheel', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const delta = -e.deltaY * 0.001; // Normalize scroll amount
        
        if(e.ctrlKey || e.metaKey) {
          // Rotate with Ctrl/Cmd + wheel
          const currentRotation = parseFloat(node.dataset.rotation || '0');
          const newRotation = currentRotation + (delta * 15); // 15 degrees per scroll unit
          node.dataset.rotation = String(newRotation);
        } else {
          // Scale with wheel
          const currentScale = parseFloat(node.dataset.scale || '1');
          const newScale = Math.max(0.2, Math.min(5, currentScale + delta));
          node.dataset.scale = String(newScale);
        }
        
        applyTransform(node);
        const svg = node.closest('svg');
        if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
        queueSave();
        saveAll();
      }, {passive: false});
      
      // Enable label dragging (independent of parent item)
      enableLabelDrag(node);
    }
    
    function enableLabelDrag(node){
      const lbl=findText(node);
      if(!lbl) return;
      
      let labelStart=null;
      let labelOrig=null;
      const maxOffset=150; // Maximum distance from parent
      
      const clampOffset=(val)=> Math.max(-maxOffset, Math.min(maxOffset, val));
      
      // Mouse drag for label
      lbl.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        if(node.dataset.showLabel!=='1') return; // Only drag if label is shown
        e.stopPropagation(); // Prevent parent drag
        labelStart={x:e.clientX, y:e.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
        document.addEventListener('mousemove',labelMove);
        document.addEventListener('mouseup',labelUp);
        lbl.style.cursor='grabbing';
      });
      
      const labelMove=(e)=>{
        if(!labelStart) return;
        const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
        const dx=(e.clientX-labelStart.x)/zoom;
        const dy=(e.clientY-labelStart.y)/zoom;
        node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
        node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
        applyLabelTransform(node);
        queueSave();
      };
      
      const labelUp=()=>{
        labelStart=null;
        document.removeEventListener('mousemove',labelMove);
        document.removeEventListener('mouseup',labelUp);
        lbl.style.cursor='grab';
        saveAll();
      };
      
      // Touch drag for label
      let labelTouchId=null;
      lbl.addEventListener('touchstart',e=>{
        if(node.dataset.showLabel!=='1') return;
        const t=e.touches[0];
        if(!t || labelTouchId!=null) return;
        e.stopPropagation(); // Prevent parent drag
        labelTouchId=t.identifier;
        labelStart={x:t.clientX, y:t.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
      }, {passive:false});
      
      lbl.addEventListener('touchmove',e=>{
        if(labelTouchId==null) return;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){
            const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
            const dx=(t.clientX-labelStart.x)/zoom;
            const dy=(t.clientY-labelStart.y)/zoom;
            node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
            node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
            applyLabelTransform(node);
            queueSave();
            e.preventDefault();
            break;
          }
        }
      }, {passive:false});
      
      lbl.addEventListener('touchend',e=>{
        if(labelTouchId==null) return;
        let still=false;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){ still=true; break; }
        }
        if(!still){
          labelTouchId=null;
          saveAll();
        }
      });
      
      // Multi-touch pinch to scale label (for custom labels and arrows)
      let lblInitialPinchDist = null;
      let lblInitialScale = null;
      let lblIsPinching = false;
      
      lbl.addEventListener('touchstart', (e) => {
        if(e.touches.length === 2 && node.dataset.showLabel === '1') {
          lblIsPinching = true;
          labelTouchId = null; // Cancel single-touch drag
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          lblInitialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          
          const k = node.dataset.key || '';
          if(k === 'arrow' || k === 'label') {
            const currentFontSize = parseFloat(lbl.getAttribute('font-size') || '16');
            lblInitialScale = currentFontSize;
          } else {
            lblInitialScale = parseFloat(node.dataset.scale || '1');
          }
          
          e.stopPropagation();
          e.preventDefault();
        }
      }, {passive: false});
      
      lbl.addEventListener('touchmove', (e) => {
        if(lblIsPinching && e.touches.length === 2) {
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          
          const scaleChange = currentDist / lblInitialPinchDist;
          const k = node.dataset.key || '';
          
          if(k === 'arrow' || k === 'label') {
            const newFontSize = Math.max(8, Math.min(72, lblInitialScale * scaleChange));
            lbl.setAttribute('font-size', String(Math.round(newFontSize)));
          } else {
            const newScale = Math.max(0.2, Math.min(5, lblInitialScale * scaleChange));
            node.dataset.scale = String(newScale);
            applyTransform(node);
          }
          
          const svg = node.closest('svg');
          if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
          queueSave();
          e.stopPropagation();
          e.preventDefault();
        }
      }, {passive: false});
      
      lbl.addEventListener('touchend', (e) => {
        if(e.touches.length < 2) {
          if(lblIsPinching) {
            saveAll();
            snapshotStage();
          }
          lblIsPinching = false;
          lblInitialPinchDist = null;
        }
      });
      
      // Mousewheel: scale label on wheel
      lbl.addEventListener('wheel', (e) => {
        if(node.dataset.showLabel !== '1') return;
        e.preventDefault();
        e.stopPropagation();
        
        const delta = -e.deltaY * 0.001;
        const k = node.dataset.key || '';
        
        if(k === 'arrow' || k === 'label') {
          const currentFontSize = parseFloat(lbl.getAttribute('font-size') || '16');
          const newFontSize = Math.max(8, Math.min(72, currentFontSize + (delta * 20)));
          lbl.setAttribute('font-size', String(Math.round(newFontSize)));
        } else {
          const currentScale = parseFloat(node.dataset.scale || '1');
          const newScale = Math.max(0.2, Math.min(5, currentScale + delta));
          node.dataset.scale = String(newScale);
          applyTransform(node);
        }
        
        const svg = node.closest('svg');
        if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
        queueSave();
        saveAll();
      }, {passive: false});
      
      // Set cursor style when label is draggable
      if(node.dataset.showLabel==='1'){
        lbl.style.cursor='grab';
      }
    }

    // Right-click cable drag connection gesture
    (function setupCableDrag(){
      const svg=document.getElementById('stageSvgFull'); if(!svg) return;
      let cableDrag=null; // {source, x1,y1, line}
      function clientToSvg(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      svg.addEventListener('contextmenu',e=>{ if(e.target.closest('svg#stageSvgFull')){ e.preventDefault(); }});
      let disconnectTimer=null;
      svg.addEventListener('mousedown',e=>{
        if(e.button!==2) return; // only right-click
        const g=e.target.closest && e.target.closest('g[data-draggable]');
        if(!g) return; e.preventDefault();
        // Start disconnect timer - if held for 500ms without movement, disconnect
        const startX=e.clientX, startY=e.clientY;
        disconnectTimer=setTimeout(()=>{
          // Disconnect this item from all connections
          if(g.dataset.routeTo){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); }
          Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(node=>{ if(node.dataset.routeTo===g.dataset.id){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); } });
          saveAll(); refreshStageLegend(); refreshCables(svg);
          disconnectTimer=null;
        },500);
        const p=clientToSvg(e.clientX,e.clientY);
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p.x); line.setAttribute('y1', p.y); line.setAttribute('x2', p.x); line.setAttribute('y2', p.y);
        line.setAttribute('stroke','#000'); line.setAttribute('stroke-width','2'); line.setAttribute('stroke-dasharray','6,4'); line.setAttribute('data-temp','cable');
        svg.appendChild(line);
        cableDrag={source:g, x1:p.x, y1:p.y, line:line, startX:startX, startY:startY};
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });
      function onMove(e){ if(!cableDrag) return; 
        // Cancel disconnect timer if mouse moved significantly
        if(disconnectTimer && cableDrag.startX!=null){
          const dx=Math.abs(e.clientX-cableDrag.startX), dy=Math.abs(e.clientY-cableDrag.startY);
          if(dx>8 || dy>8){ clearTimeout(disconnectTimer); disconnectTimer=null; }
        }
        const p=clientToSvg(e.clientX,e.clientY); cableDrag.line.setAttribute('x2',p.x); cableDrag.line.setAttribute('y2',p.y); }
      function onUp(e){ if(disconnectTimer){ clearTimeout(disconnectTimer); disconnectTimer=null; } if(!cableDrag) return; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp);
        const line=cableDrag.line; const source=cableDrag.source; line.remove();
        // determine drop target
        const el=document.elementFromPoint(e.clientX,e.clientY);
        const target= el && el.closest && el.closest('g[data-draggable]');
        if(target && target!==source){
          const sAllowed=effectiveTargets(source); const tAllowed=effectiveTargets(target);
          if(sAllowed.includes(target.dataset.type||'other')){ source.dataset.routeTo=target.dataset.id; }
          else if(tAllowed.includes(source.dataset.type||'other')){ target.dataset.routeTo=source.dataset.id; }
          // Easter egg: Fan connected to vocal mic
          if((source.dataset.key==='fan' && target.dataset.key==='vocal') || (target.dataset.key==='fan' && source.dataset.key==='vocal')){
            const fanNode = source.dataset.key==='fan' ? source : target;
            const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
          }
          saveAll(); refreshStageLegend();
        }
        cableDrag=null;
      }
    })();

    function initDatasetFromTransform(node){
      if(node.dataset.x && node.dataset.y) return;
      const m=node.transform.baseVal.consolidate();
      const t=m? m.matrix : {e:0,f:0,a:1,d:1};
      node.dataset.x=String(t.e||0);
      node.dataset.y=String(t.f||0);
      // scale approx from matrix a/d
      const s=(t.a&&t.d)? Math.max(1e-3, Math.sqrt(Math.abs(t.a*t.d))) : 1;
      node.dataset.scale=String(s);
      applyTransform(node);
    }

    function applyTransform(node){
      const x=parseFloat(node.dataset.x||'0');
      const y=parseFloat(node.dataset.y||'0');
      const s=parseFloat(node.dataset.scale||'1');
      const r=parseFloat(node.dataset.rotation||'0');
      node.setAttribute('transform',`translate(${x},${y}) scale(${s}) rotate(${r})`);
    }

  function findText(node){ return node.querySelector('text[data-role="label"]') || node.querySelector('text'); }
  
  // Apply label offset transform (labels can be dragged independently)
  function applyLabelTransform(node){
    const lbl=findText(node);
    if(!lbl) return;
    const offsetX=parseFloat(node.dataset.labelOffsetX||'0');
    const offsetY=parseFloat(node.dataset.labelOffsetY||'0');
    lbl.setAttribute('x',String(offsetX));
    lbl.setAttribute('y',String(offsetY));
    const size=parseInt(node.dataset.labelSize||'16',10);
    lbl.setAttribute('font-size',String(size));
  }

    // selection + inspector (selectedNode declared at top level before openStageModal)
    function selectNode(g){
      // Remove any existing selection highlight across both SVGs
      document.querySelectorAll('#stageSvgFull g[data-draggable].selected, #stageSvg g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      selectedNode=g||null;
      const nameInp=document.getElementById('selName');
      const sizeInp=document.getElementById('selSize');
      const showLabelChk=document.getElementById('selShowLabel');
      const inspector=document.getElementById('stageInspector');
      const delBtn=document.getElementById('delSel');
      const dupBtn=document.getElementById('dupSel');
      const rotInp=document.getElementById('selRotation');
      const rotVal=document.getElementById('selRotationValue');
      const labelSizeInp=document.getElementById('selLabelSize');
      const labelSizeControls=document.getElementById('labelSizeControls');
      const selLabel=document.getElementById('selLabel');
      
      // Always keep inspector visible
      if(inspector) inspector.style.display='flex';
      
      if(!g){
        // Show placeholder state
        if(selLabel) selLabel.textContent='Selected: (none)';
        if(nameInp){ nameInp.value=''; nameInp.placeholder='Click an item to select'; nameInp.disabled=true; }
        if(sizeInp){ sizeInp.value='1'; sizeInp.disabled=true; }
        if(rotInp){ rotInp.value='0'; rotInp.disabled=true; }
        if(rotVal) rotVal.textContent='0¬∞';
        if(showLabelChk){ showLabelChk.checked=false; showLabelChk.disabled=true; }
        if(labelSizeControls) labelSizeControls.style.display='none';
        if(delBtn) delBtn.disabled=true;
        if(dupBtn) dupBtn.disabled=true;
        return;
      }
      
      // Enable controls for selected item
      if(selLabel) selLabel.textContent='Selected:';
      if(nameInp){ nameInp.disabled=false; nameInp.placeholder='Label (double‚Äëclick item to rename)'; }
      if(sizeInp) sizeInp.disabled=false;
      if(rotInp) rotInp.disabled=false;
      if(showLabelChk) showLabelChk.disabled=false;
      if(delBtn) delBtn.disabled=false;
      if(dupBtn) dupBtn.disabled=false;
      
      g.classList.add('selected');
      const lbl=g.querySelector('[data-role="label"]');
      if(nameInp)nameInp.value=(lbl?lbl.textContent:'')||g.dataset.key||'';
      if(sizeInp)sizeInp.value=g.dataset.scale||'1';
      if(showLabelChk)showLabelChk.checked=(g.dataset.showLabel==='1');
      if(labelSizeControls)labelSizeControls.style.display=(g.dataset.showLabel==='1')?'flex':'none';
      if(labelSizeInp&&lbl)labelSizeInp.value=lbl.getAttribute('font-size')||'16';
      if(rotInp)rotInp.value=g.dataset.rotation||'0';
      if(rotVal)rotVal.textContent=(g.dataset.rotation||'0')+'¬∞';
      
      // Build and show signal chain display
      buildConnectionChain(g, inspector);
      if(delBtn){
        delBtn.onclick=()=>{
          if(!selectedNode)return;
          const confirmed=confirm('Delete this item?');
          if(confirmed){selectedNode.remove();selectNode(null);refreshStageLegend();refreshCables(selectedNode.closest('svg'));saveAll();}
        };
      }
      if(dupBtn){
        dupBtn.onclick=()=>{
          if(!selectedNode)return;
          const svg=selectedNode.closest('svg');
          const clone=selectedNode.cloneNode(true);
          const x=parseFloat(clone.dataset.x||'0');
          const y=parseFloat(clone.dataset.y||'0');
          clone.dataset.x=String(x+30);
          clone.dataset.y=String(y+30);
          applyTransform(clone);
          svg.appendChild(clone);
          enableSvgDrag(clone);
          selectNode(clone);
          refreshStageLegend();
          refreshCables(svg);
          saveAll();
        };
      }
      if(nameInp){
        nameInp.oninput=()=>{
          if(!selectedNode)return;
          const val=nameInp.value;
          const lbl=selectedNode.querySelector('[data-role="label"]');
          if(lbl)lbl.textContent=val;
          refreshStageLegend();
          saveAll();
        };
      }
      if(sizeInp){
        sizeInp.oninput=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.scale=sizeInp.value;
          applyTransform(selectedNode);
          const svg=selectedNode.closest('svg');
          refreshCables(svg);
          saveAll();
        };
      }
      if(showLabelChk){
        showLabelChk.onchange=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.showLabel=showLabelChk.checked?'1':'0';
          updateLabelVisibility(selectedNode);
          if(labelSizeControls)labelSizeControls.style.display=showLabelChk.checked?'flex':'none';
          saveAll();
        };
      }
      if(labelSizeInp){
        labelSizeInp.oninput=()=>{
          if(!selectedNode)return;
          const lbl=selectedNode.querySelector('[data-role="label"]');
          if(lbl){
            selectedNode.dataset.labelSize=labelSizeInp.value;
            updateLabelSize(selectedNode);
            saveAll();
          }
        };
      }
      if(rotInp){
        rotInp.oninput=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.rotation=rotInp.value;
          applyTransform(selectedNode);
          if(rotVal)rotVal.textContent=rotInp.value+'¬∞';
          const svg=selectedNode.closest('svg');
          refreshCables(svg);
          saveAll();
        };
      }
    }
    
    function bindSelection(svg){
        svg.addEventListener('click',ev=>{
          // Skip if preset modal is open
          const presetModal = document.getElementById('presetModal');
          if(presetModal && presetModal.style.display === 'flex') return;
          
          const g=ev.target.closest && ev.target.closest('g[data-draggable]');
          if(g){ selectNode(g); refreshStageLegend(); ev.stopPropagation(); return; }
          // click on whitespace creates a text label at click position
          const bg=ev.target.closest && ev.target.closest('.stage-bg');
          if(bg){
            if(_suppressBgClick){ _suppressBgClick=false; ev.stopPropagation(); return; }
            const pt=svg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=svg.getScreenCTM().inverse(); const p=pt.matrixTransform(ctm);
            // Ask first; cancel or empty -> deselect only (don't create label)
            let entered=prompt('Text label (leave empty to deselect):',''); 
            if(entered==null || entered.trim()==='') { selectNode(null); refreshStageLegend(); return; }
            entered=String(entered).trim();
            const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(p.x)); gN.dataset.y=String(Math.round(p.y)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
            const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
            applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
            const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); }
            ev.stopPropagation();
            return;
          }
          // Only deselect if clicking on truly empty space (not on any element)
          if(ev.target === svg || ev.target.tagName === 'svg'){
            selectNode(null); refreshStageLegend();
          }
        });
    }
  function ensureSelectionBindings(){ const svg=document.getElementById('stageSvgFull'); if(svg && !svg._boundSel){ bindSelection(svg); svg._boundSel=true; } }
    
    // selectNode function already defined above with selectedNode declaration
    
    function buildConnectionChain(selectedItem, inspector){
      const svg=selectedItem.closest('svg');
      if(!svg) return;
      const allNodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      const nameInp=document.getElementById('selName');
      const selLabel=document.getElementById('selLabel');
      
      // Check if this is a utility type (label/arrow) - show simplified display
      // Check both type and key since legacy items may have type='other' but key='label'/'arrow'
      const itemType = selectedItem.dataset.type || 'other';
      const itemKey = selectedItem.dataset.key || '';
      const isUtility = (itemType === 'label' || itemType === 'arrow' || itemKey === 'label' || itemKey === 'arrow');
      
      if(isUtility){
        // Utility types just show their name - no routing, no channel
        if(nameInp) nameInp.style.display='none';
        if(selLabel) selLabel.style.display='none';
        
        // Remove any existing chain displays
        inspector.querySelectorAll('.connection-chain').forEach(el => el.remove());
        
        // Create simple name-only display
        const utilDiv=document.createElement('div');
        utilDiv.className='connection-chain';
        utilDiv.style.cssText='display:flex;align-items:center;gap:6px;padding:6px 8px;background:#f3f4f6;border-radius:6px;';
        
        const itemInput=document.createElement('input');
        itemInput.type='text';
        itemInput.value=findText(selectedItem)?.textContent || 'Label';
        itemInput.style.cssText='padding:4px 8px;border:2px solid #374151;border-radius:4px;font-size:13px;font-weight:700;background:#e5e7eb;width:180px;';
        itemInput.title='Name';
        itemInput.addEventListener('change',()=>{
          const t=findText(selectedItem);
          if(t){ t.textContent=itemInput.value; saveAll(); refreshStageLegend(); }
        });
        utilDiv.appendChild(itemInput);
        
        const typeLabel=document.createElement('span');
        typeLabel.textContent= itemType==='arrow' ? '(arrow)' : '(text label)';
        typeLabel.style.cssText='color:#6b7280;font-size:12px;font-style:italic;';
        utilDiv.appendChild(typeLabel);
        
        inspector.appendChild(utilDiv);
        return; // Don't build chain for utility types
      }
      
      // Build the complete chain by finding the true start
      const chain=[];
      const visited=new Set();
      
      // Helper: determine type priority for proper chain ordering
      const typePriority=(node)=>{
        const type=node.dataset.type||'other';
        if(type==='acoustic' || type==='electric' || type==='keys' || type==='sax' || type==='deck' || type==='drum' || type==='cymbal') return 0; // instruments/sources
        if(type==='amp') return 1; // amps
        if(type==='mic') return 2; // mics
        if(type==='di') return 1.5; // DI boxes
        if(type==='fx') return 1.7; // FX
        if(type==='sampler') return 0.5; // samplers
        return 3; // others/channel endpoints
      };
      
      // Find the absolute start of the chain by walking backwards from selected item
      const findChainStart=(item)=>{
        const candidates=[];
        const seen=new Set();
        
        // Recursively find all items that route to this item
        const walkBack=(target)=>{
          if(seen.has(target.dataset.id)) return;
          seen.add(target.dataset.id);
          const incoming=allNodes.filter(n=> n.dataset.routeTo===target.dataset.id);
          if(incoming.length===0){
            candidates.push(target); // This is a potential start
          } else {
            incoming.forEach(src=> walkBack(src));
          }
        };
        
        walkBack(item);
        
        // Sort candidates by priority to get the true start (instrument before amp before mic)
        candidates.sort((a,b)=> typePriority(a) - typePriority(b));
        return candidates.length>0 ? candidates[0] : item;
      };
      
      const chainStart = findChainStart(selectedItem);
      
      // Walk forward from the true start to build the COMPLETE chain (don't stop at intermediate items with channels)
      let current=chainStart;
      const maxIterations=50; // safety limit
      let iterations=0;
      while(current && !visited.has(current) && iterations<maxIterations){
        iterations++;
        visited.add(current);
        chain.push(current);
        const nextId=current.dataset.routeTo;
        if(!nextId) break;
        const next=allNodes.find(n=> n.dataset.id===nextId);
        if(!next) break;
        // Skip utility types (labels/arrows) - they can't be part of signal chain
        const nextType = next.dataset.type || 'other';
        const nextKey = next.dataset.key || '';
        if(nextType === 'label' || nextType === 'arrow' || nextKey === 'label' || nextKey === 'arrow') break;
        // validate connection is allowed
        const allowed=effectiveTargets(current);
        if(!allowed.includes(nextType)) break;
        current=next;
      }
      
      // Ensure selected item is in the chain
      if(!chain.includes(selectedItem)){
        chain.push(selectedItem);
      }
      
      // Always use chain display for consistency (even for single items)
      // Hide standard name input
      if(nameInp) nameInp.style.display='none';
      if(selLabel) selLabel.style.display='none';
      
      // Remove any existing chain displays to prevent duplicates
      inspector.querySelectorAll('.connection-chain').forEach(el => el.remove());
      
      // Create chain display (single row, no wrap) - ALWAYS shown for consistency
      const chainDiv=document.createElement('div');
      chainDiv.className='connection-chain';
      chainDiv.style.cssText='display:flex;align-items:center;gap:6px;flex-wrap:nowrap;padding:6px 8px;background:#f3f4f6;border-radius:6px;overflow-x:auto;width:100%';
      
      chain.forEach((node,idx)=>{
        const isSelected = node===selectedItem;
        const isLast = idx===chain.length-1;
        
        // Item name field - fixed width for consistency
        const itemInput=document.createElement('input');
        itemInput.type='text';
        itemInput.value=findText(node)?.textContent || node.dataset.key||'Item';
        itemInput.style.cssText=`padding:4px 8px;border:2px solid ${isSelected?'#374151':'#d1d5db'};border-radius:4px;font-size:13px;font-weight:${isSelected?'700':'400'};background:${isSelected?'#e5e7eb':'#fff'};width:120px;flex-shrink:0`;
        itemInput.title='Name: '+itemInput.value;
        itemInput.addEventListener('change',()=>{
          const t=findText(node);
          if(t){ 
            t.textContent=itemInput.value; 
            saveAll(); 
            refreshStageLegend();
            if(node===selectedItem) syncInspectorFrom(node);
          }
        });
        chainDiv.appendChild(itemInput);
        
        // Arrow between items (only if there's actually a connection)
        if(!isLast){
          const arrow=document.createElement('span');
          arrow.textContent='‚Üí';
          arrow.style.cssText='color:#6b7280;font-size:14px;font-weight:bold;flex-shrink:0';
          chainDiv.appendChild(arrow);
        }
      });
      
      // Find which item in the chain can/should have the channel
      // Check all items in chain (backwards) to find one with channel capability
      let channelNode=null;
      
      // First check if any item already has a channel assigned
      for(let i=chain.length-1; i>=0; i--){
        const node=chain[i];
        if(node.dataset.channel && node.dataset.channel!==''){
          channelNode=node;
          break;
        }
      }
      
      // If no channel assigned, check if any item CAN have a channel (prefer last item)
      if(!channelNode){
        for(let i=chain.length-1; i>=0; i--){
          const node=chain[i];
          const targets=effectiveTargets(node);
          if(targets.includes('channel')){
            channelNode=node;
            break;
          }
        }
      }
      
      // ALWAYS add channel field if any item can have one (for consistent formatting)
      if(channelNode){
        const isStereo=(channelNode.dataset.key||'')==='stereoPair';
        const chInput=document.createElement('input');
        chInput.type='number';
        chInput.min='1';
        chInput.max=isStereo?'63':'64';
        chInput.placeholder='Ch';
        chInput.value=channelNode.dataset.channel||'';
        chInput.style.cssText='padding:4px 8px;border:2px solid #10b981;border-radius:4px;font-size:13px;font-weight:700;background:#d1fae5;width:70px;flex-shrink:0';
        chInput.title='Channel number (assigned to '+((findText(channelNode)?.textContent)||'this item')+')';
        
        chInput.addEventListener('change',()=>{
          const newCh=parseInt(chInput.value,10);
          if(!Number.isFinite(newCh) || newCh<1){
            delete channelNode.dataset.channel;
            channelNode.removeAttribute('data-channel');
          } else {
            // Check if channel is taken
            const taken=allNodes.find(n=> n!==channelNode && occupiesChannelHelper(n,newCh));
            if(taken){
              const takenName=findText(taken)?.textContent||'another item';
              if(!confirm(`Channel ${newCh} is used by ${takenName}. Reassign anyway? (This will disconnect ${takenName})`)){
                chInput.value=channelNode.dataset.channel||'';
                return;
              }
              delete taken.dataset.channel;
              taken.removeAttribute('data-channel');
            }
            channelNode.dataset.channel=String(newCh);
          }
          saveAll();
          refreshStageLegend();
          const stageSvg=channelNode.closest('svg');
          if(stageSvg) refreshCables(stageSvg);
        });
        
        chainDiv.appendChild(chInput);
      }
      
      // Insert chain display before the standard name input
      inspector.insertBefore(chainDiv, inspector.firstChild);
    }
    
    function occupiesChannelHelper(node,ch){
      if(!ch) return false;
      const a=parseInt(node.dataset.channel||'0',10);
      if(!a) return false;
      const isStereo=(node.dataset.key||'')==='stereoPair';
      if(isStereo){ return ch===a || ch===a+1; }
      return ch===a;
    }
    function syncInspectorFrom(g){ if(!g) return; const nameInp=document.getElementById('selName'); const sizeInp=document.getElementById('selSize'); const rotInp=document.getElementById('selRotation'); const rotVal=document.getElementById('selRotationValue'); if(nameInp){ const txt=findText(g); nameInp.value=txt? (txt.textContent||'') : ''; } if(sizeInp){ sizeInp.value=g.dataset.scale||'1'; } if(rotInp){ const r=parseFloat(g.dataset.rotation||'0'); rotInp.value=String(Math.round(r)%360); if(rotVal) rotVal.textContent=Math.round(r)%360+'¬∞'; } }
  document.getElementById('selName').addEventListener('change',()=>{ if(!selectedNode) return; const t=findText(selectedNode); if(t){ t.textContent=document.getElementById('selName').value; saveAll(); }});
  document.getElementById('selName').addEventListener('change',()=> refreshStageLegend());
  document.getElementById('selSize').addEventListener('input',()=>{ if(!selectedNode) return; const v=parseFloat(document.getElementById('selSize').value); const k=selectedNode.dataset.key||''; if(k==='arrow' || k==='label'){ const lbl=findText(selectedNode); if(lbl){ const base = (k==='arrow')?14:16; const fs=Math.max(8, Math.round(base*v)); lbl.setAttribute('font-size', String(fs)); } } else { selectedNode.dataset.scale=String(v); applyTransform(selectedNode); } saveAll(); });
  document.getElementById('selSize').addEventListener('change',()=>{ if(isStageLocked()) return; saveAll(); snapshotStage(); });
  document.getElementById('selRotation').addEventListener('input',()=>{ if(!selectedNode || isStageLocked()) return; const v=parseFloat(document.getElementById('selRotation').value); selectedNode.dataset.rotation=String(v); applyTransform(selectedNode); const svg=selectedNode.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } const rotVal=document.getElementById('selRotationValue'); if(rotVal) rotVal.textContent=Math.round(v)+'¬∞'; queueSave(); saveAll(); });
  document.getElementById('selRotation').addEventListener('change',()=>{ if(isStageLocked()) return; saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=>{ if(!selectedNode || isStageLocked()) return; selectedNode.remove(); selectedNode=null; document.getElementById('selName').value=''; saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=> refreshStageLegend());
  // Show label toggle
  const showLabelChk=document.getElementById('selShowLabel');
  const labelSizeControls=document.getElementById('labelSizeControls');
  const labelSizeSlider=document.getElementById('selLabelSize');
  if(showLabelChk){
    showLabelChk.addEventListener('change',()=>{
      if(!selectedNode) return; 
      selectedNode.dataset.showLabel= showLabelChk.checked ? '1':'0'; 
      const lbl=findText(selectedNode); 
      if(lbl){ 
        lbl.style.display= showLabelChk.checked ? 'block':'none'; 
        // Initialize label offset if not set
        if(!selectedNode.dataset.labelOffsetX) selectedNode.dataset.labelOffsetX='0';
        if(!selectedNode.dataset.labelOffsetY) selectedNode.dataset.labelOffsetY='0';
        if(!selectedNode.dataset.labelSize) selectedNode.dataset.labelSize='16';
        applyLabelTransform(selectedNode);
      }
      // Show/hide label size controls
      if(labelSizeControls){ labelSizeControls.style.display= showLabelChk.checked ? 'flex':'none'; }
      if(labelSizeSlider && showLabelChk.checked){ labelSizeSlider.value=selectedNode.dataset.labelSize||'16'; }
      saveAll(); refreshStageLegend();
    });
  }
  // Label size slider
  if(labelSizeSlider){
    labelSizeSlider.addEventListener('input',()=>{
      if(!selectedNode) return;
      const size=parseInt(labelSizeSlider.value,10);
      selectedNode.dataset.labelSize=String(size);
      const lbl=findText(selectedNode);
      if(lbl){ lbl.setAttribute('font-size',String(size)); }
      saveAll();
    });
  }
  // Duplicate button
  const dupBtn=document.getElementById('dupSel');
  if(dupBtn){ dupBtn.addEventListener('click',()=>{
    if(!selectedNode) return;
    const clone=selectedNode.cloneNode(true);
    const svg=selectedNode.closest('svg');
    initDatasetFromTransform(clone);
    clone.dataset.x=String(parseFloat(clone.dataset.x||'0')+40);
    clone.dataset.y=String(parseFloat(clone.dataset.y||'0')+40);
    applyTransform(clone);
    svg.appendChild(clone);
    enableSvgDrag(clone);
    selectNode(clone);
    refreshStageLegend(); saveAll();
  }); }
  // Global touch-based toolbox drag handling
  let activeToolTouch=null;
  window.addEventListener('touchmove',e=>{
    if(!activeToolTouch) return; const t=e.touches[0]; if(!t) return; activeToolTouch.x=t.clientX; activeToolTouch.y=t.clientY; }, {passive:true});
  window.addEventListener('touchend',e=>{
    if(!activeToolTouch) return; const stage=document.getElementById('stageSvgFull'); if(stage){ const rect=stage.getBoundingClientRect(); const x=activeToolTouch.x, y=activeToolTouch.y; if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){ // inside stage
        // detect target BEFORE adding new node
        const el=document.elementFromPoint(x, y);
        const dropTarget= el && el.closest && el.closest('g[data-draggable]');
        // convert to SVG coords
        const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
        const newNode=addGlyphFull(activeToolTouch.key, {x:Math.round(svgP.x), y:Math.round(svgP.y)});
        if(newNode) selectNode(newNode);
        if(dropTarget && newNode){
          if(connectEitherDirection(newNode, dropTarget)){
            const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
            refreshCables(stage);
          }
        }
        try{ snapshotStage(); }catch(_){ }
      } }
    activeToolTouch=null;
  });
  // Mouse / touchpad fallback drag (for environments where HTML5 drag doesn't fire)
  let activeToolMouse=null; // {key,startX,startY,started,ghost}
  document.addEventListener('mousedown',e=>{
    // Skip if preset modal is open
    const presetModal = document.getElementById('presetModal');
    if(presetModal && presetModal.style.display === 'flex') return;
    
    const btn=e.target.closest && e.target.closest('button.tool');
    if(!btn) return; if(e.button!==0) return;
    // We stored key explicitly on custom images; for standard tools key derivation from dragstart handler's closure is harder; embed data-key at build time for reliability
    const explicit=btn.dataset.key; if(!explicit) return; 
    activeToolMouse={key:explicit,startX:e.clientX,startY:e.clientY,started:false,ghost:null};
  });
  // Mouse drag: start after small movement threshold, update ghost position
  document.addEventListener('mousemove',e=>{
    if(!activeToolMouse) return; 
    if(activeToolMouse.started){ 
      // Already started - just update ghost position
      if(activeToolMouse.ghost){ activeToolMouse.ghost.style.left=(e.clientX+12)+'px'; activeToolMouse.ghost.style.top=(e.clientY+12)+'px'; } 
      return; 
    }
    // Not started yet - check if moved enough from start position
    const dx=Math.abs(e.clientX - activeToolMouse.startX), dy=Math.abs(e.clientY - activeToolMouse.startY); 
    if(dx+dy>6){
      activeToolMouse.started=true;
      const ghost=document.createElement('div'); ghost.style.position='fixed'; ghost.style.left=(e.clientX+12)+'px'; ghost.style.top=(e.clientY+12)+'px'; ghost.style.pointerEvents='none'; ghost.style.zIndex='99999'; ghost.style.padding='4px 6px'; ghost.style.background='rgba(31,41,55,0.85)'; ghost.style.color='#fff'; ghost.style.fontSize='11px'; ghost.style.borderRadius='4px'; ghost.style.boxShadow='0 2px 6px rgba(0,0,0,0.4)'; ghost.textContent='Place '+activeToolMouse.key; document.body.appendChild(ghost); activeToolMouse.ghost=ghost;
    }
  });
  document.addEventListener('mouseup',e=>{
    if(!activeToolMouse) return; const data=activeToolMouse; activeToolMouse=null; if(data.ghost){ data.ghost.remove(); }
    // Skip if preset modal is open
    const presetModal = document.getElementById('presetModal');
    if(presetModal && presetModal.style.display === 'flex') return;
    
    if(!data.started) return; const stage=document.getElementById('stageSvgFull'); if(!stage) return; const rect=stage.getBoundingClientRect(); const x=e.clientX, y=e.clientY; if(x<rect.left||x>rect.right||y<rect.top||y>rect.bottom) return;
    // detect target before adding
    const el=document.elementFromPoint(x,y); const dropTarget= el && el.closest && el.closest('g[data-draggable]');
    const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
    const newNode=addGlyphFull(data.key,{x:Math.round(svgP.x), y:Math.round(svgP.y)}); if(newNode) selectNode(newNode);
    if(dropTarget && newNode){ if(connectEitherDirection(newNode, dropTarget)){ const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); refreshCables(stage); } }
    saveAll(); try{ snapshotStage(); }catch(_){ }
  });
  function getStageGroups(){ const full=document.getElementById('stageSvgFull'); if(!full) return []; return Array.from(full.querySelectorAll('g[data-draggable]')); }
  // Draw curvy dotted cables between connected items (routeTo chains)
  function refreshCables(svg){ if(!svg) return; const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
    // ensure a dedicated layer
    let layer=svg.querySelector('g[data-layer="cables"]'); if(layer){ layer.remove(); }
    layer=document.createElementNS('http://www.w3.org/2000/svg','g'); layer.setAttribute('data-layer','cables'); layer.setAttribute('pointer-events','none'); svg.appendChild(layer);
    const byId=new Map(nodes.map(n=> [n.dataset.id, n]));
    function centerOf(n){ return {x:parseFloat(n.dataset.x||'0')||0, y:parseFloat(n.dataset.y||'0')||0}; }
    function nodeRadius(n){ const s=Math.max(0.3, parseFloat(n.dataset.scale||'1')||1); const k=n.dataset.key||''; const base=(k==='label'||k==='arrow')? 20 : 30; return base*s; }
    function sampleQuad(a,c,b,t){ const x=(1-t)*(1-t)*a.x + 2*(1-t)*t*c.x + t*t*b.x; const y=(1-t)*(1-t)*a.y + 2*(1-t)*t*c.y + t*t*b.y; return {x,y}; }
    function pickControl(a,b,initial, obstacles){ let c={x:initial.x,y:initial.y}; const clamp=(v,min,max)=> Math.max(min, Math.min(max,v)); const vb=svg.viewBox && svg.viewBox.baseVal; const bx={x:0,y:0,w:(vb?vb.width:1500),h:(vb?vb.height:900)};
      for(let it=0; it<3; it++){
        // sample along curve, compute repulsion from obstacles
        let rx=0, ry=0; const steps=10; for(let i=1;i<steps;i++){ const t=i/steps; const p=sampleQuad(a,c,b,t); obstacles.forEach(o=>{
            const dx=p.x-o.x, dy=p.y-o.y; const d=Math.hypot(dx,dy); const th=o.r+40; if(d<th && d>1e-3){ const f=(th-d)/th; rx += (dx/d)*f; ry += (dy/d)*f; }
        }); }
        // apply small push
        const push=30; c.x = clamp(c.x + rx*push, bx.x+4, bx.x+bx.w-4); c.y = clamp(c.y + ry*push, bx.y+4, bx.y+bx.h-4);
      }
      return c;
    }
    // build obstacle list (centers + radii)
    const obstacles = nodes.map(n=>{ const c=centerOf(n); return {x:c.x,y:c.y,r:nodeRadius(n)}; });
    nodes.forEach(src=>{
      const to=src.dataset.routeTo; if(!to) return; const dst=byId.get(to); if(!dst) return;
      // make sure the connection is allowed; use effectiveTargets if available
      try{ if(typeof effectiveTargets==='function'){ const ok=effectiveTargets(src).includes(dst.dataset.type||'other'); if(!ok) return; } }catch(_){ /* ignore */ }
      
      // Check if this is a mic-amp connection (either direction)
      const srcType=src.dataset.type||'other';
      const dstType=dst.dataset.type||'other';
      const isMicAmpConnection = (srcType==='amp' && dstType==='mic') || (srcType==='mic' && dstType==='amp');
      
      const a=centerOf(src), b=centerOf(dst); const dx=b.x-a.x, dy=b.y-a.y; const len=Math.hypot(dx,dy)||1; const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const nx=-dy/len, ny=dx/len; const baseK=30; const init={x:mx+nx*baseK, y:my+ny*baseK};
      
      if(isMicAmpConnection){
        // Draw straight arrow for mic-amp connection (no curve)
        const d=`M ${a.x} ${a.y} L ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','2'); 
        p.setAttribute('marker-end','url(#arrowhead)');
        layer.appendChild(p);
        
        // Ensure arrowhead marker exists
        let defs=svg.querySelector('defs');
        if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
        if(!defs.querySelector('#arrowhead')){
          const marker=document.createElementNS('http://www.w3.org/2000/svg','marker');
          marker.setAttribute('id','arrowhead');
          marker.setAttribute('markerWidth','10');
          marker.setAttribute('markerHeight','10');
          marker.setAttribute('refX','9');
          marker.setAttribute('refY','3');
          marker.setAttribute('orient','auto');
          const triangle=document.createElementNS('http://www.w3.org/2000/svg','polygon');
          triangle.setAttribute('points','0 0, 10 3, 0 6');
          triangle.setAttribute('fill','#111');
          marker.appendChild(triangle);
          defs.appendChild(marker);
        }
      } else {
        // Draw normal curved dotted cable
        const c=pickControl(a,b,init, obstacles);
        const d=`M ${a.x} ${a.y} Q ${c.x} ${c.y} ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','1.5'); 
        p.setAttribute('stroke-dasharray','4 3'); 
        layer.appendChild(p);
      }
    });
  }
  function refreshStageLegend(){
    const host=document.getElementById('stageLegend'); if(!host) return;
    const rows=getStageGroups();
    host.innerHTML='';
    // sort with priority processors first
    rows.sort((a,b)=>{
      const ta=a.dataset.type||'other', tb=b.dataset.type||'other';
      const pa=PRIORITY_TYPES.has(ta), pb=PRIORITY_TYPES.has(tb);
      if(pa&&!pb) return -1; if(pb&&!pa) return 1; return parseInt(a.dataset.id||'0')-parseInt(b.dataset.id||'0');
    });

    // helpers for channels and chains
    function isStereo(node){ return (node.dataset.key||'')==='stereoPair'; }
    function occupiesChannel(node, ch){ if(!ch) return false; const a=parseInt(node.dataset.channel||'0',10); if(!a) return false; if(isStereo(node)){ return ch===a || ch===a+1; } return ch===a; }
    function channelTaken(ch, except){ return rows.find(r=> r!==except && occupiesChannel(r, ch)); }
    function nextFreeChannel(start, dir, stereo){ let c=start; const upper=stereo?63:64; const lower=1; while(true){ if(c<lower || c>upper) return null; const occupied = channelTaken(c, null) || (stereo && channelTaken(c+1, null)); if(!occupied) return c; c += dir; }
    }
    // helper to build chain string
    function buildChain(from){
      const seen=new Set();
      const parts=[];
      let cur=from;
      while(cur){
        if(seen.has(cur)) { parts.push('[loop]'); break; }
        seen.add(cur);
        const t=findText(cur); const base=(t && t.textContent)||cur.dataset.key||'Item';
        parts.push(base);
        const nextId=cur.dataset.routeTo || '';
        if(!nextId) break;
        const next=rows.find(r=> r.dataset.id===nextId);
        if(!next) break;
        // Skip utility types (labels/arrows can't be in signal chain)
        const nextType = next.dataset.type || 'other';
        const nextKey = next.dataset.key || '';
        if(nextType === 'label' || nextType === 'arrow' || nextKey === 'label' || nextKey === 'arrow') break;
        // validate that next type is an allowed target from current type
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(nextType)===-1){ break; }
        cur=next;
      }
      const last=cur||from;
      if(last.dataset.channel){
        if(isStereo(last)){
          const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1));
        }else{
          parts.push('Ch '+last.dataset.channel);
        }
      }
      return parts.join(' - ');
    }

      // Build incoming map to identify roots (start of chains)
      const incoming=new Set(); rows.forEach(r=>{ const to=r.dataset.routeTo; if(to) incoming.add(to); });
      // Filter: hide annotations; compact view = only root items OR items that expose a channel directly
      const displayRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const targets=ROUTE_TARGETS[tp]||[];
        const exposesChannel=targets.includes('channel');
        const isRoot=!incoming.has(r.dataset.id);
        return isRoot || exposesChannel; // keep if chain start or endpoint with channel
      });
      // Identify unconnected items (no routeTo, no channel, not routed to by anyone, not utility annotations)
      const unconnectedRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const hasChannel = r.dataset.channel;
        const hasRouteTo = r.dataset.routeTo;
        const isRoutedTo = incoming.has(r.dataset.id);
        return !hasChannel && !hasRouteTo && !isRoutedTo;
      });
    // Precompute candidates map for routing dropdown population
    const byType={}; displayRows.forEach(r=>{ const t=r.dataset.type||'other'; (byType[t]||(byType[t]=[])).push(r); });

    // determine dynamic channel range (still consider all rows for occupancy logic)
    const assignedChannels=rows.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
    const maxChan=assignedChannels.length? Math.max(...assignedChannels):0;
      displayRows.forEach((g,i)=>{
      const item=document.createElement('div'); item.className='row';
      const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
      const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
      const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);

      const type=g.dataset.type||'other';
  const targets=effectiveTargets(g);
      // Routing (routeTo or channel) cell
      const routeCell=document.createElement('div');
      let chInput=null;
      // Channel editing is applied to the chain endpoint, not necessarily the current row
      const resolveEnd=(start)=>{ let s=new Set(); let cur=start; while(cur && !s.has(cur)){ s.add(cur); const nid=cur.dataset.routeTo||''; if(!nid) break; const nxt=rows.find(r=> r.dataset.id===nid); if(!nxt) break; const allowed=effectiveTargets(cur); if(allowed.indexOf(nxt.dataset.type||'other')===-1) break; cur=nxt; } return cur||start; };
      const endNode=resolveEnd(g);
      const endTargets=effectiveTargets(endNode);
      if(endTargets.includes('channel')){
        const stereo=isStereo(endNode);
        chInput=document.createElement('input'); chInput.type='number'; chInput.min='1'; chInput.max= stereo ? '63' : '64'; chInput.step='1'; chInput.placeholder='Ch'; chInput.style.width='56px'; chInput.value=endNode.dataset.channel||''; chInput.title='Right-click drag between items to auto-chain';
        let prevVal = endNode.dataset.channel||'';
        const applyChannel=(ch)=>{ if(!ch){ endNode.dataset.channel=''; delete endNode.dataset.channel2; saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } return; }
          // block if taken
          if(channelTaken(ch, endNode) || (stereo && channelTaken(ch+1, endNode))){ chInput.value = prevVal; return; }
          endNode.dataset.channel=String(ch); if(stereo){ endNode.dataset.channel2=String(ch+1); } else { delete endNode.dataset.channel2; }
          prevVal=String(ch); saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } };
        const onChanChange=()=>{ const v=parseInt(chInput.value||'0',10); if(!isFinite(v) || v<1){ applyChannel(null); }
          else { const val=Math.min(stereo?63:64, v); if(channelTaken(val, endNode) || (stereo && channelTaken(val+1, endNode))){ chInput.value=prevVal; return; } applyChannel(val); } };
        chInput.addEventListener('focus',()=>{ prevVal = chInput.value; });
        chInput.addEventListener('change', onChanChange);
        chInput.addEventListener('blur', onChanChange);
        chInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ onChanChange(); }
          if(e.key==='ArrowUp' || e.key==='ArrowDown'){ e.preventDefault(); const dir = e.key==='ArrowUp' ? 1 : -1; const cur=parseInt(chInput.value|| (prevVal||'0'),10) || 0; const start = Math.max(1, cur + dir); const nf = nextFreeChannel(start, dir, stereo); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } }
        });
        chInput.addEventListener('input', ()=>{ const cur=parseInt(chInput.value||'0',10)||0; const pv=parseInt(prevVal||'0',10)||0; const stereoNow=stereo; if(cur===pv+1 || cur===pv-1){ const dir = (cur>pv)?1:-1; const nf = nextFreeChannel(cur, dir, stereoNow); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } } });
        routeCell.appendChild(chInput);
      }
      // RouteTo select for processors / sources that can feed other processors
      if(targets.filter(t=> t!=='channel').length){
        const rtSel=document.createElement('select'); rtSel.className='routeSel'; rtSel.appendChild(new Option('‚Üí none',''));
        const elig=[]; targets.forEach(tt=>{ if(tt==='channel') return; const groups=byType[tt]; if(groups){ groups.forEach(gr=>{ if(gr!==g) elig.push(gr); }); } });
        elig.forEach(gr=>{ const name=findText(gr); const label=(name && name.textContent)||gr.dataset.key||('Item '+gr.dataset.id); rtSel.appendChild(new Option(label, gr.dataset.id)); });
        // sanitize existing route if invalid
        if(g.dataset.routeTo){ const curNext=rows.find(r=> r.dataset.id===g.dataset.routeTo); const allowed=effectiveTargets(g); if(!curNext || allowed.indexOf(curNext.dataset.type||'other')===-1){ g.dataset.routeTo=''; } }
        rtSel.value=g.dataset.routeTo||'';
        rtSel.addEventListener('change',()=>{ const dest=rows.find(r=> r.dataset.id===rtSel.value); const allowed=effectiveTargets(g); if(dest && allowed.indexOf(dest.dataset.type||'other')!==-1){ g.dataset.routeTo=rtSel.value; } else { g.dataset.routeTo=''; } saveAll(); refreshStageLegend(); });
        routeCell.appendChild(rtSel);
      }
      item.appendChild(routeCell);

      // Chain cell
  const chainCell=document.createElement('div'); chainCell.className='chain'; chainCell.textContent=buildChain(g); item.appendChild(chainCell);

      host.appendChild(item);
    });
    // Add unconnected items section if any exist
    if(unconnectedRows.length>0){
      const divider=document.createElement('div'); divider.style.cssText='border-top:2px solid #d1d5db;margin:12px 0 8px 0;padding-top:8px;font-weight:600;color:#64748b;font-size:12px';
      divider.textContent='Unconnected Items (acoustic/props):';
      host.appendChild(divider);
      unconnectedRows.forEach((g,i)=>{
        const item=document.createElement('div'); item.className='row'; item.style.opacity='0.7';
        const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
        const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
        const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);
        const noteCell=document.createElement('div'); noteCell.style.cssText='font-size:11px;color:#64748b;font-style:italic'; noteCell.textContent='(no signal path)'; item.appendChild(noteCell);
        host.appendChild(item);
      });
    }
    // After legend rebuild, refresh visual cables on both editor and stored SVGs
    const svgFull=document.getElementById('stageSvgFull'); if(svgFull) refreshCables(svgFull);
    const svgSmall=document.getElementById('stageSvg'); if(svgSmall) refreshCables(svgSmall);
  }
  /* Filter system removed: icons now assumed to have proper transparency baked in. */

    // Print Tech Rider + Stage
  // Print Tech button opens chooser modal
  document.getElementById('printTech').addEventListener('click',()=>{
    openPrintChooser('tech');
  });
  document.getElementById('closeTech').addEventListener('click',()=> document.getElementById('modalTech').classList.remove('open'));

    // Stage selection state (must be declared before openStageModal)
    let selectedNode = null;

    // Fullscreen stage editor open/close (now inline, used for Stage Plot view)
    function openStageModal(){
      // ensure header reflects current gig
      try{
        refreshStageHeader();
        // ensure toolbox is populated
        try{ buildTools(); }catch(_){ /* ignore */ }
        
        // Re-attach drag handlers to ensure they work
        attachStageDragHandlers();
        
        // Initialize drag-assign handles
        initDragAssignHandles();
        
        // FIRST: Load stage from tourDate if available
        if(selectedTourDateId){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate && tourDate.stage && tourDate.stage.length > 0){
            const container = document.getElementById('stageStore');
            if(container){
              container.innerHTML = tourDate.stage;
              const svg = container.querySelector('svg');
              if(svg){
                svg.id = 'stageSvg';
                svg.classList.add('bw');
                try{ refreshCables(svg); }catch(e){}
              }
            }
          }
        }
        
        // seed full editor from stored svg
        const store=document.getElementById('stageSvg');
        const full=document.getElementById('stageSvgFull');
        // enforce stage outline
        if(full && !full.classList.contains('bw')) full.classList.add('bw');
        const bg=full && full.querySelector('rect.stage-bg');
        if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        
        // STAGE SIZE LIMITS - viewBox always matches canvas size (no scaling)
        const STAGE_MIN_SIZE = 300;
        const STAGE_MAX_SIZE = 1500;
        const STAGE_DEFAULT_WIDTH = 1000;
        const STAGE_DEFAULT_HEIGHT = 600;
        
        // Initialize resize handles - viewBox and canvas always match (1:1 pixel mapping)
        (function initStageResize(){
          const frame=document.getElementById('stageFrame'); if(!frame||!full) return;
          
          // Restore size from stored data attributes (persisted between sessions)
          let stageW = parseInt(full.dataset.stageWidth || store?.dataset?.stageWidth || '0', 10);
          let stageH = parseInt(full.dataset.stageHeight || store?.dataset?.stageHeight || '0', 10);
          
          // Validate and apply defaults if needed
          if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
          if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
          
          // Apply size - viewBox matches canvas exactly (no scaling)
          frame.style.width = stageW + 'px';
          frame.style.height = stageH + 'px';
          full.style.width = stageW + 'px';
          full.style.height = stageH + 'px';
          full.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
          full.dataset.stageWidth = String(stageW);
          full.dataset.stageHeight = String(stageH);
          
          // Update background rect to match size
          const bgRect = full.querySelector('rect.stage-bg');
          if(bgRect){
            bgRect.setAttribute('x', '1');
            bgRect.setAttribute('y', '1');
            bgRect.setAttribute('width', String(stageW - 2));
            bgRect.setAttribute('height', String(stageH - 2));
          }
          
          const handles=frame.querySelectorAll('.stage-handle');
          handles.forEach(h=>{
            h.addEventListener('mousedown',e=>{
              if(e.button!==0) return; e.preventDefault();
              const startX=e.clientX, startY=e.clientY;
              const startW=frame.offsetWidth, startH=frame.offsetHeight;
              const pos=h.dataset.handle;
              
              function move(ev){
                let dx=ev.clientX-startX, dy=ev.clientY-startY;
                let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                
                // Enforce min/max limits
                newW = Math.max(STAGE_MIN_SIZE, Math.min(STAGE_MAX_SIZE, newW));
                newH = Math.max(STAGE_MIN_SIZE, Math.min(STAGE_MAX_SIZE, newH));
                
                // Update canvas AND viewBox together (no scaling, just resize the area)
                frame.style.width = newW + 'px';
                frame.style.height = newH + 'px';
                full.style.width = newW + 'px';
                full.style.height = newH + 'px';
                full.setAttribute('viewBox', '0 0 ' + newW + ' ' + newH);
                full.dataset.stageWidth = String(newW);
                full.dataset.stageHeight = String(newH);
                
                // Update background rect to match new size
                const bgRect = full.querySelector('rect.stage-bg');
                if(bgRect){
                  bgRect.setAttribute('width', String(newW - 2));
                  bgRect.setAttribute('height', String(newH - 2));
                }
              }
              
              function up(){
                document.removeEventListener('mousemove', move);
                document.removeEventListener('mouseup', up);
                // Sync to stored SVG and save
                syncStageSize();
                saveAll();
              }
              document.addEventListener('mousemove', move);
              document.addEventListener('mouseup', up);
            });
            
            // Touch support for handles
            h.addEventListener('touchstart',e=>{
              e.preventDefault();
              const t=e.touches[0]; if(!t) return;
              const startX=t.clientX, startY=t.clientY;
              const startW=frame.offsetWidth, startH=frame.offsetHeight;
              const pos=h.dataset.handle;
              
              function touchMove(ev){
                const tt=ev.touches[0]; if(!tt) return;
                let dx=tt.clientX-startX, dy=tt.clientY-startY;
                let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                
                // Enforce min/max limits
                newW = Math.max(STAGE_MIN_SIZE, Math.min(STAGE_MAX_SIZE, newW));
                newH = Math.max(STAGE_MIN_SIZE, Math.min(STAGE_MAX_SIZE, newH));
                
                // Update canvas AND viewBox together (no scaling)
                frame.style.width = newW + 'px';
                frame.style.height = newH + 'px';
                full.style.width = newW + 'px';
                full.style.height = newH + 'px';
                full.setAttribute('viewBox', '0 0 ' + newW + ' ' + newH);
                full.dataset.stageWidth = String(newW);
                full.dataset.stageHeight = String(newH);
                
                // Update background rect
                const bgRect = full.querySelector('rect.stage-bg');
                if(bgRect){
                  bgRect.setAttribute('width', String(newW - 2));
                  bgRect.setAttribute('height', String(newH - 2));
                }
                ev.preventDefault();
              }
              
              function touchEnd(){
                document.removeEventListener('touchmove', touchMove);
                document.removeEventListener('touchend', touchEnd);
                syncStageSize();
                saveAll();
              }
              document.addEventListener('touchmove', touchMove, {passive:false});
              document.addEventListener('touchend', touchEnd);
            },{passive:false});
          });
          
          // Helper: sync stage size from full editor to stored SVG
          function syncStageSize(){
            const small = document.getElementById('stageSvg');
            if(small && full){
              const w = parseInt(full.dataset.stageWidth || String(STAGE_DEFAULT_WIDTH), 10);
              const h = parseInt(full.dataset.stageHeight || String(STAGE_DEFAULT_HEIGHT), 10);
              small.dataset.stageWidth = String(w);
              small.dataset.stageHeight = String(h);
              // viewBox matches size (no scaling)
              small.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
              small.style.width = w + 'px';
              small.style.height = h + 'px';
              // Update background rect to match
              const smallBg = small.querySelector('rect.stage-bg');
              if(smallBg){
                smallBg.setAttribute('width', String(w - 2));
                smallBg.setAttribute('height', String(h - 2));
              }
            }
          }
        })();
        if(!full){ throw new Error('Stage SVG not found'); }
        // reset children (keep first two nodes: bg rect and title)
        while(full.childNodes.length>2) full.removeChild(full.lastChild);
        if(store){
          Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
          var tnode=store.querySelector('#stageTitle'); var ttl=document.getElementById('stageTitleFull'); if(ttl){ ttl.textContent=(tnode && tnode.textContent) || ttl.textContent; }
        }
  // Ensure arrow markers are available
    ensureStageMarkers(full);
  // Filter defs removed (icons expected to be clean PNGs without white fill)
        // Migration: remove legacy background rects behind emojis/images
        Array.from(full.querySelectorAll('g[data-draggable]')).forEach(gr=>{
          // assign ids/types to legacy nodes
          if(!gr.dataset.id){ gr.dataset.id=String(_nextStageId++); }
          if(!gr.dataset.type){ const k=gr.dataset.key||''; gr.dataset.type=TYPE_MAP[k]||'other'; }
          if(!('showLabel' in gr.dataset)) gr.dataset.showLabel = (gr.dataset.key==='label' || gr.dataset.key==='arrow') ? '1':'0';
          const hasImg = !!gr.querySelector('image');
          const hadEmoji = !!gr.querySelector('text[data-role="emoji"]');
          if(hasImg || hadEmoji){ Array.from(gr.querySelectorAll('rect[data-bg]')).forEach(r=> r.remove()); }
          // Remove any legacy filter attributes
          Array.from(gr.querySelectorAll('image[filter]')).forEach(im=> im.removeAttribute('filter'));
        });
  // Clean up invalid routes to utility types (labels/arrows can't receive connections)
  // Check both type and key since legacy items may have type='other' but key='label'/'arrow'
  const allStageNodes = Array.from(full.querySelectorAll('g[data-draggable]'));
  let cleanedRoutes = false;
  allStageNodes.forEach(g=>{
    const routeToId = g.dataset.routeTo;
    if(routeToId){
      const target = allStageNodes.find(n=> n.dataset.id === routeToId);
      if(target){
        const targetType = target.dataset.type || 'other';
        const targetKey = target.dataset.key || '';
        if(targetType === 'label' || targetType === 'arrow' || targetKey === 'label' || targetKey === 'arrow'){
          // Clear invalid route to utility type
          delete g.dataset.routeTo;
          g.removeAttribute('data-route-to');
          cleanedRoutes = true;
          // Also fix the target's type if it's wrong
          if(targetKey === 'label' && targetType !== 'label') target.dataset.type = 'label';
          if(targetKey === 'arrow' && targetType !== 'arrow') target.dataset.type = 'arrow';
        }
      }
    }
    // Also fix this node's type if needed
    const key = g.dataset.key || '';
    const type = g.dataset.type || 'other';
    if(key === 'label' && type !== 'label') g.dataset.type = 'label';
    if(key === 'arrow' && type !== 'arrow') g.dataset.type = 'arrow';
  });
  if(cleanedRoutes) saveAll();
  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=>{
    enableSvgDrag(g);
    applyLabelTransform(g); // Apply saved label offsets and size
  });
  refreshCables(full);
  bindSelection(full);
  const modal=document.getElementById('stageModal');
  if(!modal){ throw new Error('Stage modal not found'); }
  modal.classList.add('open');
  refreshStageLegend();
  selectNode(null);
  }catch(err){
    if(window && window.alert){ alert('Could not open Stage Plot editor. See console for details.'); }
    if(console && console.error) console.error(err);
  }
}

// closeStageModal function
function closeStageModal(){
  const full=document.getElementById('stageSvgFull');
  let small=document.getElementById('stageSvg');
  
  // Stage dimension constants (must match initStageResize)
  const STAGE_DEFAULT_WIDTH = 1000;
  const STAGE_DEFAULT_HEIGHT = 600;
  
  if(full){
    if(!small){
      const store=document.getElementById('stageStore');
      if(store){ small=full.cloneNode(true); small.id='stageSvg'; small.classList.add('bw'); store.appendChild(small); }
    }
    if(small){
      // Sync stage dimensions from full editor to stored SVG
      const stageW = full.dataset.stageWidth || String(STAGE_DEFAULT_WIDTH);
      const stageH = full.dataset.stageHeight || String(STAGE_DEFAULT_HEIGHT);
      small.dataset.stageWidth = stageW;
      small.dataset.stageHeight = stageH;
      // viewBox must match canvas for 1:1 pixel mapping (no scaling)
      small.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
      small.style.width = stageW + 'px';
      small.style.height = stageH + 'px';
      // Sync background rect
      const bgRect = small.querySelector('rect.stage-bg');
      if(bgRect){
        bgRect.setAttribute('x', '1');
        bgRect.setAttribute('y', '1');
        bgRect.setAttribute('width', String(parseInt(stageW, 10) - 2));
        bgRect.setAttribute('height', String(parseInt(stageH, 10) - 2));
      }
      
      // Sync elements
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
      Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(gr=>{ const lbl=findText(gr); if(lbl){ lbl.style.display = gr.dataset.showLabel==='1' ? 'block':'none'; } });
      ensureStageMarkers(small); refreshCables(small);
      const fullTitle=document.getElementById('stageTitleFull');
      let smallTitle=document.getElementById('stageTitle');
      if(!smallTitle && small){ smallTitle=small.querySelector('#stageTitle'); }
      if(fullTitle){
        if(smallTitle){ smallTitle.textContent=fullTitle.textContent; }
        else {
          const stageWForTitle = parseInt(stageW, 10);
          const t=document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('id','stageTitle'); t.setAttribute('x',String(stageWForTitle/2)); t.setAttribute('y','36'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','22'); t.setAttribute('font-weight','bold'); t.textContent=fullTitle.textContent; small.appendChild(t);
        }
      }
    }
  }
  
  // Save stage to current tour date immediately (use small/stored SVG which was just synced)
  // SAFETY: Only save if we have actual stage content - never overwrite existing data with blank
  if(selectedTourDateId){
    const tourDate = tourDates.find(td => td.id === selectedTourDateId);
    if(tourDate && small){
      // Get the synced small SVG (stageSvg) not the editor (stageSvgFull)
      const hasItems = small.querySelectorAll('g[data-draggable]').length > 0;
      const stageHTML = small.outerHTML;
      // Only save if we have items OR if there was no previous stage data
      if(hasItems || !tourDate.stage){
        tourDate.stage = stageHTML;
      }
      tourDate.gearSummary = gearSummary;
      tourDate.techNotes = techNotes;
    }
  }
  
  saveAll();
  
  // Update Calendar tab preview after closing stage editor
  if(selectedTourDateId){
    const tourDate = tourDates.find(td => td.id === selectedTourDateId);
    if(tourDate && typeof renderTourPreviews === 'function'){
      setTimeout(() => renderTourPreviews(tourDate), 100);
    }
  }
  
  document.getElementById('stageModal').classList.remove('open');
}

    // Unified toggle: Stage Plot <-> Lighting & FX
    function toggleStageAndNotes(){
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      const btn=document.getElementById('stageToggle');
      if(!stageModal || !notesModal || !btn) return;

      const showingStage = stageModal.classList.contains('open');

      if(showingStage){
        // currently Stage Plot -> switch to Lighting / FX view
        closeStageModal();
        buildTechTableFull();
        const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary||'';
        notesModal.classList.add('open');
        btn.textContent = 'Stage Plot';
        saveAll(); // persist after switching away
      } else {
        // currently Lighting / FX (or neither) -> switch to Stage Plot view
        notesModal.classList.remove('open');
        openStageModal();
        btn.textContent = 'Lighting / FX';
        saveAll(); // persist after opening stage
      }
    }
    window.toggleStageAndNotes = toggleStageAndNotes;
    window.openStageModal = openStageModal; // legacy safety
    // final safety: delegate click in case listeners were missed
    document.addEventListener('click',ev=>{
      const trg=ev.target && ev.target.closest ? ev.target.closest('#openStage') : null;
      if(trg){ ev.preventDefault(); openStageModal(); }
    });
    document.getElementById('closeStage').addEventListener('click',closeStageModal);
    // Clear full stage editor
    const clearStageBtn=document.getElementById('clearStage');
    if(clearStageBtn){ clearStageBtn.addEventListener('click',()=>{
      if(isStageLocked()){ alert('Stage plot is locked. Uncheck the lock to make changes.'); return; }
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      // preserve background rect and title only
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll(); snapshotStage();
    }); }
    
    // New Stage button
    const newStageBtn=document.getElementById('newStageBtn');
    if(newStageBtn){ newStageBtn.addEventListener('click',()=>{
      if(isStageLocked()){ alert('Stage plot is locked. Uncheck the lock to make changes.'); return; }
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      const hasItems = full.childNodes.length > 2;
      if(!hasItems){
        alert('Stage is already empty!');
        return;
      }
      const save = confirm('Save current stage plot as a preset before starting fresh?\n\nOK = Save as preset\nCancel = Just clear (lose current plot)');
      if(save){
        const name = prompt('Name this stage preset:', 'Stage ' + new Date().toLocaleDateString());
        if(name && name.trim()){
          const container = document.getElementById('stageStore');
          if(container && container.querySelector('svg')){
            const stageSvgCopy = container.querySelector('svg').cloneNode(true);
            stagePresets.push({
              name: name.trim(),
              svg: stageSvgCopy.outerHTML,
              date: new Date().toISOString()
            });
            saveAll();
            if(typeof renderPresetList === 'function') renderPresetList();
            alert('Stage plot saved as preset: ' + name.trim());
          }
        }
      }
      // Clear stage (preserve background and title)
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll();
      snapshotStage();
    }); }

    // Keyboard shortcuts in stage editor: Ctrl+D duplicate (undo/redo handled globally)
    document.addEventListener('keydown',e=>{
      const modal=document.getElementById('stageModal');
      if(!modal || !modal.classList.contains('open')) return;
      if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
      if(e.ctrlKey && !e.shiftKey && (e.key==='d' || e.key==='D')){
        e.preventDefault();
        const dupBtn=document.getElementById('dupSel');
        if(dupBtn) dupBtn.click();
      }
    });

    // Lighting notes now controlled via unified toggle; keep close button local only
  const closeNotesBtn=document.getElementById('closeNotes');
  if(closeNotesBtn){ closeNotesBtn.addEventListener('click',()=> document.getElementById('notesModal').classList.remove('open')); }

    // Stage Preset Management (stagePresets is global, persists across all dates)
    
    function loadStagePreset(preset){
      if(!preset || !preset.stage) return;
      
      // Stage dimension constants
      const STAGE_DEFAULT_WIDTH = 1000;
      const STAGE_DEFAULT_HEIGHT = 600;
      const STAGE_MIN_SIZE = 300;
      const STAGE_MAX_SIZE = 1500;
      
      const svg = document.getElementById('stageSvgFull');
      const frame = document.getElementById('stageFrame');
      if(!svg) return;
      const parent = svg.parentNode;
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = preset.stage;
      const newSvg = tempDiv.querySelector('svg');
      if(!newSvg) return;
      
      // Extract stored dimensions from preset
      let stageW = parseInt(newSvg.dataset.stageWidth || '0', 10);
      let stageH = parseInt(newSvg.dataset.stageHeight || '0', 10);
      if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
      if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
      
      // Apply dimensions - viewBox must match canvas for 1:1 pixel mapping
      newSvg.id = 'stageSvgFull';
      newSvg.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
      newSvg.dataset.stageWidth = String(stageW);
      newSvg.dataset.stageHeight = String(stageH);
      newSvg.style.width = stageW + 'px';
      newSvg.style.height = stageH + 'px';
      // Ensure background rect matches
      const bgRect = newSvg.querySelector('rect.stage-bg');
      if(bgRect){
        bgRect.setAttribute('x', '1');
        bgRect.setAttribute('y', '1');
        bgRect.setAttribute('width', String(stageW - 2));
        bgRect.setAttribute('height', String(stageH - 2));
      }
      
      if(frame){
        frame.style.width = stageW + 'px';
        frame.style.height = stageH + 'px';
      }
      
      parent.replaceChild(newSvg, svg);
      if(preset.gearSummary !== undefined){
        gearSummary = preset.gearSummary;
        const gearEl = document.getElementById('gear');
        if(gearEl) gearEl.value = gearSummary;
      }
      saveAll();
      rebuildStageInteractions();
      alert(`Preset "${preset.name}" loaded!`);
    }
    
    function rebuildStageInteractions(){
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      svg.querySelectorAll('g[data-draggable]').forEach(enableSvgDrag);
      refreshStageLegend();
      refreshCables(svg);
    }
    
    // Show preset modal - created dynamically to avoid event issues
    function showPresetModal(){
      // Remove any existing modal
      const existing = document.getElementById('presetModal');
      if(existing) existing.remove();
      
      // Create modal overlay
      const modal = document.createElement('div');
      modal.id = 'presetModal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:99999;display:flex;align-items:center;justify-content:center';
      
      // Create modal content
      const content = document.createElement('div');
      content.style.cssText = 'background:#fff;border-radius:10px;padding:24px;max-width:700px;width:90%;max-height:80vh;overflow-y:auto;box-shadow:0 8px 32px rgba(0,0,0,0.3)';
      
      // Header
      const header = document.createElement('h3');
      header.textContent = 'Stage Plot Presets';
      header.style.cssText = 'margin:0 0 16px 0;font-size:20px;color:#1e293b';
      content.appendChild(header);
      
      // Save button
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'üíæ Save Current';
      saveBtn.className = 'btn';
      saveBtn.style.cssText = 'background:#065f46;color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;margin-bottom:16px;font-size:14px';
      saveBtn.onclick = function(e) {
        e.stopPropagation();
        const svg = document.getElementById('stageSvgFull');
        if(!svg) { alert('No stage plot to save'); return; }
        const defaultName = (gig.band || 'Band') + '_StagePlot';
        const name = prompt('Preset name:', defaultName);
        if(!name || !name.trim()) return;
        const preset = {
          name: name.trim(),
          date: new Date().toISOString(),
          stage: svg.outerHTML,
          gearSummary: gearSummary || ''
        };
        stagePresets.push(preset);
        saveAll();
        showPresetModal(); // Refresh
        alert('Preset "' + preset.name + '" saved!');
      };
      content.appendChild(saveBtn);
      
      // Preset list container
      const listContainer = document.createElement('div');
      listContainer.style.cssText = 'margin-bottom:16px';
      
      if(!stagePresets || stagePresets.length === 0){
        listContainer.innerHTML = '<div style="color:#6b7280;font-size:14px;padding:20px;text-align:center;border:2px dashed #d1d5db;border-radius:8px">No presets saved yet</div>';
      } else {
        listContainer.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill, minmax(180px, 1fr));gap:12px;margin-bottom:16px';
        
        stagePresets.forEach((preset, idx) => {
          const card = document.createElement('div');
          card.style.cssText = 'border:2px solid #e5e7eb;border-radius:8px;background:#fff;overflow:hidden;cursor:pointer';
          
          // Thumbnail
          const thumb = document.createElement('div');
          thumb.style.cssText = 'width:100%;height:100px;background:#f8fafc;display:flex;align-items:center;justify-content:center;overflow:hidden;border-bottom:1px solid #e5e7eb';
          if(preset.stage){
            const temp = document.createElement('div');
            temp.innerHTML = preset.stage;
            const svg = temp.querySelector('svg');
            if(svg){
              svg.removeAttribute('id');
              svg.style.cssText = 'width:100%;height:100%;pointer-events:none';
              thumb.appendChild(svg);
            }
          } else {
            thumb.textContent = 'No preview';
          }
          card.appendChild(thumb);
          
          // Info bar
          const info = document.createElement('div');
          info.style.cssText = 'padding:8px;display:flex;align-items:center;justify-content:space-between;gap:6px;background:#f9fafb';
          
          const name = document.createElement('span');
          name.textContent = preset.name;
          name.style.cssText = 'font-size:11px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1';
          info.appendChild(name);
          
          const delBtn = document.createElement('button');
          delBtn.textContent = 'üóëÔ∏è';
          delBtn.style.cssText = 'background:#ef4444;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px';
          delBtn.onclick = function(e) {
            e.stopPropagation();
            if(confirm('Delete "' + preset.name + '"?')){
              stagePresets.splice(idx, 1);
              saveAll();
              showPresetModal(); // Refresh
            }
          };
          info.appendChild(delBtn);
          
          card.appendChild(info);
          
          // Card click to load
          card.onclick = function(e) {
            e.stopPropagation();
            if(confirm('Load "' + preset.name + '"? This will replace your current stage plot.')){
              loadStagePreset(preset);
              modal.remove();
            }
          };
          
          card.onmouseenter = function(){ card.style.borderColor = '#0ea5e9'; };
          card.onmouseleave = function(){ card.style.borderColor = '#e5e7eb'; };
          
          listContainer.appendChild(card);
        });
      }
      content.appendChild(listContainer);
      
      // Close button
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'btn secondary';
      closeBtn.style.cssText = 'background:#6b7280;color:#fff;border:none;padding:10px 24px;border-radius:6px;cursor:pointer;float:right';
      closeBtn.onclick = function(e) {
        e.stopPropagation();
        modal.remove();
      };
      content.appendChild(closeBtn);
      
      // Clear float
      const clearDiv = document.createElement('div');
      clearDiv.style.clear = 'both';
      content.appendChild(clearDiv);
      
      modal.appendChild(content);
      
      // Click outside to close
      modal.onclick = function(e) {
        if(e.target === modal) modal.remove();
      };
      
      // Stop all events from reaching stage behind
      content.onclick = function(e) { e.stopPropagation(); };
      content.onmousedown = function(e) { e.stopPropagation(); };
      content.ontouchstart = function(e) { e.stopPropagation(); };
      
      document.body.appendChild(modal);
    }
    
    // Make showPresetModal globally accessible
    window.showPresetModal = showPresetModal;
    
    const presetBtn = document.getElementById('stagePresetBtnTop');
    if(presetBtn){
      presetBtn.addEventListener('click', ()=>{
        // Open stage plot first if not already open
        const stageModal = document.getElementById('stageModal');
        if(stageModal && !stageModal.classList.contains('open')){
          openStageModal();
        }
        showPresetModal();
      });
    }

    // Drag from toolbox into full SVG at drop position
    let currentDragSource = null;
    let dragHandlersAttached = false;
    
    function attachStageDragHandlers(){
      const fullSvg=document.getElementById('stageSvgFull');
      if(!fullSvg) return;
      
      // Remove old listeners if reattaching
      if(dragHandlersAttached){
        fullSvg.removeEventListener('dragover', stageDragOver);
        fullSvg.removeEventListener('drop', stageDrop);
      }
      
      fullSvg.addEventListener('dragover', stageDragOver);
      fullSvg.addEventListener('drop', stageDrop);
      dragHandlersAttached = true;
    }
    
    function stageDragOver(ev){
      if(isStageLocked()) return;
      ev.preventDefault();
    }
    
    function stageDrop(ev){
      ev.preventDefault();
      if(isStageLocked()) return;
      const fullSvg=document.getElementById('stageSvgFull');
      if(!fullSvg) return;
      
      const key=ev.dataTransfer.getData('text/plain');
      if(!key) return;
      
      // detect target under cursor BEFORE adding new glyph
      const el=document.elementFromPoint(ev.clientX, ev.clientY);
      const dropTarget= el && el.closest && el.closest('g[data-draggable]');
      const pt=fullSvg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=fullSvg.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
      const newNode=addGlyphFull(key,{x:Math.round(svgP.x), y:Math.round(svgP.y)});
      if(newNode) selectNode(newNode);
      if(dropTarget && newNode){
        if(connectEitherDirection(newNode, dropTarget)){
          const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
          refreshCables(fullSvg);
        }
      }
    }
    
    // Attach handlers on page load
    attachStageDragHandlers();
    
    // Track drag source for duplicate prevention
    document.addEventListener('dragstart', (ev)=>{
      const toolBtn = ev.target.closest('.tool');
      if(toolBtn){
        currentDragSource = toolBtn;
      }
    });
    document.addEventListener('dragend', ()=>{
      currentDragSource = null;
    });

    // Arrow drawing: drag anywhere in SVG (hold Shift to draw over items)
    (function(){
      let drawing=null; // {x0,y0, preview}
      const svg=document.getElementById('stageSvgFull');
      if(!svg) return; // Exit if stage editor not available
      ensureStageMarkers(svg);
      function svgPointFromClient(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      function startDraw(x,y){ drawing={x0:x,y0:y, preview:document.createElementNS('http://www.w3.org/2000/svg','line')}; const ln=drawing.preview; ln.setAttribute('x1',String(x)); ln.setAttribute('y1',String(y)); ln.setAttribute('x2',String(x)); ln.setAttribute('y2',String(y)); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-dasharray','4,3'); ln.setAttribute('stroke-width','2'); ln.setAttribute('pointer-events','none'); svg.appendChild(ln); }
      function updateDraw(x,y){ if(!drawing) return; drawing.preview.setAttribute('x2',String(x)); drawing.preview.setAttribute('y2',String(y)); }
      function finishDraw(x1,y1){ if(!drawing){ return; } const {x0,y0, preview}=drawing; svg.removeChild(preview); drawing=null; const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy); if(dist<6){ // treat as click -> create label here
          // Ask first; cancel or empty -> abort (no stray labels)
          let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
          // Create label at point
          const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(x0)); gN.dataset.y=String(Math.round(y0)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='label'; gN.dataset.showLabel='1';
          const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
          applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
          const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
          if(!isMobile){ const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); } }
          _suppressBgClick=true;
          return;
        }
        // Create arrow group anchored at origin (x0,y0) pointing to (x1,y1)
        const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.dataset.x=String(Math.round(x0)); g.dataset.y=String(Math.round(y0)); g.dataset.scale='1'; g.setAttribute('data-draggable','1'); g.dataset.key='arrow'; g.dataset.type='arrow'; g.dataset.showLabel='1';
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line'); ln.setAttribute('x1','0'); ln.setAttribute('y1','0'); ln.setAttribute('x2',String(Math.round(dx))); ln.setAttribute('y2',String(Math.round(dy))); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrowHead)'); g.appendChild(ln);
        // Ask for arrow label; cancel or empty -> abort entire arrow creation
        let enteredA=prompt('Arrow label:',''); if(enteredA==null) return; enteredA=String(enteredA).trim(); if(!enteredA) return;
  const t=document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('x', (Math.abs(dx)>Math.abs(dy) ? (dx<0?-8:8) : 0) );
  const yOff = (dy<0? 14 : -10);
  t.setAttribute('y', String(yOff));
  t.setAttribute('font-size','14'); t.setAttribute('text-anchor','start'); t.setAttribute('dominant-baseline','alphabetic'); t.setAttribute('data-role','label');
  t.textContent=enteredA; g.appendChild(t);
        applyTransform(g); svg.appendChild(g); enableSvgDrag(g); selectNode(g); refreshStageLegend(); saveAll();
        _suppressBgClick=true;
      }
      // Mouse support (capture to preempt item drag when Shift is held)
      svg.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        // ignore UI controls outside svg content AND drag handles
        if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions,.drag-assign-handle')) return;
        const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]'));
        if(overItem && !e.shiftKey) return; // allow drawing over items only with Shift
        const p=svgPointFromClient(e.clientX,e.clientY); startDraw(p.x,p.y); e.stopImmediatePropagation(); e.preventDefault();
      }, {capture:true});
      svg.addEventListener('mousemove',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); updateDraw(p.x,p.y); }, {capture:true});
      window.addEventListener('mouseup',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); finishDraw(p.x,p.y); }, {capture:true});
      // Touch support (capture); only allow drawing from whitespace background
      svg.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions,.drag-assign-handle')) return; const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]')); const onBg = !!(e.target.closest && e.target.closest('.stage-bg')); if(overItem || !onBg) return; const p=svgPointFromClient(t.clientX,t.clientY); startDraw(p.x,p.y); e.preventDefault(); e.stopImmediatePropagation(); }, {passive:false, capture:true});
      window.addEventListener('touchmove',e=>{ if(!drawing) return; const t=e.touches[0]; if(!t) return; const p=svgPointFromClient(t.clientX,t.clientY); updateDraw(p.x,p.y); }, {passive:true});
      window.addEventListener('touchend',e=>{ if(!drawing) return; const ct=(e.changedTouches && e.changedTouches[0])|| (e.touches && e.touches[0]); if(!ct) return; const p=svgPointFromClient(ct.clientX, ct.clientY); finishDraw(p.x,p.y); }, {passive:true});
    })();

    // Removed legacy custom tool buttons (label/rect/default layout). New upload image flow below.
    const uploadBtn=document.getElementById('uploadImageBtn');
    const uploadInput=document.getElementById('uploadImageInput');
    function rebuildCustomImages(){
      const host=document.getElementById('customImages'); if(!host) return; host.innerHTML='';
      (gig.customImages||[]).forEach(ci=>{
        const b=document.createElement('button'); b.className='tool'; b.dataset.key=ci.key; b.innerHTML=`<img src="${ci.data}" alt="${ci.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${ci.label}`; host.appendChild(b);
      });
    }
    if(uploadBtn && uploadInput){
      uploadBtn.addEventListener('click',()=> uploadInput.click());
      uploadInput.addEventListener('change',()=>{
        const file=uploadInput.files && uploadInput.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{
          const dataUrl=reader.result; const rawName=file.name.replace(/\.[^.]+$/,''); const label=prompt('Image label:', rawName)||rawName;
          const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl});
          saveAll(); rebuildCustomImages(); buildTools(); // add to toolbox drag list
        }; reader.readAsDataURL(file);
        uploadInput.value='';
      });
      // hydrate any existing
      rebuildCustomImages();
    }
    // New Icon drawing logic
    const newIconBtn=document.getElementById('newIconBtn');
    const iconModal=document.getElementById('iconMakerModal');
    const iconCanvas=document.getElementById('iconCanvas');
    const iconLineWidth=document.getElementById('iconLineWidth');
    const iconClear=document.getElementById('iconClear');
    const iconSave=document.getElementById('iconSave');
    const iconCancel=document.getElementById('iconCancel');
    let iconDrawing=false; let iconStrokes=[]; let currentStroke=null;
    function openIconModal(){ 
      if(iconModal){ 
        iconModal.style.display='flex'; 
        iconModal.classList.add('open'); 
        iconStrokes=[]; 
        redrawIcon();
      }
    }
    function closeIconModal(){ 
      if(iconModal){ 
        iconModal.classList.remove('open'); 
        iconModal.style.display='none';
        iconStrokes = [];
        if(iconCanvas){
          const ctx = iconCanvas.getContext('2d');
          ctx.clearRect(0, 0, iconCanvas.width, iconCanvas.height);
        }
      }
    }
    
    // Close modal when clicking backdrop
    if(iconModal){
      iconModal.addEventListener('click', (e) => {
        if(e.target === iconModal){
          closeIconModal();
        }
      });
    }
    function redrawIcon(){ if(!iconCanvas) return; const ctx=iconCanvas.getContext('2d'); ctx.clearRect(0,0,iconCanvas.width,iconCanvas.height); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle='#000'; iconStrokes.forEach(st=>{ ctx.lineWidth=st.w; ctx.beginPath(); st.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.stroke(); }); }
    function classifyStroke(pts){ 
      if(pts.length<8) return 'line';
      const first=pts[0], last=pts[pts.length-1];
      const minX=Math.min(...pts.map(p=>p.x)), maxX=Math.max(...pts.map(p=>p.x));
      const minY=Math.min(...pts.map(p=>p.y)), maxY=Math.max(...pts.map(p=>p.y));
      const w=maxX-minX, h=maxY-minY;
      const closeDist=Math.hypot(last.x-first.x,last.y-first.y);
      
      // Must be a closed shape
      if(closeDist > Math.max(30, 0.2*Math.max(w,h))) return 'line';
      if(pts.length<12) return 'line';
      
      // Look for concentrated direction changes (corners)
      // Group nearby angle changes together as one corner
      let cornerRegions = [];
      const minCornerAngle = Math.PI/4; // 45 degrees
      
      for(let i=5; i<pts.length-5; i++){
        const dx1 = pts[i].x - pts[i-5].x;
        const dy1 = pts[i].y - pts[i-5].y;
        const dx2 = pts[i+5].x - pts[i].x;
        const dy2 = pts[i+5].y - pts[i].y;
        
        const len1 = Math.hypot(dx1, dy1);
        const len2 = Math.hypot(dx2, dx2);
        if(len1 < 10 || len2 < 10) continue;
        
        const angle1 = Math.atan2(dy1, dx1);
        const angle2 = Math.atan2(dy2, dx2);
        let diff = Math.abs(angle2 - angle1);
        if(diff > Math.PI) diff = 2*Math.PI - diff;
        
        if(diff > minCornerAngle){
          // Check if this is near an existing corner region
          const nearExisting = cornerRegions.some(c => Math.abs(i - c) < 15);
          if(!nearExisting){
            cornerRegions.push(i);
          }
        }
      }
      
      // 3-5 distinct corner regions = rectangle
      if(cornerRegions.length >= 3 && cornerRegions.length <= 5){
        return 'rect';
      }
      
      // Smooth path with 0-2 corners = circle/ellipse
      if(cornerRegions.length <= 2){
        const aspect = w/h;
        if(aspect > 0.5 && aspect < 2.0){
          return 'ellipse';
        }
      }
      
      return 'line';
    }
    function normalizeStrokes(){ // replace rough shapes with ideal forms
      iconStrokes=iconStrokes.map(st=>{ const kind=classifyStroke(st.pts); if(kind==='line'){ return st; } const minX=Math.min(...st.pts.map(p=>p.x)), maxX=Math.max(...st.pts.map(p=>p.x)); const minY=Math.min(...st.pts.map(p=>p.y)), maxY=Math.max(...st.pts.map(p=>p.y)); if(kind==='rect'){ return {w:st.w, pts:[{x:minX,y:minY},{x:maxX,y:minY},{x:maxX,y:maxY},{x:minX,y:maxY},{x:minX,y:minY}]}; } if(kind==='ellipse'){ const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const rx=(maxX-minX)/2, ry=(maxY-minY)/2; const steps=40; const pts=[]; for(let i=0;i<=steps;i++){ const a=(i/steps)*Math.PI*2; pts.push({x:cx+rx*Math.cos(a), y:cy+ry*Math.sin(a)}); } return {w:st.w, pts}; } return st; }); }
    function iconPointerDown(x,y){ iconDrawing=true; currentStroke={w:parseInt(iconLineWidth.value)||4, pts:[{x,y}]}; iconStrokes.push(currentStroke); redrawIcon(); }
    function iconPointerMove(x,y){ if(!iconDrawing || !currentStroke) return; currentStroke.pts.push({x,y}); redrawIcon(); }
    function iconPointerUp(){ if(!iconDrawing) return; iconDrawing=false; currentStroke=null; normalizeStrokes(); redrawIcon(); }
    if(iconCanvas){
      iconCanvas.addEventListener('mousedown',e=>{ 
        e.preventDefault();
        e.stopPropagation();
        const r=iconCanvas.getBoundingClientRect(); 
        iconPointerDown(e.clientX-r.left,e.clientY-r.top);
      });
      window.addEventListener('mousemove',e=>{ 
        if(!iconDrawing) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerMove(e.clientX-r.left,e.clientY-r.top);
      });
      window.addEventListener('mouseup',()=> iconPointerUp());
      iconCanvas.addEventListener('touchstart',e=>{ 
        e.preventDefault();
        e.stopPropagation();
        const t=e.touches[0];
        if(!t) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerDown(t.clientX-r.left,t.clientY-r.top);
      }, {passive:false});
      iconCanvas.addEventListener('touchmove',e=>{ 
        e.preventDefault();
        const t=e.touches[0];
        if(!t) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerMove(t.clientX-r.left,t.clientY-r.top);
      }, {passive:false});
      iconCanvas.addEventListener('touchend',e=>{ 
        e.preventDefault();
        iconPointerUp();
      });
    }
    if(newIconBtn) newIconBtn.addEventListener('click', openIconModal);
    if(iconCancel) iconCancel.addEventListener('click', closeIconModal);
    if(iconClear) iconClear.addEventListener('click',()=>{ iconStrokes=[]; redrawIcon(); });
    if(iconSave) iconSave.addEventListener('click',()=>{ if(!iconCanvas) return; normalizeStrokes(); redrawIcon(); const label=prompt('Icon label:','Custom')||'Custom'; const dataUrl=iconCanvas.toDataURL('image/png'); const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl}); saveAll(); rebuildCustomImages(); buildTools(); closeIconModal(); });
    // (Removed default layout auto-placement code)

    // Shuffle playlist (guard if legacy button exists)
    (function(){ const sh=document.getElementById('shuffleBtn'); if(!sh) return; sh.addEventListener('click',()=>{
      const songs=setlist.filter(x=>x.type==='song');
      const others=setlist.filter(x=>x.type!=='song');
      const shuffled=shuffle(songs);
      // keep others in their relative positions (insert breaks/encore by index mapping)
      let i=0; setlist=setlist.map(x=> x.type==='song' ? shuffled[i++] : x);
      buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll();
    }); })();

    // Gig info now edited directly on sheet header (no separate input fields)
    // Header flags removed - all header elements now always visible and directly editable
  // Logo and font selection UI removed - now edited directly on sheet
    // Gear summary persistence
  const gearEl2=document.getElementById('gear'); if(gearEl2){ gearEl2.addEventListener('input',()=>{ gearSummary=gearEl2.value; }); gearEl2.addEventListener('change',()=>{ gearSummary=gearEl2.value; saveAll(); }); }

    // Global print chooser wiring
    function openPrintChooser(pref){
      const dlg=document.getElementById('printChooser');
      // Close other modals so chooser is visible above everything and not printed with them
      ['stageModal','notesModal','modal','modalTech'].forEach(id=>{ const m=document.getElementById(id); if(m) m.classList.remove('open'); });
      const cSet=document.getElementById('pSet');
      const cStage=document.getElementById('pStage');
      const cTech=document.getElementById('pTech');
      // default: at least one checked
      const all=[cSet,cStage,cTech];
      all.forEach(c=> c.checked=false);
      if(pref==='set') cSet.checked=true; else if(pref==='stage') cStage.checked=true; else if(pref==='tech') cTech.checked=true; else cSet.checked=true;
      dlg.classList.add('open');
      validatePrintSelection();
    }
    function validatePrintSelection(){
      const btn=document.getElementById('doPrint');
      const any= document.getElementById('pSet').checked || document.getElementById('pStage').checked || document.getElementById('pTech').checked || document.getElementById('pLyrics').checked || document.getElementById('pItinerary').checked;
      btn.disabled = !any;
    }
    ['pSet','pStage','pTech','pLyrics','pItinerary'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('change',validatePrintSelection); }});
    
    // Lyrics checkbox handler - show song selector when checked
    const pLyricsCheckbox = document.getElementById('pLyrics');
    const lyricsSongSelector = document.getElementById('lyricsSongSelector');
    const lyricsSongList = document.getElementById('lyricsSongList');
    if(pLyricsCheckbox && lyricsSongSelector && lyricsSongList){
      pLyricsCheckbox.addEventListener('change', ()=>{
        if(pLyricsCheckbox.checked){
          // Populate song list with ALL songs from database that have lyrics
          lyricsSongList.innerHTML = '';
          const songsWithLyrics = db.filter(s => s.lyrics && s.lyrics.trim());
          if(songsWithLyrics.length === 0){
            lyricsSongList.innerHTML = '<div style="color:#9ca3af;font-size:12px">No songs with lyrics in database.</div>';
            lyricsSongSelector.style.display = 'block';
            return;
          }
          songsWithLyrics.forEach(s => {
            const label = document.createElement('label');
            label.style.cssText = 'display:flex;align-items:center;gap:6px;cursor:pointer';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.songId = s.id;
            checkbox.checked = false; // Default none selected
            label.appendChild(checkbox);
            const text = document.createElement('span');
            text.textContent = `${s.title} - ${s.artist || 'Original'}`;
            text.style.fontSize = '13px';
            label.appendChild(text);
            lyricsSongList.appendChild(label);
          });
          lyricsSongSelector.style.display = 'block';
        } else {
          lyricsSongSelector.style.display = 'none';
        }
      });
    }
    
    const openPrintFab=document.getElementById('openPrintOptions');
    if(openPrintFab){ openPrintFab.addEventListener('click',()=> openPrintChooser()); }
    const openPrintTop=document.getElementById('openPrintOptionsTop');
    if(openPrintTop){ openPrintTop.addEventListener('click',()=> openPrintChooser()); }
    document.getElementById('closePrintChooser').addEventListener('click',()=> document.getElementById('printChooser').classList.remove('open'));
  document.getElementById('printTechModal').addEventListener('click',()=> openPrintChooser('tech'));

    async function printSelected(){
      console.log('üñ®Ô∏è Starting print preparation...');
      
      const wantSet=document.getElementById('pSet').checked;
      const wantStage=document.getElementById('pStage').checked;
      const wantTech=document.getElementById('pTech').checked;
      const wantLyrics=document.getElementById('pLyrics').checked;
      const wantItinerary=document.getElementById('pItinerary').checked;
      
      // PRE-BUILD all content BEFORE printing to ensure SVGs are rendered
      try{ 
        console.log('Building setlist sheet...');
        buildSheet('sheetInline'); 
      }catch(e){ console.error('Failed to build sheet:', e); }
      
      try{ 
        console.log('Building tech header...');
        prepHdrTech(); 
      }catch(e){ console.error('Failed to build tech header:', e); }
      
      // If stage plot is needed, build it NOW and wait for images to load
      if(wantStage){
        try{
          console.log('Pre-building stage plot...');
          const stageOut = document.getElementById('stagePrint');
          if(stageOut){
            stageOut.innerHTML = '';
            stageOut.style.display = 'block';
            buildStageExport(stageOut);
            
            // Wait for all stage images to load
            const stageSvg = stageOut.querySelector('svg');
            if(stageSvg){
              console.log('Loading stage images...');
              await inlineStageImages(stageSvg);
              console.log('‚úÖ Stage images loaded');
            }
          }
        }catch(e){ console.error('Failed to pre-build stage:', e); }
      }
      
      // Build task queue
      const tasks=[];
      if(wantSet) tasks.push(()=> printSetOnce());
      if(wantStage) tasks.push(()=> printStageOnce());
      if(wantTech) tasks.push(()=> printTechOnlyOnce());
      if(wantLyrics) tasks.push(()=> printLyricsOnce());
      if(wantItinerary) tasks.push(()=> printItineraryOnce());
      
      // Close chooser before printing to prevent it from being captured by print
      document.getElementById('printChooser').classList.remove('open');
      
      console.log(`üñ®Ô∏è Executing ${tasks.length} print tasks...`);
      for(const t of tasks){ await t(); }
      console.log('‚úÖ All print tasks complete');
    }
    document.getElementById('doPrint').addEventListener('click',printSelected);

    // PDF/ZIP download removed: users can use native browser print dialog for PDF saving.

    function makePdfFromCanvas(canvas, paper){
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p', 'pt', paper||'letter');
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      let imgW = pageW;
      let imgH = canvas.height * (imgW / canvas.width);
      if(imgH > pageH){ imgH = pageH; imgW = canvas.width * (imgH / canvas.height); }
      const x = (pageW - imgW)/2, y=(pageH - imgH)/2;
      pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
      return pdf.output('blob');
    }

    function withOffscreen(el, fn){
      // Ensure element AND its hidden ancestors are visible for layout so html2canvas gets real size
      const stack=[]; let node=el;
      while(node && node.nodeType===1){
        stack.push({node, style:{display:node.style.display, visibility:node.style.visibility, position:node.style.position, left:node.style.left, top:node.style.top}});
        node.style.display='block';
        node.style.visibility='visible';
        node = node.parentElement;
      }
      // Position target far offscreen to avoid flicker
      el.style.position='fixed'; el.style.left='-10000px'; el.style.top='0';
      return Promise.resolve(fn()).finally(()=>{
        // Restore styles in reverse order
        for(let i=0;i<stack.length;i++){
          const {node, style}=stack[i];
          node.style.display=style.display;
          node.style.visibility=style.visibility;
          node.style.position=style.position;
          node.style.left=style.left;
          node.style.top=style.top;
        }
      });
    }
    async function createSetlistPdfBlob(){
      // Use inline sheet for export (already WYSIWYG)
      buildSheet('sheetInline');
      const el=document.getElementById('sheetInline');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for setlist (mobile or missing PDF libs).');
        // Build print sheet to match preview exactly
        buildSheet('sheet');
        document.getElementById('modal').classList.add('open'); await printPromise(); window.print(); document.getElementById('modal').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, (el.classList.contains('a4')? 'a4' : 'letter'));
      return blob;
    }
    // Helper: obtain current stage SVG (fullscreen editor if open, else stored miniature)
    function getStageSource(){
      let src=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      if(!src){ const store=document.getElementById('stageStore'); if(store){ src=store.querySelector('svg'); } }
      return src;
    }
    // Helper: build channel-ordered legend + cloned stage (with border) identical to printStageOnce
    function buildStageExport(into){
      const stageOut = into; stageOut.innerHTML='';
      const src=getStageSource();
      // Clear any selection highlight before export so no blue glow prints
      document.querySelectorAll('g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      const legend=document.createElement('table'); legend.className='tech-table';
      const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Channel</th><th>Chain</th></tr>';
      const tbody=document.createElement('tbody');
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const isStereo=n=> (n.dataset.key||'')==='stereoPair';
        const typeOf=n=> n.dataset.type||'other';
        const findRoot=(end)=>{ let cur=end; const seen=new Set(); while(cur && !seen.has(cur)){ seen.add(cur); const prev=rows.find(r=> r.dataset.routeTo===cur.dataset.id && effectiveTargets(r).includes(typeOf(cur))); if(!prev) break; cur=prev; } return cur||end; };
        const buildChain=(from)=>{ const seen=new Set(); const parts=[]; let cur=from; while(cur){ if(seen.has(cur)) break; seen.add(cur); const t=cur.querySelector('text[data-role="label"]')||cur.querySelector('text'); const base=(t && t.textContent)||(cur.dataset.key||'Item'); parts.push(base); const nid=cur.dataset.routeTo||''; if(!nid) break; const next=rows.find(r=> r.dataset.id===nid); if(!next) break; const nextType=typeOf(next); const nextKey=next.dataset.key||''; if(nextType==='label' || nextType==='arrow' || nextKey==='label' || nextKey==='arrow') break; const ok=effectiveTargets(cur).includes(nextType); if(!ok) break; cur=next; } const last=cur||from; if(last.dataset.channel){ if(isStereo(last)){ const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1)); } else { parts.push('Ch '+last.dataset.channel); } } return parts.join(' - '); };
        // Collect only endpoints that have an assigned channel (used channels only)
        const endpoints=rows.filter(r=> r.dataset.channel && r.dataset.channel!=='' && (parseInt(r.dataset.channel||'0',10)>0));
        const byCh = endpoints
          .map(n=> ({ node:n, ch: parseInt(n.dataset.channel||'0',10)||0 }))
          .filter(x=> x.ch>0)
          .sort((a,b)=> a.ch - b.ch);
        for(const {node:end, ch} of byCh){
          const tr=document.createElement('tr');
          const chCell=document.createElement('td');
          if(isStereo(end)) chCell.textContent = `${ch} & ${ch+1}`; else chCell.textContent=String(ch);
          const chainCell=document.createElement('td');
          const root=findRoot(end); chainCell.textContent = buildChain(root);
          tr.append(chCell, chainCell); tbody.appendChild(tr);
        }
      }
      legend.append(thead,tbody);
      // Add unconnected items section to print legend
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const typeOf=n=> n.dataset.type||'other';
        const UTILITY_TYPES=['label','arrow'];
        const unconnectedRows = rows.filter(g=>{
          const t=typeOf(g);
          if(UTILITY_TYPES.includes(t)) return false;
          const hasRouteTo = (g.dataset.routeTo||'').trim().length>0;
          const hasChannel = (g.dataset.channel||'').trim().length>0 && parseInt(g.dataset.channel||'0',10)>0;
          const routedTo = rows.some(r=> (r.dataset.routeTo===g.dataset.id) && effectiveTargets(r).includes(t));
          return !hasRouteTo && !hasChannel && !routedTo;
        });
        if(unconnectedRows.length>0){
          const dividerRow=document.createElement('tr');
          const dividerCell=document.createElement('td'); dividerCell.colSpan=2;
          dividerCell.style.cssText='border-top:2px solid #000;padding-top:8px;padding-bottom:4px;font-weight:600;font-size:11pt';
          dividerCell.textContent='Unconnected Items (acoustic/props): ';
          const itemNames = unconnectedRows.map(g=>{
            const tEl=g.querySelector('text[data-role="label"]')||g.querySelector('text');
            const key=g.dataset.key||'';
            const icon=ICON_ITEMS.find(x=>x.key===key);
            return (tEl && tEl.textContent) || (icon?icon.label:'Item');
          });
          const boldSpan=document.createElement('span');
          boldSpan.style.fontWeight='bold';
          boldSpan.textContent=itemNames.join(', ');
          dividerCell.appendChild(boldSpan);
          dividerRow.appendChild(dividerCell);
          tbody.appendChild(dividerRow);
        }
      }
      stageOut.appendChild(legend);
      if(src){
        // Stage dimension constants
        const STAGE_DEFAULT_WIDTH = 1000;
        const STAGE_DEFAULT_HEIGHT = 600;
        const STAGE_MIN_SIZE = 300;
        const STAGE_MAX_SIZE = 1500;
        
        const clone=src.cloneNode(true); 
        clone.removeAttribute('id'); 
        clone.setAttribute('preserveAspectRatio','xMidYMid meet');
        
        // Get the stored canvas size
        let stageW = parseInt(src.dataset.stageWidth || '0', 10);
        let stageH = parseInt(src.dataset.stageHeight || '0', 10);
        if(stageW < STAGE_MIN_SIZE || stageW > STAGE_MAX_SIZE) stageW = STAGE_DEFAULT_WIDTH;
        if(stageH < STAGE_MIN_SIZE || stageH > STAGE_MAX_SIZE) stageH = STAGE_DEFAULT_HEIGHT;
        
        // viewBox must match canvas for 1:1 mapping - print at actual proportions
        clone.setAttribute('viewBox', '0 0 ' + stageW + ' ' + stageH);
        
        // Calculate aspect ratio from stored canvas size for print layout
        const aspectRatio = stageW / stageH;
        
        // For print: fit within 7.5in wide, 6.5in tall, maintaining stored aspect ratio
        const maxPrintW = 7.5; // inches
        const maxPrintH = 6.5; // inches
        let printW = maxPrintW;
        let printH = printW / aspectRatio;
        if(printH > maxPrintH){
          printH = maxPrintH;
          printW = printH * aspectRatio;
        }
        
        clone.style.width = printW + 'in';
        clone.style.height = printH + 'in';
        clone.style.maxWidth = '100%';
        clone.style.display = 'block';
        clone.style.margin = '0 auto';
        
        // Ensure background rect matches stage size
        const bgRect = clone.querySelector('rect.stage-bg');
        if(bgRect){
          bgRect.setAttribute('x', '1');
          bgRect.setAttribute('y', '1');
          bgRect.setAttribute('width', String(stageW - 2));
          bgRect.setAttribute('height', String(stageH - 2));
        }
        
        // Add print border that matches the actual stage size
        try{ 
          // Remove any existing print borders
          clone.querySelectorAll('[data-print-border]').forEach(el => el.remove());
          
          const br=document.createElementNS('http://www.w3.org/2000/svg','rect'); 
          br.setAttribute('x','1.5'); 
          br.setAttribute('y','1.5'); 
          br.setAttribute('width', String(stageW - 3)); 
          br.setAttribute('height', String(stageH - 3)); 
          br.setAttribute('fill','none'); 
          br.setAttribute('stroke','#000'); 
          br.setAttribute('stroke-width','3'); 
          br.setAttribute('pointer-events','none'); 
          br.setAttribute('data-print-border','1'); 
          clone.appendChild(br); 
        }catch(_){ }
        stageOut.appendChild(clone);
      }
      return stageOut;
    }
    async function inlineStageImages(svg){
      if(!svg) return;
      const images=Array.from(svg.querySelectorAll('image'));
      for(const im of images){
        const href=im.getAttribute('href')||im.getAttribute('xlink:href');
        if(!href || href.startsWith('data:')) continue;
        try{
          const resp=await fetch(href);
          if(!resp.ok) continue;
          const blob=await resp.blob();
          await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>{ im.setAttribute('href', fr.result); res(); }; fr.readAsDataURL(blob); });
        }catch(e){ /* ignore fetch failures (e.g. file:// restrictions) */ }
      }
    }
    async function createStagePdfBlob(){
      prepHdrTech(); const techOut=$('#techPrint'); techOut.innerHTML='';
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; buildStageExport(stageOut); // unified rendering identical to print
      // Keep legend with stage plot on same page for PDF
      const legend = stageOut.querySelector('table.tech-table');
      // Don't move legend, leave it in stageOut for single-page layout
      // Remove page breaks to fit everything on one page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      await inlineStageImages(stageOut.querySelector('svg'));
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for stage (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2, useCORS:true, allowTaint:true}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }
    async function createTechPdfBlob(){
      prepHdrTech(); const stageOut=$('#stagePrint'); stageOut.innerHTML=''; const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl);
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for tech sheet (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }

    function printPromise(){ 
      const delay = isMobileLike() ? 800 : 150; // Mobile needs more time to render
      return new Promise(res=> setTimeout(res, delay)); 
    }
    
    // Convert SVG to high-quality canvas for reliable printing across platforms
    async function svgToCanvas(svgElement, targetWidth, targetHeight) {
      return new Promise((resolve, reject) => {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // High DPI for crisp print output
          const scale = 2;
          canvas.width = targetWidth * scale;
          canvas.height = targetHeight * scale;
          canvas.style.width = targetWidth + 'px';
          canvas.style.height = targetHeight + 'px';
          ctx.scale(scale, scale);
          
          // Serialize SVG to data URL
          const serializer = new window.XMLSerializer();
          const svgData = serializer.serializeToString(svgElement);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          
          const img = new Image();
          img.onload = () => {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, targetWidth, targetHeight);
            ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
            URL.revokeObjectURL(url);
            resolve(canvas);
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load SVG'));
          };
          img.src = url;
        } catch (e) {
          reject(e);
        }
      });
    }
    
    // Platform-specific print preparation
    async function preparePrintContent(modalElement, contentElement) {
      const paperSize = getPreferredPaperSize();
      const isLetter = paperSize === 'letter';
      
      // Paper dimensions in pixels at 96 DPI (standard screen DPI)
      const paperWidth = isLetter ? 816 : 794;  // 8.5in or 210mm
      const paperHeight = isLetter ? 1056 : 1123; // 11in or 297mm
      
      // Convert any SVG elements to canvas for reliable printing
      const svgElements = contentElement.querySelectorAll('svg');
      for (const svg of svgElements) {
        if (isAndroid() || isIOS()) {
          // Mobile: Convert SVG to canvas for consistent rendering
          const rect = svg.getBoundingClientRect();
          const canvas = await svgToCanvas(svg, rect.width, rect.height);
          canvas.className = svg.className;
          svg.parentNode.replaceChild(canvas, svg);
        } else {
          // Desktop: Keep SVG but ensure proper sizing
          svg.style.maxWidth = '100%';
          svg.style.height = 'auto';
        }
      }
      
      return { paperWidth, paperHeight, paperSize };
    }
    
    async function printSetOnce(){ 
      console.log('üñ®Ô∏è SETLIST PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      const modal=document.getElementById('modal'); 
      const sheet=document.getElementById('sheet');
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      const fileMenuContainer=document.querySelector('.file-menu-container');
      const dateHeader=document.querySelector('.date-header');
      
      // Hide everything except modal content for all platforms
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      if(fileMenuContainer) fileMenuContainer.style.display='none';
      if(dateHeader) dateHeader.style.display='none';
      
      modal.classList.add('open'); 
      modal.style.display='flex'; // Force visible
      modal.style.position='static'; // Ensure in document flow for mobile
      
      // Set sheet to print dimensions BEFORE building (remove preview scale)
      if(sheet) {
        sheet.style.transform = 'none';
        sheet.style.width = '8.5in';
        sheet.style.padding = '0.15in 0.25in';
      }
      
      await printPromise();
      
      // NOW build the sheet at print dimensions so fitToPage calculates correctly
      buildSheet('sheet');
      
      // Platform-specific handling
      if(sheet) {
        sheet.style.opacity='1';
        sheet.style.visibility='visible';
        
        // Count songs to determine if we need multiple pages
        const songCount = setlist.filter(x => x.title || x.type === 'break' || x.type === 'encore').length;
        const isLargeSetlist = songCount > 35;
        
        // For large setlists, allow content to flow to multiple pages
        if(isLargeSetlist){
          sheet.style.height = 'auto';
          sheet.style.minHeight = 'auto';
          sheet.style.maxHeight = 'none';
          sheet.style.overflow = 'visible';
          sheet.style.aspectRatio = 'unset';
          // Let the songs container also overflow
          const songsEl = sheet.querySelector('.songs');
          if(songsEl){
            songsEl.style.height = 'auto';
            songsEl.style.overflow = 'visible';
            songsEl.style.justifyContent = 'flex-start';
            songsEl.style.gap = '2pt';
          }
        } else {
          sheet.style.height = '10.5in';
          sheet.style.minHeight = '10.5in';
          sheet.style.overflow = 'hidden';
        }
        
        // Prepare content for printing (convert SVGs if needed)
        await preparePrintContent(modal, sheet);
        
        // Force layout recalculation
        sheet.offsetHeight;
      }
      
      // Extra wait for mobile devices
      await printPromise();
      if(isMobileLike()) {
        await printPromise(); // Double wait for mobile
      }
      
      console.log('üñ®Ô∏è Triggering print dialog...');
      window.print(); 
      await printPromise();
      
      modal.classList.remove('open'); 
      modal.style.display=''; // Reset
      modal.style.position=''; // Reset
      
      // Reset sheet styles for preview mode
      if(sheet) {
        sheet.style.transform = '';
        sheet.style.width = '';
        sheet.style.minHeight = '';
        sheet.style.height = '';
        sheet.style.padding = '';
      }
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      if(fileMenuContainer) fileMenuContainer.style.display='';
      if(dateHeader) dateHeader.style.display='';
      
      await printPromise();
      console.log('‚úÖ Setlist print complete');
    }
    function prepHdrTech(){
      const hdr=$('#hdrTech'); hdr.innerHTML='';
      const hf=(function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band&&!f.venue&&!f.sub&&!f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.append(el('div','band',(gig.band||'BAND')));
      if(hf.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
      if(hf.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
      if(hf.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
    }
    async function printStageOnce(){
      console.log('üñ®Ô∏è STAGE PLOT PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech();
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='none';
      const stageOut=$('#stagePrint');
      
      // Check if stage content was already built in printSelected()
      const hasPrebuiltStage = stageOut && stageOut.querySelector('svg');
      if(!hasPrebuiltStage){
        console.log('Stage not pre-built, building now...');
        stageOut.innerHTML='';
        buildStageExport(stageOut);
        // Force images to load before printing
        await inlineStageImages(stageOut.querySelector('svg'));
      } else {
        console.log('Using pre-built stage content');
      }
      
      stageOut.style.display='block';
      
      // Keep legend with stage plot on same page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      // Hide everything except the tech/stage modal content
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(setlistModal) setlistModal.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      
      const modal=document.getElementById('modalTech');
      modal.classList.add('open');
      modal.style.display='flex'; // Force visible for mobile
      modal.style.position='static'; // Ensure in document flow
      
      await printPromise();
      
      // Platform-specific SVG handling
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        sheet.style.opacity='1';
        sheet.style.visibility='visible';
        
        // For mobile: rebuild the stage SVG at correct scale AFTER modal is visible
        if(isMobileLike()){
          console.log('üì± Mobile detected - rebuilding stage at correct scale...');
          stageOut.innerHTML='';
          buildStageExport(stageOut);
          await inlineStageImages(stageOut.querySelector('svg'));
          await printPromise(); // Extra time for images to load
        }
        
        // Prepare content for printing (convert SVGs on mobile)
        await preparePrintContent(modal, stageOut);
        
        // Force layout recalculation
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='flex';
        sheet.offsetHeight; // trigger reflow again
      }
      
      // Extra wait for mobile devices
      await printPromise();
      if(isMobileLike()) {
        await printPromise(); // Double wait for mobile
      }
      
      console.log('üñ®Ô∏è Triggering print dialog for stage plot...');
      window.print();
      await printPromise();
      modal.classList.remove('open');
      modal.style.display=''; // Reset
      modal.style.position=''; // Reset
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(setlistModal) setlistModal.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      
      await printPromise();
      console.log('‚úÖ Stage plot print complete');
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        // Re-render the current view by toggling stage/notes modals
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          // Stage was visible - reopen it
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          // Tech table was visible - rebuild it
          try{ buildTechTableFull(); }catch(_){}
        } else {
          // Neither was open, default to stage plot
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }
    async function printTechOnlyOnce(){ 
      console.log('üñ®Ô∏è TECH NOTES PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech(); 
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; stageOut.style.display='none'; 
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='block';
      // Ensure no forced page break when printing tech-only
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl); 
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      // Hide everything except the tech modal content
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(setlistModal) setlistModal.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      
      const modal=document.getElementById('modalTech'); 
      modal.classList.add('open'); 
      await printPromise(); 
      
      // Force layout recalculation
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering print dialog for tech notes...');
      window.print(); 
      await printPromise();
      modal.classList.remove('open'); 
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(setlistModal) setlistModal.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      
      await printPromise();
      console.log('‚úÖ Tech notes print complete');
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          try{ buildTechTableFull(); }catch(_){}
        } else {
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }
    
    async function printLyricsOnce(){
      console.log('üñ®Ô∏è LYRICS PRINT');
      
      // Get selected song IDs from the lyrics selector
      const selectedSongIds = [];
      const lyricsSongList = document.getElementById('lyricsSongList');
      if(lyricsSongList){
        const checkboxes = lyricsSongList.querySelectorAll('input[type="checkbox"]:checked');
        checkboxes.forEach(cb => {
          if(cb.dataset.songId) selectedSongIds.push(cb.dataset.songId);
        });
      }
      
      if(selectedSongIds.length === 0){
        alert('No songs selected for lyrics printing.');
        return;
      }
      
      // Hide ALL UI elements that could interfere with print
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const modals=document.querySelectorAll('.modal');
      const stagePrint = document.getElementById('stagePrint');
      const techPrint = document.getElementById('techPrint');
      const modalTech = document.getElementById('modalTech');
      const stageModal = document.getElementById('stageModal');
      const notesModal = document.getElementById('notesModal');
      const modal = document.getElementById('modal');
      
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      modals.forEach(m => { m.style.display='none'; m.classList.remove('open'); });
      // Explicitly hide stage-related elements
      if(stagePrint) stagePrint.style.display='none';
      if(techPrint) techPrint.style.display='none';
      if(modalTech) { modalTech.style.display='none'; modalTech.classList.remove('open'); }
      if(stageModal) { stageModal.style.display='none'; stageModal.classList.remove('open'); }
      if(notesModal) { notesModal.style.display='none'; notesModal.classList.remove('open'); }
      if(modal) { modal.style.display='none'; modal.classList.remove('open'); }
      
      // Create a temporary print container
      const printContainer = document.createElement('div');
      printContainer.id = 'lyricsPrintContainer';
      printContainer.style.cssText = 'width:8.5in;padding:0.15in 0.4in;font-family:system-ui,-apple-system,sans-serif;background:white;margin:0 auto';
      
      // Get songs directly from database and print whatever text is in the lyrics field
      for(const id of selectedSongIds){
        const dbSong = db.find(ds => ds.id == id);
        if(!dbSong) continue;
        
        const songPage = document.createElement('div');
        songPage.style.cssText = 'page-break-after:always;page-break-inside:avoid;min-height:10in;max-height:10.5in';
        
        const title = document.createElement('h1');
        title.textContent = dbSong.title || 'Untitled';
        title.style.cssText = 'font-size:16px;font-weight:bold;margin:0 0 2px 0;color:#111';
        
        const artist = document.createElement('h2');
        artist.textContent = dbSong.artist || 'Original';
        artist.style.cssText = 'font-size:12px;font-weight:600;margin:0 0 8px 0;color:#666';
        
        const lyrics = document.createElement('div');
        // Remove excessive blank lines (more than 2 consecutive newlines become 2)
        const cleanedLyrics = (dbSong.lyrics || '(no lyrics)').replace(/\n\n\n+/g, '\n\n');
        lyrics.textContent = cleanedLyrics;
        lyrics.style.cssText = 'white-space:pre-wrap;font-family:system-ui,-apple-system,sans-serif;font-size:11px;line-height:1.35;margin:0;color:#111';
        
        songPage.appendChild(title);
        songPage.appendChild(artist);
        songPage.appendChild(lyrics);
        printContainer.appendChild(songPage);
      }
      
      document.body.appendChild(printContainer);
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering lyrics print dialog...');
      window.print();
      await printPromise();
      
      // Cleanup
      document.body.removeChild(printContainer);
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      modals.forEach(m => m.style.display='');
      // Restore stage-related elements (don't re-show them, just remove display:none)
      if(stagePrint) stagePrint.style.display='';
      if(techPrint) techPrint.style.display='';
      if(modalTech) modalTech.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      if(modal) modal.style.display='';
      
      console.log('‚úÖ Lyrics print complete');
    }
    
    async function printItineraryOnce(){
      console.log('üñ®Ô∏è ITINERARY PRINT');
      
      // Get current tour date
      const tourDate = tourDates.find(td => td.id === selectedTourDateId);
      if(!tourDate){
        alert('No tour date selected for itinerary printing.');
        return;
      }
      
      if(!tourDate.itinerary || tourDate.itinerary.length === 0){
        alert('No itinerary items for this date.');
        return;
      }
      
      // Create a temporary print container
      const printContainer = document.createElement('div');
      printContainer.id = 'itineraryPrintContainer';
      printContainer.style.cssText = 'position:fixed;top:-10000px;left:-10000px;width:8.5in;padding:0.5in;font-family:system-ui,-apple-system,sans-serif;background:white';
      
      // Header
      const header = document.createElement('div');
      header.style.cssText = 'margin-bottom:24px;border-bottom:2px solid #111;padding-bottom:12px';
      
      const title = document.createElement('h1');
      title.textContent = 'Daily Itinerary';
      title.style.cssText = 'font-size:24px;font-weight:bold;margin:0 0 8px 0;color:#111';
      
      const dateInfo = document.createElement('div');
      const dateObj = new Date(tourDate.date + 'T00:00:00');
      dateInfo.textContent = `${dateObj.toLocaleDateString('en-US', {weekday:'long', year:'numeric', month:'long', day:'numeric'})} ‚Ä¢ ${tourDate.venue || 'No venue'}`;
      dateInfo.style.cssText = 'font-size:14px;color:#666;margin-bottom:4px';
      
      const addressInfo = document.createElement('div');
      addressInfo.textContent = tourDate.address || '';
      addressInfo.style.cssText = 'font-size:12px;color:#888';
      
      header.appendChild(title);
      header.appendChild(dateInfo);
      if(tourDate.address) header.appendChild(addressInfo);
      printContainer.appendChild(header);
      
      // Itinerary items
      const items = [...tourDate.itinerary].sort((a, b) => {
        const [aH, aM] = a.time.split(':').map(Number);
        const [bH, bM] = b.time.split(':').map(Number);
        return (aH * 60 + aM) - (bH * 60 + bM);
      });
      
      items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.style.cssText = 'margin-bottom:16px;padding:12px;border-left:4px solid #3b82f6;background:#f9fafb';
        
        const timeDiv = document.createElement('div');
        timeDiv.textContent = item.time;
        timeDiv.style.cssText = 'font-size:14px;font-weight:bold;color:#111;margin-bottom:4px';
        
        const titleDiv = document.createElement('div');
        titleDiv.textContent = item.title;
        titleDiv.style.cssText = 'font-size:16px;font-weight:600;color:#111;margin-bottom:4px';
        
        const durationDiv = document.createElement('div');
        durationDiv.textContent = `Duration: ${item.duration || 30} minutes`;
        durationDiv.style.cssText = 'font-size:12px;color:#666;margin-bottom:4px';
        
        itemDiv.appendChild(timeDiv);
        itemDiv.appendChild(titleDiv);
        itemDiv.appendChild(durationDiv);
        
        if(item.notes){
          const notesDiv = document.createElement('div');
          notesDiv.textContent = item.notes;
          notesDiv.style.cssText = 'font-size:12px;color:#666;margin-top:8px;font-style:italic';
          itemDiv.appendChild(notesDiv);
        }
        
        printContainer.appendChild(itemDiv);
      });
      
      document.body.appendChild(printContainer);
      
      // Hide all UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const modals=document.querySelectorAll('.modal');
      
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      modals.forEach(m => m.style.display='none');
      
      printContainer.style.position='static';
      printContainer.style.top='';
      printContainer.style.left='';
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering itinerary print dialog...');
      window.print();
      await printPromise();
      
      // Cleanup
      document.body.removeChild(printContainer);
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      modals.forEach(m => m.style.display='');
      
      console.log('‚úÖ Itinerary print complete');
    }

    // Share Database
    const shareBtn = document.getElementById('shareBtn');
    if(shareBtn){ 
      shareBtn.addEventListener('click', async ()=>{
        var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
        const stage = stageEl ? stageEl.outerHTML : '';
        const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
        const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
        const jsonStr = JSON.stringify(data,null,2);
        const blob=new Blob([jsonStr],{type:'application/json'});
        const filename = ((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band');
        
        // Try Web Share API first (mobile-friendly)
        if(navigator.share && navigator.canShare){
          try{
            const file = new File([blob], filename, {type:'application/json'});
            const shareData = {
              title: 'FASTFAST Setlist Database',
              text: `Sharing ${gig.band || 'band'} profile with ${db.length} songs`,
              files: [file]
            };
            if(navigator.canShare(shareData)){
              await navigator.share(shareData);
              console.log('‚úÖ Shared via Web Share API');
              return;
            }
          }catch(e){
            console.log('Web Share API failed, falling back to download/email', e);
          }
        }
        
        // Fallback: Download file + offer email option
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); 
        a.href=url; 
        a.download=filename; 
        a.click(); 
        URL.revokeObjectURL(url);
        
        // Offer email option
        setTimeout(()=>{
          if(confirm('File downloaded. Would you like to open your email client to share it?')){
            const subject = encodeURIComponent(`FASTFAST Setlist: ${gig.band || 'Band'} Profile`);
            const body = encodeURIComponent(`Hi,\n\nI'm sharing my FASTFAST Setlist database with you.\n\nDatabase contains ${db.length} songs.\n\nPlease download the attached .BAND file and load it in FASTFAST Setlist using the "Load Profile (.BAND)" button.\n\nCheers!`);
            window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
          }
        }, 500);
      });
    }
    
    // Save/Load Profile (.BAND)
    const saveProfileBtn=document.getElementById('saveProfile');
    if(saveProfileBtn){ saveProfileBtn.addEventListener('click',()=>{
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      const stage = stageEl ? stageEl.outerHTML : '';
      const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
      // Save EVERYTHING - complete backup
      const data={
        version:4,
        type:'fastfast-band',
        db:dbOut,
        setlist,
        gig,
        gearSummary,
        techNotes,
        stage,
        setlistColumns,
        pageLayout,
        tourDates,
        tourCustomSearchTerms,
        customSearchButtons,
        selectedTourDateId,
        bandPresets,
        currentBandPresetId,
        stagePresets,
        setlistPresets,
        lastUsedSetlist
      };
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
    }); }
    const loadProfileBtn=document.getElementById('loadProfile'); const loadProfileFile=document.getElementById('loadProfileFile');
    if(loadProfileBtn && loadProfileFile){
      loadProfileBtn.addEventListener('click',()=> loadProfileFile.click());
      loadProfileFile.addEventListener('change',()=>{
        const f=loadProfileFile.files && loadProfileFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && Array.isArray(obj.db)){
              // merge db by title+artist (case-insensitive)
              const keyOf=s=> ((s.title||'').toLowerCase().trim()+'|'+((s.artist||'Original').toLowerCase().trim()));
              const existing=new Set(db.map(keyOf));
              obj.db.forEach(s=>{
                const { audioData, ...rest } = s||{}; // drop any embedded audio from import
                const item={...rest};
                if(!item.id) item.id=Date.now()+Math.random();
                if(!item.artist) item.artist='Original';
                if(!item.length) item.length=3.5;
                if(!existing.has(keyOf(item))){ db.push(item); existing.add(keyOf(item)); }
              });
              renderDB();
            }
            if(obj && obj.gig){
              // merge gig fields only if missing
              const fields=['band','date','venue','address','contact','notes','font','logo'];
              fields.forEach(k=>{ if(!gig[k] && obj.gig[k]) gig[k]=obj.gig[k]; });
              if(obj.gig.headerFlags){ gig.headerFlags=Object.assign({band:true,venue:true,sub:true,notes:true}, gig.headerFlags, obj.gig.headerFlags); }
              if(obj.gig.customMoods){ gig.customMoods=obj.gig.customMoods; }
              if(obj.gig.customImages){ gig.customImages=obj.gig.customImages; }
              if(obj.gig.hiddenIcons){ gig.hiddenIcons=obj.gig.hiddenIcons; }
              if(obj.gig.liveDark !== undefined){ gig.liveDark=obj.gig.liveDark; }
              if(obj.gig.customColumns){ gig.customColumns=obj.gig.customColumns; }
              // hydrate UI
              if(gig.band) document.getElementById('gBand').value=gig.band;
              if(gig.date) document.getElementById('gDate').value=gig.date;
              if(gig.venue) document.getElementById('gVenue').value=gig.venue;
              if(gig.address) document.getElementById('gAddr').value=gig.address;
              if(gig.contact) document.getElementById('gContact').value=gig.contact;
              if(gig.notes) document.getElementById('gNotes').value=gig.notes;
              const gFontElTmp=document.getElementById('gFont'); if(gFontElTmp && gig.font) gFontElTmp.value=gig.font;
              // header flags checkboxes
              ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
              refreshLogoPreview();
            }
            // hydrate gear and stage if present
            if(obj && 'gearSummary' in obj){ gearSummary = obj.gearSummary || ''; const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary; }
            if(obj && 'techNotes' in obj && typeof obj.techNotes === 'object'){ techNotes = obj.techNotes; }
            if(obj && obj.setlistColumns){ setlistColumns = Object.assign({artist:false, capo:true, key:true, notes:false, bpm:false, lyrics:false}, obj.setlistColumns); }
            if(obj && obj.pageLayout){ pageLayout = Object.assign({format:'letter', pageCount:1, songsPerPage:25}, obj.pageLayout); }
            if(obj && Array.isArray(obj.tourDates)){ tourDates = obj.tourDates; }
            if(obj && typeof obj.tourCustomSearchTerms === 'string'){ tourCustomSearchTerms = obj.tourCustomSearchTerms; }
            if(obj && Array.isArray(obj.customSearchButtons)){ customSearchButtons = obj.customSearchButtons; }
            if(obj && obj.selectedTourDateId){ selectedTourDateId = obj.selectedTourDateId; }
            if(obj && Array.isArray(obj.bandPresets)){ bandPresets = obj.bandPresets; }
            if(obj && obj.currentBandPresetId){ currentBandPresetId = obj.currentBandPresetId; }
            if(obj && Array.isArray(obj.stagePresets)){ stagePresets = obj.stagePresets; }
            if(obj && Array.isArray(obj.setlistPresets)){ setlistPresets = obj.setlistPresets; }
            if(obj && obj.lastUsedSetlist){ lastUsedSetlist = obj.lastUsedSetlist; }
            if(obj && obj.stage){
              const container=document.getElementById('stageStore');
              if(container){
                container.innerHTML=obj.stage;
                const svg=container.querySelector('svg');
                if(svg){
                  svg.id='stageSvg';
                  svg.classList.add('bw');
                  try{ refreshCables(svg); }catch(_){ }
                }
              }
              // Overwrite existing full editor (if open) with loaded stage BEFORE any autosave can race
              const full=document.getElementById('stageSvgFull');
              const stageModal=document.getElementById('stageModal');
              const store=document.getElementById('stageSvg');
              if(full && store){
                try{
                  while(full.childNodes.length>2) full.removeChild(full.lastChild);
                  Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
                  ensureStageMarkers(full);
                  refreshCables(full);
                  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
                  bindSelection(full);
                  if(typeof refreshStageLegend==='function') refreshStageLegend();
                  if(typeof selectNode==='function') selectNode(null);
                }catch(_){ /* non-fatal */ }
              }
              // If Tech/Stage tab is active and modal not open, auto-open it now to show restored layout
              const advPanel=document.getElementById('adv');
              const tabActive = advPanel && advPanel.style.display!=='none';
              if(tabActive && stageModal && !stageModal.classList.contains('open')){
                try{ if(typeof openStageModal==='function') openStageModal(); }catch(_){ }
              }
            }
            // Restore setlist & tech notes if present (current set)
            if(obj && Array.isArray(obj.setlist)){
              setlist = obj.setlist;
              try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(_){ }
            }
            if(obj && obj.techNotes && typeof obj.techNotes==='object'){
              techNotes = obj.techNotes;
            }
            saveAll();
          }catch(err){ alert('Failed to read .BAND file'); }
        };
        r.readAsText(f);
      });
    }

    // Zoom control for stage (applies to small canvas)
    // No inline zoom control anymore

    // Save .SET (export setlist with full song details including lyrics for phone viewing)
    const saveSetBtn=document.getElementById('saveSet'); if(saveSetBtn){ saveSetBtn.addEventListener('click',()=>{
      // Enrich setlist with full song data including lyrics
      const enrichedSetlist = setlist.map(item => {
        if(item.type === 'song'){
          const baseSong = findSongById(item.id) || findSongByTitle(item.title);
          if(baseSong){
            return {
              ...item,
              lyrics: baseSong.lyrics || item.lyrics || '',
              artist: item.artist || baseSong.artist || 'Original',
              key: item.key || baseSong.key || '',
              capo: item.capo !== undefined ? item.capo : baseSong.capo,
              bpm: item.bpm || baseSong.bpm
            };
          }
        }
        return item;
      });
      const data={version:2,type:'fastfast-set',setlist:enrichedSetlist,gig:{band:gig.band,venue:gig.venue,date:gig.date}};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(gig.band? gig.band.replace(/\s+/g,'_')+'_' : '')+'setlist.set'; a.click(); URL.revokeObjectURL(a.href);
    }); }
    // Load .SET (import setlist only, keep current gig)
    const loadSetBtn=document.getElementById('loadSet'); const loadSetFile=document.getElementById('loadSetFile');
    if(loadSetBtn && loadSetFile){
      loadSetBtn.addEventListener('click',()=> loadSetFile.click());
      loadSetFile.addEventListener('change',()=>{
        const f=loadSetFile.files && loadSetFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && obj.setlist && Array.isArray(obj.setlist)){
              setlist=obj.setlist; buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll();
            }else{ alert('Invalid .SET file'); }
          }catch(err){ alert('Failed to read .SET file'); }
        };
        r.readAsText(f);
      });
    }
    // --- Import (OCR / Paste) ---
    (function setupImport(){
      const txt=document.getElementById('importText');
      const file=document.getElementById('importFile');
      const parseBtn=document.getElementById('importParseBtn');
      const commitBtn=document.getElementById('importCommitBtn');
      const statusEl=document.getElementById('importStatus');
      const previewEl=document.getElementById('importPreview');
      if(!txt || !file || !parseBtn || !commitBtn) return;
      let parsed=[];
      function sanitizeLine(line){ return line.replace(/\s+/g,' ').trim(); }
      function detectCapo(str){ const m=str.match(/capo\s*(\d{1,2})/i); if(m){ const v=parseInt(m[1],10); if(Number.isInteger(v) && v>=0 && v<=24) return v; } return 0; }
      function detectKey(str){ // first standalone musical key token
        const m=str.match(/\b([A-G](?:#|b)?m?(?:aj|in|ajor|inor)?)\b/i); return m? m[1] : ''; }
      function parseSongLines(text){
        const out=[]; const lines=text.split(/\r?\n/);
        for(let raw of lines){ 
          let line=sanitizeLine(raw); 
          if(!line) continue;
          
          // Skip header lines (band name, venue, date, etc.)
          if(/^(the\s+)?[a-z\s]+hotel$/i.test(line)) continue;
          if(/^\d{4}-\d{2}-\d{2}/.test(line)) continue;
          if(/^\d{1,2}(:\d{2})?\s*(am|pm)?$/i.test(line)) continue;
          if(/^(set\s*\d|encore|break|intermission)$/i.test(line)) continue;
          
          // Remove leading numbers (setlist numbering like "1 Blue Shadows" or "1. Blue Shadows")
          line = line.replace(/^\d+[.)\s-]+\s*/, '').trim();
          
          // Remove trailing duration (like "4m" or "3.5m" or "4:30")
          line = line.replace(/\s+\d+(\.\d+)?m$/i, '').trim();
          line = line.replace(/\s+\d+:\d{2}$/, '').trim();
          
          if(!line) continue;
          
          const capo=detectCapo(line); 
          if(capo) line=line.replace(/capo\s*\d{1,2}/i,'').trim(); 
          
          // Detect key - look for "Key: X" or just standalone key
          let key = '';
          const keyMatch = line.match(/key[:\s]+([A-G](?:#|b)?(?:\s*(?:m|maj|min|major|minor))?)/i);
          if(keyMatch){
            key = keyMatch[1].trim();
            line = line.replace(/key[:\s]+[A-G](?:#|b)?(?:\s*(?:m|maj|min|major|minor))?/i, '').trim();
          } else {
            key = detectKey(line);
          }
          
          let title=line; 
          // remove key if separated by dash/pipe/colon or at end
          if(key){ 
            const sepPattern=new RegExp('[-|:]?\\s*'+key.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+'\\s*$','i'); 
            title=title.replace(sepPattern,'').trim(); 
            if(title.toLowerCase().startsWith(key.toLowerCase()+' ')) title=title.slice(key.length).trim(); 
          }
          // Remove trailing parentheses or brackets containing key or capo info
          title=title.replace(/\((?:capo|key)[^)]*\)$/i,'').trim();
          // Remove "Key: X" from title
          title=title.replace(/key[:\s]+[A-G](?:#|b)?m?/i,'').trim();
          
          // Skip if title is too short or just a key/number
          if(title.length < 2) continue;
          if(/^[A-G](?:#|b)?m?$/i.test(title)) continue;
          
          if(title) out.push({title, key, capo, length:3.5, artist:'Original'}); 
        }
        return out; }
      function dedupe(list){ const seen=new Set(); return list.filter(s=>{ const k=(s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); if(seen.has(k)) return false; seen.add(k); return true; }); }
      function renderPreview(){ if(!parsed.length){ previewEl.innerHTML='<em>No parsed songs.</em>'; commitBtn.disabled=true; return; }
        // Build editable table with all columns
        const tbl=document.createElement('table'); tbl.style.width='100%'; tbl.style.borderCollapse='collapse'; tbl.style.fontSize='12px';
        const thead=document.createElement('thead'); 
        thead.innerHTML='<tr style="background:#e2e8f0"><th style="text-align:left;padding:4px 6px">Title</th><th style="text-align:left;padding:4px 6px">Artist</th><th style="text-align:left;padding:4px 6px">Key</th><th style="text-align:left;padding:4px 6px">Capo</th><th style="text-align:left;padding:4px 6px">BPM</th><th style="text-align:left;padding:4px 6px">Len</th><th style="text-align:left;padding:4px 6px">üéµ</th><th style="text-align:left;padding:4px 6px;max-width:200px">Lyrics</th><th style="text-align:left;padding:4px 6px">Cover</th><th style="text-align:left;padding:4px 6px">√ó</th></tr>';
        const tbody=document.createElement('tbody');
        parsed.forEach((s,i)=>{
          const tr=document.createElement('tr'); tr.style.borderBottom='1px solid #e5e7eb';
          
          // Title
          const tdTitle=document.createElement('td'); const inpTitle=document.createElement('input'); inpTitle.type='text'; inpTitle.value=s.title||''; inpTitle.style.cssText='width:100%;min-width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpTitle.addEventListener('input',()=>{ s.title=inpTitle.value.trim(); }); tdTitle.style.padding='4px 6px'; tdTitle.appendChild(inpTitle);
          
          // Artist
          const tdArtist=document.createElement('td'); const inpArtist=document.createElement('input'); inpArtist.type='text'; inpArtist.value=s.artist||'Original'; inpArtist.style.cssText='width:100px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpArtist.addEventListener('input',()=>{ s.artist=inpArtist.value.trim()||'Original'; s.isCover=(s.artist.toLowerCase()!=='original'); }); tdArtist.style.padding='4px 6px'; tdArtist.appendChild(inpArtist);
          
          // Key
          const tdKey=document.createElement('td'); const inpKey=document.createElement('input'); inpKey.type='text'; inpKey.value=s.key||''; inpKey.placeholder='Key'; inpKey.style.cssText='width:50px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpKey.addEventListener('input',()=>{ s.key=inpKey.value.trim(); }); tdKey.style.padding='4px 6px'; tdKey.appendChild(inpKey);
          
          // Capo
          const tdCapo=document.createElement('td'); const inpCapo=document.createElement('input'); inpCapo.type='number'; inpCapo.min='0'; inpCapo.max='24'; inpCapo.value=String(Number.isInteger(s.capo)? s.capo:0); inpCapo.style.cssText='width:45px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpCapo.addEventListener('change',()=>{ let v=parseInt(inpCapo.value,10); if(!Number.isInteger(v)||v<0) v=0; if(v>24) v=24; s.capo=v; inpCapo.value=String(v); }); tdCapo.style.padding='4px 6px'; tdCapo.appendChild(inpCapo);
          
          // BPM
          const tdBpm=document.createElement('td'); const inpBpm=document.createElement('input'); inpBpm.type='number'; inpBpm.min='0'; inpBpm.max='300'; inpBpm.value=String(s.bpm||0); inpBpm.placeholder='BPM'; inpBpm.style.cssText='width:50px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpBpm.addEventListener('change',()=>{ let v=parseInt(inpBpm.value,10); if(!Number.isInteger(v)||v<0) v=0; s.bpm=v; }); tdBpm.style.padding='4px 6px'; tdBpm.appendChild(inpBpm);
          
          // Length
          const tdLen=document.createElement('td'); const inpLen=document.createElement('input'); inpLen.type='number'; inpLen.min='0.5'; inpLen.step='0.5'; inpLen.value=String(s.length||3.5); inpLen.style.cssText='width:50px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:12px'; inpLen.addEventListener('change',()=>{ let v=parseFloat(inpLen.value); if(!isFinite(v)||v<=0) v=3.5; s.length=v; inpLen.value=String(v); }); tdLen.style.padding='4px 6px'; tdLen.appendChild(inpLen);
          
          // Audio file indicator
          const tdAudio=document.createElement('td'); tdAudio.style.cssText='padding:4px 6px;text-align:center';
          if(s._audioFile || s.audioFileName){
            const audioIcon=document.createElement('span'); audioIcon.textContent='üîä'; audioIcon.style.cursor='default';
            audioIcon.title='Audio: '+(s.audioFileName||s._audioFile?.name||'attached');
            tdAudio.appendChild(audioIcon);
          } else {
            tdAudio.textContent='-';
            tdAudio.style.color='#9ca3af';
          }
          
          // Lyrics preview
          const tdLyrics=document.createElement('td'); tdLyrics.style.cssText='padding:4px 6px;max-width:200px';
          const lyricsPreview = (s.lyrics||'').substring(0,80).replace(/\n/g,' ');
          if(s.lyrics){
            const lyricsSpan=document.createElement('span'); lyricsSpan.style.cssText='font-size:10px;color:#64748b;cursor:pointer;display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:180px';
            lyricsSpan.textContent=lyricsPreview+(s.lyrics.length>80?'...':'');
            lyricsSpan.title='Click to edit lyrics';
            lyricsSpan.addEventListener('click',()=>{
              const ta=document.createElement('textarea'); ta.value=s.lyrics||''; ta.style.cssText='width:180px;height:60px;font-size:10px;padding:2px;border:1px solid #3b82f6;border-radius:3px';
              ta.addEventListener('blur',()=>{ s.lyrics=ta.value; renderPreview(); });
              ta.addEventListener('keydown',(e)=>{ if(e.key==='Escape'){ renderPreview(); } });
              tdLyrics.innerHTML=''; tdLyrics.appendChild(ta); ta.focus();
            });
            tdLyrics.appendChild(lyricsSpan);
          } else {
            const addBtn=document.createElement('button'); addBtn.type='button'; addBtn.textContent='+'; addBtn.style.cssText='padding:1px 6px;font-size:10px;cursor:pointer;background:#f1f5f9;border:1px solid #d1d5db;border-radius:3px';
            addBtn.title='Add lyrics';
            addBtn.addEventListener('click',()=>{
              const ta=document.createElement('textarea'); ta.value=''; ta.placeholder='Paste lyrics...'; ta.style.cssText='width:180px;height:60px;font-size:10px;padding:2px;border:1px solid #3b82f6;border-radius:3px';
              ta.addEventListener('blur',()=>{ s.lyrics=ta.value; renderPreview(); });
              tdLyrics.innerHTML=''; tdLyrics.appendChild(ta); ta.focus();
            });
            tdLyrics.appendChild(addBtn);
          }
          
          // Cover checkbox
          const tdCover=document.createElement('td'); tdCover.style.padding='4px 6px';
          const chkCover=document.createElement('input'); chkCover.type='checkbox'; chkCover.checked=s.isCover||(s.artist&&s.artist.toLowerCase()!=='original'); chkCover.style.cssText='width:16px;height:16px';
          chkCover.addEventListener('change',()=>{ s.isCover=chkCover.checked; });
          tdCover.appendChild(chkCover);
          
          // Remove button
          const tdRemove=document.createElement('td'); tdRemove.style.padding='4px 6px'; const btnRem=document.createElement('button'); btnRem.type='button'; btnRem.textContent='√ó'; btnRem.className='btn danger'; btnRem.style.cssText='padding:2px 8px;font-size:12px;background:#dc2626;color:white;border:none;border-radius:3px;cursor:pointer'; btnRem.addEventListener('click',()=>{ parsed.splice(i,1); renderPreview(); }); tdRemove.appendChild(btnRem);
          
          tr.append(tdTitle,tdArtist,tdKey,tdCapo,tdBpm,tdLen,tdAudio,tdLyrics,tdCover,tdRemove); tbody.appendChild(tr);
        });
        tbl.append(thead,tbody); previewEl.innerHTML=''; previewEl.style.maxHeight='400px'; previewEl.style.overflowY='auto'; previewEl.appendChild(tbl); commitBtn.disabled=false;
      }
      function addParsedToDb(){ 
        const existingKeyOf=s=> (s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); 
        const existing=new Set(db.map(existingKeyOf)); 
        let added=0; 
        parsed.forEach(s=>{ 
          if(!existing.has(existingKeyOf(s))){ 
            s.id=Date.now()+Math.random(); 
            // If song has an audio file attached, arm it in armedAudio
            if(s._audioFile){
              try{
                armedAudio[s.id] = URL.createObjectURL(s._audioFile);
                // Clean up the temporary _audioFile property (not needed for storage)
                delete s._audioFile;
              }catch(e){ console.warn('Failed to arm audio:', e); }
            }
            db.push(s); 
            existing.add(existingKeyOf(s)); 
            added++; 
          } 
        }); 
        renderDB(); renderSongPool(); saveAll(); 
        statusEl.textContent=`Imported ${added} new song${added===1?'':'s'}.`; 
      }
      parseBtn.addEventListener('click',()=>{ parsed=dedupe(parseSongLines(txt.value||'')); statusEl.textContent=`Parsed ${parsed.length} song line${parsed.length===1?'':'s'}.`; renderPreview(); });
      commitBtn.addEventListener('click', addParsedToDb);
      async function ensurePdfJs(){ if(window.pdfjsLib) return; statusEl.textContent='Loading PDF.js‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); if(window.pdfjsLib){ window.pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; } }
      async function ensureTesseract(){ if(window.Tesseract) return; statusEl.textContent='Loading Tesseract‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); }
      
      // Folder checkbox handler
      const folderCb=document.getElementById('importFolder');
      if(folderCb){
        folderCb.addEventListener('change',()=>{
          file.webkitdirectory = folderCb.checked;
          file.multiple = true;
          file.value = '';
        });
      }
      
      // Paste handler for images and text (CTRL+V on the import section)
      const importBlock = document.getElementById('importBlock');
      if(importBlock){
        importBlock.addEventListener('paste', async (e) => {
          const items = e.clipboardData?.items;
          if(!items || items.length === 0) return;
          
          let hasImage = false;
          let imageFile = null;
          let pastedText = '';
          
          // Check for images first
          for(let i = 0; i < items.length; i++){
            const item = items[i];
            if(item.type.startsWith('image/')){
              hasImage = true;
              imageFile = item.getAsFile();
              break;
            }
          }
          
          // If no image, check for text
          if(!hasImage){
            for(let i = 0; i < items.length; i++){
              const item = items[i];
              if(item.type === 'text/plain'){
                pastedText = await new Promise(resolve => item.getAsString(resolve));
                break;
              }
            }
          }
          
          // Process pasted image with OCR
          if(imageFile){
            e.preventDefault();
            
            // Show spinner
            const spinner = document.getElementById('importSpinner');
            const spinnerText = document.getElementById('importSpinnerText');
            if(spinner){ spinner.style.display = 'flex'; }
            const updatePasteSpinner = (text) => { 
              if(spinnerText) spinnerText.textContent = text; 
              statusEl.textContent = text; 
            };
            
            updatePasteSpinner('Processing pasted image...');
            
            try{
              await ensureTesseract();
              const { Tesseract } = window;
              
              // Preprocess image for better handwriting OCR
              updatePasteSpinner('Preprocessing image...');
              const canvas = await prepareImageForOCR(imageFile, 3);
              
              const result = await Tesseract.recognize(canvas, 'eng', {
                logger: m => {
                  if(m.status === 'recognizing text'){
                    updatePasteSpinner(`OCR pasted image: ${Math.round(m.progress*100)}%`);
                  }
                }
              });
              
              const ocrText = result?.data?.text || '';
              if(ocrText.trim()){
                // Parse the OCR text as song lines
                const songs = parseSongLines(ocrText);
                if(songs.length > 0){
                  parsed = dedupe([...parsed, ...songs]);
                  updatePasteSpinner(`Extracted ${songs.length} song${songs.length===1?'':'s'} from pasted image.`);
                  renderPreview();
                } else {
                  // Put the OCR text in the textarea for manual review
                  txt.value = (txt.value ? txt.value + '\n' : '') + ocrText;
                  updatePasteSpinner('OCR complete. Review text and click Extract.');
                }
              } else {
                updatePasteSpinner('No text detected in pasted image.');
              }
            }catch(err){
              console.error('Paste OCR error:', err);
              updatePasteSpinner('Failed to process pasted image.');
            }
            
            // Hide spinner
            if(spinner){ spinner.style.display = 'none'; }
          }
          // Process pasted text (if not pasted into textarea)
          else if(pastedText && document.activeElement !== txt){
            // Let the paste go through to textarea if that's focused
            // Otherwise, process it as song lines
            e.preventDefault();
            
            const songs = parseSongLines(pastedText);
            if(songs.length > 0){
              parsed = dedupe([...parsed, ...songs]);
              statusEl.textContent = `Extracted ${songs.length} song${songs.length===1?'':'s'} from pasted text.`;
              renderPreview();
            } else {
              // Put text in textarea
              txt.value = (txt.value ? txt.value + '\n' : '') + pastedText;
              statusEl.textContent = 'Text pasted. Click Extract to parse.';
            }
          }
        });
      }
      
      // Image preprocessing for better OCR (especially handwriting)
      function preprocessImageForOCR(canvas){
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        
        // Convert to grayscale and enhance contrast
        for(let i = 0; i < data.length; i += 4){
          // Grayscale using luminance formula
          const gray = 0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2];
          
          // Enhance contrast (stretch histogram)
          let enhanced = ((gray - 128) * 1.5) + 128;
          enhanced = Math.max(0, Math.min(255, enhanced));
          
          // Apply adaptive thresholding for handwriting
          // This helps separate ink from paper
          const threshold = 180; // Adjust for yellowed paper
          const binarized = enhanced < threshold ? 0 : 255;
          
          data[i] = binarized;
          data[i+1] = binarized;
          data[i+2] = binarized;
        }
        
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      }
      
      // Prepare canvas from image for OCR with preprocessing
      async function prepareImageForOCR(imageSource, scale = 3){
        const imgBitmap = await createImageBitmap(imageSource);
        const canvas = document.createElement('canvas');
        canvas.width = imgBitmap.width * scale;
        canvas.height = imgBitmap.height * scale;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        // Fill with white background first (helps with transparency)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
        
        // Apply preprocessing for handwriting
        preprocessImageForOCR(canvas);
        
        return canvas;
      }
      
      // Load jsmediatags library for ID3 reading
      async function ensureMediaTags(){
        if(window.jsmediatags) return;
        statusEl.textContent='Loading metadata parser‚Ä¶';
        await new Promise((res,rej)=>{
          const sc=document.createElement('script');
          sc.src='https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js';
          sc.onload=res;
          sc.onerror=rej;
          document.head.appendChild(sc);
        });
      }
      
      // Extract metadata from audio/video files
      async function extractAudioMetadata(f){
        return new Promise((resolve)=>{
          // Try to read ID3 tags first (MP3, M4A, etc.)
          ensureMediaTags().then(()=>{
              window.jsmediatags.read(f, {
              onSuccess: (tag)=>{
                const tags = tag.tags || {};
                let title = tags.title || '';
                let artist = tags.artist || '';
                let album = tags.album || '';
                let lyrics = tags.lyrics || tags.USLT || tags.unsynchronizedLyrics || '';
                
                // Clean up any non-English characters if they're garbled
                /* eslint-disable-next-line no-control-regex */
                const controlCharsPattern = new RegExp('[\\x00-\\x1F\\x7F-\\x9F]', 'g');
                const cleanText = (str) => {
                  if(!str) return '';
                  // Strip control characters that corrupt tags
                  return str.replace(controlCharsPattern, '').trim();
                };
                
                title = cleanText(title);
                artist = cleanText(artist);
                lyrics = cleanText(lyrics);
                
                // Fallback to filename if tags are empty or garbled
                if(!title || title.length < 2 || /[^\u0020-\u007E\u00A0-\uFFFF]/.test(title)){
                  const fileName = f.name.replace(/\.[^.]+$/, '');
                  const patterns = [
                    /^\d+[._\s-]*(.+?)\s*[_-]\s*(.+)$/,
                    /^(.+?)\s*[_-]\s*(.+)$/
                  ];
                  for(const pattern of patterns){
                    const match = fileName.match(pattern);
                    if(match){
                      if(!artist || artist.length < 2) artist = match[1].trim();
                      title = match[2].trim();
                      break;
                    }
                  }
                  if(!title) title = fileName;
                }
                
                if(!artist || artist.length < 2) artist = 'Original';
                
                // Get duration using HTML5 Audio API
                const audio = new Audio();
                const url = URL.createObjectURL(f);
                audio.src = url;
                audio.addEventListener('loadedmetadata', ()=>{
                  const duration = audio.duration || 0;
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    album: album || '',
                    length: Math.round(duration / 60 * 10) / 10 || 3.5,
                    lyrics: lyrics || '',
                    key: '',
                    capo: 0,
                    bpm: 0,
                    _audioFile: f,          // Keep reference to original audio file
                    audioFileName: f.name   // Store the filename
                  });
                });
                audio.addEventListener('error', ()=>{
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    album: album || '',
                    length: 3.5,
                    lyrics: lyrics || '',
                    key: '',
                    capo: 0,
                    bpm: 0,
                    _audioFile: f,          // Keep reference to original audio file
                    audioFileName: f.name   // Store the filename
                  });
                });
              },
              onError: ()=>{
                // Fallback to filename parsing if ID3 reading fails
                const fileName = f.name.replace(/\.[^.]+$/, '');
                let title = fileName;
                let artist = 'Original';
                const patterns = [
                  /^\d+[._\s-]*(.+?)\s*[_-]\s*(.+)$/,
                  /^(.+?)\s*[_-]\s*(.+)$/
                ];
                for(const pattern of patterns){
                  const match = fileName.match(pattern);
                  if(match){
                    artist = match[1].trim();
                    title = match[2].trim();
                    break;
                  }
                }
                
                // Get duration
                const audio = new Audio();
                const url = URL.createObjectURL(f);
                audio.src = url;
                audio.addEventListener('loadedmetadata', ()=>{
                  const duration = audio.duration || 0;
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    length: Math.round(duration / 60 * 10) / 10 || 3.5,
                    lyrics: '',
                    key: '',
                    capo: 0,
                    bpm: 0,
                    _audioFile: f,          // Keep reference to original audio file
                    audioFileName: f.name   // Store the filename
                  });
                });
                audio.addEventListener('error', ()=>{
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    length: 3.5,
                    lyrics: '',
                    key: '',
                    capo: 0,
                    bpm: 0,
                    _audioFile: f,          // Keep reference to original audio file
                    audioFileName: f.name   // Store the filename
                  });
                });
              }
            });
          }).catch(err=>{
            console.error('Metadata extraction failed:', err);
            resolve(null);
          });
        });
      }
      
      // Parse CSV content
      function parseCSV(text){
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        if(lines.length < 2) return [];
        const headers = lines[0].toLowerCase().split(/[,\t;]/).map(h => h.trim());
        const titleIdx = headers.findIndex(h => /title|song|name/.test(h));
        const artistIdx = headers.findIndex(h => /artist|band|by/.test(h));
        const keyIdx = headers.findIndex(h => /key/.test(h));
        const capoIdx = headers.findIndex(h => /capo/.test(h));
        const bpmIdx = headers.findIndex(h => /bpm|tempo/.test(h));
        const lengthIdx = headers.findIndex(h => /length|duration|time/.test(h));
        if(titleIdx === -1) return [];
        const songs = [];
        for(let i = 1; i < lines.length; i++){
          const cols = lines[i].split(/[,\t;]/).map(c => c.trim().replace(/^"|"$/g, ''));
          if(!cols[titleIdx]) continue;
          const song = {
            title: cols[titleIdx],
            artist: artistIdx >= 0 && cols[artistIdx] ? cols[artistIdx] : 'Original',
            key: keyIdx >= 0 && cols[keyIdx] ? cols[keyIdx] : '',
            capo: capoIdx >= 0 && cols[capoIdx] ? parseInt(cols[capoIdx]) || 0 : 0,
            bpm: bpmIdx >= 0 && cols[bpmIdx] ? parseInt(cols[bpmIdx]) || 0 : 0,
            length: lengthIdx >= 0 && cols[lengthIdx] ? parseFloat(cols[lengthIdx]) || 3.5 : 3.5
          };
          songs.push(song);
        }
        return songs;
      }
      
      // Parse spreadsheet (basic XLS/XLSX support)
      async function parseSpreadsheet(f){
        return new Promise((resolve)=>{
          const reader = new FileReader();
          reader.onload = (e)=>{
            try{
              const text = String(e.target.result || '');
              const songs = parseCSV(text);
              resolve(songs);
            }catch{
              resolve([]);
            }
          };
          reader.onerror = ()=> resolve([]);
          reader.readAsText(f);
        });
      }
      
      file.addEventListener('change', async()=>{
        previewEl.innerHTML=''; parsed=[]; commitBtn.disabled=true; statusEl.textContent='';
        const files = Array.from(file.files || []);
        if(!files.length) return;
        
        // Show spinning vinyl overlay
        const spinner = document.getElementById('importSpinner');
        const spinnerText = document.getElementById('importSpinnerText');
        if(spinner){ spinner.style.display = 'flex'; }
        const updateSpinner = (text) => { if(spinnerText) spinnerText.textContent = text; statusEl.textContent = text; };
        
        updateSpinner(`Processing ${files.length} file${files.length===1?'':'s'}...`);
        
        // First, group files by base name to match audio with lyrics
        const fileGroups = new Map(); // baseName -> {audio: file, lyrics: [files]}
        const standaloneFiles = []; // Files without a match
        
        for(const f of files){
          const baseName = f.name.replace(/\.(mp3|wav|flac|m4a|aac|ogg|wma|mp4|avi|mov|mkv|txt|pdf|jpg|jpeg|png|gif|bmp)$/i, '').toLowerCase();
          const isAudio = /\.(mp3|wav|flac|m4a|aac|ogg|wma|mp4|avi|mov|mkv)$/i.test(f.name);
          const isLyrics = /\.(txt|pdf|jpg|jpeg|png|gif|bmp)$/i.test(f.name);
          
          if(!fileGroups.has(baseName)){
            fileGroups.set(baseName, {audio: null, lyrics: []});
          }
          const group = fileGroups.get(baseName);
          
          if(isAudio){
            group.audio = f;
          } else if(isLyrics){
            group.lyrics.push(f);
          } else {
            standaloneFiles.push(f);
          }
        }
        
        let allSongs = [];
        let processed = 0;
        
        // Process grouped files (audio + lyrics)
        for(const [baseName, group] of fileGroups){
          try{
            let songData = null;
            let lyricsText = '';
            
            // Extract audio metadata if present
            if(group.audio){
              songData = await extractAudioMetadata(group.audio);
              updateSpinner(`Processing ${processed+1}/${files.length}: ${group.audio.name}...`);
            }
            
            // Extract lyrics from companion files
            for(const lyricsFile of group.lyrics){
              updateSpinner(`Processing lyrics: ${lyricsFile.name}...`);
              const type = lyricsFile.type || '';
              const name = lyricsFile.name.toLowerCase();
              
              if(type.startsWith('text/') || name.endsWith('.txt')){
                const text = await new Promise((res)=>{
                  const r = new FileReader();
                  r.onload = e => res(String(e.target.result || ''));
                  r.onerror = () => res('');
                  r.readAsText(lyricsFile);
                });
                lyricsText += (lyricsText ? '\n\n' : '') + text;
              }
              else if(name.endsWith('.pdf')){
                await ensurePdfJs();
                const url = URL.createObjectURL(lyricsFile);
                const doc = await window.pdfjsLib.getDocument(url).promise;
                let pdfText = '';
                
                // Try to extract text
                for(let p = 1; p <= doc.numPages; p++){
                  const page = await doc.getPage(p);
                  const txtC = await page.getTextContent();
                  pdfText += txtC.items.map(i => i.str).join(' ') + '\n';
                }
                
                // If no text, OCR the PDF pages
                const textOnly = pdfText.replace(/\s+/g, '').trim();
                if(textOnly.length < 20){
                  await ensureTesseract();
                  const { Tesseract } = window;
                  pdfText = '';
                  
                  for(let p = 1; p <= doc.numPages; p++){
                    updateSpinner(`OCR lyrics PDF page ${p}/${doc.numPages}...`);
                    const page = await doc.getPage(p);
                    const viewport = page.getViewport({ scale: 2.0 });
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;
                    const ctx = canvas.getContext('2d');
                    await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                    
                    const result = await Tesseract.recognize(canvas, 'eng', {
                      logger: m => {
                        if(m.status === 'recognizing text'){
                          updateSpinner(`OCR lyrics page ${p}: ${Math.round(m.progress*100)}%`);
                        }
                      }
                    });
                    pdfText += (result?.data?.text || '') + '\n';
                  }
                }
                
                URL.revokeObjectURL(url);
                lyricsText += (lyricsText ? '\n\n' : '') + pdfText;
              }
              else if(type.startsWith('image/')){
                await ensureTesseract();
                const { Tesseract } = window;
                
                // Preprocess image for better handwriting OCR
                updateSpinner(`Preprocessing: ${lyricsFile.name}...`);
                const canvas = await prepareImageForOCR(lyricsFile, 3);
                
                const result = await Tesseract.recognize(canvas, 'eng', {
                  logger: m => {
                    if(m.status === 'recognizing text'){
                      updateSpinner(`OCR lyrics: ${lyricsFile.name} ${Math.round(m.progress*100)}%`);
                    }
                  }
                });
                lyricsText += (lyricsText ? '\n\n' : '') + (result?.data?.text || '');
              }
              processed++;
            }
            
            // Merge lyrics into song data
            if(songData){
              songData.lyrics = lyricsText || songData.lyrics || '';
              allSongs.push(songData);
              if(group.audio) processed++;
            } else if(lyricsText){
              // Lyrics only, no audio - parse as song lines (this is likely a setlist or lyrics sheet)
              console.log('Parsing lyrics-only text:', lyricsText.substring(0, 500));
              const parsedSongs = parseSongLines(lyricsText);
              console.log('Parsed songs from lyrics:', parsedSongs);
              allSongs.push(...parsedSongs);
              processed++;
            } else if(group.lyrics.length > 0){
              // Had lyrics files but no text extracted - count as processed
              processed++;
            }
          }catch(err){
            console.error(`Failed to process group ${baseName}:`, err);
          }
        }
        
        // Process standalone files (CSV, spreadsheet, standalone text)
        for(const f of standaloneFiles){
          const type = f.type || '';
          const name = (f.name || '').toLowerCase();
          try{
            if(type.startsWith('text/') || name.endsWith('.txt')){
              const text = await new Promise((res)=>{
                const r = new FileReader();
                r.onload = e => res(String(e.target.result || ''));
                r.onerror = () => res('');
                r.readAsText(f);
              });
              allSongs.push(...parseSongLines(text));
            }
            else if(name.endsWith('.csv') || type === 'text/csv'){
              const text = await new Promise((res)=>{
                const r = new FileReader();
                r.onload = e => res(String(e.target.result || ''));
                r.onerror = () => res('');
                r.readAsText(f);
              });
              allSongs.push(...parseCSV(text));
            }
            else if(name.match(/\.(xlsx?|ods)$/)){
              const songs = await parseSpreadsheet(f);
              allSongs.push(...songs);
            }
            else if(name.endsWith('.pdf') || type === 'application/pdf'){
              await ensurePdfJs();
              const url = URL.createObjectURL(f);
              const doc = await window.pdfjsLib.getDocument(url).promise;
              let full = '';
              
              // Try to extract text from each page
              for(let p = 1; p <= doc.numPages; p++){
                const page = await doc.getPage(p);
                const txtC = await page.getTextContent();
                full += txtC.items.map(i => i.str).join(' ') + '\n';
              }
              
              // If no text found, PDF is likely image-based - OCR each page
              const textOnly = full.replace(/\s+/g, '').trim();
              if(textOnly.length < 20){
                updateSpinner(`PDF appears to be image-based, running OCR on ${f.name}...`);
                await ensureTesseract();
                const { Tesseract } = window;
                full = '';
                
                for(let p = 1; p <= doc.numPages; p++){
                  updateSpinner(`OCR page ${p}/${doc.numPages} of ${f.name}...`);
                  const page = await doc.getPage(p);
                  const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR
                  
                  // Render PDF page to canvas
                  const canvas = document.createElement('canvas');
                  canvas.width = viewport.width;
                  canvas.height = viewport.height;
                  const ctx = canvas.getContext('2d');
                  
                  await page.render({ canvasContext: ctx, viewport: viewport }).promise;
                  
                  // OCR the rendered page
                  const result = await Tesseract.recognize(canvas, 'eng', {
                    logger: m => {
                      if(m.status === 'recognizing text'){
                        updateSpinner(`OCR page ${p}/${doc.numPages}: ${Math.round(m.progress*100)}%`);
                      }
                    }
                  });
                  full += (result?.data?.text || '') + '\n';
                }
              }
              
              URL.revokeObjectURL(url);
              allSongs.push(...parseSongLines(full));
            }
            else if(type.startsWith('image/')){
              await ensureTesseract();
              const { Tesseract } = window;
              
              // Preprocess image for better handwriting OCR
              updateSpinner(`Preprocessing: ${f.name}...`);
              const canvas = await prepareImageForOCR(f, 3);
              
              const result = await Tesseract.recognize(canvas, 'eng', {
                logger: m => {
                  if(m.status === 'recognizing text'){
                    updateSpinner(`OCR ${processed+1}/${files.length}: ${Math.round(m.progress*100)}%`);
                  }
                }
              });
              const text = result && result.data && result.data.text || '';
              allSongs.push(...parseSongLines(text));
            }
          }catch(err){
            console.error(`Failed to process ${f.name}:`, err);
          }
          processed++;
          updateSpinner(`Processed ${processed}/${files.length} files...`);
        }
        parsed = dedupe(allSongs);
        statusEl.textContent = `Parsed ${parsed.length} song${parsed.length===1?'':'s'} from ${files.length} file${files.length===1?'':'s'}.`;
        
        // Hide spinner when done
        const spinnerDone = document.getElementById('importSpinner');
        if(spinnerDone){ spinnerDone.style.display = 'none'; }
        
        renderPreview();
      });
      
      // Database dropzone handler - drag files onto the DATABASE tab to import
      const dbCard = document.getElementById('db');
      const dbDropzone = document.getElementById('dbDropzone');
      
      if(dbCard && dbDropzone){
        let dragCounter = 0;
        
        dbCard.addEventListener('dragenter', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter++;
          dbDropzone.style.display = 'flex';
        });
        
        dbCard.addEventListener('dragleave', (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter--;
          if(dragCounter <= 0){
            dragCounter = 0;
            dbDropzone.style.display = 'none';
          }
        });
        
        dbCard.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.dataTransfer.dropEffect = 'copy';
        });
        
        dbCard.addEventListener('drop', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          dragCounter = 0;
          dbDropzone.style.display = 'none';
          
          // Scroll to import section so user can see progress
          const importBlock = document.getElementById('importBlock');
          if(importBlock){
            importBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          
          // Show spinning vinyl overlay immediately
          const spinner = document.getElementById('importSpinner');
          const spinnerText = document.getElementById('importSpinnerText');
          if(spinner){ spinner.style.display = 'flex'; }
          const updateDropSpinner = (text) => { 
            if(spinnerText) spinnerText.textContent = text; 
            statusEl.textContent = text; 
          };
          
          updateDropSpinner('Processing dropped files‚Ä¶');
          console.log('Drop event received');
          
          // Collect all files from the drop (including from folders)
          const items = e.dataTransfer.items;
          const dtFiles = e.dataTransfer.files;
          let droppedFiles = [];
          
          console.log('items:', items?.length, 'files:', dtFiles?.length);
          
          // Helper to recursively get files from directory entries
          function getFilesFromEntry(entry){
            return new Promise((resolve) => {
              if(!entry){
                resolve([]);
                return;
              }
              if(entry.isFile){
                entry.file((f) => {
                  console.log('Got file from entry:', f.name);
                  resolve([f]);
                }, (err) => {
                  console.warn('Failed to get file from entry:', err);
                  resolve([]);
                });
              } else if(entry.isDirectory){
                console.log('Reading directory:', entry.name);
                const reader = entry.createReader();
                const allFiles = [];
                const readBatch = () => {
                  reader.readEntries((entries) => {
                    console.log('Read', entries.length, 'entries from', entry.name);
                    if(entries.length === 0){
                      resolve(allFiles);
                    } else {
                      Promise.all(entries.map(e => getFilesFromEntry(e))).then(results => {
                        results.forEach(files => allFiles.push(...files));
                        readBatch(); // Keep reading (Chrome returns max 100 entries per call)
                      });
                    }
                  }, (err) => {
                    console.warn('Failed to read directory:', err);
                    resolve(allFiles);
                  });
                };
                readBatch();
              } else {
                resolve([]);
              }
            });
          }
          
          // Try using DataTransferItemList with webkitGetAsEntry for folder support
          if(items && items.length > 0){
            console.log('Using DataTransferItemList');
            const entryPromises = [];
            
            // Must capture entries synchronously
            for(let i = 0; i < items.length; i++){
              const item = items[i];
              console.log('Item', i, 'kind:', item.kind, 'type:', item.type);
              
              if(item.webkitGetAsEntry){
                const entry = item.webkitGetAsEntry();
                console.log('Got entry:', entry?.name, 'isDir:', entry?.isDirectory, 'isFile:', entry?.isFile);
                if(entry){
                  entryPromises.push(getFilesFromEntry(entry));
                }
              } else if(item.kind === 'file'){
                // Fallback for browsers without webkitGetAsEntry
                const f = item.getAsFile();
                if(f){
                  console.log('Got file directly:', f.name);
                  droppedFiles.push(f);
                }
              }
            }
            
            // Wait for all entries to be processed
            if(entryPromises.length > 0){
              updateDropSpinner('Reading folder contents‚Ä¶');
              const results = await Promise.all(entryPromises);
              results.forEach(files => droppedFiles.push(...files));
            }
          }
          
          // Fallback: use dataTransfer.files if no files collected yet
          if(droppedFiles.length === 0 && dtFiles && dtFiles.length > 0){
            console.log('Falling back to dataTransfer.files');
            droppedFiles = Array.from(dtFiles);
          }
          
          console.log('Total dropped files:', droppedFiles.length);
          
          if(droppedFiles.length === 0){
            updateDropSpinner('No files detected. Try: check "Folder" ‚Üí Choose Files.');
            if(spinner){ spinner.style.display = 'none'; }
            return;
          }
          
          // Filter to supported file types
          const supportedExtensions = /\.(txt|pdf|csv|xls|xlsx|ods|mp3|wav|flac|m4a|aac|ogg|wma|mp4|avi|mov|mkv|jpg|jpeg|png|gif|bmp)$/i;
          const validFiles = droppedFiles.filter(f => supportedExtensions.test(f.name));
          
          console.log('Valid files:', validFiles.length, validFiles.map(f=>f.name));
          updateDropSpinner(`Found ${droppedFiles.length} files, ${validFiles.length} supported.`);
          
          if(validFiles.length === 0){
            updateDropSpinner(`No supported files in ${droppedFiles.length} items.`);
            if(spinner){ spinner.style.display = 'none'; }
            return;
          }
          
          // Create a DataTransfer to simulate file input
          const dt = new DataTransfer();
          validFiles.forEach(f => dt.items.add(f));
          file.files = dt.files;
          
          // Trigger the change event to process files (spinner will be hidden by the change handler when done)
          updateDropSpinner(`Processing ${validFiles.length} files‚Ä¶`);
          file.dispatchEvent(new Event('change', { bubbles: true }));
        });
      }
    })();
  </script>
  <!-- Lightweight libs for client PDF/ZIP export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Bottom brand bar -->
  <div class="brand-bar">
    FASTFAST SETLIST and STAGE DESIGNER (c) 2025 All Rights Reserved
  </div>
</body>
</html>
