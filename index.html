<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    :root{
      --bg:#f5f7fb; --card:#ffffff; --muted:#4b5563; --accent:#1f2937; --accent2:#374151; --danger:#374151;
      --paperText:#111; --paperRule:#444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-size:16px;font-family:Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif;background:#f3f4f6;color:#1f2937}
  .wrap{max-width:min(1600px,98vw);margin:0 auto;padding:24px}
    .hero{background:linear-gradient(135deg,#e0ecff 0%,#f0f7ff 60%,#e6fbff 100%);border:1px solid #dbeafe;border-radius:16px;padding:28px;text-align:center;color:#111;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .hero h1{margin:0 0 6px;font-size:32px}
  .tabs{display:flex;margin:16px 0;border-bottom:1px solid #e5e7eb}
  .tab{flex:1;padding:12px 16px;background:transparent;border:none;color:#374151;font-weight:700;cursor:pointer}
    .tab.active{color:#111;border-bottom:3px solid var(--accent)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:12px;padding:16px}
    .card h2{margin:0 0 12px;font-size:20px;color:#111}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>.field{flex:1;min-width:220px}
    .field{margin:8px 0}
    label{display:block;margin-bottom:6px;font-size:13px;color:#374151;font-weight:600}
    input,select,textarea{width:100%;padding:12px 12px;border-radius:10px;border:1px solid #d1d5db;background:#ffffff;color:#111;font-size:15px}
    input[type="checkbox"]{width:auto}
    .checks{display:flex;flex-wrap:wrap;gap:12px}
    .btn{padding:11px 16px;border-radius:10px;border:1px solid #374151;color:#f9fafb;background:#1f2937;cursor:pointer;font-weight:800}
    .btn.secondary{background:#6b7280;border-color:#4b5563}
    .btn.danger{background:#374151;border-color:#1f2937;color:#f9fafb}
    .list{display:grid;gap:10px;margin-top:12px}
  .song{display:flex;gap:12px;align-items:center;justify-content:space-between;background:#ffffff;border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .song.dragging{opacity:.6}
    .song .meta{font-size:13px;color:#4b5563}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;margin-right:6px}
  .handle{cursor:grab;color:#6b7280;font-size:18px;user-select:none;margin-right:6px}
  .handle:active{cursor:grabbing}

    /* Print preview (paper look) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:24px;z-index:80}
    .modal.open{display:flex}
    .sheet{width:8.5in;max-width:100%;height:11in;background:white;color:var(--paperText);border-radius:8px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:0.65in;overflow:auto}
  @media (max-width:768px){
    .modal{align-items:flex-start;padding:10px}
    .modal .sheet{width:100%;height:auto;max-height:90vh;padding:16px;box-sizing:border-box}
  }
    .sheet.a4{width:210mm;height:297mm}
  .hdr{text-align:center;padding-bottom:8px;margin-bottom:8px}
    .hdr .band{font-size:26pt;font-weight:900;letter-spacing:.6px}
    .hdr .venue{font-size:22pt;font-weight:800;letter-spacing:.5px;margin-top:2px}
  .hdr .sub{font-size:10pt;color:#444;margin-top:4px}
  .hdr .notes{font-size:10pt;color:#333;margin-top:2px;font-style:italic}
  .hdr .logo{display:block}
  .hdr .logo img{max-height:56pt;max-width:100%;height:auto}
    .songs{display:flex;flex-direction:column;gap:2px}
  .line{display:grid;grid-template-columns:22px 1fr minmax(90px,120px) 40px;align-items:baseline;column-gap:8px;padding:1px 0}
  .line .no{font-weight:800;text-align:right;opacity:.85}
  .line .title{font-weight:900;letter-spacing:.1px}
  .line .title .notePrint{font-size:9pt;font-style:italic;font-weight:400;opacity:.75;margin-left:6px}
  .line .key{font-size:10pt;color:#374151;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .time{font-size:10pt;text-align:right;opacity:.9}
    .no{font-weight:800;font-size:12pt;min-width:26px;text-align:right;color:#333}
  .title{flex:1;font-size:17pt;font-weight:900;letter-spacing:0.2px}
    .time{min-width:42px;text-align:right;font-size:10pt;color:#444}
  .subnotes{font-size:9pt;color:#4b5563;font-style:italic;margin-top:-2px;margin-left:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .break{font-weight:900;text-transform:uppercase;font-size:14pt;color:#7b1fa2;text-align:center;border:2px dashed #7b1fa2;padding:6px 8px;border-radius:8px;background:#f7efff}

  .tools{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:12px}
    .tools .paper{color:#374151}

  /* Floating Song Pool */
  .pool-flyout{position:fixed;top:76px;right:18px;width:320px;max-width:92vw;height:calc(100% - 100px);background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,.18);display:none;flex-direction:column;z-index:65}
  .pool-flyout.open{display:flex}
  .pool-head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #e5e7eb}
  .pool-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .pool-sec h4{margin:0 0 6px 0;font-size:13px;color:#6b7280;text-transform:uppercase;letter-spacing:.6px}
  /* Base pill chip styling (used in Song Pool) */
  .pill{display:inline-flex;align-items:center;gap:6px;border:2px solid #d1d5db;border-radius:999px;padding:4px 10px;background:#fff;font-size:12px;color:#111827}
  .pool-sec .pill{cursor:grab}
  .pill.drag-touch{opacity:.55;outline:2px dashed #374151}
  .touch-target-highlight{box-shadow:inset 0 3px 0 #374151,inset 0 -3px 0 #374151}
  /* Live layout: no wrap on wide screens; wrap on narrow */
  #liveFlex{flex-wrap:nowrap;flex-direction:row}
  #liveLeftCol{flex:0 0 340px;min-width:340px}
  @media (max-width: 900px){ #liveFlex{flex-wrap:wrap;flex-direction:row} #liveLeftCol{flex:1 1 100%;min-width:260px} }
  /* Mood pastel chips */
  .pill.mood-upbeat{background:#FECACA;border-color:#FCA5A5}
  .pill.mood-happy{background:#FEF9C3;border-color:#FDE68A}
  .pill.mood-energetic{background:#CFFAFE;border-color:#A5F3FC}
  .pill.mood-mellow{background:#FFEDD5;border-color:#FED7AA}
  .pill.mood-sad{background:#DBEAFE;border-color:#BFDBFE}
  /* Drop indicator on set rows */
  #setList .song.drop-before{box-shadow:inset 0 3px 0 0 #60a5fa}
  #setList .song.drop-after{box-shadow:inset 0 -3px 0 0 #60a5fa}
  /* Drop indicator on preview sheet rows */
  .line.drop-before, .break.drop-before{box-shadow:inset 0 3px 0 0 #60a5fa}
  .line.drop-after, .break.drop-after{box-shadow:inset 0 -3px 0 0 #60a5fa}

    @media print{
      body,*{background:transparent!important;overflow:visible!important}
      .wrap{display:none}
      .modal{position:static;display:none;background:none;padding:0}
      .modal.open{display:block}
      .sheet{box-shadow:none;height:auto;overflow:visible!important}
      .tools{display:none}
      /* Never print the Print Options dialog */
      #printChooser{display:none!important}
      .break.pagebreak{page-break-after:always}
      #songPoolFlyout{display:none!important}
      /* Hide scrollbars in print */
      *::-webkit-scrollbar{display:none!important}
      *{scrollbar-width:none!important}
    }

  /* Fullscreen Stage Editor */
  /* Inline stage editor (converted from fullscreen) */
  .stage-modal{position:static;background:transparent;display:none;z-index:auto;margin-top:12px}
  .stage-modal.open{display:flex}
  .stage-editor{display:grid;grid-template-columns:340px 1fr;gap:16px;background:#fff;width:100%;min-height:640px}
  .stage-pane{padding:10px 12px 16px;overflow:hidden;border-right:1px solid #e5e7eb}
  .stage-pane .tool{white-space:nowrap}
  .stage-pane .toolbox-actions{display:flex;flex-wrap:wrap;gap:8px;margin:0 0 8px}
  .stage-pane .toolbox-actions button{padding:6px 10px;font-size:12px}
  .stage-canvas{padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;overflow:auto}
  /* Preserve full-size stage canvas on desktop; limit height on tablets/phones */
  #stageSvgFull{width:100% !important;height:auto !important;aspect-ratio:1500/900;flex:0 0 auto;max-height:70vh}
  #stageFrame{max-width:100%;overflow:visible}
  @media (max-width:900px){
    #stageSvgFull{max-height:55vh;max-width:100%;aspect-ratio:1500/900!important;height:auto!important}
    #stageFrame{max-width:calc(100vw - 48px)}
    .stage-canvas{padding:6px}
  }
  .stage-legend{width:100%;border:1px solid #e5e7eb;background:#f9fafb;border-radius:6px;padding:4px;display:flex;flex-direction:column;gap:2px;font-size:11px;line-height:1.1}
  .stage-legend .row{display:grid;grid-template-columns:60px 1fr 110px 160px;align-items:center;gap:6px;padding:1px 4px;}
  .stage-legend .row:nth-child(odd){background:#fff}
  .stage-legend img{width:16px;height:16px;object-fit:contain;display:block;margin:0 auto}
  .stage-legend .nm{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:11px}
  .stage-legend select,.stage-legend input[type=number]{font-size:11px;padding:0 2px;height:18px}
  .stage-legend .chain{font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .tool[draggable="true"]{user-select:none}
  .stage-actions{position:absolute;top:10px;right:10px;display:flex;gap:8px}
  /* Hide close button in inline mode; Clear moved into toolbox footer */
  #closeStage{display:none}
  /* Tech / Stage: tech rider & stage plot (B&W) */
  .advanced-grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
  .tech-table{width:100%;border-collapse:collapse}
  .tech-table th,.tech-table td{border:1px solid #e5e7eb;padding:4px 6px;font-size:11px;line-height:1.2}
  .stage-wrap{border:1px solid #e5e7eb;border-radius:8px;background:#fff;padding:10px}
  .stage-tools{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}
  .tool{border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;padding:6px 8px;font-size:13px;cursor:pointer}
  .stage{width:100%;height:90vh;min-height:640px;border:1px dashed #cbd5e1;background:#ffffff}
  .stage svg{width:100%;height:100%;background:white}
  /* B&W outlines for glyphs, keep background white */
  .bw .stage-bg{fill:#fff;stroke:#000;stroke-width:2}
  /* Allow colored emoji backgrounds: only force outline for rects without data-bg */
  .bw rect:not([data-bg]){fill:none;stroke:#000}
  .bw path,.bw circle,.bw ellipse,.bw line,.bw polyline,.bw polygon{fill:none;stroke:#000}
  .bw text{fill:#000;stroke:none}
  /* selection visual (editor only; not printed) */
  g[data-draggable].selected path,
  g[data-draggable].selected rect,
  g[data-draggable].selected circle,
  g[data-draggable].selected ellipse,
  g[data-draggable].selected line,
  g[data-draggable].selected polyline,
  g[data-draggable].selected polygon{stroke:#374151}
  g[data-draggable].selected text{text-decoration:underline}
  g[data-draggable].selected{filter:drop-shadow(0 0 6px rgba(37,99,235,0.65));}
  .stage-inspector{display:flex;gap:10px;align-items:center;flex-wrap:wrap;position:relative;padding:8px;background:#fff;border:1px solid #e5e7eb;border-radius:6px}
  .stage-inspector .connection-chain{order:-1;flex-basis:100%;margin-bottom:4px}
  /* Stage frame & resize handles */
  #stageFrame{outline:3px solid #000;pointer-events:none}
  #stageFrame .stage-handle{position:absolute;width:16px;height:16px;background:#000;border:2px solid #fff;border-radius:4px;z-index:85;pointer-events:auto;box-shadow:0 0 0 1px #000}
  #stageFrame .stage-handle.tl{top:-10px;left:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle.tr{top:-10px;right:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.bl{bottom:-10px;left:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.br{bottom:-10px;right:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle:active{background:#374151}
  #stageSvgFull{pointer-events:auto}
  .stage-inspector .muted{color:#6b7280;font-size:13px}
  .gear-wrap{margin-top:8px}
  .gear-wrap textarea{width:100%;min-height:42px}
  /* Global print FAB */
  .print-fab{position:fixed;right:18px;bottom:18px;z-index:70;border-radius:999px;padding:12px 16px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
  @media print{ .print-fab{display:none} }
  /* Print-specific tweaks for tech/stage so content stays on page */
  @media print{
    #sheetTech{width:8.5in;max-width:8.5in;padding:0.5in}
    #sheetTech .tech-table th,#sheetTech .tech-table td{font-size:9pt;padding:3px 4px}
    #stagePrint svg{max-height:6.5in;max-width:7.5in;width:100%;height:auto}
    #stagePrint{overflow:hidden}
  }
  /* Touch optimizations */
  #stageSvgFull{ touch-action:none; }
  .stage-canvas{ -webkit-user-select:none; user-select:none; }
  /* Global sticky actions (top-left) */
  .global-actions{position:sticky;top:0;z-index:60;display:flex;gap:8px;flex-wrap:wrap;padding:6px 0 4px 0;margin:0 0 8px 0;background:rgba(249,250,251,0.96);backdrop-filter:blur(2px)}
  @media print{ .global-actions{display:none} }
  /* Database: horizontal scroll on narrow screens */
  @media (max-width: 768px){
    #dbList{overflow-x:auto;overflow-y:visible}
    .db-row{min-width:900px}
  }
  /* Missing songs list */
  .missing{margin:8px 0 6px 0;display:flex;flex-wrap:wrap;gap:6px}
  .missing .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #d1d5db;border-radius:999px;padding:4px 8px;background:#fff;font-size:12px;color:#111827}
  .missing .pill .add{background:#065f46;color:#fff;border:none;border-radius:999px;padding:2px 8px;cursor:pointer}
  .missing .pill .add:hover{background:#064e3b}
  /* Tabs styling */
  .tabs{display:flex;gap:4px;margin-bottom:10px;border-bottom:1px solid #374151}
  .tab{border:none;padding:6px 12px;font-size:14px;background:#6b7280;color:#f9fafb;border-top-left-radius:6px;border-top-right-radius:6px;cursor:pointer}
  .tab.active{background:#1f2937;color:#f9fafb}
  .tab:not(.active):hover{background:#4b5563}
  /* Bottom brand bar */
  .brand-bar{position:fixed;bottom:0;left:0;right:0;height:20px;background:#1f2937;color:#e5e7eb;font-size:11px;display:flex;align-items:center;justify-content:center;z-index:80}
  .brand-bar a{color:inherit;text-decoration:none}
  .brand-bar a:hover{text-decoration:underline}
  /* Hide global actions row when Live tab active */
  body.live-mode .global-actions{display:none}
  /* Live fullscreen lyrics */
  .live-lyrics-overlay{position:fixed;inset:0;background:#020617;color:#e5e7eb;z-index:90;display:none;flex-direction:column}
  .live-lyrics-overlay.open{display:flex}
  .live-lyrics-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:#0b1120;border-bottom:1px solid #1f2937}
  .live-lyrics-title{font-weight:700;font-size:16px;margin-right:auto;margin-left:10px}
  .live-lyrics-main{flex:1 1 auto;overflow:auto;padding:16px;display:flex;align-items:flex-start;justify-content:center}
  .live-lyrics-body{white-space:pre-wrap;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;font-size:20px;line-height:1.5;text-align:center;max-width:1100px;margin:0 auto}
  .live-lyrics-play{padding:8px 14px;border-radius:999px;border:none;background:#22c55e;color:#022c22;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-stop{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-exit{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer}
  @media (max-width:768px){
    .live-lyrics-body{font-size:18px}
  }
  /* Live tab theming */
  body.live-dark #live{background:#020617;color:#e5e7eb}
  body.live-dark #liveList{background:#020617;border-color:#1f2937}
  body.live-dark #liveList .live-row{border-bottom-color:#111827}
  body.live-dark #liveLyrics{background:#020617;border-color:#1f2937;color:#e5e7eb}
  body.live-dark .tab[data-tab="live"].active{background:#0f172a;color:#f9fafb}
  /* Desktop inline live controls stick to top while scrolling */
  #liveLyrics{position:relative}
  #liveLyrics #liveInlineControls{position:sticky;top:0;z-index:2;padding:6px 4px;margin:-12px -12px 8px -12px;border-bottom:1px solid #e5e7eb;background:linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0));backdrop-filter:saturate(1.2) blur(2px)}
  body.live-dark #liveLyrics #liveInlineControls{border-bottom-color:#1f2937;background:linear-gradient(180deg, rgba(2,6,23,0.96), rgba(2,6,23,0))}
  /* Live mode: hide brand bar and any open stage/notes modals for distraction-free view */
  body.live-mode .brand-bar{display:none}
  body.live-mode #stageModal, body.live-mode #notesModal{display:none !important}
  </style>
</head>
<body>
  <div class="wrap" style="padding-bottom:28px">
    <!-- Global sticky actions: always available top-left -->
    <div class="global-actions">
      <button class="btn" id="gearBtn" title="Show save/load tools">‚öôÔ∏è</button>
      <button class="btn" id="openPrintOptionsTop" title="Print‚Ä¶">Print‚Ä¶</button>
      <button class="btn secondary" id="helpBtn" title="Help / Tutorial">?</button>
      <div id="gearPanel" style="display:none;gap:8px;flex-wrap:wrap;margin-left:12px">
        <button class="btn" id="saveProfile">Save Profile (.BAND)</button>
        <button class="btn" id="loadProfile">Load Profile (.BAND)</button>
        <input type="file" id="loadProfileFile" accept=".band,application/json" style="display:none" />
        <button class="btn" id="saveSet">Save .SET</button>
        <button class="btn" id="loadSet">Load .SET</button>
        <input type="file" id="loadSetFile" accept=".set,application/json" style="display:none" />
      </div>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="db">Song Database</button>
      <button class="tab" data-tab="set">Setlist</button>
      <button class="tab" data-tab="adv">Tech / Stage</button>
      <button class="tab" data-tab="live">Live</button>
    </div>

    <div class="grid">
      <div class="card" id="db" style="grid-column:1 / -1; width:100%;">
        <h2>Song Database</h2>
          <div style="margin:12px 0;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <input type="text" id="dbSearch" placeholder="Search songs..." style="flex:1 1 200px;padding:8px;border:1px solid #d1d5db;border-radius:4px;font-size:14px">
            <label style="font-size:12px;color:#64748b">Sort by:</label>
            <select id="dbSort" style="padding:6px 8px;border:1px solid #d1d5db;border-radius:4px">
              <option value="added">Order Added</option>
              <option value="alpha" selected>Alpha by Song</option>
              <option value="band">Alpha by Band</option>
              <option value="mood">Mood Order</option>
              <option value="rating">Audience Rating</option>
              <option value="mostUsed">Most Selected</option>
              <option value="leastUsed">Least Selected</option>
            </select>
          </div>
          <div style="margin:8px 0;display:flex;flex-wrap:wrap;gap:12px;align-items:center;font-size:13px">
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterCovers"> Covers</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterOriginals"> Originals</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasLyrics"> Has Lyrics</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterKaraoke"> Karaoke</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasAudio"> Has Audio</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasURL"> Has URL</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterInSet"> In Current Set</label>
            <label style="font-size:12px;color:#64748b;margin-left:8px">Mood:</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterUpbeat"> Upbeat</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHappy"> Happy</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterEnergetic"> Energetic</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterMellow"> Mellow</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterSad"> Sad</label>
            <span id="customMoodFilters"></span>
          </div>
        <!-- Profile buttons moved to global-actions -->
        <div class="list" id="dbList" style="width:100%;"></div>
        <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
          <button class="btn" id="addCustomColumn" style="background:#065f46;color:#f9fafb;border:1px solid #064e3b">+ Add Custom Column</button>
          <div style="display:flex;gap:12px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer"><input type="checkbox" id="clearDBLock" style="width:18px;height:18px"><span style="font-size:14px">üîì Unlock Clear</span></label>
            <button class="btn danger" id="clearDB" style="background:#374151;color:#f9fafb">Clear Database</button>
          </div>
        </div>
        <div class="import-block" id="importBlock" style="margin-top:22px;padding:14px;border:1px solid #e2e8f0;border-radius:8px;background:#f8fafc">
          <h3 style="margin:0 0 10px;font-size:18px">Import Songs (OCR / Paste)</h3>
          <textarea id="importText" rows="4" placeholder="Paste lines e.g.\nSong Title - Am (Capo 2)\nAnother Song G Capo 3\nThird Song - F#m" style="width:100%;resize:vertical;font-family:monospace"></textarea>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center">
            <input type="file" id="importFile" accept=".txt,.pdf,image/*" style="flex:1 1 240px" />
            <button class="btn" id="importParseBtn" type="button">Parse Text & Preview</button>
            <button class="btn secondary" id="importCommitBtn" type="button" disabled>Add Parsed Songs</button>
          </div>
          <div id="importStatus" style="margin-top:8px;font-size:12px;color:#64748b"></div>
          <div id="importPreview" style="margin-top:10px;font-size:13px;line-height:1.4"></div>
          <div style="margin-top:10px;font-size:11px;color:#94a3b8">Image/PDF OCR uses Tesseract.js & PDF.js in-browser; accuracy varies with scan quality. Keys & capo detected heuristically. Review before importing.</div>
        </div>
      </div>

      <!-- Combined Setlist + Generator Tab -->
      <div class="card" id="set" style="display:none;grid-column:1 / -1;width:100%">
        <h2>Setlist</h2>
        <div id="setlistLayout" style="display:flex;flex-wrap:nowrap;gap:24px;align-items:flex-start;margin-top:12px;width:100%">
          <div id="poolCol" style="flex:0 0 260px;display:flex;flex-direction:column;gap:12px;align-items:flex-start">
            <h3 style="margin:0">Song Pool</h3>
            <div id="poolControls" style="display:flex;flex-direction:column;gap:6px;width:100%">
              <input type="text" id="poolSearch" placeholder="Search songs..." style="width:100%;padding:6px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Type</label>
                <select id="poolType" style="flex:1 1 auto;min-width:120px">
                  <option value="all" selected>All</option>
                  <option value="originals">Originals</option>
                  <option value="covers">Covers</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Sort</label>
                <select id="poolSort" style="flex:1 1 auto;min-width:140px">
                  <option value="alpha" selected>Alphabetical</option>
                  <option value="band">Band Name</option>
                  <option value="mood">Mood Order</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Mood</label>
                <select id="poolMood" style="flex:1 1 auto;min-width:140px">
                  <option value="all" selected>All</option>
                  <option value="upbeat">Upbeat</option>
                  <option value="happy">Happy</option>
                  <option value="energetic">Energetic</option>
                  <option value="mellow">Mellow</option>
                  <option value="sad">Sad</option>
                </select>
              </div>
            </div>
            <div id="poolOriginals" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolCoversHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Covers</h4>
            <div id="poolCovers" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolBreaksHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Break</h4>
            <div id="poolBreaks" style="display:flex;flex-direction:column;gap:6px"></div>
          </div>
          <div id="previewCol" style="flex:1 1 auto;min-width:640px;max-width:1100px;position:sticky;top:12px;align-self:flex-start;max-height:calc(100vh - 24px);display:flex;flex-direction:column">
            <h3 style="margin:0 0 8px">Preview</h3>
            <div class="sheet" id="sheetInline" style="overflow:auto;flex:1 1 auto;height:auto;max-height:calc(100vh - 100px)">
              <div class="hdr" id="hdrInline"></div>
              <div class="songs" id="songsInline"></div>
            </div>
            <div style="margin-top:10px;font-size:12px;color:#64748b">Drag songs from the pool directly into the preview. Drag rows to reorder. Double‚Äëclick a title to add/edit notes. Drag a Break chip to insert a break.</div>
          </div>
        </div>

        <!-- Generator / Gig Info moved below setlist -->
        <div style="margin-top:32px;padding-top:24px;border-top:2px solid #e5e7eb">
          <h3 style="margin-top:0">Generator / Gig Info</h3>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px 16px">
            <div class="field"><label>Band Name</label><input id="gBand" placeholder="Band name" style="max-width:240px"></div>
            <div class="field"><label>Date</label><input id="gDate" type="date" style="max-width:160px"></div>
            <div class="field"><label>Venue</label><input id="gVenue" placeholder="Venue name" style="max-width:240px"></div>
            <div class="field"><label>Address</label><input id="gAddr" placeholder="123 Main St" style="max-width:280px"></div>
            <div class="field"><label>Contact</label><input id="gContact" placeholder="Name / phone" style="max-width:200px"></div>
            <div class="field"><label>Setlist Font</label>
              <select id="gFont" style="max-width:180px">
                <option value="default">Default</option>
                <option value="helvetica">Helvetica/Arial</option>
                <option value="georgia">Georgia (serif)</option>
                <option value="roboto-condensed">Roboto Condensed</option>
                <option value="courier">Courier New (mono)</option>
              </select>
            </div>
          </div>
          <div class="field" style="margin-top:12px;max-width:600px"><label>Notes (small, under header)</label><textarea id="gNotes" rows="2" placeholder="Load-in, request, etc"></textarea></div>
          <div class="field" style="margin-top:12px">
            <label>Logo (overrides Band Name in print)</label>
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <input id="gLogo" type="file" accept="image/*" style="max-width:240px" />
              <img id="gLogoPrev" alt="logo preview" style="max-height:48px;display:none" />
              <button class="btn danger" id="gLogoClear" type="button">Remove Logo</button>
            </div>
          </div>

          <h4 style="margin-top:24px;margin-bottom:8px">Generator Settings</h4>
          <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px 16px;max-width:900px">
            <div class="field"><label>Set length (min)</label><input id="gLen" type="number" min="10" value="60" placeholder="60" style="max-width:100px"></div>
            <div class="field"><label>Cover ratio</label>
              <select id="gCover" style="max-width:140px">
                <option value="0">100% Originals</option>
                <option value="25">25% Covers</option>
                <option value="50" selected>50/50</option>
                <option value="75">75% Covers</option>
                <option value="90">90% Covers</option>
                <option value="100">100% Covers</option>
              </select>
            </div>
            <div class="field"><label>Breaks</label>
              <select id="gBreaks" style="max-width:120px">
                <option value="0">No breaks</option>
                <option value="1">1 break</option>
                <option value="2">2 breaks</option>
                <option value="3">3 breaks</option>
              </select>
            </div>
            <div class="field"><label>Break length (min)</label><input id="gBreakLen" type="number" min="5" value="15" style="max-width:100px"></div>
            <div class="field"><label>Mood</label>
              <select id="gMood" style="max-width:140px">
                <option value="mixed">Mixed</option>
                <option value="upbeat">Upbeat</option>
                <option value="happy">Happy</option>
                <option value="mellow">Mellow</option>
                <option value="energetic">Energetic</option>
                <option value="sad">Sad</option>
              </select>
            </div>
            <div class="field" style="grid-column:1"><label><input type="checkbox" id="gEncore"> Include Encore</label></div>
          </div>

          <div class="field" style="margin-top:12px">
            <label>Grouping Rules</label>
            <div class="checks" style="gap:6px">
              <label class="chip"><input type="checkbox" id="gKeepCovers"> Keep Covers Together</label>
              <label class="chip"><input type="checkbox" id="gKeepKeys"> Keep Keys Together</label>
              <label class="chip"><input type="checkbox" id="gKeepMoods"> Keep Moods Together</label>
            </div>
          </div>
          <div class="field" style="margin-top:8px">
            <label>Header print elements</label>
            <div class="checks" style="gap:6px">
              <label class="chip"><input type="checkbox" id="hdrBand" checked> Band/Logo</label>
              <label class="chip"><input type="checkbox" id="hdrVenue" checked> Venue</label>
              <label class="chip"><input type="checkbox" id="hdrSub" checked> Date / Address / Contact</label>
              <label class="chip"><input type="checkbox" id="hdrNotes" checked> Notes</label>
            </div>
          </div>
          <div style="margin-top:16px;display:flex;gap:8px;align-items:center;justify-content:flex-start">
            <button class="btn" id="genBtn">Generate</button>
            <button class="btn danger" id="clearSet" type="button">Clear Setlist</button>
          </div>
          <div id="genStats" style="margin-top:10px;color:#64748b;font-size:12px"></div>
        </div>
      </div>

      <div id="adv" style="display:none;padding-top:6px;margin-top:8px">
        <div class="row" style="gap:8px;margin-bottom:4px;padding:0 4px">
          <button class="btn" id="stageToggle" onclick="toggleStageAndNotes()">Stage Plot</button>
        </div>
      </div>

      <!-- Live Mode: full-screen, touch-first setlist + lyrics viewer -->
      <div id="live" style="display:none;grid-column:1 / -1;width:100%;margin-top:12px">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px">
              <h2 style="margin:0">Live Mode</h2>
              <button id="liveThemeToggle" type="button" title="Toggle light/dark" style="margin-left:auto;border-radius:999px;border:none;width:34px;height:34px;display:flex;align-items:center;justify-content:center;font-size:18px;background:#0f172a;color:#fbbf24;cursor:pointer">üåô</button>
            </div>
        <div id="liveFlex" style="display:flex;gap:12px;min-height:60vh">
          <div id="liveLeftCol" style="display:flex;flex-direction:column;gap:6px;max-height:80vh">
            <div style="display:flex;align-items:center;gap:8px">
              <button id="armAllBtn" type="button" title="Arm local audio files for this set" class="btn">Arm All</button>
            </div>
            <input id="armAllDir" type="file" webkitdirectory directory multiple style="display:none" />
            <input id="armSongFile" type="file" accept="audio/*" style="display:none" />
            <div id="liveList" style="flex:1 1 auto;border:1px solid #e5e7eb;border-radius:8px;padding:8px;overflow:auto">
            <!-- live setlist rows injected here -->
          </div>
          </div>
          <div id="liveLyrics" style="flex:2 1 360px;min-width:280px;border:1px solid #e5e7eb;border-radius:8px;padding:12px;max-height:80vh;overflow:auto;font-size:16px;line-height:1.4">
            <div id="liveInlineControls" style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
              <button id="liveInlinePlay" class="live-lyrics-play" type="button">Play</button>
              <button id="liveInlineStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
              <div style="display:flex;align-items:center;gap:6px;margin-left:auto">
                <span style="font-size:11px;color:#64748b">Zoom</span>
                <input id="liveInlineZoom" type="range" min="16" max="32" value="20" step="1" style="width:140px">
              </div>
              <div style="display:flex;align-items:center;gap:4px">
                <span style="font-size:11px;color:#64748b">Speed</span>
                <button id="liveInlineSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
                <span id="liveInlineSpeedDisplay" style="font-size:14px;color:#111;font-weight:bold;min-width:12px;text-align:center">5</span>
                <button id="liveInlineSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">+</button>
              </div>
              <button id="metronomeBtn" type="button" title="Metronome: Tap once=flash, twice=click, thrice=off. Hold to set BPM" style="padding:6px 12px;border-radius:4px;border:2px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:16px;font-weight:bold;margin-left:8px">‚ô©</button>
            </div>
            <div id="liveLyricsTitle" style="font-weight:bold;font-size:20px;margin-bottom:8px"></div>
            <pre id="liveLyricsBody" style="white-space:pre-wrap;font-family:inherit"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help / Tutorial Modal -->
  <div class="modal" id="helpModal" style="display:none">
    <div class="sheet" style="max-width:760px;height:auto">
      <h2>Jiffykit Setlist ‚Äì Quick Tutorial</h2>
      <ol style="font-size:14px;line-height:1.6;margin-left:20px">
        <li><strong>Song Database</strong>: Add every tune you might play. Mark moods & cover status so the generator can balance energy and originals/covers for you.</li>
        <li><strong>Lyrics / Chords</strong>: Paste lyrics or chords into the song, or hit ‚ÄúSearch Lyrics / Chords‚Äù to open a web search and copy from the site you trust.</li>
        <li><strong>Setlist</strong>: Enter gig details (band, venue, date, notes) and click Generate, or drag songs in manually from the Song Pool. Reorder with the handle (‚ãÆ‚ãÆ) and type notes inline ‚Äì notes appear under the title in the print-friendly sheet.</li>
        <li><strong>Breaks & Events</strong>: Drag Break, Encore, and custom event chips into the set to mark intermissions, announcements, raffles and more. The preview always shows your real running order and total time.</li>
        <li><strong>Live Mode</strong>: On show night, switch to the Live tab. Tap a song to see big, high-contrast lyrics. On phone/tablet, tap again for fullscreen; the Play button gently auto-scrolls based on song length so you reach the bottom of the page about 75% through the song.</li>
        <li><strong>Tech / Stage</strong>: Use the Toolbox icons to build a clean, black-and-white stage plot. Drag to move, double‚Äëclick labels to rename, assign channels in the legend, and use Clear Stage (at the bottom of the toolbox) only when you really want to start over.</li>
        <li><strong>Lighting / FX</strong>: Switch to ‚ÄúLighting / FX‚Äù from Tech / Stage to type per‚Äësong notes (e.g., ‚ÄúBlue wash, delay on chorus‚Äù). These print alongside the stage plot in the tech rider.</li>
        <li><strong>Printing</strong>: Use the Print‚Ä¶ button at the top to choose Setlist, Stage Plot, and Tech Notes. Each prints separately so you can give the band, engineer and lighting tech exactly what they need.</li>
        <li><strong>Profiles & Sets</strong>: Save Profile (.BAND) to back up your whole song database and settings. Save .SET when you like a particular set order so you can reload it later.</li>
        <li><strong>Autosave & Safety</strong>: The app saves as you go, even while dragging things around. You can also duplicate stage items with Ctrl+D and step through recent stage changes with Ctrl+Z / Ctrl+Y.</li>
      </ol>
      <div style="margin-top:16px;font-size:14px;background:#f1f5f9;padding:12px;border-radius:8px">
        The app is free. If it saves you time and you‚Äôd like to support development, you can donate:
        <p style="margin:10px 0"><a href="https://paypal.me/jamesmulvale" target="_blank" rel="noopener" class="btn" style="text-decoration:none">Donate via PayPal</a></p>
        Thank you and have a great show!
      </div>
      <div style="margin-top:18px;display:flex;gap:10px;justify-content:flex-end">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <!-- Floating Song Pool Flyout -->
  <div class="pool-flyout" id="songPoolFlyout">
    <div class="pool-head">
      <strong>Song Pool</strong>
      <button class="btn secondary" id="closePool" type="button">Close</button>
    </div>
    <div class="pool-body">
      <div class="pool-sec">
        <h4>Originals</h4>
        <div id="poolOriginals" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Covers</h4>
        <div id="poolCovers" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Breaks</h4>
        <div id="poolBreaks" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
    </div>
  </div>

  <!-- Global Print FAB removed; using top-row Print button for consistency -->

  <!-- Stage Fullscreen Modal -->
  <div class="stage-modal" id="stageModal">
    <div class="stage-editor">
      <div class="stage-pane">
  <h3>Toolbox <span style="font-weight:400;font-size:12px;color:#6b7280">(Drag and drop items)</span></h3>
        <div class="stage-tools" id="stageToolsFull"></div>
        <div style="margin-top:10px">
          <h4>Custom</h4>
          <button class="tool" id="uploadImageBtn">Upload Image</button>
          <input type="file" id="uploadImageInput" accept="image/*" style="display:none" />
          <button class="tool" id="newIconBtn">New Icon</button>
          <div id="customImages" style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px"></div>
        </div>
        <div style="margin-top:14px;display:flex;justify-content:flex-end;align-items:center">
          <button class="btn danger" id="clearStage" type="button" title="Clear stage plot (keeps background & title)">Clear Stage</button>
        </div>
      </div>
      <div class="stage-canvas">
        <div style="position:absolute;top:8px;right:8px;z-index:50;display:flex;gap:6px;align-items:center;pointer-events:none">
          <button class="btn" id="stagePresetBtn" style="padding:4px 10px;font-size:12px;background:#065f46;color:#f9fafb;border:1px solid #064e3b;pointer-events:auto">PRESET</button>
        </div>
        <div class="stage-inspector" id="stageInspector" style="margin-bottom:8px">
          <span class="muted" id="selLabel">Selected:</span>
          <input id="selName" placeholder="Label (double‚Äëclick item to rename)" style="min-width:220px" />
          <label class="muted" for="selSize">Size</label>
          <input id="selSize" type="range" min="0.3" max="5" step="0.05" value="1" style="width:160px" />
          
          <label class="muted" for="selShowLabel" style="display:flex;align-items:center;gap:4px"><input type="checkbox" id="selShowLabel" /> Show Label</label>
          <span id="labelSizeControls" style="display:none;align-items:center;gap:6px">
            <label class="muted" for="selLabelSize">Label Size</label>
            <input id="selLabelSize" type="range" min="8" max="32" step="1" value="16" style="width:120px" />
          </span>
          <button class="btn danger" id="delSel">Delete</button>
          <button class="btn" id="dupSel" type="button">Duplicate</button>
        </div>
        <div id="stageFrame" style="position:relative;display:inline-block;">
          <svg id="stageSvgFull" class="bw" viewBox="0 0 1500 900" xmlns="http://www.w3.org/2000/svg" style="display:block;">
            <rect class="stage-bg" x="1" y="1" width="1498" height="898"/>
            <text x="750" y="50" text-anchor="middle" font-size="26" font-weight="bold" id="stageTitleFull">Band ‚Ä¢ Date</text>
          </svg>
          <div class="stage-handle tl" data-handle="tl"></div>
          <div class="stage-handle tr" data-handle="tr"></div>
          <div class="stage-handle bl" data-handle="bl"></div>
          <div class="stage-handle br" data-handle="br"></div>
        </div>
        <div id="stageLegend" class="stage-legend"></div>
        <div class="stage-actions">
            <button class="btn secondary" id="closeStage">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- New Icon Drawing Modal -->
  <div class="modal" id="iconMakerModal" style="display:none">
    <div class="sheet" style="max-width:480px">
      <h3 style="margin-top:0">Create New Icon</h3>
      <canvas id="iconCanvas" width="400" height="400" style="border:1px solid #d1d5db;background:transparent;display:block;width:400px;height:400px;touch-action:none"></canvas>
      <div style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <label style="font-size:12px;color:#64748b">Line Width
          <input id="iconLineWidth" type="range" min="2" max="6" step="1" value="4" style="width:160px">
        </label>
        <button class="btn" id="iconClear">Clear</button>
        <button class="btn" id="iconSave">Save Icon</button>
        <button class="btn secondary" id="iconCancel">Cancel</button>
      </div>
      <div style="margin-top:6px;font-size:11px;color:#64748b">Draw with mouse or touch. Rough shapes will auto-normalize into lines, rectangles, or ellipses where recognized.</div>
    </div>
  </div>

  <!-- Lighting Notes Fullscreen Modal -->
  <!-- Stage Preset Modal -->
  <div class="modal" id="presetModal" style="display:none">
    <div style="background:#fff;border-radius:8px;padding:24px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;box-shadow:0 4px 12px rgba(0,0,0,0.15)">
      <h3 style="margin:0 0 16px 0;font-size:20px">Stage Plot Presets</h3>
      <div style="display:flex;gap:8px;margin-bottom:16px">
        <button class="btn" id="addPresetBtn" style="background:#065f46;color:#f9fafb;border:1px solid #064e3b;flex:1">üíæ Save Current</button>
      </div>
      <div id="presetList" style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px"></div>
      <div style="display:flex;justify-content:flex-end;gap:8px">
        <button class="btn secondary" id="closePreset">Close</button>
      </div>
    </div>
  </div>

  <div class="stage-modal" id="notesModal">
    <div class="stage-editor" style="grid-template-columns:1fr">
      <div class="stage-pane" style="border-right:none">
        <h3>Lighting Notes</h3>
        <table class="tech-table">
          <thead><tr><th>#</th><th>Song</th><th>Notes (e.g., Blue fade to orange, Delays in chorus)</th></tr></thead>
          <tbody id="techBodyFull"></tbody>
        </table>
        <div class="gear-wrap">
          <label>Gear list (printed under stage)</label>
          <textarea id="gear" placeholder="e.g., DI x3 ‚Ä¢ Guitar amp x2 ‚Ä¢ Vox x3 ‚Ä¢ Wireless x2"></textarea>
        </div>
        <div class="stage-actions">
          <button class="btn secondary" id="closeNotes">Close</button>
          <button class="btn" id="printTech">Print Tech Rider + Stage</button>
          <button class="btn" id="printTechOnly">Print Tech Only</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Print Modal -->
  <div class="modal" id="modal">
    <div class="sheet" id="sheet">
      <div class="hdr" id="hdr"></div>
      <div class="songs" id="songs"></div>
    </div>
    <div class="tools">
      <span class="paper">Paper:</span>
      <select id="paperSel">
        <option value="letter">Letter 8.5√ó11</option>
        <option value="a4">A4 210√ó297mm</option>
      </select>
  <button class="btn" id="printSheet">Print</button>
      <button class="btn secondary" id="closeModal">Close</button>
    </div>
  </div>

  <!-- Tech/Stage Print Modal -->
  <div class="modal" id="modalTech">
    <div class="sheet" id="sheetTech">
      <div class="hdr" id="hdrTech"></div>
      <div id="techPrint"></div>
      <div id="stagePrint"></div>
    </div>
    <div class="tools">
      <button class="btn" id="printTechModal">Print</button>
      <button class="btn secondary" id="closeTech">Close</button>
    </div>
  </div>

  <!-- Print Options Modal -->
  <div class="modal" id="printChooser">
    <div class="sheet" style="width:560px;height:auto;max-width:95vw">
      <div class="hdr"><div class="band">Print Options</div></div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <label class="chip"><input type="checkbox" id="pSet"> Setlist</label>
        <label class="chip"><input type="checkbox" id="pStage"> Stage Plot</label>
        <label class="chip"><input type="checkbox" id="pTech"> Lighting / Tech Notes</label>
        <div class="muted">Select one or more. Each prints separately.</div>
      </div>
      <div class="tools" style="justify-content:flex-end">
        <button class="btn" id="doPrint">Print Selected</button>
        <button class="btn secondary" id="closePrintChooser">Close</button>
      </div>
    </div>
  </div>

  <!-- Hidden storage for Stage SVG (used for save/print) -->
  <div id="stageStore" style="display:none">
    <svg id="stageSvg" class="bw" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
      <rect class="stage-bg" x="1" y="1" width="998" height="598"/>
      <text x="500" y="36" text-anchor="middle" font-size="22" font-weight="bold" id="stageTitle">Band ‚Ä¢ Date</text>
    </svg>
  </div>

  <!-- Live fullscreen lyrics overlay (phone / tablet / desktop) -->
  <div id="liveLyricsOverlay" class="live-lyrics-overlay">
    <div class="live-lyrics-header">
      <button id="liveLyricsPlay" class="live-lyrics-play" type="button">Play</button>
      <button id="liveLyricsStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
      <div id="liveLyricsOverlayTitle" class="live-lyrics-title"></div>
      <div style="display:flex;align-items:center;gap:6px;margin-right:10px">
        <span style="font-size:11px;color:#9ca3af">Zoom</span>
        <input id="liveLyricsZoom" type="range" min="16" max="96" value="20" step="1" style="width:180px">
      </div>
      <div style="display:flex;align-items:center;gap:4px;margin-right:10px">
        <span style="font-size:11px;color:#9ca3af">Speed</span>
        <button id="liveSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
        <span id="liveSpeedDisplay" style="font-size:14px;color:#e5e7eb;font-weight:bold;min-width:12px;text-align:center">5</span>
        <button id="liveSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">+</button>
      </div>
      <button id="metronomeBtnOverlay" type="button" title="Metronome: Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM." style="padding:6px 12px;border-radius:4px;border:2px solid #444;background:#1f2937;color:#fbbf24;cursor:pointer;font-size:18px;font-weight:bold;margin-right:12px">‚ô©</button>
      <button id="liveLyricsExit" class="live-lyrics-exit" type="button">Back to Setlist</button>
    </div>
    <div id="liveLyricsOverlayMain" class="live-lyrics-main">
      <pre id="liveLyricsOverlayBody" class="live-lyrics-body"></pre>
    </div>
  </div>

  <script>
    // Data
  const db = []; // {id,title,artist,length,key,isCover,isUpbeat,isHappy,isMellow,isEnergetic,isSad,customMoods?:string[]}
  let setlist = []; // array of {type:'song'|'break'|'encore', ...}
  let gig = { band:'', date:'', venue:'', address:'', contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[], hiddenIcons:[], liveDark:false };
  let gearSummary = '';
  // Tech notes persist independently of the current set (keyed by song id)
  let techNotes = {};
  // Stage undo/redo history (stores serialized SVG for stageSvgFull)
  const stageHistory=[];
  let stageHistoryIndex=-1;
  // Live audio playback handles
  let _liveAudioEl=null; // <audio> reused element
  let _liveAudioWin=null; // external window (YouTube/Spotify)
  let _liveLastExternalUrl=null; // last non-stream URL opened (avoid duplicate popups)
  const armedAudio = {}; // session-only object URLs keyed by song id
  // App-wide undo/redo history (setlist + stage); max 25
  const appHistory=[]; let appHistoryIndex=-1; let _restoring=false;
  // Basic platform helpers (do NOT change desktop behavior)
  function isIOS(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return /ipad|iphone|ipod/.test(ua) || (/macintosh/.test(ua) && 'ontouchend' in document);
  }
  function isAndroid(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('android');
  }
  function isMobileLike(){ return isIOS() || isAndroid(); }
  function getStageHTML(){
    const el=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
    return el ? el.outerHTML : '';
  }
  function deepCopySetlist(src){ try{ return JSON.parse(JSON.stringify(src||[])); }catch(_){ return []; } }
  function makeSnapshot(){ return { setlist: deepCopySetlist(setlist), stage: getStageHTML() }; }
  function snapshotSignature(s){ return JSON.stringify({s:s.setlist, h:(s.stage||'').length}); }
  function pushAppHistory(reason){ if(_restoring) return; const snap=makeSnapshot(); const sig=snapshotSignature(snap); const cur= appHistoryIndex>=0? appHistory[appHistoryIndex] : null; if(cur && cur.sig===sig) return; appHistory.splice(appHistoryIndex+1); appHistory.push({ ...snap, sig }); if(appHistory.length>25){ appHistory.shift(); } appHistoryIndex=appHistory.length-1; }
  function applySnapshot(snap){ if(!snap) return; _restoring=true; try{
      // restore setlist
      setlist = deepCopySetlist(snap.setlist||[]);
      try{ renderSet(); }catch(_){ }
      // restore stage
      const html = snap.stage||'';
      if(html){
        const modal=document.getElementById('stageModal');
        if(modal && modal.classList.contains('open')){
          const full=document.getElementById('stageSvgFull'); if(full){ const parent=full.parentNode; const tmp=document.createElement('div'); tmp.innerHTML=html; const fresh=tmp.querySelector('svg'); if(fresh && parent){ parent.replaceChild(fresh, full); fresh.id='stageSvgFull'; Array.from(fresh.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag); ensureStageMarkers(fresh); refreshCables(fresh); bindSelection(fresh); } }
        } else {
          const store=document.getElementById('stageStore'); if(store){ store.innerHTML=html; const svg=store.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); refreshCables(svg); } }
        }
      }
      saveAll();
    }finally{ _restoring=false; }
  }
  function undoApp(){ if(appHistoryIndex>0){ appHistoryIndex--; applySnapshot(appHistory[appHistoryIndex]); } }
  function redoApp(){ if(appHistoryIndex>=0 && appHistoryIndex<appHistory.length-1){ appHistoryIndex++; applySnapshot(appHistory[appHistoryIndex]); } }
  // Global undo/redo keybindings (Ctrl+Z / Ctrl+Y, Shift+Ctrl+Z)
  document.addEventListener('keydown', e=>{
    const key = e.key || '';
    const mod = e.ctrlKey || e.metaKey;
    const isUndo = mod && !e.shiftKey && (key==='z' || key==='Z');
    const isRedo = (mod && (key==='y' || key==='Y')) || (mod && e.shiftKey && (key==='z' || key==='Z'));
    if(!(isUndo || isRedo)) return;
    if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(isUndo) undoApp(); else redoApp();
  });
  const DEFAULT_MOODS = ['upbeat','happy','energetic','mellow','sad'];
  const moodLabel = (k)=> k.charAt(0).toUpperCase()+k.slice(1);
  const getAllMoods = ()=> [...DEFAULT_MOODS, ...((gig.customMoods||[]).filter(x=>!DEFAULT_MOODS.includes(x)))].slice(0,12);
  function renderAddMoodsUI(){
    const host=document.getElementById('addCustomMoods'); if(!host) return;
    host.innerHTML='';
    (gig.customMoods||[]).forEach(k=>{
      const lab=document.createElement('label'); lab.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id='cm-'+k;
      lab.appendChild(cb); lab.appendChild(document.createTextNode(' '+moodLabel(k)));
      host.appendChild(lab);
    });
  }

  // Storage
  const STORE_KEY='fastfast-setlist-v1';
  function saveAll(){
    try{
      // Prefer full editor SVG if open; fallback to stored small one
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      let stageHTML='';
      if(stageEl){
        const clone=stageEl.cloneNode(true);
        clone.querySelectorAll('g[data-draggable].selected').forEach(n=> n.classList.remove('selected'));
        stageHTML=clone.outerHTML;
        // Keep compact stored svg synchronized when full editor present
        const full=document.getElementById('stageSvgFull');
        const small=document.getElementById('stageSvg');
        if(full && small){
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
          Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
        }
      }
      // Strip any embedded audioData before persisting to storage
      const dbOut = db.map(s=>{ const { audioData, ...rest } = s || {}; return rest; });
      const payload={db:dbOut,setlist,gig,gearSummary,techNotes,stage:stageHTML};
      localStorage.setItem(STORE_KEY, JSON.stringify(payload));
    }catch(e){ console.error('saveAll failed', e); }
  }

  function findSongById(id){ return db.find(x=> x.id===id); }
  function findSongByTitle(title){ return db.find(x=> (x.title||'').trim()===String(title||'').trim()); }
  function ensureLiveAudioEl(){ if(!_liveAudioEl){ _liveAudioEl=new Audio(); _liveAudioEl.preload='auto'; _liveAudioEl.crossOrigin='anonymous'; } return _liveAudioEl; }
  function stopSongAudio(){ try{ if(_liveAudioEl){ _liveAudioEl.pause(); _liveAudioEl.currentTime=0; } }catch(_){ }
    try{ if(_liveAudioWin && !(_liveAudioWin.closed)){ _liveAudioWin.close(); } }catch(_){ }
    _liveAudioWin=null;
  }
  function preloadSongAudioFor(setItem){
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return;
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    if(armed){ const a=ensureLiveAudioEl(); if(a.src!==armed){ a.src=armed; } try{ a.load(); }catch(_){ } return; }
    if(url){ const lower=url.toLowerCase(); const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream'); if(isStream){ const a=ensureLiveAudioEl(); if(a.src!==url){ a.src=url; } try{ a.load(); }catch(_){ } }
    }
  }
  function playSongAudioFor(setItem){
    // Prefer looking up canonical song in db to access latest audio fields
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return; // nothing to play
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    // Armed local file or URL (session)
    if(armed){
      // Always stop any other playback before starting
      stopSongAudio();
      // Check if armed value is a URL string (http/https) or blob URL
      const armedValue = armedAudio[song.id];
      const isExternalUrl = typeof armedValue==='string' && (armedValue.startsWith('http://') || armedValue.startsWith('https://'));
      if(isExternalUrl){
        // Armed URL - treat as external link
        const lower=armedValue.toLowerCase();
        const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
        if(isStream){
          const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
        } else {
          // External provider (YouTube/Spotify/etc.)
          if(_liveAudioWin && !_liveAudioWin.closed){
            if(_liveLastExternalUrl===armedValue){ return; }
            try{ _liveAudioWin.location.href=armedValue; _liveLastExternalUrl=armedValue; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
          }
          try{ _liveAudioWin = window.open(armedValue,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=armedValue; }catch(_){ _liveAudioWin=null; }
        }
      } else {
        // Armed local file (blob URL)
        const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
      }
      return;
    }
    if(url){
      const lower=url.toLowerCase();
      const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      if(isStream){
        // Stop any previous audio before starting this stream
        stopSongAudio();
        const a=ensureLiveAudioEl(); a.src=url; a.play().catch(()=>{}); return;
      }
      // External provider (YouTube/Spotify/etc.): reuse single popup and avoid re-opening if same URL
      if(_liveAudioWin && !_liveAudioWin.closed){
        if(_liveLastExternalUrl===url){ return; }
        try{ _liveAudioWin.location.href=url; _liveLastExternalUrl=url; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
      }
      try{ _liveAudioWin = window.open(url,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=url; }catch(_){ _liveAudioWin=null; }
      return;
    }
  }

  // Capture a snapshot of the current full stage SVG for undo/redo
  function snapshotStage(){
    const full=document.getElementById('stageSvgFull');
    if(!full) return;
    const html=full.outerHTML;
    if(stageHistoryIndex>=0 && stageHistory[stageHistoryIndex]===html) return;
    stageHistory.splice(stageHistoryIndex+1);
    stageHistory.push(html);
    stageHistoryIndex=stageHistory.length-1;
    try{ pushAppHistory('stage'); }catch(_){ }
  }
  // Throttled save for high-frequency drag updates
  let _savePending=false; let _lastSaveTs=0; const SAVE_MIN_INTERVAL=250; // ms
  function queueSave(){
    const now=Date.now();
    if(!_savePending && (now-_lastSaveTs)>=SAVE_MIN_INTERVAL){
      _savePending=true;
      requestAnimationFrame(()=>{
        _savePending=false; _lastSaveTs=Date.now(); saveAll();
      });
    }
  }
  // Persist on navigation away
  window.addEventListener('beforeunload', ()=>{ try{ for(const k in armedAudio){ try{ URL.revokeObjectURL(armedAudio[k]); }catch(_){} } }catch(_){} saveAll(); });
    
    // Add custom column button
    const addCustomColumnBtn=document.getElementById('addCustomColumn');
    if(addCustomColumnBtn){ addCustomColumnBtn.addEventListener('click', ()=>{
      const name = prompt('Custom column name (e.g., Genre, Language, Tempo):');
      if(!name || name.trim().length === 0) return;
      const key = name.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if(!gig.customColumns) gig.customColumns = [];
      if(gig.customColumns.find(c => c.key === key)){
        alert('Column already exists.');
        return;
      }
      // Ask if they want to push this field to setlist
      const pushToSet = confirm('Push this field data to setlist display?\n\nClick OK to show this column in the printed setlist alongside song titles.\nClick Cancel to keep it database-only.');
      gig.customColumns.push({key, name: name.trim(), pushToSetlist: pushToSet});
      // Add to column order
      if(!gig.dbColumns.order) gig.dbColumns.order = ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      // Insert before actions
      const actionsIdx = gig.dbColumns.order.indexOf('actions');
      if(actionsIdx > -1){
        gig.dbColumns.order.splice(actionsIdx, 0, key);
      } else {
        gig.dbColumns.order.push(key);
      }
      saveAll();
      renderDB();
      buildSheet('sheetInline');
    }); }
    
    // Clear database
    const clearDBBtn=document.getElementById('clearDB');
    const clearDBLock=document.getElementById('clearDBLock');
    if(clearDBBtn){ clearDBBtn.addEventListener('click',()=>{
      if(!db.length) return;
      if(clearDBLock && !clearDBLock.checked){ alert('Please check the unlock checkbox first to enable clearing the database.'); return; }
      // Offer to save a .BAND backup first
      try{
        if(confirm('Download a .BAND backup before clearing the database? Click OK to Save, or Cancel to skip.')){
          var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
          const stage = stageEl ? stageEl.outerHTML : '';
          const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
          const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
          const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
        }
      }catch(_){ /* ignore */ }
      if(!confirm('Clear entire song database now? This cannot be undone (unless you reload a .BAND profile).')) return;
      db.splice(0,db.length); renderDB(); saveAll();
    }); }
    // Clear setlist
    const clearSetBtn=document.getElementById('clearSet');
    if(clearSetBtn){ clearSetBtn.addEventListener('click',()=>{ if(!setlist.length) return; if(!confirm('Clear current setlist?')) return; setlist=[]; renderSet(); saveAll(); }); }
    // Help modal open/close and Gear panel
    const helpBtn=document.getElementById('helpBtn'); const helpModal=document.getElementById('helpModal'); const closeHelp=document.getElementById('closeHelp');
    if(helpBtn && helpModal){ helpBtn.addEventListener('click',()=>{ helpModal.style.display='flex'; helpModal.classList.add('open'); }); }
    if(closeHelp){ closeHelp.addEventListener('click',()=>{ helpModal.classList.remove('open'); helpModal.style.display='none'; }); }
    if(helpModal){
      helpModal.addEventListener('click',e=>{
        if(e.target===helpModal){ helpModal.classList.remove('open'); helpModal.style.display='none'; }
      });
    }
    const gearBtn=document.getElementById('gearBtn');
    const gearPanel=document.getElementById('gearPanel');
    if(gearBtn && gearPanel){
      gearBtn.addEventListener('click',()=>{
        const show=gearPanel.style.display==='none' || !gearPanel.style.display;
        gearPanel.style.display= show ? 'flex' : 'none';
      });
    }

    // Lyrics helpers: search popup (user chooses source)
    (function setupLyricsHelpers(){
      const searchBtn=document.getElementById('searchLyricsBtn');
      if(searchBtn){
        searchBtn.addEventListener('click',()=>{
          const titleEl=document.getElementById('t');
          const artistEl=document.getElementById('a');
          const title=(titleEl && titleEl.value.trim())||'';
          const artist=(artistEl && artistEl.value.trim())||'';
          if(!title){ alert('Enter a song title first to build a search.'); return; }
          const q=encodeURIComponent([title, artist, 'lyrics chords'].filter(Boolean).join(' '));
          const url='https://www.google.com/search?q='+q;
          window.open(url,'lyricsSearch','noopener');
        });
      }
    })();
  function loadAll(){
    try{
      const raw=localStorage.getItem(STORE_KEY); if(!raw) return;
    const {db:dbIn,setlist:setIn,gig:gigIn,gearSummary:gearIn,techNotes:tnIn,stage}=JSON.parse(raw);
      if(Array.isArray(dbIn)) db.push(...dbIn);
      if(Array.isArray(setIn)) setlist=setIn;
      if(gigIn) gig=Object.assign(gig,gigIn);
      if(gearIn) { gearSummary = gearIn; }
  if(tnIn && typeof tnIn==='object') { techNotes = tnIn; }
  // header flag hydration
  if(!gig.headerFlags) gig.headerFlags={band:true,venue:true,sub:true,notes:true};
  ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
      // UI hydrate
      if(gig.band) document.getElementById('gBand').value=gig.band;
      if(gig.date) document.getElementById('gDate').value=gig.date;
      if(gig.venue) document.getElementById('gVenue').value=gig.venue;
      if(gig.address) document.getElementById('gAddr').value=gig.address;
      if(gig.contact) document.getElementById('gContact').value=gig.contact;
      if(gig.notes) document.getElementById('gNotes').value=gig.notes;
      const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value = gearSummary || '';
      renderDB(); renderSet();
      if(stage){ const container=document.getElementById('stageStore'); container.innerHTML=stage; const svg=container.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); refreshCables(svg); }
      }
    }catch(e){/* ignore */}
  }

    // Helpers
    const $ = s=>document.querySelector(s);
    const el = (t,cls,txt)=>{const n=document.createElement(t); if(cls) n.className=cls; if(txt!=null) n.textContent=txt; return n;}
    const shuffle = a=>{const r=[...a]; for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[r[i],r[j]]=[r[j],r[i]];} return r}

    // Title shortening: trims, collapses, removes parentheticals, limits words, ensures width via characters
    function shorten(title, maxChars=48){
      if(!title) return '';
      // Keep original wording; only trim whitespace and optional parentheticals for clutter
      let t=title.replace(/\s+/g,' ').trim();
      t=t.replace(/\s*\([^\)]*\)\s*/g,' '); // remove (feat), (live), etc
      if(t.length>maxChars) t=t.slice(0,maxChars-1)+'‚Ä¶';
      return t;
    }

    function minutes(sum){ return `${sum.toFixed(1)}m`; }

    // Tabs
    document.querySelectorAll('.tab').forEach(btn=>btn.addEventListener('click',e=>{
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      ['db','set','adv','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      document.getElementById(btn.dataset.tab).style.display='block';
      // Only Tech/Stage tab should show stage or lighting sections
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      document.body.classList.toggle('live-mode', btn.dataset.tab==='live');
      if(btn.dataset.tab==='adv'){
        if(stageModal && !stageModal.classList.contains('open') && notesModal && !notesModal.classList.contains('open')){
          // Default to Stage Plot view when entering Tech/Stage
          toggleStageAndNotes();
        }
      } else if(btn.dataset.tab==='live'){
        // Closing any stage/notes modals for distraction-free live view
        if(stageModal && stageModal.classList.contains('open')){ try{ closeStageModal(); }catch(_){ stageModal.classList.remove('open'); } }
        if(notesModal && notesModal.classList.contains('open')){ notesModal.classList.remove('open'); }
        // Refresh live view when switching to Live tab
        try{ renderLive(); }catch(_){ }
        // Notify listeners we entered live to trigger auto-arm prompt
        try{ document.dispatchEvent(new Event('live-enter')); }catch(_){ }
      } else {
        // Leaving Tech/Stage: if stage editor open, perform full sync via closeStageModal (ensures compact svg updated)
        if(stageModal && stageModal.classList.contains('open')){
          closeStageModal();
        } else if(stageModal){
          saveAll(); stageModal.classList.remove('open');
        }
        if(notesModal) notesModal.classList.remove('open');
      }
    }));

    // Prefill date today
    (function prefill(){
      const d=$('#gDate'); if(d && !d.value){ const t=new Date(); const iso=new Date(t.getTime()-t.getTimezoneOffset()*60000).toISOString().slice(0,10); d.value=iso; }
      loadAll();
      // Build initial inline preview
      try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){ }
      try{ renderAddMoodsUI(); }catch(_){ }
      try{ renderLive(); }catch(_){ }
      // Apply saved live theme
      if(gig && gig.liveDark){ document.body.classList.add('live-dark'); }
    })();

    // Add new song inline at top of database
    function addNewSongRow(){
      const newSong = {
        id: Date.now(),
        title: '',
        artist: 'Original',
        length: 3.5,
        key: '',
        capo: 0,
        bpm: 0,
        lyrics: '',
        audienceRating: 2,
        usageCount: 0,
        isCover: false,
        isUpbeat: false,
        isHappy: false,
        isMellow: false,
        isEnergetic: false,
        isSad: false,
        customMoods: []
      };
      db.unshift(newSong); // Add to start of array
      renderDB();
      saveAll();
      // Focus the title field of the new row
      setTimeout(() => {
        const list = document.getElementById('dbList');
        if(list) {
          const firstRow = list.querySelector('.db-row');
          if(firstRow) {
            const titleInput = firstRow.querySelector('input[placeholder="Title"]');
            if(titleInput) titleInput.focus();
          }
        }
      }, 50);
    }

    // DB Column configuration - persisted widths and order
    if(!gig.dbColumns){
      gig.dbColumns={
        order:['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'],
        widths:{add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120}
      };
    }

    function renderDB(){
      const list=$('#dbList'); list.innerHTML='';
      if(!db.length){ list.textContent='No songs yet.'; return; }
      
      // Column headers with resizing and reordering
      const hdrRow=document.createElement('div'); hdrRow.style.cssText='display:flex;gap:4px;align-items:center;padding:4px;background:#f3f4f6;font-weight:600;font-size:11px;border-bottom:2px solid #d1d5db;position:relative';
      
      const colOrder = gig.dbColumns.order || ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      const colWidths = gig.dbColumns.widths || {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
      const hiddenCols = gig.dbColumns.hidden || [];
      if(!gig.customColumns) gig.customColumns = [];
      
      const colDefs = {
        add: {text:'', isButton:true, sortKey:null},
        cover: {text:'C', sortKey:'cover'},
        title: {text:'Title', sortKey:'alpha'},
        artist: {text:'Artist', sortKey:'band'},
        len: {text:'Len', sortKey:'length'},
        key: {text:'Key', sortKey:'key'},
        capo: {text:'Cp', sortKey:'capo'},
        bpm: {text:'BPM', sortKey:'bpm'},
        mood: {text:'‚ô´', sortKey:'mood'},
        lyrics: {text:'Lyrics / Preview', sortKey:null, flex:true},
        audio: {text:'Audio / URL', sortKey:null, flex:true},
        rating: {text:'Rate', sortKey:'rating'},
        actions: {text:'', sortKey:null}
      };
      // Add custom columns to definitions
      gig.customColumns.forEach(cc=>{
        colDefs[cc.key] = {text:cc.name, sortKey:null, isCustom:true};
        if(!colWidths[cc.key]) colWidths[cc.key] = 100;
      });
      
      colOrder.forEach((colKey,colIndex)=>{
        const def = colDefs[colKey];
        if(!def || hiddenCols.includes(colKey)) return;
        const width = colWidths[colKey] || 100;
        
        const hdr = document.createElement('div');
        hdr.dataset.colKey = colKey;
        hdr.style.cssText = `position:relative;flex-shrink:0;text-align:center;cursor:${def.sortKey?'pointer':'default'};user-select:none;${def.flex?`flex:1 1 auto;min-width:${width}px;max-width:${width+100}px`:`width:${width}px`}`;
        
        // Add button special case
        if(colKey==='add'){
          const addBtn=document.createElement('button'); 
          addBtn.textContent='+'; 
          addBtn.type='button'; 
          addBtn.title='Add new song'; 
          addBtn.style.cssText='width:24px;height:24px;border:2px solid #374151;border-radius:4px;background:#fff;color:#374151;font-size:18px;font-weight:bold;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0';
          addBtn.addEventListener('click', addNewSongRow);
          hdr.appendChild(addBtn);
        } else {
          hdr.textContent = def.text;
        }
        
        // Triple-click to restore default width
        let clickCount = 0;
        let clickTimer = null;
        hdr.addEventListener('click', (e)=>{
          if(e.target.style.cursor==='col-resize' || e.target.classList.contains('resizer')) return;
          clickCount++;
          if(clickTimer) clearTimeout(clickTimer);
          if(clickCount === 3){
            // Triple click - restore default width
            const defaultWidths = {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
            if(defaultWidths[colKey]){
              colWidths[colKey] = defaultWidths[colKey];
              saveAll();
              renderDB();
            }
            clickCount = 0;
          } else if(clickCount === 2 && def.sortKey){
            // Double-click to sort
            const sortSel = document.getElementById('dbSort');
            if(sortSel){ sortSel.value = def.sortKey; renderDB(); }
            clickCount = 0;
          } else {
            clickTimer = setTimeout(()=>{ clickCount = 0; }, 500);
          }
        });
        hdr.title = (def.sortKey ? 'Double-click to sort by ' + def.text + ', ' : '') + 'Triple-click to restore default width';
        
        // Column reorder by dragging header (long-hold for touch)
        if(!def.isButton){
          let dragTimer = null;
          let isDraggingCol = false;
          let startY = 0;
          let startX = 0;
          let currentY = 0;
          let hasDraggedUp = false;
          const startColDrag = (clientY, clientX)=>{
            if(dragTimer) return;
            startY = clientY;
            startX = clientX;
            currentY = clientY;
            hasDraggedUp = false;
            dragTimer = setTimeout(()=>{
              isDraggingCol = true;
              hdr.style.opacity = '0.5';
              hdr.style.cursor = 'move';
            }, 400);
          };
          const trackMove = (clientY, clientX)=>{
            if(!isDraggingCol && !dragTimer) return;
            currentY = clientY;
            const deltaY = startY - currentY; // positive = dragging up
            const deltaX = Math.abs(startX - clientX);
            // If dragged up 50px or more, mark for hide
            if(deltaY >= 50 && deltaX < 30){
              hasDraggedUp = true;
              hdr.style.opacity = '0.3';
              hdr.style.transform = 'translateY(-10px)';
            }
          };
          const endColDrag = ()=>{
            if(dragTimer){ clearTimeout(dragTimer); dragTimer=null; }
            hdr.style.transform = '';
            if(isDraggingCol){
              hdr.style.opacity = '';
              hdr.style.cursor = '';
              isDraggingCol = false;
            }
            // Hide column if dragged up 50px
            if(hasDraggedUp){
              if(!gig.dbColumns.hidden) gig.dbColumns.hidden = [];
              if(!gig.dbColumns.hidden.includes(colKey)){
                gig.dbColumns.hidden.push(colKey);
                saveAll();
                renderDB();
              }
            }
            startY = 0;
            startX = 0;
            currentY = 0;
            hasDraggedUp = false;
          };
          
          // Mouse drag tracking
          hdr.addEventListener('mousedown',(e)=>{
            if(e.target.style.cursor==='col-resize') return; // Don't interfere with resize
            startColDrag(e.clientY, e.clientX);
            const onMouseMove = (e2)=>{
              trackMove(e2.clientY, e2.clientX);
            };
            const onMouseUp = ()=>{
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              endColDrag();
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
          
          // Touch drag tracking
          hdr.addEventListener('touchstart',(e)=>{
            const touch = e.touches[0];
            if(touch) startColDrag(touch.clientY, touch.clientX);
            const onTouchMove = (e2)=>{
              const t = e2.touches[0];
              if(t) trackMove(t.clientY, t.clientX);
            };
            const onTouchEnd = ()=>{
              document.removeEventListener('touchmove', onTouchMove);
              document.removeEventListener('touchend', onTouchEnd);
              endColDrag();
            };
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd);
          });
          
          // Drag events for reordering columns
          hdr.setAttribute('draggable', true);
          hdr.addEventListener('dragstart',(e)=>{
            if(!isDraggingCol) return e.preventDefault();
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', colKey);
            hdr.style.opacity = '0.4';
          });
          hdr.addEventListener('dragend',(e)=>{
            hdr.style.opacity = '';
            isDraggingCol = false;
          });
          hdr.addEventListener('dragover',(e)=>{
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          });
          hdr.addEventListener('drop',(e)=>{
            e.preventDefault();
            const draggedKey = e.dataTransfer.getData('text/plain');
            if(!draggedKey || draggedKey===colKey) return;
            const fromIndex = colOrder.indexOf(draggedKey);
            const toIndex = colOrder.indexOf(colKey);
            if(fromIndex===-1 || toIndex===-1) return;
            // Reorder array
            colOrder.splice(fromIndex, 1);
            colOrder.splice(toIndex, 0, draggedKey);
            gig.dbColumns.order = colOrder;
            saveAll();
            renderDB();
          });
        }
        
        // Resizer handle (right edge)
        if(!def.isButton && colKey!=='actions'){
          const resizer = document.createElement('div');
          resizer.style.cssText='position:absolute;right:-6px;top:-8px;bottom:-8px;width:12px;cursor:col-resize;z-index:10;background:rgba(209,213,219,0.5);touch-action:none';resizer.title='Drag to resize';
          resizer.classList.add('resizer');
          
          // Mouse resize
          resizer.addEventListener('mousedown',(e)=>{
            e.stopPropagation();
            const startX = e.clientX;
            const startWidth = width;
            const onMove = (e2)=>{
              const delta = e2.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              saveAll();
              renderDB();
            };
            const onUp = ()=>{
              document.removeEventListener('mousemove', onMove);
              document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          });
          
          // Touch resize
          resizer.addEventListener('touchstart',(e)=>{
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            if(!touch) return;
            const startX = touch.clientX;
            const startWidth = width;
            let isResizing = true;
            const onMove = (e2)=>{
              e2.preventDefault();
              if(!isResizing) return;
              const t = e2.touches[0];
              if(!t) return;
              const delta = t.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              hdr.style.width = newWidth + 'px';
            };
            const onUp = ()=>{
              isResizing = false;
              document.removeEventListener('touchmove', onMove, {passive:false});
              document.removeEventListener('touchend', onUp);
              document.removeEventListener('touchcancel', onUp);
              saveAll();
              renderDB();
            };
            document.addEventListener('touchmove', onMove, {passive:false});
            document.addEventListener('touchend', onUp);
            document.addEventListener('touchcancel', onUp);
          });
          
          hdr.appendChild(resizer);
        }
        
        hdrRow.appendChild(hdr);
      });
      
      // Hidden Columns eye emoji button on header row
      if(hiddenCols.length > 0){
        const eyeHdr = document.createElement('div');
        eyeHdr.style.cssText = 'position:relative;flex-shrink:0;width:40px;text-align:center;cursor:pointer;user-select:none';
        const restoreBtn = document.createElement('button');
        restoreBtn.textContent = 'üëÄ';
        restoreBtn.type = 'button';
        restoreBtn.title = `${hiddenCols.length} hidden column${hiddenCols.length>1?'s':''}`;
        restoreBtn.style.cssText = 'padding:2px 4px;border:none;background:transparent;font-size:20px;cursor:pointer;position:relative';
        const popup = document.createElement('div');
        popup.style.cssText = 'display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:240px;top:100%;right:0;margin-top:2px';
        hiddenCols.forEach(colKey=>{
          const def = colDefs[colKey];
          if(!def) return;
          const rowDiv = document.createElement('div');
          rowDiv.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0';
          const showBtn = document.createElement('button');
          showBtn.textContent = `Show ${def.text || colKey}`;
          showBtn.type = 'button';
          showBtn.style.cssText = 'flex:1;padding:4px 8px;border:1px solid #d1d5db;border-radius:3px;background:#f9fafb;cursor:pointer;text-align:left;font-size:12px';
          showBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            const idx = hiddenCols.indexOf(colKey);
            if(idx > -1){
              hiddenCols.splice(idx, 1);
              gig.dbColumns.hidden = hiddenCols;
              saveAll();
              renderDB();
            }
          });
          // Only show delete checkbox for custom columns
          const isCustom = def.isCustom || (gig.customColumns && gig.customColumns.find(c => c.key === colKey));
          if(isCustom){
            const delChk = document.createElement('input');
            delChk.type = 'checkbox';
            delChk.title = 'Delete column permanently';
            delChk.style.cssText = 'width:16px;height:16px;cursor:pointer';
            const delLbl = document.createElement('label');
            delLbl.textContent = 'üóëÔ∏è';
            delLbl.title = 'Delete permanently';
            delLbl.style.cssText = 'cursor:pointer;font-size:14px';
            delChk.addEventListener('change', ()=>{
              if(delChk.checked && confirm(`Permanently delete custom column "${def.text || colKey}"? This will remove all data in this column from all songs.`)){
                // Remove from hidden columns
                const hiddenIdx = hiddenCols.indexOf(colKey);
                if(hiddenIdx > -1){
                  hiddenCols.splice(hiddenIdx, 1);
                  gig.dbColumns.hidden = hiddenCols;
                }
                // Remove from column order
                const orderIdx = gig.dbColumns.order.indexOf(colKey);
                if(orderIdx > -1){
                  gig.dbColumns.order.splice(orderIdx, 1);
                }
                // Remove from custom columns
                if(gig.customColumns){
                  const customIdx = gig.customColumns.findIndex(c => c.key === colKey);
                  if(customIdx > -1){
                    gig.customColumns.splice(customIdx, 1);
                  }
                }
                // Remove column width
                if(gig.dbColumns.widths && gig.dbColumns.widths[colKey]){
                  delete gig.dbColumns.widths[colKey];
                }
                // Remove data from all songs
                db.forEach(song => {
                  if(song.customFields && song.customFields[colKey]){
                    delete song.customFields[colKey];
                  }
                });
                saveAll();
                renderDB();
              } else {
                delChk.checked = false;
              }
            });
            rowDiv.append(showBtn, delChk, delLbl);
          } else {
            rowDiv.appendChild(showBtn);
          }
          popup.appendChild(rowDiv);
        });
        restoreBtn.addEventListener('mouseenter', ()=>{ popup.style.display = 'block'; });
        restoreBtn.addEventListener('mouseleave', ()=>{ popup.style.display = 'none'; });
        restoreBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); popup.style.display = popup.style.display==='block'?'none':'block'; });
        popup.addEventListener('click', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchstart', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchend', (e)=>{ e.stopPropagation(); });
        restoreBtn.appendChild(popup);
        eyeHdr.appendChild(restoreBtn);
        hdrRow.appendChild(eyeHdr);
      }
      
      list.appendChild(hdrRow);
      // Filters / sort
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const sortVal=(sSel&&sSel.value)||'alpha';
      const searchTerm=(searchInput&&searchInput.value)||'';
      const filterCovers=document.getElementById('filterCovers')?.checked;
      const filterOriginals=document.getElementById('filterOriginals')?.checked;
      const filterHasLyrics=document.getElementById('filterHasLyrics')?.checked;
      const filterKaraoke=document.getElementById('filterKaraoke')?.checked;
      const filterHasAudio=document.getElementById('filterHasAudio')?.checked;
      const filterHasURL=document.getElementById('filterHasURL')?.checked;
      const filterInSet=document.getElementById('filterInSet')?.checked;
      const filterUpbeat=document.getElementById('filterUpbeat')?.checked;
      const filterHappy=document.getElementById('filterHappy')?.checked;
      const filterEnergetic=document.getElementById('filterEnergetic')?.checked;
      const filterMellow=document.getElementById('filterMellow')?.checked;
      const filterSad=document.getElementById('filterSad')?.checked;
      const used=(arr)=>arr.filter(Boolean);
      const hasMood=(song, key)=>{
        if(DEFAULT_MOODS.includes(key)){
          return (key==='upbeat'&&song.isUpbeat) || (key==='happy'&&song.isHappy) || (key==='energetic'&&song.isEnergetic) || (key==='mellow'&&song.isMellow) || (key==='sad'&&song.isSad);
        }
        const cm = song.customMoods||[]; return cm.includes(key);
      };
      const songMood=(song)=>{
        if(song.isUpbeat) return 'upbeat'; if(song.isHappy) return 'happy'; if(song.isEnergetic) return 'energetic'; if(song.isMellow) return 'mellow'; if(song.isSad) return 'sad';
        const cm=(song.customMoods||[])[0]; return cm||'none';
      };
      const rankMap={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:99};
      getAllMoods().forEach((m,i)=>{ if(!(m in rankMap)) rankMap[m]=50+i; });
      let rows=db.slice();
      if(filterCovers) rows = rows.filter(s=> s.isCover);
      if(filterOriginals) rows = rows.filter(s=> !s.isCover);
      if(filterHasLyrics) rows = rows.filter(s=> (s.lyrics||'').trim().length>0);
      if(filterKaraoke) rows = rows.filter(s=> (s.lyrics||'').toLowerCase().includes('karaoke'));
      if(filterHasAudio) rows = rows.filter(s=> (s.audioFileName||'').length>0 || (armedAudio[s.id]));
      if(filterHasURL) rows = rows.filter(s=> (s.audioUrl||'').trim().length>0);
      if(filterInSet) rows = rows.filter(s=> setlist.some(x=>x.id===s.id));
      if(filterUpbeat) rows = rows.filter(s=> s.isUpbeat);
      if(filterHappy) rows = rows.filter(s=> s.isHappy);
      if(filterEnergetic) rows = rows.filter(s=> s.isEnergetic);
      if(filterMellow) rows = rows.filter(s=> s.isMellow);
      if(filterSad) rows = rows.filter(s=> s.isSad);
      if(searchTerm){
        try{
          const regex = new RegExp(searchTerm, 'i');
          rows = rows.filter(s=> regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||''));
        }catch(e){ rows = rows.filter(s=> (s.title||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.artist||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.composer||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.lyrics||'').toLowerCase().includes(searchTerm.toLowerCase())); }
      }
      const byAdded=(a,b)=> a.id - b.id;
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (rankMap[songMood(a)] - rankMap[songMood(b)]) || a.title.localeCompare(b.title);
      const byRating=(a,b)=> (b.audienceRating||0) - (a.audienceRating||0) || a.title.localeCompare(b.title);
      const byMostUsed=(a,b)=> (b.usageCount||0) - (a.usageCount||0) || a.title.localeCompare(b.title);
      const byLeastUsed=(a,b)=> (a.usageCount||0) - (b.usageCount||0) || a.title.localeCompare(b.title);
      const sorter = sortVal==='added'? byAdded : sortVal==='band'? byBand : sortVal==='mood'? byMood : sortVal==='rating'? byRating : sortVal==='mostUsed'? byMostUsed : sortVal==='leastUsed'? byLeastUsed : byAlpha;
      rows.sort(sorter);
      rows.forEach(s=>{
        const row=document.createElement('div'); row.className='db-row'; row.style.display='flex'; row.style.gap='4px'; row.style.alignItems='center'; row.style.padding='4px'; row.style.border='1px solid #e5e7eb'; row.style.borderRadius='4px'; row.style.margin='4px 0';
        
        // Cover checkbox
        const coverChk=document.createElement('input'); coverChk.type='checkbox'; coverChk.checked=!!s.isCover; coverChk.title='Cover song'; coverChk.style.cssText='width:18px;height:18px;margin:0;cursor:pointer';
        coverChk.addEventListener('change',()=>{ 
          s.isCover=!!coverChk.checked; 
          if(!s.isCover){ s.artist='Original'; artist.value=''; artist.disabled=true; artist.style.opacity='0.5'; } 
          else { artist.disabled=false; artist.style.opacity='1'; } 
          saveAll(); renderSongPool(); 
        });
        
        // Title (reduced width)
        const title=document.createElement('input'); title.value=s.title||''; title.placeholder='Title'; title.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px';
        title.addEventListener('change',()=>{ s.title=title.value.trim()||s.title; saveAll(); buildSheet('sheetInline'); renderSongPool(); });
        
        // Artist (reduced width)
        const artist=document.createElement('input'); artist.placeholder='Artist'; artist.value=(s.isCover? (s.artist||'') : ''); artist.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px;opacity:'+(s.isCover?'1':'0.5'); artist.disabled=!s.isCover;
        artist.addEventListener('change',()=>{ s.artist = coverChk.checked ? (artist.value.trim()||s.artist||'') : 'Original'; saveAll(); });
        
        // Length (5 chars width)
        const len=document.createElement('input'); len.type='number'; len.step='0.5'; len.min='0.5'; len.value=String(s.length||3.5); len.title='Length (min)'; len.style.cssText='width:58px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center;color:#0f172a';
        len.addEventListener('change',()=>{ const v=parseFloat(len.value); if(v>0) s.length=v; saveAll(); buildSheet('sheetInline'); });
        
        // Key (3 chars width)
        const key=document.createElement('input'); key.placeholder='Key'; key.value=s.key||''; key.style.cssText='width:35px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        key.addEventListener('change',()=>{ s.key=key.value.trim(); saveAll(); buildSheet('sheetInline'); });
        
        // Capo (2 chars width)
        const capo=document.createElement('input'); capo.type='number'; capo.min='0'; capo.max='24'; capo.value=String(Number.isInteger(s.capo)? s.capo : 0); capo.title='Capo'; capo.style.cssText='width:30px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        capo.addEventListener('change',()=>{ let v=parseInt(capo.value,10); if(!Number.isInteger(v) || v<0) v=0; if(v>24) v=24; s.capo=v; capo.value=String(v); saveAll(); buildSheet('sheetInline'); });
        
        // BPM
        const bpm=document.createElement('input'); bpm.type='number'; bpm.min='30'; bpm.max='300'; bpm.value=String(Number.isInteger(s.bpm) && s.bpm>0 ? s.bpm : ''); bpm.placeholder='BPM'; bpm.title='Beats per minute'; bpm.style.cssText='width:40px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        bpm.addEventListener('change',()=>{ let v=parseInt(bpm.value,10); if(!Number.isInteger(v) || v<30) v=0; if(v>300) v=300; s.bpm=v||0; bpm.value=v>0?String(v):''; saveAll(); buildSheet('sheetInline'); });
        
        // Custom columns rendering
        const customColInputs = {};
        gig.customColumns.forEach(cc=>{
          const custInput = document.createElement('input');
          custInput.placeholder = cc.name;
          if(!s.customFields) s.customFields = {};
          custInput.value = s.customFields[cc.key] || '';
          custInput.style.cssText = `width:${colWidths[cc.key]||100}px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px`;
          custInput.addEventListener('change', ()=>{
            if(!s.customFields) s.customFields = {};
            s.customFields[cc.key] = custInput.value.trim();
            saveAll();
            buildSheet('sheetInline');
          });
          customColInputs[cc.key] = custInput;
        });
        
        // Mood submenu (hoverable)
        const moodBtn=document.createElement('button'); moodBtn.textContent='‚ô´'; moodBtn.type='button'; moodBtn.title='Moods'; moodBtn.style.cssText='padding:2px 6px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;position:relative;font-size:14px;width:28px;height:24px';
        const moodMenu=document.createElement('div'); moodMenu.style.cssText='display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:140px;top:100%;left:0;margin-top:2px;text-align:left';
        const moodChecks=['upbeat','happy','energetic','mellow','sad'].map(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=s['is'+m.charAt(0).toUpperCase()+m.slice(1)]; chk.addEventListener('change',()=>{ s['is'+m.charAt(0).toUpperCase()+m.slice(1)]=chk.checked; saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); return lbl; });
        moodChecks.forEach(c=>moodMenu.appendChild(c));
        // Add custom moods
        (gig.customMoods||[]).forEach(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=(s.customMoods||[]).includes(m); chk.addEventListener('change',()=>{ if(!s.customMoods) s.customMoods=[]; const idx=s.customMoods.indexOf(m); if(chk.checked && idx===-1){ s.customMoods.push(m); } else if(!chk.checked && idx>-1){ s.customMoods.splice(idx,1); } saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); moodMenu.appendChild(lbl); });
        // Add "+ Add Mood" button at bottom of mood menu
        const addMoodDiv=document.createElement('div'); addMoodDiv.style.cssText='margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb';
        const addMoodBtn=document.createElement('button'); addMoodBtn.type='button'; addMoodBtn.textContent='+ Add Mood'; addMoodBtn.style.cssText='width:100%;padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;background:#f9fafb;cursor:pointer;font-size:12px;font-weight:500;color:#0f172a';
        addMoodBtn.addEventListener('click',(e)=>{
          e.stopPropagation();
          const name = prompt('New mood name (max 16 chars).'); 
          if(name==null) return; 
          const n=name.trim(); 
          if(!n){ return; }
          const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
          const DEFAULT_MOODS=['upbeat','happy','energetic','mellow','sad'];
          const all=[...DEFAULT_MOODS,...(gig.customMoods||[])];
          if(all.length>=12){ alert('Max 12 moods reached.'); return; }
          if(all.includes(key)){ alert('Mood already exists.'); return; }
          gig.customMoods = gig.customMoods || []; 
          gig.customMoods.push(key);
          saveAll();
          // Re-render database to show new mood in all menus
          renderDB(); 
          renderSongPool();
          // Add custom mood filter checkbox
          const filterContainer=document.getElementById('customMoodFilters');
          if(filterContainer){
            const lbl=document.createElement('label');
            lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
            const chk=document.createElement('input');
            chk.type='checkbox';
            chk.id='filter-'+key;
            chk.addEventListener('change', renderDB);
            lbl.appendChild(chk);
            const moodLabel=(k)=>{const caps=k.split('-').map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(' '); return caps;};
            lbl.appendChild(document.createTextNode(moodLabel(key)));
            filterContainer.appendChild(lbl);
          }
        });
        addMoodDiv.appendChild(addMoodBtn);
        moodMenu.appendChild(addMoodDiv);
        moodBtn.appendChild(moodMenu);
        moodBtn.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodBtn.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        moodMenu.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodMenu.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        // Lyrics / chords quick edit (collapsed textarea)
        const lyricsWrap=document.createElement('div'); lyricsWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const lyrBtn=document.createElement('button'); lyrBtn.textContent='Lyrics'; lyrBtn.className='btn'; lyrBtn.type='button'; lyrBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0;background:#6b7280;color:#f9fafb'; lyrBtn.title='Edit lyrics / chords for this song';
        const lyricsPreview=document.createElement('div'); lyricsPreview.style.cssText='font-size:10px;color:#64748b;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1 1 auto';
        const findFirstLyricLine=(txt)=>{ const lines=(txt||'').split('\n'); for(let l of lines){ const t=l.trim(); if(!t) continue; if(t.startsWith('[') && t.includes(']')) continue; if(t.startsWith('|')) continue; if(/^[A-G]([#b]?m?|add\d|maj|min|sus|dim|aug|\d)*[\s\/]+/.test(t)) continue; return t; } return ''; };
        const firstLine=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=firstLine? (firstLine.length>25? firstLine.substring(0,25)+'...' : firstLine) : '';
        lyricsWrap.append(lyrBtn,lyricsPreview);
        const lyrBox=document.createElement('textarea'); lyrBox.rows=3; lyrBox.style.width='100%'; lyrBox.style.marginTop='4px'; lyrBox.style.display='none'; lyrBox.placeholder='Lyrics / chords'; lyrBox.value=s.lyrics||'';
        lyrBtn.addEventListener('click',()=>{
          const showing = lyrBox.style.display!=='none';
          // If cover song with no lyrics, search for them
          if(!showing && s.isCover && (!s.lyrics || s.lyrics.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' ' + (s.artist||'') + ' lyrics chords');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          lyrBox.style.display = showing ? 'none' : 'block';
        });
        lyrBox.addEventListener('change',()=>{ s.lyrics=lyrBox.value; const fl=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=fl? (fl.length>25? fl.substring(0,25)+'...' : fl) : ''; saveAll(); });
        // Audio attach / link with inline URL preview/edit
        const audioWrap=document.createElement('div'); audioWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const audioBtn=document.createElement('button'); audioBtn.textContent='Audio'; audioBtn.className='btn'; audioBtn.type='button'; audioBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0'; audioBtn.title='Attach MP3/WAV or link a URL (YouTube, Spotify, etc.)';
        const audioInline=document.createElement('input'); audioInline.type='url'; audioInline.placeholder='URL or file path...'; audioInline.value=s.audioUrl||s.audioFileName||''; audioInline.style.cssText='flex:1 1 auto;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:10px';
        audioInline.addEventListener('change',()=>{ s.audioUrl=audioInline.value.trim(); saveAll(); });
        audioWrap.append(audioBtn,audioInline);
        const audioBox=document.createElement('div'); audioBox.style.display='none'; audioBox.style.width='100%'; audioBox.style.marginTop='4px'; audioBox.style.padding='8px'; audioBox.style.border='1px solid #e5e7eb'; audioBox.style.borderRadius='6px';
        const audioUrlIn=document.createElement('input'); audioUrlIn.type='url'; audioUrlIn.placeholder='https:// link to audio, YouTube, or Spotify'; audioUrlIn.style.width='60%'; audioUrlIn.value = s.audioUrl||'';
        const saveUrlBtn=document.createElement('button'); saveUrlBtn.className='btn'; saveUrlBtn.textContent='Save URL'; saveUrlBtn.type='button'; saveUrlBtn.style.marginLeft='8px';
        const fileIn=document.createElement('input'); fileIn.type='file'; fileIn.accept='audio/*'; fileIn.style.marginLeft='12px'; fileIn.title='Choose local audio file (session only)';
        const fileRefIn=document.createElement('input'); fileRefIn.type='text'; fileRefIn.placeholder='Preferred filename for Arm All (e.g., 01 - Imagine.mp3)'; fileRefIn.style.marginLeft='12px'; fileRefIn.style.flex='1 1 220px'; fileRefIn.value = s.audioFileName||'';
        const saveRefBtn=document.createElement('button'); saveRefBtn.className='btn'; saveRefBtn.textContent='Save File Ref'; saveRefBtn.type='button';
        const infoSpan=document.createElement('span'); infoSpan.style.marginLeft='8px'; infoSpan.style.fontSize='12px'; infoSpan.style.color='#64748b';
        const clearBtn=document.createElement('button'); clearBtn.className='btn danger'; clearBtn.textContent='Remove Audio'; clearBtn.type='button'; clearBtn.style.marginLeft='auto';
        const rowCtl=document.createElement('div'); rowCtl.style.display='flex'; rowCtl.style.alignItems='center'; rowCtl.style.gap='8px';
        rowCtl.append(audioUrlIn, saveUrlBtn, fileIn, fileRefIn, saveRefBtn, clearBtn, infoSpan);
        audioBox.append(rowCtl);
        audioBtn.addEventListener('click',()=>{ 
          const showing = audioBox.style.display!=='none';
          if(!showing && s.isCover && (!s.audioUrl || s.audioUrl.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' by ' + (s.artist||'') + ' Karaoke Backing Track');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          audioBox.style.display = showing ? 'none' : 'block'; 
        });
        function updateAudioInfo(){
          const armed = (s.id!=null && armedAudio[s.id]);
          if(armed){ infoSpan.textContent = 'Armed file (session)'; return; }
          const linked = (s.audioUrl && s.audioUrl.trim());
          infoSpan.textContent = linked ? ('Linked: '+(s.audioUrl||'')) : '(no audio)';
        }
        updateAudioInfo();
        saveUrlBtn.addEventListener('click',()=>{ const v=(audioUrlIn.value||'').trim(); s.audioUrl = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved audio URL.' : 'Audio URL cleared.'); });
        saveRefBtn.addEventListener('click',()=>{ const v=(fileRefIn.value||'').trim(); s.audioFileName = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved file reference.' : 'File reference cleared.'); });
        clearBtn.addEventListener('click',()=>{ s.audioUrl=''; if(s.id!=null && armedAudio[s.id]){ try{ URL.revokeObjectURL(armedAudio[s.id]); }catch(_){} delete armedAudio[s.id]; } updateAudioInfo(); saveAll(); });
        fileIn.addEventListener('change',()=>{
          const f=fileIn.files && fileIn.files[0]; if(!f || s.id==null) return;
          try{ if(armedAudio[s.id]){ URL.revokeObjectURL(armedAudio[s.id]); } }catch(_){ }
          const objUrl = URL.createObjectURL(f);
          armedAudio[s.id] = objUrl;
          s.audioName = f.name||'audio'; s.audioFileName = f.name||s.audioFileName||'';
          // do not embed or persist the file; session only
          updateAudioInfo();
          alert('Audio armed for this session: '+(s.title||'song'));
        });
        
        // Audience rating (0-3: thumbs down, sideways, up, double up) - click to cycle, default 2
        if(s.audienceRating===undefined || s.audienceRating===null) s.audienceRating=2;
        const rating = s.audienceRating;
        const ratingIcons = ['üëé','üëà','üëç','üëç‚Ääüëç'];
        const ratingBtn=document.createElement('button'); ratingBtn.type='button'; ratingBtn.textContent=ratingIcons[rating]; ratingBtn.style.cssText='padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;font-size:14px;min-width:32px;height:24px'; ratingBtn.title='Rating: '+rating+' (click to cycle)';
        ratingBtn.addEventListener('click',()=>{ s.audienceRating=((s.audienceRating||0)+1)%4; saveAll(); renderDB(); });
        
        const toSetBtn=document.createElement('button'); toSetBtn.className='btn'; toSetBtn.textContent='To Set'; toSetBtn.style.cssText='margin-left:auto;padding:2px 8px;font-size:11px;border-radius:3px;min-width:56px'; toSetBtn.title='Add this song to the end of the current setlist';
        toSetBtn.addEventListener('click',()=>{ 
          if(setlist.some(x=>x.type==='song' && x.id===s.id)){ 
            alert('Song already in setlist.'); 
            return; 
          } 
          setlist.push({...s,type:'song',notes:''}); 
          saveAll(); 
          renderSet(); 
          buildSheet('sheetInline'); 
          renderSongPool(); 
          alert('Added "'+s.title+'" to setlist.'); 
        });
        const del=document.createElement('button'); del.className='btn danger'; del.textContent='Del'; del.style.cssText='padding:2px 8px;font-size:11px;border-radius:3px;min-width:50px'; del.addEventListener('click',()=>{ const i=db.findIndex(x=>x.id===s.id); if(i>-1){ db.splice(i,1); renderDB(); renderSongPool(); saveAll(); } });
        
        // Append in column order, applying widths
        const cellMap = {
          add: (() => {
            const addPlaceholder = document.createElement('div');
            addPlaceholder.style.cssText='width:24px;height:24px;flex-shrink:0';
            return addPlaceholder;
          })(),
          cover: coverChk,
          title: title,
          artist: artist,
          len: len,
          key: key,
          capo: capo,
          bpm: bpm,
          mood: moodBtn,
          lyrics: lyricsWrap,
          audio: audioWrap,
          rating: ratingBtn,
          actions: (() => {
            const actionsWrap = document.createElement('div');
            actionsWrap.style.cssText='display:flex;gap:4px;margin-left:auto;width:'+colWidths.actions+'px';
            actionsWrap.append(toSetBtn,del);
            return actionsWrap;
          })()
        };
        // Add custom column cells to cellMap
        gig.customColumns.forEach(cc=>{
          cellMap[cc.key] = customColInputs[cc.key];
        });
        
        colOrder.forEach(colKey=>{
          if(hiddenCols.includes(colKey)) return; // Skip hidden columns
          const cell = cellMap[colKey];
          if(!cell) return;
          const width = colWidths[colKey];
          // Apply width to cell if fixed-width column
          if(colKey!=='lyrics' && colKey!=='audio' && colKey!=='actions'){
            cell.style.width = width+'px';
            cell.style.flexShrink = '0';
          } else if(colKey==='lyrics' || colKey==='audio'){
            cell.style.flex = `1 1 auto`;
            cell.style.minWidth = width+'px';
            cell.style.maxWidth = (width+100)+'px';
          }
          row.appendChild(cell);
        });
        
        list.appendChild(row);
        list.appendChild(lyrBox);
        list.appendChild(audioBox);
      });
      try{ renderSongPool(); }catch(_){ }
    }

    // Generate fresh set each click (ignores current setlist)
    $('#genBtn').addEventListener('click', ()=>{
      const setLen = parseFloat($('#gLen').value || '60') || 60;
      const coverRatio=parseInt($('#gCover').value)||0;
      const breaks=parseInt($('#gBreaks').value)||0; // retained in gig but not auto-inserted
      const breakLen=parseFloat($('#gBreakLen').value)||15;
      const encore=$('#gEncore').checked;
      const mood=$('#gMood').value;

      var gFontElTmp=document.getElementById('gFont');
      gig={ band:$('#gBand').value, date:$('#gDate').value, venue:$('#gVenue').value, address:$('#gAddr').value, contact:$('#gContact').value, notes:$('#gNotes').value, breaks, breakLen, encore, font:((gFontElTmp&&gFontElTmp.value)||gig.font||'default'), logo:(gig.logo||'') };
      if(!db.length){ alert('Add some songs first.'); return; }

      // Filter pool by mood
      let pool=[...db];
      if(mood!=='mixed'){
        const keyMap={upbeat:'isUpbeat',happy:'isHappy',mellow:'isMellow',energetic:'isEnergetic',sad:'isSad'};
        pool=pool.filter(s=>s[keyMap[mood]]);
        if(!pool.length){ alert('No songs match this mood.'); return; }
      }

      const totalBreakTime = (breaks>0 ? (breaks * breakLen) : 0);
      const musicTime = Math.max(0, setLen - totalBreakTime);
      if(musicTime<=0){ alert('Set length must exceed total break time.'); return; }
      const covers=pool.filter(s=>s.isCover);
      const originals=pool.filter(s=>!s.isCover);
      let plan=[]; let total=0; const targetCover=(musicTime*coverRatio)/100;
      let coverSum=0, origSum=0;
      for(const s of shuffle(covers)){
        if(coverSum + s.length <= targetCover && total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); coverSum+=s.length; total+=s.length; }
      }
      for(const s of shuffle(originals)){
        if(total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); origSum+=s.length; total+=s.length; }
      }
      plan=shuffle(plan);
      // Apply optional grouping rules
      const keepCovers = (document.getElementById('gKeepCovers') && document.getElementById('gKeepCovers').checked) || false;
      const keepKeys   = (document.getElementById('gKeepKeys') && document.getElementById('gKeepKeys').checked) || false;
      const keepMoods  = (document.getElementById('gKeepMoods') && document.getElementById('gKeepMoods').checked) || false;
      if(keepCovers || keepKeys || keepMoods){
        const songMoodOf=(s)=>{ if(s.isUpbeat) return 'upbeat'; if(s.isHappy) return 'happy'; if(s.isEnergetic) return 'energetic'; if(s.isMellow) return 'mellow'; if(s.isSad) return 'sad'; const cm=(s.customMoods||[])[0]; return cm||'none'; };
        const applyGrouping=(arr)=>{
          const songs=arr.filter(x=>x.type==='song');
          const others=arr.filter(x=>x.type!=='song');
          if(songs.length){
            songs.sort((a,b)=>{
              if(keepCovers){ const ca=(a.isCover?1:0), cb=(b.isCover?1:0); if(ca!==cb) return ca-cb; }
              if(keepKeys){ const ka=(a.key||''), kb=(b.key||''); if(ka!==kb) return ka.localeCompare(kb); }
              if(keepMoods){ const ma=songMoodOf(a), mb=songMoodOf(b); if(ma!==mb) return ma.localeCompare(mb); }
              return 0;
            });
          }
          // Rebuild segment by replacing song slots with sorted songs in order, preserving non-song positions
          let si=0; return arr.map(x=> x.type==='song' ? songs[si++] : x);
        };
        const encIdx=plan.findIndex(x=>x.type==='encore');
        if(encIdx>-1){
          const before=applyGrouping(plan.slice(0,encIdx));
          const after=applyGrouping(plan.slice(encIdx+1));
          const hdr=plan[encIdx];
          plan=[...before, hdr, ...after];
        }else{
          plan=applyGrouping(plan);
        }
      }
      if(encore){
        const usedIds=new Set(plan.filter(x=>x.type==='song').map(x=>x.id));
        const remaining=pool.filter(s=>!usedIds.has(s.id));
        let added=false;
        for(const s of shuffle(remaining)){
          if(total + s.length <= musicTime){ if(!added){ plan.push({type:'encore',title:'Encore'}); added=true; } plan.push({...s,type:'song',notes:''}); total+=s.length; if(total>=musicTime-0.01) break; }
        }
        if(added){ const h=plan.findIndex(x=>x.type==='encore'); if(h>-1 && !plan.slice(h+1).some(x=>x.type==='song')) plan=plan.filter((x,i)=> i!==h); }
      }
      // Trim overflow if any
      while(total>musicTime){ const last=plan.map((x,i)=>({x,i})).filter(y=>y.x.type==='song').map(y=>y.i).pop(); if(last==null) break; total-=plan[last].length; plan.splice(last,1); }

      // Automatic break insertion based on requested count (by cumulative music time)
      (function autoBreaks(){
        if(!breaks || breakLen<=0) return;
        const encoreIdx=plan.findIndex(x=>x.type==='encore');
        const songIndices=[]; let cum=0; const songLengths=[];
        plan.forEach((p,i)=>{ if(p.type==='song' && (encoreIdx===-1 || i<encoreIdx)){ cum += (p.length||0); songIndices.push(i); songLengths.push(cum); } });
        const totalSongLen=songLengths[songLengths.length-1]||0;
        if(totalSongLen < breakLen*0.75) return; // too short to bother
        let fracs=[];
        if(breaks===1) fracs=[0.5];
        else if(breaks===2) fracs=[0.5, 2/3];
        else if(breaks>=3) fracs=[0.25,0.5,0.75];
        const targets=fracs.map(f=> totalSongLen*f);
        const inserted=new Set();
        for(let tIdx=0; tIdx<targets.length; tIdx++){
          const tgt=targets[tIdx]; if(tgt<=0) continue;
          // Find first song index with cumulative >= target
          let songPos=-1;
          for(let j=0;j<songLengths.length;j++){ if(songLengths[j] >= tgt){ songPos=songIndices[j]; break; } }
          if(songPos===-1) continue;
          // Avoid duplicate insertion near previous breaks
          if(inserted.has(songPos)) continue;
          // Do not insert at very beginning
          if(songPos<=0) continue;
          // If previous element already a break, skip
          if(plan[songPos-1] && plan[songPos-1].type==='break') continue;
          plan.splice(songPos,0,{type:'break',title:'Break',length:breakLen});
          inserted.add(songPos);
          // Shift later songPositions automatically due to splice; recalc cumulative references minimal by adding length to later songLengths
          for(let k=0;k<songLengths.length;k++){ if(songIndices[k] >= songPos){ songIndices[k] += 1; } }
        }
      })();

      setlist=plan;
      const actualMusic = setlist.filter(x=>x.type==='song').reduce((a,b)=>a+(b.length||0),0);
      const breakCount=setlist.filter(x=>x.type==='break').length;
      $('#genStats').textContent=`Songs: ${setlist.filter(x=>x.type==='song').length} ‚Ä¢ Music: ${actualMusic.toFixed(1)}m (‚â§ target ${musicTime.toFixed(1)}m) ‚Ä¢ Covers ${coverSum.toFixed(1)}m / Originals ${origSum.toFixed(1)}m${breakCount? ' ‚Ä¢ Breaks '+breakCount+' √ó '+breakLen+'m':''}${encore? ' ‚Ä¢ Encore':''}`;
      rebuildPreview(); renderSongPool();
    });

    function renderSet(){
      const box=document.getElementById('setList');
      if(!box){ // preview-only layout (legacy set builder removed)
        buildSheet('sheetInline'); attachPreviewInteractions(); buildTechTable(); renderSongPool(); renderEncore(); return;
      }
      box.innerHTML='';
      if(!setlist.length){ box.textContent='No setlist yet.'; buildSheet('sheetInline'); attachPreviewInteractions(); buildTechTable(); renderSongPool(); renderEncore(); return; }
      let songNum=0;
      setlist.forEach((it,i)=>{
        const row=el('div','song');
        row.setAttribute('draggable', true);
        row.dataset.index=i;
        row.dataset.type=it.type;
        if(it.type==='break'){
          const container=el('div');
          container.append(el('span','handle','‚ãÆ‚ãÆ'));
          container.append(el('div','break',`${it.title} ‚Äî ${it.length}m`));
          row.append(container);
        }else if(it.type==='encore'){
          const container=el('div');
          container.append(el('span','handle','‚ãÆ‚ãÆ'));
          container.append(el('div','break', (it.title||'ENCORE').toUpperCase() ));
          row.append(container);
        }else{
          const left=el('div');
          const top=el('div');
          top.append(el('span','handle','‚ãÆ‚ãÆ'));
          top.append(document.createTextNode(`${(++songNum)}. ${it.title}`));
          left.append(top);
          const metaKey = it.key ? (' ‚Ä¢ '+it.key) : '';
          const metaCapo = (Number.isInteger(it.capo) && it.capo>0) ? (' ‚Ä¢ Capo '+it.capo) : '';
          left.append(el('div','meta',`${it.artist} ‚Ä¢ ${it.length}m${metaKey}${metaCapo}`));
          const noteIn=el('input'); noteIn.placeholder='Add notes‚Ä¶'; noteIn.value=it.notes||'';
          // Update notes live while typing and refresh preview immediately
          noteIn.oninput=()=>{ it.notes=noteIn.value; saveAll(); buildSheet('sheetInline'); };
          noteIn.onchange=()=>{ it.notes=noteIn.value; saveAll(); buildSheet('sheetInline'); };
          noteIn.style.maxWidth='320px';
      const rm=el('button','btn danger','Remove'); rm.onclick=()=>{ setlist.splice(i,1); rebuildPreview(); saveAll(); };
          row.append(left,noteIn,rm);
        }
        box.append(row);
      });
      enableDrag();
      // Update inline preview
      buildSheet('sheetInline');
  buildTechTable(); // keep tech table in sync
  renderSongPool();
  renderEncore();
      try{ pushAppHistory('renderSet'); }catch(_){ }
    }

    function enableDrag(){
      let dragIndex=null;
      const rows=[...document.querySelectorAll('#setList .song')];
      rows.forEach(r=>{
        // Desktop drag
        r.addEventListener('dragstart',e=>{ if(r.getAttribute('draggable')==='true'){ dragIndex=parseInt(r.dataset.index,10); r.classList.add('dragging'); try{ e.dataTransfer.setData('text/x-set-index', String(dragIndex)); }catch(_){ } }});
        r.addEventListener('dragend',()=> r.classList.remove('dragging'));
        // Touch drag for mobile
        r.addEventListener('touchstart', ev => {
          const t = ev.touches[0];
          if (!t) return;
          window._activeSetTouch = { idx: parseInt(r.dataset.index, 10), startX: t.clientX, startY: t.clientY, x: t.clientX, y: t.clientY, removed: false, reorderTarget: parseInt(r.dataset.index, 10) };
          r.classList.add('drag-touch');
        }, { passive: false });
        r.addEventListener('touchend', () => {
          r.classList.remove('drag-touch');
          const act = window._activeSetTouch;
          if (act && act.reorderTarget !== act.idx) {
            const item = setlist.splice(act.idx, 1)[0];
            setlist.splice(act.reorderTarget, 0, item);
            renderSet();
            saveAll();
          }
          window._activeSetTouch = null;
        });
        r.addEventListener('dragover',e=>{ e.preventDefault();
          // if dragging from pool, show above/below indicator
          const idRaw=e.dataTransfer.getData('text/plain');
          if(idRaw){ const rect=r.getBoundingClientRect(); const before=e.clientY < rect.top + rect.height/2; r.classList.toggle('drop-before', before); r.classList.toggle('drop-after', !before); }
        });
        r.addEventListener('dragleave',()=>{ r.classList.remove('drop-before','drop-after'); });
        r.addEventListener('drop',e=>{
          e.preventDefault();
          const to=parseInt(r.dataset.index,10);
          const fromSetIdxRaw=e.dataTransfer.getData('text/x-set-index');
          const incomingSongIdRaw=e.dataTransfer.getData('text/plain');
          const rect=r.getBoundingClientRect(); 
          const before=e.clientY < rect.top + rect.height/2;
          // Reorder existing
          if(fromSetIdxRaw && Number.isInteger(dragIndex)){
            const targetPos = before ? to : to+1;
            if(dragIndex!==targetPos && dragIndex+1!==targetPos){
              const item=setlist.splice(dragIndex,1)[0];
              const adj= (dragIndex<targetPos) ? targetPos-1 : targetPos;
              setlist.splice(adj,0,item);
              renderSet(); saveAll();
            }
            return;
          }
          // Insert new from pool at position (before/after based on cursor)
          if(incomingSongIdRaw){
            const id=parseInt(incomingSongIdRaw,10);
            const song=db.find(s=>s.id===id); if(!song) return;
            if(setlist.some(x=>x.id===song.id)) return;
            const rect=r.getBoundingClientRect(); const before=e.clientY < rect.top + rect.height/2;
            const insertAt = before ? to : to+1;
            // If dropping on ENCORE header, always insert after header
            if(r.dataset.type==='encore'){
              const idx=to+1; setlist.splice(idx,0,{...song,type:'song',notes:'',lyrics:song.lyrics||''});
            }else{
              setlist.splice(insertAt,0,{...song,type:'song',notes:'',lyrics:song.lyrics||''});
            }
            renderSet(); saveAll();
          }
        });
      });
    }
    

    // Preview (guarded if button exists)
    (function(){ const pb=document.getElementById('previewBtn'); if(pb){ pb.addEventListener('click', ()=>{ buildSheet('sheet'); document.getElementById('modal').classList.add('open'); }); } })();
  $('#closeModal').addEventListener('click', ()=> $('#modal').classList.remove('open'));
    $('#paperSel').addEventListener('change', ()=>{
      const sheet=$('#sheet');
      if($('#paperSel').value==='a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
    });
  // Setlist modal print opens print chooser for consistency
  document.getElementById('printSheet').addEventListener('click',()=> openPrintChooser('set'));

    // Live Mode rendering
    let _pendingArmSongId=null;
    function renderLive(){
      const listEl=document.getElementById('liveList'); if(!listEl) return;
      const titleEl=document.getElementById('liveLyricsTitle');
      const bodyEl=document.getElementById('liveLyricsBody');
      const themeBtn=document.getElementById('liveThemeToggle');
      const songArmInput=document.getElementById('armSongFile');
      // Wire per-song arm input once
      if(songArmInput && !songArmInput._wired){
        songArmInput.addEventListener('change',()=>{
          if(!_pendingArmSongId) return;
          const file = songArmInput.files && songArmInput.files[0];
            if(!file){ _pendingArmSongId=null; songArmInput.value=''; return; }
            const song=findSongById(_pendingArmSongId);
            if(song){
              try{ if(armedAudio[song.id]) URL.revokeObjectURL(armedAudio[song.id]); }catch(_){ }
              armedAudio[song.id]=URL.createObjectURL(file);
              song.audioFileName=file.name;
              saveAll();
              try{ renderLive(); }catch(_){ }
            }
            _pendingArmSongId=null; songArmInput.value='';
        });
        songArmInput._wired=true;
      }
      if(themeBtn){
        const dark=!!gig.liveDark;
        document.body.classList.toggle('live-dark', dark);
        themeBtn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
        themeBtn.style.background = dark ? '#fef3c7' : '#0f172a';
        themeBtn.style.color = dark ? '#92400e' : '#fbbf24';
      }
      listEl.innerHTML='';
      if(!setlist.length){ listEl.textContent='No setlist yet.'; if(titleEl) titleEl.textContent=''; if(bodyEl) bodyEl.textContent=''; return; }
      let songNum=0;
      let liveHoldTimer=null;
      let liveDragIndex=null;
      setlist.forEach((it,i)=>{
        const row=document.createElement('div');
        row.className='live-row';
        row.dataset.index=i;
        row.dataset.type=it.type;
        row.style.padding='10px 8px';
        row.style.borderBottom='1px solid #e5e7eb';
        row.style.display='flex';
        row.style.alignItems='center';
        row.style.gap='8px';
        row.style.cursor='pointer';
        row.style.transition='background 0.2s, transform 0.2s';
        
        // Handle breaks and encores as buttons
        if(it.type==='break'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚è∏'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=it.title||'Break'; ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#374151';
          const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280'; meta.textContent=it.length+'m';
          main.append(ttl,meta);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        if(it.type==='encore'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚≠ê'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=(it.title||'ENCORE').toUpperCase(); ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#1f2937';
          main.append(ttl);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        
        // Song rows
        const numSpan=document.createElement('span'); numSpan.textContent=String(++songNum)+'.'; numSpan.style.minWidth='24px';
        const main=document.createElement('div'); main.style.flex='1 1 auto';
        const ttl=document.createElement('div'); ttl.textContent=it.title||''; ttl.style.fontWeight='600'; ttl.style.fontSize='16px';
        const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280';
        const keyBits=[]; if(it.artist) keyBits.push(it.artist); if(it.key) keyBits.push(it.key); if(Number.isInteger(it.capo) && it.capo>0) keyBits.push('Capo '+it.capo); if(Number.isInteger(it.bpm) && it.bpm>0) keyBits.push(it.bpm+' BPM');
        meta.textContent=keyBits.join(' ‚Ä¢ ');
        // audio badge + per-song arm (show Arm button for any URL or file reference)
        try{
          const baseSong = findSongById(it.id) || findSongByTitle(it.title);
          const hasFileRef = baseSong && ((baseSong.audioFileName||'').trim());
          const hasUrl = baseSong && ((baseSong.audioUrl||'').trim());
          const isArmed = baseSong && armedAudio[baseSong.id];
          if(baseSong && (isArmed || hasUrl || hasFileRef)){
            const badge=document.createElement('span'); badge.textContent='üîä'; badge.title=isArmed? 'Audio armed' : (hasUrl? 'Audio URL linked' : 'Audio file referenced'); badge.style.marginLeft='6px'; ttl.appendChild(badge);
          }
          // Show Arm button: if URL exists, just arm it; if file ref exists, prompt for file
          if(baseSong && (hasFileRef || hasUrl) && !isArmed){
            const armBtn=document.createElement('button'); armBtn.type='button'; armBtn.textContent='Arm'; 
            if(hasUrl && !hasFileRef){
              // URL only - just arm it without file prompt
              armBtn.title='Arm this URL for playback';
              armBtn.addEventListener('click',e=>{ 
                e.stopPropagation(); 
                if(baseSong.id!=null){
                  try{ if(armedAudio[baseSong.id]) URL.revokeObjectURL(armedAudio[baseSong.id]); }catch(_){ }
                  armedAudio[baseSong.id]=baseSong.audioUrl;
                  armBtn.textContent='Armed';
                  armBtn.disabled=true;
                  armBtn.style.opacity='0.5';
                  saveAll();
                  renderLive();
                }
              });
            } else {
              // Has file reference - prompt for file selection
              armBtn.title='Select local audio file for this song';
              armBtn.addEventListener('click',e=>{ e.stopPropagation(); _pendingArmSongId=baseSong.id; songArmInput.click(); });
            }
            armBtn.style.fontSize='11px'; armBtn.style.padding='4px 8px'; armBtn.style.border='1px solid #d1d5db'; armBtn.style.background='#fff'; armBtn.style.borderRadius='4px'; armBtn.style.cursor='pointer';
            row.appendChild(armBtn);
          }
        }catch(_){ }
        main.append(ttl,meta);
        row.append(numSpan,main);
        // Track if we're dragging to prevent click during drag
        let clickAllowed=true;
        let clickTimer=null;
        row.addEventListener('touchstart',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('mousedown',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('touchend',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('mouseup',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('click',()=>{
          if(!clickAllowed) return; // Prevent click during long-hold drag
          document.querySelectorAll('#liveList .live-row').forEach(r=> r.style.background='');
          const dark = document.body.classList.contains('live-dark');
          row.style.background = dark ? '#0b3a59' : '#e0f2fe';
          if(titleEl) titleEl.textContent=it.title||'';
          if(bodyEl){
            bodyEl.textContent=it.lyrics || '';
            bodyEl.style.paddingTop='50vh';
            // Add rating UI at bottom
            const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
            const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:18px';
            const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:10px';
            const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
            const updateRatingButtons=()=>{
              ratingBtns.innerHTML='';
              [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:8px 16px;border:2px solid '+(it.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(it.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:24px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(it.id)||findSongByTitle(it.title); if(baseSong){ baseSong.audienceRating=r; it.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
            };
            updateRatingButtons();
            ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
          }
          const lyrMain=document.getElementById('liveLyrics'); if(lyrMain){ lyrMain.scrollTop=0; }
          const zoom=document.getElementById('liveInlineZoom'); if(zoom){ zoom.value=String(liveZoomPx); }
          const body=document.getElementById('liveLyricsBody'); if(body){ body.style.fontSize=liveZoomPx+'px'; }
          try{ stopLiveInlineAutoScroll(); }catch(_){ }
          try{ preloadSongAudioFor(it); }catch(_){ }
          // Show Play button again for new selection; keep Stop hidden until audio/scroll actions
          const pBtn=document.getElementById('liveInlinePlay'); const sBtn=document.getElementById('liveInlineStop');
          if(pBtn){ pBtn.style.display=''; }
          if(sBtn){ sBtn.style.display='none'; }
          // On phones/tablets, single tap opens fullscreen. Desktop uses double‚Äëclick.
          const isNarrow = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;
          if(isNarrow){ openLiveLyricsOverlay(it); }
        });
        // Desktop: double‚Äëclick to open fullscreen lyrics
        // Mobile: handle double-tap gesture
        let lastTap = 0;
        row.addEventListener('touchend', (e) => {
          const now = Date.now();
          const DOUBLE_TAP_DELAY = 300;
          if (now - lastTap < DOUBLE_TAP_DELAY) {
            e.preventDefault();
            openLiveLyricsOverlay(it);
            lastTap = 0;
          } else {
            lastTap = now;
          }
        });
        row.addEventListener('dblclick',()=>{ openLiveLyricsOverlay(it); });
        // Setup long-hold reorder for songs
        setupLiveRowReorder(row,i);
        listEl.appendChild(row);
      });
      
      // Setup long-hold reordering for all rows
      function setupLiveRowReorder(row,index){
        let holdTimer=null;
        let isDragging=false;
        let dragReady=false; // Hold completed, ready to drag
        let startY=0;
        let currentY=0;
        let placeholder=null;
        
        const startHold=(e)=>{
          if(holdTimer) return;
          dragReady=false;
          holdTimer=setTimeout(()=>{
            dragReady=true; // Hold completed - now ready to activate drag on move
          }, 500);
        };
        
        const activateDrag=()=>{
          if(isDragging) return;
          isDragging=true;
          row.style.opacity='0.7';
          row.style.transform='scale(1.05)';
          row.style.zIndex='1000';
          row.style.position='relative';
          // Create placeholder
          placeholder=document.createElement('div');
          placeholder.style.height=row.offsetHeight+'px';
          placeholder.style.background='#dbeafe';
          placeholder.style.border='2px dashed #374151';
          placeholder.style.borderRadius='4px';
          placeholder.style.margin='4px 0';
          row.parentNode.insertBefore(placeholder, row.nextSibling);
        };
        
        const endHold=()=>{
          if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }
          dragReady=false;
          if(isDragging){
            // Get the current index from the dataset (in case it changed)
            const currentIndex = parseInt(row.dataset.index, 10);
            if(!isFinite(currentIndex) || currentIndex<0){ 
              // Cleanup and bail
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
              isDragging=false;
              return;
            }
            
            // Find where the placeholder is positioned
            const allChildren=Array.from(listEl.children);
            let placeholderPos=-1;
            for(let i=0; i<allChildren.length; i++){
              if(allChildren[i]===placeholder){
                placeholderPos=i;
                break;
              }
            }
            
            // Map DOM position back to setlist index by counting rows before placeholder
            let targetSetlistIndex=0;
            for(let i=0; i<placeholderPos; i++){
              const child=allChildren[i];
              if(child.classList && child.classList.contains('live-row')){
                targetSetlistIndex++;
              }
            }
            
            if(targetSetlistIndex!==currentIndex){
              // Move in setlist array
              const item=setlist.splice(currentIndex,1)[0];
              const finalIndex = targetSetlistIndex > currentIndex ? targetSetlistIndex-1 : targetSetlistIndex;
              setlist.splice(finalIndex,0,item);
              saveAll();
              rebuildPreview();
              renderLive();
            } else {
              // No change, just cleanup
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
            }
            isDragging=false;
          }
        };
        
        const moveWhileDragging=(e)=>{
          // Only activate drag if hold completed AND user is moving
          if(dragReady && !isDragging){
            activateDrag();
          }
          if(!isDragging) return;
          e.preventDefault();
          const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
          const deltaY = clientY - startY;
          row.style.transform=`translateY(${deltaY}px) scale(1.05)`;
          // Move placeholder based on position
          const rows=Array.from(listEl.querySelectorAll('.live-row')).filter(r=>r!==placeholder);
          let insertBefore=null;
          rows.forEach(r=>{
            const rect=r.getBoundingClientRect();
            const mid=rect.top+rect.height/2;
            if(clientY < mid && !insertBefore){ insertBefore=r; }
          });
          if(insertBefore && placeholder){
            listEl.insertBefore(placeholder, insertBefore);
          } else if(placeholder && !insertBefore){
            listEl.appendChild(placeholder);
          }
        };
        
        // Touch events
        row.addEventListener('touchstart',(e)=>{
          startY = e.touches[0].clientY;
          startHold(e);
        });
        row.addEventListener('touchmove',(e)=>{
          moveWhileDragging(e);
        });
        row.addEventListener('touchend',(e)=>{
          endHold();
        });
        row.addEventListener('touchcancel',(e)=>{
          endHold();
        });
        
        // Mouse events for desktop - attach move/up to document to prevent losing grip
        const onMouseMove=(e)=>{
          moveWhileDragging(e);
        };
        const onMouseUp=(e)=>{
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          endHold();
        };
        row.addEventListener('mousedown',(e)=>{
          startY = e.clientY;
          startHold(e);
          // Attach global listeners when drag starts
          setTimeout(()=>{
            if(isDragging){
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            }
          }, 510); // Just after the 500ms hold timer
        });
      }
    }

    // Live theme toggle wiring
    (function wireLiveThemeToggle(){
      const btn=document.getElementById('liveThemeToggle');
      if(!btn) return;
      btn.addEventListener('click',()=>{
        gig.liveDark = !gig.liveDark;
        document.body.classList.toggle('live-dark', gig.liveDark);
        // Re-render live to refresh colors and icon
        try{ renderLive(); }catch(_){ }
        saveAll();
      });
    })();

    // Arm All: batch-arm audio by selecting a folder and matching filenames
    (function wireArmAll(){
      const armBtn=document.getElementById('armAllBtn');
      const armDir=document.getElementById('armAllDir');
      if(!armBtn || !armDir) return;
      const matchAndArm=(fileList)=>{
        if(!fileList || !fileList.length) return 0;
        const map=new Map();
        for(const f of fileList){ map.set((f.name||'').toLowerCase(), f); }
        let armed=0;
        const targetSongs = setlist.filter(x=>x.type==='song');
        targetSongs.forEach(it=>{
          const base = (findSongById(it.id) || findSongByTitle(it.title)); if(!base) return;
          // Try to match by filename first
          const want=(base.audioFileName||'').toLowerCase().trim();
          let file=null;
          if(want){ file = map.get(want) || null; }
          if(!file){
            // heuristic: try title match
            const t=(base.title||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
            if(t){ for(const [nm,f] of map){ if(nm.replace(/[^a-z0-9]+/g,' ').includes(t)){ file=f; break; } }
            }
          }
          // If file found OR has URL, arm it
          if(base.id!=null){
            if(file){
              // Arm with local file
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=URL.createObjectURL(file);
              armed++;
            } else if((base.audioUrl||'').trim()){
              // Arm with URL (mark as armed by setting a flag)
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=base.audioUrl; // store URL directly
              armed++;
            }
          }
        });
        return armed;
      };
      armBtn.addEventListener('click',()=> armDir.click());
      armDir.addEventListener('change',()=>{
        const n=matchAndArm(armDir.files||[]);
        alert(n? ('Armed '+n+' audio track'+(n===1?'':'s')+' (files and URLs) for this set.') : 'No matching files found. Add audio files or URLs to songs in Database.');
      });
    })();

    // Live fullscreen lyrics: timed auto-scroll to ~75% of song length
    let liveScrollTimer=null;
    let liveScrollStart=null;
    let liveScrollDurationMs=0;
    let liveZoomPx=20; // inline lyrics zoom (desktop pane)
    let liveOverlayZoomPx=20; // fullscreen overlay zoom
    let liveScrollSpeed=5; // user-adjustable scroll speed (0-9, default 5, 0=stopped, 9=fastest)
    let liveManualScrollOffset=0; // manual scroll adjustment during playback
    // Compute scroll duration based on lines-per-minute model
    function computeScrollDuration(container, bodyEl, zoomPx, speedSetting){
      try{
        if(!container || !bodyEl) return 0;
        const lineHeightPx = zoomPx * 1.4; // approximate line-height factor
        const totalLines = Math.max(1, Math.round(bodyEl.scrollHeight / lineHeightPx));
        const visibleLines = Math.max(1, Math.round(container.clientHeight / lineHeightPx));
        const linesToScroll = Math.max(1, totalLines - visibleLines);
        if(speedSetting===0) return 0;
        // Base lines per minute scaling; speed 9 roughly 2x previous max
        const baseLinesPerMin = 30 + speedSetting * 10; // 1=>40, 9=>120
        // Bigger zoom => fewer lines visible, scroll proportionally faster
        const linesPerMin = baseLinesPerMin * (zoomPx / 20);
        const durationMs = (linesToScroll / linesPerMin) * 60000;
        return durationMs;
      }catch(e){ return 0; }
    }
    // Inline (desktop) auto-scroll
    let liveInlineScrollTimer=null;
    let liveInlineScrollStart=null;
    let liveInlineScrollDurationMs=0;
    let liveInlineManualScrollOffset=0;
    function stopLiveAutoScroll(){
      if(liveScrollTimer){ cancelAnimationFrame(liveScrollTimer); liveScrollTimer=null; }
      liveScrollStart=null; liveScrollDurationMs=0;
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function stopLiveInlineAutoScroll(){
      if(liveInlineScrollTimer){ cancelAnimationFrame(liveInlineScrollTimer); liveInlineScrollTimer=null; }
      liveInlineScrollStart=null; liveInlineScrollDurationMs=0;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function openLiveLyricsOverlay(item){
      const overlay=document.getElementById('liveLyricsOverlay');
      const titleEl=document.getElementById('liveLyricsOverlayTitle');
      const bodyEl=document.getElementById('liveLyricsOverlayBody');
      if(!overlay || !titleEl || !bodyEl) return;
      stopLiveAutoScroll();
      overlay.classList.add('open');
      titleEl.textContent=item.title || '';
      bodyEl.textContent=item.lyrics || '';
      bodyEl.style.paddingTop='50vh';
      // Add rating UI at bottom
      const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
      const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:24px';
      const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:12px';
      const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
      const updateRatingButtons=()=>{
        ratingBtns.innerHTML='';
        [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:10px 20px;border:2px solid '+(item.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(item.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:32px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(item.id)||findSongByTitle(item.title); if(baseSong){ baseSong.audienceRating=r; item.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
      };
      updateRatingButtons();
      ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
      const main=document.getElementById('liveLyricsOverlayMain');
      if(main){ main.scrollTop=0; }
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(zoomSlider){
        zoomSlider.value=String(liveOverlayZoomPx);
      }
      const body=document.getElementById('liveLyricsOverlayBody');
      if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
      // Reset play visibility for new overlay song
      const pBtn=document.getElementById('liveLyricsPlay'); const sBtn=document.getElementById('liveLyricsStop');
      if(pBtn){ pBtn.style.display=''; }
      if(sBtn){ sBtn.style.display='none'; }
    }
    function closeLiveLyricsOverlay(){
      const overlay=document.getElementById('liveLyricsOverlay');
      if(overlay){ overlay.classList.remove('open'); }
      stopLiveAutoScroll();
    }
    function startLiveAutoScroll(){
      const overlay=document.getElementById('liveLyricsOverlay');
      const main=document.getElementById('liveLyricsOverlayMain');
      if(!overlay || !main || !overlay.classList.contains('open')) return;
      const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsOverlayBody');
      liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
      if(liveScrollDurationMs<=0) liveScrollDurationMs=15000; // fallback
      const maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveScrollStart = performance.now();
      liveManualScrollOffset = 0; // reset manual offset for new scroll
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      let lastComputedTop = startTop;
      function step(now){
        if(!liveScrollStart){ return; }
        const elapsed = now - liveScrollStart;
        const t = Math.min(1, elapsed / liveScrollDurationMs);
        // Compute target position for this frame
        const targetTop = startTop + (maxTop - startTop) * t;
        // Detect user manual scroll: if actual position differs from last computed, update offset
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){ 
          liveManualScrollOffset = actualTop - targetTop;
        }
        // Apply target + offset and remember for next frame
        lastComputedTop = targetTop + liveManualScrollOffset;
        main.scrollTop = lastComputedTop;
        if(t<1){ liveScrollTimer = requestAnimationFrame(step); }
        else { stopLiveAutoScroll(); }
      }
      liveScrollTimer = requestAnimationFrame(step);
    }
    // Schedule scroll start after Play; immediate for armed/local or stream, delayed for external popup providers
    function scheduleOverlayScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200; // small delay for direct audio, longer for external to allow manual play
      setTimeout(()=>{ try{ startLiveAutoScroll(); }catch(_){ } }, delay);
    }
    function startLiveInlineAutoScroll(){
      const main=document.getElementById('liveLyrics');
      if(!main) return;
      const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsBody');
      liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
      if(liveInlineScrollDurationMs<=0) liveInlineScrollDurationMs=15000;
      const maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveInlineScrollStart = performance.now();
      liveInlineManualScrollOffset = 0;
      let lastComputedTop = startTop;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      function step(now){
        if(!liveInlineScrollStart){ return; }
        const elapsed = now - liveInlineScrollStart;
        const t = Math.min(1, elapsed / liveInlineScrollDurationMs);
        const targetTop = startTop + (maxTop - startTop) * t;
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){
          liveInlineManualScrollOffset = actualTop - targetTop;
        }
        lastComputedTop = targetTop + liveInlineManualScrollOffset;
        main.scrollTop = lastComputedTop;
        if(t<1){ liveInlineScrollTimer = requestAnimationFrame(step); }
        else { stopLiveInlineAutoScroll(); }
      }
      liveInlineScrollTimer = requestAnimationFrame(step);
    }
    function scheduleInlineScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200;
      setTimeout(()=>{ try{ startLiveInlineAutoScroll(); }catch(_){ } }, delay);
    }
    (function wireLiveOverlayControls(){
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      const scrollBtn=document.getElementById('liveLyricsScroll');
      const exitBtn=document.getElementById('liveLyricsExit');
      const main=document.getElementById('liveLyricsOverlayMain');
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleOverlayScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveAutoScroll); }
      if(exitBtn){ exitBtn.addEventListener('click',closeLiveLyricsOverlay); }
      if(main){ main.addEventListener('click',closeLiveLyricsOverlay); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveOverlayZoomPx=Math.min(96, Math.max(16, v));
          const body=document.getElementById('liveLyricsOverlayBody');
          if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
          // Zoom change should not restart scrolling or audio
        });
      }
      const speedDownBtn=document.getElementById('liveSpeedDown');
      const speedUpBtn=document.getElementById('liveSpeedUp');
      const speedDisplay=document.getElementById('liveSpeedDisplay');
      if(speedDownBtn){
        speedDownBtn.addEventListener('click',()=>{
          if(liveScrollSpeed > 0) liveScrollSpeed--;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveScrollTimer && liveScrollStart){
            const elapsed = performance.now() - liveScrollStart;
            const oldT = Math.min(1, elapsed / liveScrollDurationMs);
            const main=document.getElementById('liveLyricsOverlayMain');
            const body=document.getElementById('liveLyricsOverlayBody');
            liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
            liveScrollStart = performance.now() - (oldT * liveScrollDurationMs);
          }
        });
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('click',()=>{
          if(liveScrollSpeed < 9) liveScrollSpeed++;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveScrollTimer && liveScrollStart){
            const elapsed = performance.now() - liveScrollStart;
            const oldT = Math.min(1, elapsed / liveScrollDurationMs);
            const main=document.getElementById('liveLyricsOverlayMain');
            const body=document.getElementById('liveLyricsOverlayBody');
            liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
            liveScrollStart = performance.now() - (oldT * liveScrollDurationMs);
          }
        });
      }
    })();

    // Desktop inline Live controls
    (function wireLiveInlineControls(){
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      const scrollBtn=document.getElementById('liveInlineScroll');
      const zoomSlider=document.getElementById('liveInlineZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleInlineScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveInlineAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveInlineAutoScroll); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveZoomPx=Math.min(32, Math.max(16, v));
          const body=document.getElementById('liveLyricsBody');
          if(body){ body.style.fontSize=liveZoomPx+'px'; }
          // Zoom change should not restart scrolling or touch audio
        });
        // initialize to current zoom
        try{ zoomSlider.value=String(liveZoomPx); }catch(_){ }
      }
      const speedDownBtn=document.getElementById('liveInlineSpeedDown');
      const speedUpBtn=document.getElementById('liveInlineSpeedUp');
      const speedDisplay=document.getElementById('liveInlineSpeedDisplay');
      if(speedDownBtn){
        speedDownBtn.addEventListener('click',()=>{
          if(liveScrollSpeed > 0) liveScrollSpeed--;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveInlineScrollTimer && liveInlineScrollStart){
            const elapsed = performance.now() - liveInlineScrollStart;
            const oldT = Math.min(1, elapsed / liveInlineScrollDurationMs);
            const main=document.getElementById('liveLyrics');
            const body=document.getElementById('liveLyricsBody');
            liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
            liveInlineScrollStart = performance.now() - (oldT * liveInlineScrollDurationMs);
          }
        });
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('click',()=>{
          if(liveScrollSpeed < 9) liveScrollSpeed++;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveInlineScrollTimer && liveInlineScrollStart){
            const elapsed = performance.now() - liveInlineScrollStart;
            const oldT = Math.min(1, elapsed / liveInlineScrollDurationMs);
            const main=document.getElementById('liveLyrics');
            const body=document.getElementById('liveLyricsBody');
            liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
            liveInlineScrollStart = performance.now() - (oldT * liveInlineScrollDurationMs);
          }
        });
      }
    })();

    // Metronome functionality with tap tempo (4+ taps) & overlay support
    (function(){
      let metronomeState = 0; // 0=off, 1=flash, 2=flash+click
      let metronomeInterval = null;
      let metronomeBPM = 120;
      let metronomeHoldTimer = null;
      let tapTimes=[]; let lastClickTime=0;
      const btns=[document.getElementById('metronomeBtn'), document.getElementById('metronomeBtnOverlay')].filter(Boolean);
      if(!btns.length) return;

      // Create audio context for click sound
      let audioCtx = null;
      const getAudioContext = () => {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      };
      const playClick = () => {
        try {
          const ctx = getAudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.value = 1000;
          gain.gain.value = 0.3;
          osc.start();
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
          osc.stop(ctx.currentTime + 0.05);
        } catch(e) {}
      };

      const flashButtons = () => {
        btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#fbbf24':'#fbbf24'; b.style.transform='scale(1.12)'; });
        setTimeout(()=>{ btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#1f2937':'#fff'; b.style.transform='scale(1)'; }); },110);
      };

      const updateTitles=()=>{
        btns.forEach(b=>{
          if(metronomeState===0){ b.title='Metronome OFF - Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM.'; b.style.border=b.id==='metronomeBtnOverlay'?'2px solid #444':'2px solid #d1d5db'; }
          else { b.title=metronomeBPM+' BPM - '+(metronomeState===1?'Flash':'Flash + Click'); b.style.border='2px solid #065f46'; }
        });
      };
      const startMetronome=()=>{
        if(metronomeInterval) clearInterval(metronomeInterval);
        const intervalMs=60000/metronomeBPM;
        metronomeInterval=setInterval(()=>{ flashButtons(); if(metronomeState===2) playClick(); }, intervalMs);
        updateTitles();
      };

      const stopMetronome=()=>{ if(metronomeInterval) clearInterval(metronomeInterval); metronomeInterval=null; updateTitles(); };

      const persistSongBPM=(bpm)=>{
        const titleEl=document.getElementById('liveLyricsTitle');
        if(titleEl && titleEl.textContent){
          const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
          const baseSong=song?(findSongById(song.id)||findSongByTitle(song.title)):null;
          if(baseSong){ baseSong.bpm=bpm; song.bpm=bpm; saveAll(); }
        }
      };
      const handleTap=(e)=>{
        // Cancel hold timer immediately on quick tap
        if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; }
        
        const now=performance.now();
        const gap=now-lastClickTime;
        lastClickTime=now;
        
        // Long pause (>1200ms) = mode cycle
        if(gap>1200){
          tapTimes=[];
          metronomeState=(metronomeState+1)%3;
          if(metronomeState===0){ stopMetronome(); }
          else {
            // adopt song bpm if exists
            const titleEl=document.getElementById('liveLyricsTitle');
            if(titleEl && titleEl.textContent){
              const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
              if(song && song.bpm && song.bpm>0) metronomeBPM=song.bpm;
            }
            startMetronome();
          }
          updateTitles();
          return;
        }
        
        // Tap tempo: collect tap times
        tapTimes.push(now);
        
        // After 4+ taps, calculate BPM from intervals
        if(tapTimes.length>=4){
          const intervals=[];
          for(let i=1;i<tapTimes.length;i++){ 
            const dt=tapTimes[i]-tapTimes[i-1]; 
            if(dt>0 && dt<2000) intervals.push(dt); 
          }
          if(intervals.length>=3){
            const recent=intervals.slice(-Math.min(8, intervals.length)); // use last 8 intervals max
            const avg=recent.reduce((a,b)=>a+b,0)/recent.length;
            let bpm=Math.round(60000/avg); 
            if(bpm<30)bpm=30; 
            if(bpm>300)bpm=300;
            metronomeBPM=bpm;
            persistSongBPM(bpm);
            // Start metronome with new BPM immediately
            if(metronomeState===0){ metronomeState=1; }
            stopMetronome();
            startMetronome();
          }
        }
        updateTitles();
      };
      
      btns.forEach(btn=>{
        btn.addEventListener('click', handleTap);
        btn.addEventListener('mousedown', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0; // reset tap state
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('mouseup', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('mouseleave', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('touchstart', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0;
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('touchend', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
      });
      updateTitles();
    })();

    function buildSheet(target='sheet'){
      const isInline = (target!=='sheet');
      const sheet = document.getElementById(target);
      const hdr = document.getElementById(isInline? 'hdrInline' : 'hdr');
      const songs = document.getElementById(isInline? 'songsInline' : 'songs');
      if(!sheet || !hdr || !songs) return;
      // Header
      hdr.innerHTML='';
      const b = gig.logo ? (function(){ const d=el('div','logo'); const img=document.createElement('img'); img.src=gig.logo; img.alt='Band Logo'; d.appendChild(img); return d; })() : el('div','band',(gig.band||'').trim()||'BAND NAME');
      const v=el('div','venue',gig.venue||'VENUE');
      const sub=el('div','sub', [gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '));
      const n=el('div','notes', gig.notes||'');
      // Effective header flags: if all off, show all
      const hf = (function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band && !f.venue && !f.sub && !f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.appendChild(b);
      if(hf.venue) hdr.appendChild(v);
      if(hf.sub && sub.textContent.trim()) hdr.appendChild(sub);
      if(hf.notes && gig.notes) hdr.appendChild(n);

      // Apply font selection
      const fontMap={
        'default':'Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif',
        'helvetica':'Helvetica, Arial, sans-serif',
        'georgia':'Georgia, Times, serif',
        'roboto-condensed':'"Roboto Condensed", Roboto, Arial, sans-serif',
        'courier':'"Courier New", Courier, monospace'
      };
      sheet.style.fontFamily = fontMap[gig.font||'default']||fontMap.default;

      // Songs
      songs.innerHTML='';
      // dynamic font scaling to fit one page
      // Start with base sizes and try to fit, shrink if overflow
  const base = { title:14, lineGap:3 };

      const lines=[];
      let sinceBreak=0;
      let songCounter=0;
      setlist.forEach((it, idx)=>{
        if(it.type==='break'){
          const br=el('div','break',`${it.title} ‚Äî ${it.length}m`);
          if(sinceBreak>=15) br.classList.add('pagebreak');
          lines.push(br); sinceBreak=0; return;
        }
        if(it.type==='encore'){ const label=(it.title||'Encore'); const enc=el('div','break',label.toUpperCase()); if(sinceBreak>=15) enc.classList.add('pagebreak'); lines.push(enc); sinceBreak=0; return; }
        const row=el('div','line');
        row.append(el('div','no', String(++songCounter)));
        const title=el('div','title', shorten(it.title));
        if(it.notes){ const noteSpan=el('span','notePrint',' ‚Äì '+it.notes); title.appendChild(noteSpan); }
        // Add custom column data if pushToSetlist is enabled
        if(gig.customColumns && it.customFields){
          const customBits = [];
          gig.customColumns.forEach(cc=>{
            if(cc.pushToSetlist && it.customFields[cc.key]){
              customBits.push(it.customFields[cc.key]);
            }
          });
          if(customBits.length > 0){
            const customSpan = el('span','notePrint',' ‚Äì ' + customBits.join(' ‚Äì '));
            title.appendChild(customSpan);
          }
        }
        row.append(title);
        const keyBits=[]; if(it.key) keyBits.push(String(it.key)); if(Number.isInteger(it.capo) && it.capo>0) keyBits.push('Capo '+it.capo); if(Number.isInteger(it.bpm) && it.bpm>0) keyBits.push(it.bpm+' BPM');
        const keyTxt = keyBits.join(' ‚Ä¢ ');
        row.append(el('div','key', keyTxt));
        row.append(el('div','time', `${it.length}m`));
        lines.push(row); sinceBreak++;
      });

      // Add/update total time footer BEFORE appending and fitting (includes songs + breaks)
      const totalMin = setlist.reduce((acc,it)=> acc + ((it.type==='song'||it.type==='break') ? (parseFloat(it.length)||0) : 0), 0);
      let totalEl = sheet.querySelector('.total-time');
      if(!totalEl){ totalEl=document.createElement('div'); totalEl.className='total-time'; sheet.appendChild(totalEl); }
      totalEl.textContent = `Total: ${totalMin.toFixed(0)}m`;
      totalEl.style.textAlign='right'; totalEl.style.marginTop='8px'; totalEl.style.fontWeight='600'; totalEl.style.fontSize='12pt';

      // Append songs, then check overflow; shrink title font until fits
      songs.append(...lines);
      fitToPage();

      function fitToPage(){
        // Remove any transform scaling - fit naturally
        songs.style.transform = 'none';
        songs.style.width = '100%';
        
        // Aggressive font shrinking to fit on one page
        let tSize=11; // start smaller
        for(let i=0;i<20;i++){
          songs.style.setProperty('--t', tSize);
          Array.from(songs.querySelectorAll('.title')).forEach(d=> d.style.fontSize = tSize+'pt');
          const minor = Math.max(5, tSize-4);
          Array.from(songs.querySelectorAll('.key,.time,.no')).forEach(d=> d.style.fontSize = minor+'pt');
          if(sheet.scrollHeight<=sheet.clientHeight) return; // fits
          tSize -= 0.3; if(tSize<6) break; // lower bound
        }
  // If still overflowing, reduce subnotes
  let sSize=7;
        for(let i=0;i<8 && sheet.scrollHeight>sheet.clientHeight;i++){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=> d.style.fontSize = sSize+'pt');
          sSize -= 0.3; if(sSize<5) break;
        }
        // Reduce vertical gaps/padding progressively
        const gapSteps=['2px','1px','0px'];
        for(const g of gapSteps){
          if(sheet.scrollHeight<=sheet.clientHeight) break;
          songs.style.gap=g;
          Array.from(songs.querySelectorAll('.line')).forEach(d=> d.style.padding = (g==='0px'?'0px 0':'1px 0'));
        }
        // Shrink break banners
        if(sheet.scrollHeight>sheet.clientHeight){
          let bSize=10;
          for(let i=0;i<6 && sheet.scrollHeight>sheet.clientHeight;i++){
            bSize-=0.5; if(bSize<6) break;
            Array.from(songs.querySelectorAll('.break')).forEach(d=>{ d.style.fontSize=bSize+'pt'; d.style.padding='2px 4px'; });
          }
        }
        // If still overflowing, elide subnotes text more aggressively
        if(sheet.scrollHeight>sheet.clientHeight){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=>{
            if(d.textContent.length>25) d.textContent=d.textContent.slice(0,22)+'‚Ä¶';
          });
        }
        // Shrink total time footer
        if(sheet.scrollHeight>sheet.clientHeight && totalEl){
          totalEl.style.fontSize='7pt';
          totalEl.style.marginTop='0px';
          totalEl.style.paddingTop='1px';
        }
        // Last resort: shrink everything more for setlists <=35 songs
        if(sheet.scrollHeight>sheet.clientHeight && setlist.filter(x=>x.type==='song').length<=35){
          Array.from(songs.querySelectorAll('.title')).forEach(d=>{
            const currentSize=parseFloat(d.style.fontSize)||10;
            if(currentSize>5.5) d.style.fontSize = Math.max(5.5, currentSize-1.2)+'pt';
          });
          Array.from(songs.querySelectorAll('.key,.time,.no')).forEach(d=>{
            const currentSize=parseFloat(d.style.fontSize)||8;
            if(currentSize>4.5) d.style.fontSize = Math.max(4.5, currentSize-0.8)+'pt';
          });
          Array.from(songs.querySelectorAll('.break')).forEach(d=>{
            d.style.fontSize='6pt';
            d.style.padding='1px 2px';
          });
        }
      }
      
      // Attach drag/touch interactions for inline preview
      if(isInline && setlist.length > 0){
        attachPreviewInteractions();
      }
    }
    // Embedded song pool chips (Originals vs Covers) for direct drag into preview
    function renderSongPool(){
      const pO=document.getElementById('poolOriginals');
      const pC=document.getElementById('poolCovers');
      const pB=document.getElementById('poolBreaks');
      const covHdr=document.getElementById('poolCoversHdr');
      const brHdr=document.getElementById('poolBreaksHdr');
      const typeSel=document.getElementById('poolType');
      const sortSel=document.getElementById('poolSort');
      const moodSel=document.getElementById('poolMood');
      const searchInput=document.getElementById('poolSearch');
      if(!pO || !pC) return;
      // Allow dropping items from set back into the pool to remove them
      [pO,pC,pB].forEach(el=>{ if(!el) return; el.addEventListener('dragover',e=> e.preventDefault()); el.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); rebuildPreview(); } } }); });
      pO.innerHTML=''; pC.innerHTML=''; if(pB) pB.innerHTML='';
      if(!db.length){ pO.textContent='No songs.'; pC.textContent=''; return; }
      const usedIds=new Set(setlist.filter(x=>x.type==='song').map(x=>x.id));
      const typeVal=(typeSel && typeSel.value) || 'all';
      const sortVal=(sortSel && sortSel.value) || 'alpha';
      const moodVal=(moodSel && moodSel.value) || 'all';
      const searchTerm=(searchInput && searchInput.value) || '';

      const songMood=(s)=> s.isUpbeat? 'upbeat' : s.isHappy? 'happy' : s.isEnergetic? 'energetic' : s.isMellow? 'mellow' : s.isSad? 'sad' : ((s.customMoods||[])[0] || 'none');
      const moodRank={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:5}; getAllMoods().forEach((m,i)=>{ if(!(m in moodRank)) moodRank[m]=6+i; });
      const moodMatch=(s)=> moodVal==='all' || songMood(s)===moodVal;
      const searchMatch=(s)=>{
        if(!searchTerm) return true;
        try{
          const regex = new RegExp(searchTerm, 'i');
          return regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||'');
        }catch(e){
          const term=searchTerm.toLowerCase();
          return (s.title||'').toLowerCase().includes(term) || (s.artist||'').toLowerCase().includes(term) || (s.composer||'').toLowerCase().includes(term) || (s.lyrics||'').toLowerCase().includes(term);
        }
      };
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (moodRank[songMood(a)] - moodRank[songMood(b)]) || a.title.localeCompare(b.title);
      const applySort=(arr,isCover)=>{
        if(sortVal==='band') return (isCover? arr.sort(byBand) : arr.sort(byAlpha));
        if(sortVal==='mood') return arr.sort(byMood);
        return arr.sort(byAlpha);
      };

      let originals=db.filter(s=>!s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      let covers=db.filter(s=>s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      originals=applySort(originals,false);
      covers=applySort(covers,true);

      // Toggle visibility based on type filter
      const showOriginals = typeVal==='all' || typeVal==='originals';
      const showCovers    = typeVal==='all' || typeVal==='covers';
      pO.style.display = showOriginals? 'flex':'none';
      if(covHdr) covHdr.style.display = showCovers? '' : 'none';
      pC.style.display = showCovers? 'flex':'none';
      if(brHdr) brHdr.style.display=''; if(pB) pB.style.display='flex'; // always show break section

      const hueFromStr=(str)=>{ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h%360; };
      const makeChip=(s)=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.setAttribute('draggable','true'); chip.style.cursor='grab'; chip.dataset.id=s.id;
        const moodClass = s.isUpbeat ? 'mood-upbeat'
          : s.isHappy ? 'mood-happy'
          : s.isEnergetic ? 'mood-energetic'
          : s.isMellow ? 'mood-mellow'
          : s.isSad ? 'mood-sad'
          : ((s.customMoods||[]).length ? 'mood-custom' : '');
        if(moodClass) chip.classList.add(moodClass);
        // Custom mood color (use first custom mood)
        if(!s.isUpbeat && !s.isHappy && !s.isEnergetic && !s.isMellow && !s.isSad && (s.customMoods||[]).length){
          const key=(s.customMoods||[])[0]; const h=hueFromStr(key);
          chip.style.backgroundColor = `hsl(${h} 90% 95%)`;
          chip.style.borderColor = `hsl(${h} 60% 80%)`;
          chip.style.color = '#0f172a';
        }
        const showArtist = s.isCover && s.artist && s.artist!=='Original';
        chip.textContent = showArtist ? `${s.artist} - ${s.title}` : s.title;
        chip.title=`${s.artist} ‚Ä¢ ${s.length}m${s.key? ' ‚Ä¢ '+s.key:''}`;
        chip.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/plain', String(s.id)); });
        chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; activePoolTouch={kind:'song', id:s.id, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
        chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
        return chip;
      };
      if(showOriginals){
        if(!originals.length) pO.textContent = 'No songs.'; else originals.forEach(s=> pO.appendChild(makeChip(s)));
      }
      if(showCovers){
        if(!covers.length) pC.textContent = showOriginals? '' : 'No songs.'; else covers.forEach(s=> pC.appendChild(makeChip(s)));
      }
      if(pB){
        const len = parseFloat((document.getElementById('gBreakLen') && document.getElementById('gBreakLen').value) || gig.breakLen || 15);
        const makeEventChip=(label, kind, hint='')=>{
          const chip=document.createElement('div'); chip.className='pill'; chip.style.cursor='grab'; chip.setAttribute('draggable','true'); chip.textContent= hint? `${label} (${hint})` : label;
          chip.addEventListener('dragstart',e=>{ if(kind==='break'){ e.dataTransfer.setData('text/x-break', String(len)); } else { e.dataTransfer.setData('text/x-event', JSON.stringify({kind})); } });
          chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; const payload=(kind==='break')? {kind:'break', length:len} : {kind:'event', event:{kind}}; activePoolTouch={...payload, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
          chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
          return chip;
        };
        pB.appendChild(makeEventChip(`Break (${len}m)`, 'break'));
        pB.appendChild(makeEventChip('SOUNDCHECK', 'soundcheck'));
        pB.appendChild(makeEventChip('ENCORE', 'encore'));
        pB.appendChild(makeEventChip('INTERMISSION', 'intermission'));
        pB.appendChild(makeEventChip('ANNOUNCEMENT', 'announcement'));
        pB.appendChild(makeEventChip('CUSTOM‚Ä¶', 'custom'));
      }
    }
    function renderEncore(){
      const enc=document.getElementById('encoreList'); if(!enc) return; enc.innerHTML='';
      const idxHeader=setlist.findIndex(x=>x.type==='encore');
      if(idxHeader===-1){ enc.textContent='(none)'; return; }
      const encoreSongs=setlist.slice(idxHeader+1).filter(x=>x.type==='song');
      if(!encoreSongs.length){ enc.textContent='(none)'; return; }
      encoreSongs.forEach(s=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.textContent=s.title; chip.title=`${s.artist} ‚Ä¢ ${s.length}m`; const rm=document.createElement('button'); rm.className='add'; rm.textContent='Remove'; rm.onclick=()=>{ // remove only this encore song
          const pos=setlist.findIndex(x=>x.id===s.id && x.type==='song'); if(pos>-1){
            setlist.splice(pos,1);
            // If encore header becomes orphaned (no songs after it), remove just that header
            if(idxHeader>-1){ const anyAfter=setlist.slice(idxHeader+1).some(x=>x.type==='song'); if(!anyAfter){ setlist.splice(idxHeader,1); } }
            rebuildPreview(); saveAll();
          }
        }; chip.appendChild(rm); enc.appendChild(chip);
      });
    }
    // New drop handling directly on preview songs area
    const previewSongs=document.getElementById('songsInline');
    function rebuildPreview(){ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll(); try{ pushAppHistory('rebuildPreview'); }catch(_){ } }
    function attachPreviewInteractions(){
      const songs=document.getElementById('songsInline');
      if(!songs) return;
      // Mark lines and breaks draggable
      songs.querySelectorAll('.line, .break').forEach((row,i)=>{
        row.setAttribute('draggable','true');
        row.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/x-set-index', String(i)); });
        // Double-click to edit notes (only songs)
        if(row.classList.contains('line')){
          const titleDiv=row.querySelector('.title');
          if(titleDiv){ titleDiv.addEventListener('dblclick',()=>{
            const entry=setlist[i]; if(!entry || entry.type!=='song') return; const val=prompt('Notes for '+entry.title, entry.notes||''); if(val!=null){ entry.notes=val.trim(); rebuildPreview(); }
          }); }
        }
        // Touch drag out to remove (simple remove gesture)
        row.style.touchAction='none';
        row.addEventListener('touchstart',ev=>{
          const t=ev.touches[0]; if(!t) return; window._activeSetTouch={ idx:i, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY, removed:false, reorderTarget:i }; row.classList.add('drag-touch'); ev.preventDefault();
        }, {passive:false});
        row.addEventListener('touchmove',ev=>{
          const act=window._activeSetTouch; if(!act) return; for(const t of ev.touches){ if(t.identifier!=null){ act.x=t.clientX; act.y=t.clientY; break; } }
          // Determine potential reorder target if still inside sheet
          const sheet=document.getElementById('sheetInline'); if(sheet){ const rect=sheet.getBoundingClientRect(); if(act.x>=rect.left && act.x<=rect.right && act.y>=rect.top && act.y<=rect.bottom){
              const rows=[...sheet.querySelectorAll('.line, .break')];
              let targetIndex=rows.length; for(let k=0;k<rows.length;k++){ const r=rows[k].getBoundingClientRect(); if(act.y < (r.top + r.height/2)){ targetIndex=k; break; } else if(k===rows.length-1 && act.y >= (r.top + r.height/2)){ targetIndex=rows.length; break; } }
              act.reorderTarget=targetIndex;
              const showBefore=targetIndex<rows.length; rows.forEach((rEl,ri)=>{ rEl.classList.toggle('drop-before', showBefore && ri===targetIndex); rEl.classList.toggle('drop-after', !showBefore && ri===rows.length-1); });
            } else {
              // outside: clear indicators
              [...sheet.querySelectorAll('.line, .break')].forEach(rEl=> rEl.classList.remove('drop-before','drop-after'));
            }
          }
          ev.preventDefault();
        }, {passive:false});
        row.addEventListener('touchend',()=> row.classList.remove('drag-touch'));
      });
    }
    // Setup drop handlers on preview songs area (using fresh query each time since element recreated)
    (function setupPreviewDropHandlers(){
      const songs=document.getElementById('songsInline');
      if(!songs) return;
      songs.addEventListener('dragover',e=> e.preventDefault());
      songs.addEventListener('drop',e=>{
        e.preventDefault(); e.stopPropagation(); const br=e.dataTransfer.getData('text/x-break');
        const allRows=[...songs.querySelectorAll('.line, .break')];
        const getInsertIndex=(clientY)=>{ if(allRows.length===0) return 0; for(let i=0;i<allRows.length;i++){ const r=allRows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return allRows.length; };
        const insertAt=getInsertIndex(e.clientY);
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const idRaw=e.dataTransfer.getData('text/plain'); const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ // reorder existing
          const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= fromIdx<insertAt? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); }
          return;
        }
        if(!idRaw) return; if(idRaw==='__break__') return; const id=parseInt(idRaw,10); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    })();

    // Global touchend listener for removing rows by dragging them out of sheet
    window.addEventListener('touchend',()=>{
      const act=window._activeSetTouch; if(!act) return; const sheet=document.getElementById('sheetInline'); if(!sheet){ window._activeSetTouch=null; return; }
      const rect=sheet.getBoundingClientRect(); const outside = act.x < rect.left-30 || act.x > rect.right+30 || act.y < rect.top-30 || act.y > rect.bottom+30; // larger margin for removal gesture
      if(outside){ const idx=act.idx; if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); rebuildPreview(); saveAll(); } }
      else {
        // inside: perform reorder if target different
        const from=act.idx; const to=act.reorderTarget; if(Number.isInteger(from) && Number.isInteger(to) && from!==to && from>=0 && to>=0 && from<setlist.length && to<=setlist.length){ const item=setlist.splice(from,1)[0]; const adj = (from<to) ? to-1 : to; setlist.splice(adj,0,item); rebuildPreview(); saveAll(); }
      }
      window._activeSetTouch=null;
    }, {passive:true});
    // Allow dropping anywhere on the page area (sheet background/whitespace), including when blank
    const sheetInline=document.getElementById('sheetInline');
    if(sheetInline){
      sheetInline.addEventListener('dragover',e=> e.preventDefault());
      sheetInline.addEventListener('drop',e=>{
        e.preventDefault();
        // If drop hit songs container, the other handler already handled; but duplicate logic is harmless
        const rowsCont=document.getElementById('songsInline');
        const allRows= rowsCont ? [...rowsCont.querySelectorAll('.line, .break')] : [];
        const getInsertIndex=(clientY)=>{ if(allRows.length===0) return 0; for(let i=0;i<allRows.length;i++){ const r=allRows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return allRows.length; };
        const insertAt=getInsertIndex(e.clientY);
        const br=e.dataTransfer.getData('text/x-break');
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= (fromIdx<insertAt) ? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); } return; }
        const idRaw=e.dataTransfer.getData('text/plain'); if(!idRaw || idRaw==='__break__') return; const id=parseInt(idRaw,10); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    }
    // Pool open/close and drop-to-remove
    const openPoolBtn=document.getElementById('openPool');
    const closePoolBtn=document.getElementById('closePool');
    const poolFly=document.getElementById('songPoolFlyout');
    const poolCol=document.getElementById('poolCol');
    function positionPool(){
      if(!poolFly) return;
      const setCard=document.getElementById('set'); if(!setCard) return;
      const rect=setCard.getBoundingClientRect();
      const left=Math.min(window.innerWidth - poolFly.offsetWidth - 12, rect.right + 12);
      const top=Math.max(12, rect.top);
      poolFly.style.left=left+"px"; poolFly.style.top=top+"px";
      poolFly.style.right=""; // ensure left-based positioning
      poolFly.style.height = Math.min(window.innerHeight - top - 20, 720) + 'px';
    }
    // Removed openPool button usage (embedded pool); keep flyout logic if still present elsewhere
    if(closePoolBtn && poolFly){ closePoolBtn.addEventListener('click',()=> poolFly.classList.remove('open')); }
    window.addEventListener('scroll',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); }, {passive:true});
    window.addEventListener('resize',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); });
    if(poolFly){
      poolFly.addEventListener('dragover',e=> e.preventDefault());
      poolFly.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); // remove ONLY dragged item
        // If encore header now orphaned (no songs after it) remove header only
        const encIdx=setlist.findIndex(x=>x.type==='encore'); if(encIdx>-1){ const anyAfter=setlist.slice(encIdx+1).some(x=>x.type==='song'); if(!anyAfter){ setlist.splice(encIdx,1); } }
        rebuildPreview(); saveAll(); }
        }
      });
    }
    // Also allow dropping onto the embedded pool column to remove from set
    if(poolCol){
      poolCol.addEventListener('dragover',e=> e.preventDefault());
      poolCol.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); rebuildPreview(); } } });
    }
    // Initial pool render (kept ready; open with button)
    // Hook pool controls if present
    const poolType=document.getElementById('poolType');
    const poolSort=document.getElementById('poolSort');
    const poolMood=document.getElementById('poolMood');
    const poolSearch=document.getElementById('poolSearch');
    if(poolType) poolType.addEventListener('change', renderSongPool);
    if(poolSort) poolSort.addEventListener('change', renderSongPool);
    if(poolMood) poolMood.addEventListener('change', renderSongPool);
    if(poolSearch) poolSearch.addEventListener('input', renderSongPool);
    renderSongPool();

    // Hook DB controls
    (function(){
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const addBtn=document.getElementById('addMoodBtn');
      if(sSel) sSel.addEventListener('change', renderDB);
      if(searchInput) searchInput.addEventListener('input', renderDB);
      // Hook all filter checkboxes
      ['filterCovers','filterOriginals','filterHasLyrics','filterKaraoke','filterHasAudio','filterHasURL','filterInSet','filterUpbeat','filterHappy','filterEnergetic','filterMellow','filterSad'].forEach(id=>{
        const el=document.getElementById(id);
        if(el) el.addEventListener('change', renderDB);
      });
      if(addBtn) addBtn.addEventListener('click', ()=>{
        const name = prompt('New mood name (max 16 chars).'); if(name==null) return; const n=name.trim(); if(!n){ return; }
        const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
        const all=getAllMoods(); if(all.length>=12){ alert('Max 12 moods reached.'); return; }
        if(DEFAULT_MOODS.includes(key) || (gig.customMoods||[]).includes(key)){ alert('Mood already exists.'); return; }
        gig.customMoods = gig.customMoods || []; gig.customMoods.push(key);
        saveAll();
        renderAddMoodsUI();
        // Add custom mood filter checkbox
        const filterContainer=document.getElementById('customMoodFilters');
        if(filterContainer){
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        }
        renderDB(); renderSongPool();
      });
      // Hydrate custom mood filter checkboxes
      const filterContainer=document.getElementById('customMoodFilters');
      if(filterContainer && gig.customMoods){
        gig.customMoods.forEach(key=>{
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        });
      }
    })();
      // Simplified touch drag for preview-only interface (song/break/event chips)
      let activePoolTouch=null;
      window.addEventListener('touchmove',ev=>{ 
        if(!activePoolTouch) return; 
        const t=ev.touches[0]; 
        if(!t) return; 
        activePoolTouch.x=t.clientX; 
        activePoolTouch.y=t.clientY; 
        // Show visual drop indicator
        const preview=document.getElementById('songsInline');
        const sheetInline=document.getElementById('sheetInline');
        if(preview){
          const rows=[...preview.querySelectorAll('.line, .break')];
          // Check both preview content area and full sheet for better drop zone detection
          const previewRect=preview.getBoundingClientRect();
          const sheetRect=sheetInline ? sheetInline.getBoundingClientRect() : previewRect;
          const inDropZone = (activePoolTouch.x>=sheetRect.left && activePoolTouch.x<=sheetRect.right && activePoolTouch.y>=sheetRect.top && activePoolTouch.y<=sheetRect.bottom);
          if(inDropZone && rows.length>0){
            const getInsertIndex=(clientY)=>{ for(let i=0;i<rows.length;i++){ const r=rows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return rows.length; };
            const targetIdx=getInsertIndex(activePoolTouch.y);
            rows.forEach((r,i)=>{ r.classList.toggle('drop-before', i===targetIdx); r.classList.remove('drop-after'); });
          } else if(inDropZone && rows.length===0){
            // Empty setlist - highlight sheet itself
            if(sheetInline) sheetInline.style.boxShadow='inset 0 0 0 3px #60a5fa';
          } else {
            rows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
            if(sheetInline) sheetInline.style.boxShadow='';
          }
        }
        ev.preventDefault(); 
      }, {passive:false});
      window.addEventListener('touchend',ev=>{
        if(!activePoolTouch) return; 
        const x=activePoolTouch.x, y=activePoolTouch.y; 
        const preview=document.getElementById('songsInline');
        const sheetInline=document.getElementById('sheetInline');
        // Clear drop indicators
        if(preview){ 
          const allRows=[...preview.querySelectorAll('.line, .break')];
          allRows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
        }
        // Clear any visual feedback
        if(sheetInline) sheetInline.style.boxShadow='';
        // Check if dropped on preview area or entire sheet (expand boundaries for easier mobile drops)
        const dropTarget = sheetInline || preview;
        if(dropTarget){ const rect=dropTarget.getBoundingClientRect(); const margin=50; if(x>=rect.left-margin && x<=rect.right+margin && y>=rect.top-margin && y<=rect.bottom+margin){
          const rows=preview ? [...preview.querySelectorAll('.line, .break')] : [];
          const getInsertIndex=(clientY)=>{ if(rows.length===0) return 0; for(let i=0;i<rows.length;i++){ const r=rows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return rows.length; };
          const insertAt=getInsertIndex(y);
          if(activePoolTouch.kind==='song'){ const song=db.find(s=>s.id===activePoolTouch.id); if(song && !setlist.some(sl=>sl.id===song.id)){ setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview(); } }
          else if(activePoolTouch.kind==='break'){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); }
          else if(activePoolTouch.kind==='event'){
            const kind = activePoolTouch.event && activePoolTouch.event.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length; const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview();
            }else if(kind){
              const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview();
            }
          }
        } }
        activePoolTouch=null;
      });
      // Touch reorder legacy removed ‚Äì interactions handled via standard drag & drop in preview.

  // Tech / Stage: Tech Rider table generation synced to setlist (populates inline or fullscreen as available)
    function buildTechTable(){
      const body=$('#techBody'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    function buildTechTableFull(){
      const body=document.getElementById('techBodyFull'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    // Stage Plot: simple B&W draggable glyphs
    const TOOLBOX=[
  {key:'mic', label:'Vocal Mic', svg:'M0 0 h16 v48 h-16z M8 48 a8 8 0 1 0 0.01 0'},
  {key:'monitor', label:'Monitor', svg:'M0 44 l36 -18 v18 l-36 18z'},
  {key:'guitar', label:'Electric Guitar', svg:'M0 0 h16 v32 h-16z M16 10 l30 -8 l3 10 l-30 8z'},
  {key:'bassamp', label:'Bass Amp', svg:'M0 0 h34 v44 h-34z'},
  {key:'keyboard', label:'Keyboard', svg:'M0 0 h60 v16 h-60z M3 2 v12 M8 2 v12 M13 2 v12 M18 2 v12 M23 2 v12 M28 2 v12 M33 2 v12 M38 2 v12 M43 2 v12 M48 2 v12 M53 2 v12 M58 2 v12'},
  {key:'drums', label:'Drums', svg:'M15 20 a14 10 0 1 0 0.01 0 M42 20 a14 10 0 1 0 0.01 0 M28 34 a10 7 0 1 0 0.01 0'},
  {key:'di', label:'DI Box', svg:'M0 0 h40 v18 h-40z'},
      {key:'gtramp', label:'Guitar Amp', svg:'M0 0 h34 v44 h-34z'},
      {key:'label', label:'Custom Label', custom:'label'},
      {key:'rect', label:'Rectangle', custom:'rect'},
    ];

    // Image-based toolbox items (replace emojis)
    // Files must exist alongside index.html
    const ICON_ITEMS=[
      {key:'kick', label:'Kick', src:'Kick.png'},
      {key:'snare', label:'Snare', src:'Snare.png'},
      {key:'hihat', label:'Hat', src:'Hihat.png'},
      {key:'tom', label:'Tom', src:'Tom.png'},
      {key:'floor', label:'Floor Tom', src:'Floor.png'},
      {key:'overhead', label:'Instrument Mic', src:'Overhead.png'},
      {key:'crash', label:'Crash', src:'Crash.png'},
      {key:'cymbal1', label:'Crash 2', src:'Cymbal_1.png'},
      {key:'cymbal2', label:'Crash 3', src:'Cymbal_2.png'},
      // Gap then guitars
      {key:'bass', label:'Bass Guitar', src:'Bass.png'},
      {key:'bassamp', label:'Bass Amp', src:'Bassamp.png'},
      {key:'electric', label:'Electric Guitar', src:'Electric.png'},
      {key:'combo', label:'Gtr Combo', src:'Combo.png'},
      {key:'stack', label:'Gtr Stack', src:'Stack.png'},
      // Gap then vocal/stereo/DI
      {key:'vocal', label:'Vocal Mic', src:'Vocal%20Mic.png'},
      {key:'stereoPair', label:'Stereo Pair', src:'Stereo%20Pair.png'},
      {key:'di', label:'DI', src:'DI.png'},
      // Gap then sampler/laptop/power
      {key:'sampler', label:'Sampler', src:'Sampler.png'},
      {key:'laptop', label:'Laptop', src:'Laptop.png'},
      {key:'power', label:'Power', src:'Power.png'},
      // Gap then other instruments
      {key:'acoustic', label:'Acoustic', src:'Acoustic.png'},
      {key:'violin', label:'Violin', src:'Violin.png'},
      {key:'banjo', label:'Banjo', src:'Banjo.png'},
      {key:'clarinet', label:'Clarinet', src:'Clarinet.png'},
      {key:'bongoes', label:'Bongoes', src:'Bongoes.png'},
      {key:'congas', label:'Congas', src:'Congas.png'},
      {key:'deck', label:'Deck', src:'Deck.png'},
      {key:'keys', label:'Keys', src:'keys.png'},
      {key:'sax', label:'Sax', src:'sax.png'},
      {key:'fxpedal', label:'FX Pedal', src:'FXpedal.png'},
      {key:'fxboard', label:'FX Board', src:'FXboard.png'},
      // Gap then props
      {key:'tipjar', label:'Tip Jar', src:'Tipjar.png'},
      {key:'table', label:'Table', src:'Table.png'},
      {key:'stool', label:'Stool', src:'Stool.png'},
      {key:'fan', label:'Fan', src:'Fan.png'},
      // Gap then monitors
      {key:'monitor', label:'Monitor', src:'Monitor.png'},
    ];
    // Sequence with explicit gaps using special token '__gap__'
    const TOOL_ORDER=[
      'kick','snare','hihat','tom','floor','overhead','crash','cymbal1','cymbal2','__gap__',
      'bass','bassamp','electric','combo','stack','__gap__',
      'vocal','stereoPair','di','__gap__',
      'sampler','laptop','power','__gap__',
      'acoustic','violin','banjo','clarinet','bongoes','congas','deck','keys','sax','fxpedal','fxboard','__gap__',
      'tipjar','table','stool','fan','__gap__',
      'monitor'
    ];

    // Type mapping for routing logic
    const TYPE_MAP={
      acoustic:'acoustic', banjo:'acoustic', violin:'acoustic',
      electric:'electric', combo:'amp', stack:'amp', bassamp:'amp', bass:'electric',
      vocal:'mic', overhead:'mic', stereoPair:'mic', hihat:'drum', hihat2:'drum', kick:'drum', snare:'drum', tom:'drum', floor:'drum',
      crash:'cymbal', cymbal1:'cymbal', cymbal2:'cymbal', bongoes:'drum', congas:'drum',
      deck:'deck', sampler:'sampler', laptop:'sampler',
      keys:'keys', sax:'sax', fxpedal:'fx', fxboard:'fx',
      di:'di',
      monitor:'monitor',
      power:'utility', fan:'utility', table:'utility', stool:'utility', tipjar:'utility'
    };

    // Allowed routing targets by source type (routeTo). 'channel' is represented by selecting a channel directly, not via routeTo.
    const ROUTE_TARGETS={
      drum:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','monitor'], // can connect to everything except utility
      cymbal:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','monitor'],
      mic:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'], // mics can NOT connect to other mics
      di:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // can connect to everything except utility
      fx:['di','channel','sampler','fx','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // FX intermediates can connect between any items
      amp:['mic','di','channel','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'], // amps can connect to mics
      acoustic:['di','mic','channel','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      electric:['fx','amp','di','channel','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      deck:['fx','di','channel','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      sampler:['fx','di','channel','sampler','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      keys:['sampler','di','mic','channel','fx','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      sax:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      monitor:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      other:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // custom can connect to anything
    };

    // Effective per-node targets (adds key-specific rules, e.g., bass amp can go direct to channel)
    function effectiveTargets(node){
      const base=(ROUTE_TARGETS[node.dataset.type||'other']||[]).slice();
      const key=node.dataset.key||'';
      if((node.dataset.type||'')==='amp'){
        if(key==='bassamp'){ // bass amps can feed DI or mic or direct channel (via built-in DI out)
          if(!base.includes('di')) base.push('di');
          if(!base.includes('mic')) base.push('mic');
          if(!base.includes('channel')) base.push('channel');
        } else { // guitar amps must only go to mics
          return ['mic'];
        }
      }
      return base;
    }

    // Items considered processors (appear prioritized at top of legend)
    const PRIORITY_TYPES=new Set(['di','fx','amp','sampler']);

    function buildTools(){
      ['stageTools','stageToolsFull'].forEach(cid=>{
        const tools=document.getElementById(cid);
        if(!tools) return;
        tools.innerHTML='';
        const byKey=new Map(ICON_ITEMS.map(i=>[i.key,i]));
        // Show All button if any hidden
        const hidden=(gig.hiddenIcons||[]);
        const actions=document.createElement('div'); actions.className='toolbox-actions';
        if(hidden.length){
          const showAllBtn=document.createElement('button'); showAllBtn.className='tool'; showAllBtn.textContent='Show All Icons';
          showAllBtn.addEventListener('click',()=>{ gig.hiddenIcons=[]; saveAll(); buildTools(); });
          actions.appendChild(showAllBtn);
        }
        if(cid==='stageToolsFull') tools.appendChild(actions);
        TOOL_ORDER.forEach(k=>{
          if(k==='__gap__'){ const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='8px'; gap.style.borderTop='1px solid #e5e7eb'; gap.style.margin='4px 0'; tools.appendChild(gap); return; }
          const t=byKey.get(k); if(!t) return;
          if((gig.hiddenIcons||[]).includes(k)) return; // skip hidden
          const b=document.createElement('button');
          b.className='tool';
          b.innerHTML=`<img src="${t.src}" alt="${t.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${t.label}`;
          b.setAttribute('draggable','true');
          let dragUsed = false;
          b.addEventListener('dragstart',ev=>{ dragUsed = false; ev.dataTransfer.effectAllowed='copy'; ev.dataTransfer.setData('text/plain', t.key); });
          b.addEventListener('dragend',ev=>{ dragUsed = false; });
          b.dataset.getDragUsed = ()=> dragUsed;
          b.dataset.setDragUsed = ()=> { dragUsed = true; };
          b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:t.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
          // Long press (~1s) to hide icon: only when cursor/finger stays put
          let lpTimer=null; let startPos=null; const cancel=()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } startPos=null; };
          const arm=(sx,sy)=>{ cancel(); startPos={x:sx,y:sy}; lpTimer=setTimeout(()=>{
            if(!startPos) return; // was cancelled by movement or release
            if(!confirm('Hide this tool from the toolbox?')) return;
            if((gig.hiddenIcons||[]).indexOf(t.key)===-1){ gig.hiddenIcons.push(t.key); saveAll(); buildTools(); }
          },1000); };
          b.addEventListener('mousedown',e=>{ if(e.button!==0) return; arm(e.clientX,e.clientY); });
          b.addEventListener('mousemove',e=>{ if(!lpTimer||!startPos) return; const dx=Math.abs(e.clientX-startPos.x), dy=Math.abs(e.clientY-startPos.y); if(dx>2||dy>2) cancel(); });
          b.addEventListener('mouseup',cancel);
          b.addEventListener('mouseleave',cancel);
          b.addEventListener('touchstart',e=>{ const tTouch=e.touches[0]; if(!tTouch) return; arm(tTouch.clientX,tTouch.clientY); }, {passive:true});
          b.addEventListener('touchmove',e=>{ if(!lpTimer||!startPos) return; const tTouch=e.touches[0]; if(!tTouch) return; const dx=Math.abs(tTouch.clientX-startPos.x), dy=Math.abs(tTouch.clientY-startPos.y); if(dx>4||dy>4) cancel(); }, {passive:true});
          b.addEventListener('touchend',cancel);
          b.addEventListener('touchcancel',cancel);
          tools.appendChild(b);
        });
        // Custom images always at bottom of full toolbox
        if(cid==='stageToolsFull'){
          if((gig.customImages||[]).length){
            const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='10px'; gap.style.borderTop='2px dashed #d1d5db'; gap.style.margin='6px 0'; tools.appendChild(gap);
          }
          (gig.customImages||[]).forEach(imgObj=>{
            const wrap=document.createElement('div'); wrap.style.position='relative';
            const b=document.createElement('button'); b.className='tool'; b.style.paddingRight='26px';
            b.innerHTML=`<img src="${imgObj.data}" alt="${imgObj.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${imgObj.label}`;
            b.setAttribute('draggable','true'); b.dataset.key=imgObj.key;
            b.addEventListener('dragstart',ev=>{ ev.dataTransfer.effectAllowed='copy'; ev.dataTransfer.setData('text/plain', imgObj.key); });
            b.style.touchAction='none';
            b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:imgObj.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
            const del=document.createElement('button'); del.textContent='√ó'; del.title='Remove'; del.style.position='absolute'; del.style.top='2px'; del.style.right='2px'; del.style.width='20px'; del.style.height='20px'; del.style.lineHeight='16px'; del.style.padding='0'; del.style.fontSize='14px'; del.style.background='#374151'; del.style.color='#fff'; del.style.border='none'; del.style.borderRadius='4px'; del.style.cursor='pointer';
            del.addEventListener('click',()=>{ if(!confirm('Delete custom icon?')) return; gig.customImages = (gig.customImages||[]).filter(ci=>ci.key!==imgObj.key); saveAll(); buildTools(); rebuildCustomImages(); });
            wrap.appendChild(b); wrap.appendChild(del); tools.appendChild(wrap);
          });
        }
      });
    }
    buildTools();

    let _suppressBgClick=false;
    // Ensure arrow marker exists in SVG for arrow drawing
    function ensureStageMarkers(svg){ if(!svg) return; let defs=svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
      if(!svg.querySelector('marker#arrowHead')){
        const m=document.createElementNS('http://www.w3.org/2000/svg','marker'); m.setAttribute('id','arrowHead'); m.setAttribute('markerWidth','8'); m.setAttribute('markerHeight','8'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto');
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d','M0,0 L8,3 L0,6 Z'); p.setAttribute('fill','#000'); m.appendChild(p); defs.appendChild(m);
      }
    }

    function refreshStageHeader(){
      const text=`${(gig.band||'Band').trim()} ‚Ä¢ ${(gig.date||'Date')}`;
      const elT=document.getElementById('stageTitle'); if(elT) elT.textContent=text;
      const elTF=document.getElementById('stageTitleFull'); if(elTF) elTF.textContent=text;
    }

    // Note: small stage removed; glyphs are added via fullscreen only

    let _nextStageId=1;
    function addGlyphFull(key, at){
      const iconSpec=ICON_ITEMS.find(x=>x.key===key);
      const customSpec=(gig.customImages||[]).find(ci=>ci.key===key);
      const svg=document.getElementById('stageSvgFull');
      const g=document.createElementNS('http://www.w3.org/2000/svg','g');
      const x = (at && typeof at.x==='number') ? at.x : 100, y = (at && typeof at.y==='number') ? at.y : 120;
      // Compute initial scale so the visible icon is ~100px wide on screen
      const vbw = (svg && svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) ? svg.viewBox.baseVal.width : 1500;
      const pxPerUnit = svg ? (svg.getBoundingClientRect().width / vbw) : (1000/1500);
      const targetPx = (key==='tom' ? 50 : 100); const baseUnits = 60; // image width set below; toms default to 50% size
      let initScale = targetPx / (baseUnits * Math.max(0.01, pxPerUnit));
      initScale = Math.max(0.3, Math.min(5, initScale));
      g.dataset.x=String(x); g.dataset.y=String(y); g.dataset.scale=String(initScale);
      g.dataset.key=key; g.dataset.channel=g.dataset.channel||'';
      g.dataset.id=String(_nextStageId++);
      const type=TYPE_MAP[key]||'other';
      g.dataset.type=type;
      g.dataset.showLabel='0'; // default hidden
      g.setAttribute('data-draggable','1');
      // Auto-assign next channel for common sources (drums, mics)
      const autoTypes=new Set(['drum','mic']);
      const canChannel=(ROUTE_TARGETS[type]||[]).includes('channel');
      if(autoTypes.has(type) && canChannel){
        const existing=getStageGroups();
        const assigned=existing.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
        const next=(assigned.length? Math.max(...assigned):0)+1;
        g.dataset.channel=String(next);
      }
      if(customSpec){
        const img=document.createElementNS('http://www.w3.org/2000/svg','image');
        img.setAttribute('href', customSpec.data);
        img.setAttributeNS('http://www.w3.org/1999/xlink','href', customSpec.data);
        img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=customSpec.label; label.style.display='none'; g.appendChild(label);
        // Removed intrinsic autoscale override; initial scale already targets ~100px visual size.
      } else if(iconSpec){
        // Place icon image centered; no background rectangle (transparent icons expected)
  const img=document.createElementNS('http://www.w3.org/2000/svg','image');
  // set both href and xlink:href for compatibility
  img.setAttribute('href', iconSpec.src);
  img.setAttributeNS('http://www.w3.org/1999/xlink','href', iconSpec.src);
  img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=iconSpec.label;
        label.style.display='none';
        g.appendChild(label);
      }else{
        const spec=TOOLBOX.find(x=>x.key===key); if(!spec) return;
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', toPath(spec.svg));
        path.setAttribute('fill','none');
        path.setAttribute('stroke','#000');
        path.setAttribute('stroke-width','2');
        g.appendChild(path);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','58'); label.setAttribute('font-size','14'); label.setAttribute('data-role','label'); label.textContent=spec.label;
        label.style.display='none';
        g.appendChild(label);
      }
      applyTransform(g);
      svg.appendChild(g);
      enableSvgDrag(g);
      selectNode(g); // immediately select newly added item for quick edits
      // focus name field so user can rename right away (skip on mobile to avoid keyboard popup)
      const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
      if(!isMobile){
        const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); if(nameInp.select) nameInp.select(); }
      }
      refreshStageLegend(); saveAll(); snapshotStage();
      return g;
    }

    function toPath(simple){
      // simple mini-language passthrough for small glyphs (already path commands)
      return simple;
    }

    // Helper: connect source->target if allowed, otherwise try reverse
    function connectEitherDirection(source, target){
      if(!source || !target || source===target) return false;
      
      // Determine connection priority based on type hierarchy: instruments ‚Üí amps ‚Üí mics ‚Üí channels
      const getConnectionPriority=(node)=>{
        const type=node.dataset.type||'other';
        if(type==='acoustic' || type==='electric' || type==='keys' || type==='sax' || type==='deck' || type==='drum' || type==='cymbal') return 0; // instruments
        if(type==='amp') return 1; // amps
        if(type==='mic') return 2; // mics
        if(type==='di') return 1.5; // DI
        if(type==='fx') return 1.7; // FX
        if(type==='sampler') return 0.5; // samplers
        return 3; // others/endpoints
      };
      
      const sPriority=getConnectionPriority(source);
      const tPriority=getConnectionPriority(target);
      const sAllowed=effectiveTargets(source);
      const tAllowed=effectiveTargets(target);
      const sCanTarget=sAllowed.includes(target.dataset.type||'other');
      const tCanTarget=tAllowed.includes(source.dataset.type||'other');
      
      // If both directions are valid, choose based on priority (lower priority ‚Üí higher priority)
      if(sCanTarget && tCanTarget){
        if(sPriority < tPriority){ 
          // source has lower priority (e.g., amp) and target has higher priority (e.g., mic)
          source.dataset.routeTo=target.dataset.id; 
          return true; 
        } else { 
          // target has lower priority, so target routes to source
          target.dataset.routeTo=source.dataset.id; 
          return true; 
        }
      }
      
      // Only one direction is valid
      if(sCanTarget){ source.dataset.routeTo=target.dataset.id; return true; }
      if(tCanTarget){ target.dataset.routeTo=source.dataset.id; return true; }
      return false;
    }
    // Helper: find chain endpoint (following valid routeTo)
    function resolveEndpoint(start){
      const svg=start && start.closest && start.closest('svg'); if(!svg) return start;
      const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      let cur=start; const seen=new Set();
      while(cur && !seen.has(cur)){
        seen.add(cur);
        const nid=cur.dataset.routeTo||''; if(!nid) break;
        const nxt=nodes.find(n=> n.dataset.id===nid); if(!nxt) break;
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(nxt.dataset.type||'other')===-1) break;
        cur=nxt;
      }
      return cur||start;
    }
    function nameOf(node){ const t=findText(node); return (t && t.textContent) || (node.dataset.key||'Item'); }
    function maybePromptChannel(endNode){
      try{
        if(!endNode) return;
        const targets=effectiveTargets(endNode);
        if(!targets.includes('channel')) return;
        if(endNode.dataset.channel && String(endNode.dataset.channel).trim()!=='') return;
        const label=nameOf(endNode);
        const ans=prompt('Assign channel for '+label+'? (number)','');
        if(ans==null) return; const v=parseInt(String(ans).trim(),10);
        if(Number.isFinite(v) && v>=1){ endNode.dataset.channel=String(v); saveAll(); refreshStageLegend(); }
      }catch(_){ /* ignore prompt issues */ }
    }
    function autoConnectOnPoint(sourceNode, clientX, clientY){
      if(!sourceNode) return false;
      const prevPE=sourceNode.style.pointerEvents;
      sourceNode.style.pointerEvents='none';
      const el=document.elementFromPoint(clientX, clientY);
      sourceNode.style.pointerEvents=prevPE;
      const target= el && el.closest && el.closest('g[data-draggable]');
      if(!target || target===sourceNode) return false;
      const did=connectEitherDirection(sourceNode, target);
      if(did){ const end=resolveEndpoint(sourceNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); const svg=sourceNode.closest('svg'); if(svg) refreshCables(svg); return true; }
      return false;
    }
    function enableSvgDrag(node){
      function isBottomLayer(node){
        const k=node.dataset.key||'';
        return k==='kick' || k==='gtramp' || k==='bassamp' || k==='stack' || k==='combo';
      }
      function bringToFront(node){
        if(isBottomLayer(node)) return;
        const parent=node.parentNode; if(!parent) return;
        parent.appendChild(node);
      }
      // initialize dataset from existing transform if missing
      initDatasetFromTransform(node);
      let start=null; let orig=null;
      // Long-press cable drag state
      let lpTimer=null; let lpActive=false; let lpLine=null; let lpSource=null; let lpTouchId=null;
        node.addEventListener('mousedown',e=>{ if(e.button===2){ return; } bringToFront(node); start={x:e.clientX,y:e.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); e.preventDefault(); selectNode(node); });
      function move(e){ if(!start) return; var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(e.clientX-start.x)/zoom, dy=(e.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); }
        function up(e){ start=null; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); if(e && typeof e.clientX==='number'){ autoConnectOnPoint(node, e.clientX, e.clientY); } saveAll(); snapshotStage(); }
      // rename on double click (desktop only - avoid on mobile to prevent keyboard popup after drag)
      node.addEventListener('dblclick',()=>{
        const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
        if(isMobile) return; // skip on mobile/tablet
        const txt=findText(node); if(!txt) return; const nv=prompt('Rename item:', txt.textContent||''); if(nv!=null){ txt.textContent=nv; syncInspectorFrom(node); saveAll(); }
      });
      // Touch drag + long-press cable gesture OR disconnect gesture
      let touchId=null;
      node.addEventListener('touchstart',e=>{
        if(touchId!=null) return; const t=e.touches[0]; if(!t) return; touchId=t.identifier; lpTouchId=touchId; start={x:t.clientX,y:t.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; selectNode(node); e.preventDefault();
        lpTimer=setTimeout(()=>{
          if(lpTouchId===touchId){ 
            // Check if item has any connections - if so, disconnect; otherwise start cable drag
            const hasConnection = node.dataset.routeTo || Array.from(node.closest('svg').querySelectorAll('g[data-draggable]')).some(g => g.dataset.routeTo === node.dataset.id);
            if(hasConnection){
              // Disconnect: clear this node's routeTo and any incoming connections
              if(node.dataset.routeTo){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); }
              const svg=node.closest('svg'); if(svg){
                Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(g=>{ if(g.dataset.routeTo===node.dataset.id){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); } });
              }
              saveAll(); refreshStageLegend(); if(svg) refreshCables(svg);
              lpActive=false; lpTimer=null;
            } else {
              // No connection, start cable drag
              const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=start.x; pt.y=start.y; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine=document.createElementNS('http://www.w3.org/2000/svg','line'); lpLine.setAttribute('x1',p.x); lpLine.setAttribute('y1',p.y); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); lpLine.setAttribute('stroke','#000'); lpLine.setAttribute('stroke-width','2'); lpLine.setAttribute('stroke-dasharray','6,4'); lpLine.setAttribute('data-temp','cable'); svg.appendChild(lpLine); lpActive=true; lpSource=node; }
            }
          }
        },300);
      }, {passive:false});
      node.addEventListener('touchmove',e=>{
        if(touchId==null) return; for(const t of e.touches){ if(t.identifier===touchId){
            // cancel long-press if user moves significantly before it triggers
            if(!lpActive && lpTimer){ const dx=Math.abs(t.clientX-start.x), dy=Math.abs(t.clientY-start.y); if(dx>8 || dy>8){ clearTimeout(lpTimer); lpTimer=null; }
            }
            if(lpActive && lpLine){ const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=t.clientX; pt.y=t.clientY; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); } e.preventDefault(); break; }
            var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(t.clientX-start.x)/zoom, dy=(t.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); e.preventDefault(); break; } }
      }, {passive:false});
      node.addEventListener('touchend',e=>{
        if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; }
        if(lpActive){ // finalize cable connection
          if(lpLine){ lpLine.remove(); }
          const touch=e.changedTouches && e.changedTouches[0]; if(touch){ const targetEl=document.elementFromPoint(touch.clientX,touch.clientY); const tgt= targetEl && targetEl.closest && targetEl.closest('g[data-draggable]'); if(tgt && tgt!==lpSource){ const sAllowed=effectiveTargets(lpSource); const tAllowed=effectiveTargets(tgt); if(sAllowed.includes(tgt.dataset.type||'other')){ lpSource.dataset.routeTo=tgt.dataset.id; } else if(tAllowed.includes(lpSource.dataset.type||'other')){ tgt.dataset.routeTo=lpSource.dataset.id; } 
            // Easter egg: Fan connected to vocal mic
            if((lpSource.dataset.key==='fan' && tgt.dataset.key==='vocal') || (tgt.dataset.key==='fan' && lpSource.dataset.key==='vocal')){
              const fanNode = lpSource.dataset.key==='fan' ? lpSource : tgt;
              const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
            }
            saveAll(); refreshStageLegend(); } }
          lpActive=false; lpLine=null; lpSource=null; lpTouchId=null;
        }
        // Auto-connect on drop if released over another component
        const ct=(e.changedTouches && e.changedTouches[0])||null; if(ct){ autoConnectOnPoint(node, ct.clientX, ct.clientY); }
        if(touchId==null) return; let still=false; for(const t of e.touches){ if(t.identifier===touchId){ still=true; break; } } if(!still){ touchId=null; saveAll(); snapshotStage(); }
      });
      node.addEventListener('touchcancel',()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } if(lpLine){ lpLine.remove(); lpLine=null; } lpActive=false; lpSource=null; lpTouchId=null; if(touchId!=null){ touchId=null; saveAll(); }});
      
      // Enable label dragging (independent of parent item)
      enableLabelDrag(node);
    }
    
    function enableLabelDrag(node){
      const lbl=findText(node);
      if(!lbl) return;
      
      let labelStart=null;
      let labelOrig=null;
      const maxOffset=150; // Maximum distance from parent
      
      const clampOffset=(val)=> Math.max(-maxOffset, Math.min(maxOffset, val));
      
      // Mouse drag for label
      lbl.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        if(node.dataset.showLabel!=='1') return; // Only drag if label is shown
        e.stopPropagation(); // Prevent parent drag
        labelStart={x:e.clientX, y:e.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
        document.addEventListener('mousemove',labelMove);
        document.addEventListener('mouseup',labelUp);
        lbl.style.cursor='grabbing';
      });
      
      const labelMove=(e)=>{
        if(!labelStart) return;
        const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
        const dx=(e.clientX-labelStart.x)/zoom;
        const dy=(e.clientY-labelStart.y)/zoom;
        node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
        node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
        applyLabelTransform(node);
        queueSave();
      };
      
      const labelUp=()=>{
        labelStart=null;
        document.removeEventListener('mousemove',labelMove);
        document.removeEventListener('mouseup',labelUp);
        lbl.style.cursor='grab';
        saveAll();
      };
      
      // Touch drag for label
      let labelTouchId=null;
      lbl.addEventListener('touchstart',e=>{
        if(node.dataset.showLabel!=='1') return;
        const t=e.touches[0];
        if(!t || labelTouchId!=null) return;
        e.stopPropagation(); // Prevent parent drag
        labelTouchId=t.identifier;
        labelStart={x:t.clientX, y:t.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
      }, {passive:false});
      
      lbl.addEventListener('touchmove',e=>{
        if(labelTouchId==null) return;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){
            const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
            const dx=(t.clientX-labelStart.x)/zoom;
            const dy=(t.clientY-labelStart.y)/zoom;
            node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
            node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
            applyLabelTransform(node);
            queueSave();
            e.preventDefault();
            break;
          }
        }
      }, {passive:false});
      
      lbl.addEventListener('touchend',e=>{
        if(labelTouchId==null) return;
        let still=false;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){ still=true; break; }
        }
        if(!still){
          labelTouchId=null;
          saveAll();
        }
      });
      
      // Set cursor style when label is draggable
      if(node.dataset.showLabel==='1'){
        lbl.style.cursor='grab';
      }
    }

    // Right-click cable drag connection gesture
    (function setupCableDrag(){
      const svg=document.getElementById('stageSvgFull'); if(!svg) return;
      let cableDrag=null; // {source, x1,y1, line}
      function clientToSvg(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      svg.addEventListener('contextmenu',e=>{ if(e.target.closest('svg#stageSvgFull')){ e.preventDefault(); }});
      let disconnectTimer=null;
      svg.addEventListener('mousedown',e=>{
        if(e.button!==2) return; // only right-click
        const g=e.target.closest && e.target.closest('g[data-draggable]');
        if(!g) return; e.preventDefault();
        // Start disconnect timer - if held for 500ms without movement, disconnect
        const startX=e.clientX, startY=e.clientY;
        disconnectTimer=setTimeout(()=>{
          // Disconnect this item from all connections
          if(g.dataset.routeTo){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); }
          Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(node=>{ if(node.dataset.routeTo===g.dataset.id){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); } });
          saveAll(); refreshStageLegend(); refreshCables(svg);
          disconnectTimer=null;
        },500);
        const p=clientToSvg(e.clientX,e.clientY);
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p.x); line.setAttribute('y1', p.y); line.setAttribute('x2', p.x); line.setAttribute('y2', p.y);
        line.setAttribute('stroke','#000'); line.setAttribute('stroke-width','2'); line.setAttribute('stroke-dasharray','6,4'); line.setAttribute('data-temp','cable');
        svg.appendChild(line);
        cableDrag={source:g, x1:p.x, y1:p.y, line:line, startX:startX, startY:startY};
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });
      function onMove(e){ if(!cableDrag) return; 
        // Cancel disconnect timer if mouse moved significantly
        if(disconnectTimer && cableDrag.startX!=null){
          const dx=Math.abs(e.clientX-cableDrag.startX), dy=Math.abs(e.clientY-cableDrag.startY);
          if(dx>8 || dy>8){ clearTimeout(disconnectTimer); disconnectTimer=null; }
        }
        const p=clientToSvg(e.clientX,e.clientY); cableDrag.line.setAttribute('x2',p.x); cableDrag.line.setAttribute('y2',p.y); }
      function onUp(e){ if(disconnectTimer){ clearTimeout(disconnectTimer); disconnectTimer=null; } if(!cableDrag) return; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp);
        const line=cableDrag.line; const source=cableDrag.source; line.remove();
        // determine drop target
        const el=document.elementFromPoint(e.clientX,e.clientY);
        const target= el && el.closest && el.closest('g[data-draggable]');
        if(target && target!==source){
          const sAllowed=effectiveTargets(source); const tAllowed=effectiveTargets(target);
          if(sAllowed.includes(target.dataset.type||'other')){ source.dataset.routeTo=target.dataset.id; }
          else if(tAllowed.includes(source.dataset.type||'other')){ target.dataset.routeTo=source.dataset.id; }
          // Easter egg: Fan connected to vocal mic
          if((source.dataset.key==='fan' && target.dataset.key==='vocal') || (target.dataset.key==='fan' && source.dataset.key==='vocal')){
            const fanNode = source.dataset.key==='fan' ? source : target;
            const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
          }
          saveAll(); refreshStageLegend();
        }
        cableDrag=null;
      }
    })();

    function initDatasetFromTransform(node){
      if(node.dataset.x && node.dataset.y) return;
      const m=node.transform.baseVal.consolidate();
      const t=m? m.matrix : {e:0,f:0,a:1,d:1};
      node.dataset.x=String(t.e||0);
      node.dataset.y=String(t.f||0);
      // scale approx from matrix a/d
      const s=(t.a&&t.d)? Math.max(1e-3, Math.sqrt(Math.abs(t.a*t.d))) : 1;
      node.dataset.scale=String(s);
      applyTransform(node);
    }

    function applyTransform(node){
      const x=parseFloat(node.dataset.x||'0');
      const y=parseFloat(node.dataset.y||'0');
      const s=parseFloat(node.dataset.scale||'1');
      node.setAttribute('transform',`translate(${x},${y}) scale(${s})`);
    }

  function findText(node){ return node.querySelector('text[data-role="label"]') || node.querySelector('text'); }
  
  // Apply label offset transform (labels can be dragged independently)
  function applyLabelTransform(node){
    const lbl=findText(node);
    if(!lbl) return;
    const offsetX=parseFloat(node.dataset.labelOffsetX||'0');
    const offsetY=parseFloat(node.dataset.labelOffsetY||'0');
    lbl.setAttribute('x',String(offsetX));
    lbl.setAttribute('y',String(offsetY));
    const size=parseInt(node.dataset.labelSize||'16',10);
    lbl.setAttribute('font-size',String(size));
  }

    // selection + inspector
    let selectedNode=null;
    function bindSelection(svg){
        svg.addEventListener('click',ev=>{
          const g=ev.target.closest && ev.target.closest('g[data-draggable]');
          if(g){ selectNode(g); refreshStageLegend(); return; }
          // click on whitespace creates a text label at click position
          const bg=ev.target.closest && ev.target.closest('.stage-bg');
          if(bg){
            if(_suppressBgClick){ _suppressBgClick=false; ev.stopPropagation(); return; }
            const pt=svg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=svg.getScreenCTM().inverse(); const p=pt.matrixTransform(ctm);
            // Ask first; cancel or empty -> do nothing
            let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
            const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(p.x)); gN.dataset.y=String(Math.round(p.y)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
            const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
            applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
            const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); }
            ev.stopPropagation();
            return;
          }
          selectNode(null); refreshStageLegend();
        });
    }
  function ensureSelectionBindings(){ const svg=document.getElementById('stageSvgFull'); if(svg && !svg._boundSel){ bindSelection(svg); svg._boundSel=true; } }
    function selectNode(g){
      // Remove any existing selection highlight across both SVGs
      document.querySelectorAll('#stageSvgFull g[data-draggable].selected, #stageSvg g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      selectedNode=g||null;
      const nameInp=document.getElementById('selName');
      const sizeInp=document.getElementById('selSize');
      const showLabelChk=document.getElementById('selShowLabel');
      const inspector=document.getElementById('stageInspector');
      if(!nameInp||!sizeInp||!inspector) return;
      
      // Clear any existing connection chain display
      const existingChain=inspector.querySelector('.connection-chain');
      if(existingChain) existingChain.remove();
      
      if(!g){ 
        nameInp.value=''; 
        sizeInp.value='1'; 
        if(showLabelChk) showLabelChk.checked=false; 
        return; 
      }
      
      g.classList.add('selected');
      initDatasetFromTransform(g);
      const txt=findText(g); 
      nameInp.value=txt? (txt.textContent||'') : '';
      sizeInp.value=g.dataset.scale||'1';
      if(showLabelChk){ 
        showLabelChk.checked = g.dataset.showLabel==='1'; 
        // Show/hide label size controls
        const labelSizeControls=document.getElementById('labelSizeControls');
        const labelSizeSlider=document.getElementById('selLabelSize');
        if(labelSizeControls){ labelSizeControls.style.display= showLabelChk.checked ? 'flex':'none'; }
        if(labelSizeSlider && showLabelChk.checked){ labelSizeSlider.value=g.dataset.labelSize||'16'; }
      }
      
      // Build connection chain display
      buildConnectionChain(g, inspector);
    }
    
    function buildConnectionChain(selectedItem, inspector){
      const svg=selectedItem.closest('svg');
      if(!svg) return;
      const allNodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      const nameInp=document.getElementById('selName');
      const selLabel=document.getElementById('selLabel');
      
      // Build the complete chain by finding the true start
      const chain=[];
      const visited=new Set();
      
      // Helper: determine type priority for proper chain ordering
      const typePriority=(node)=>{
        const type=node.dataset.type||'other';
        if(type==='acoustic' || type==='electric' || type==='keys' || type==='sax' || type==='deck' || type==='drum' || type==='cymbal') return 0; // instruments/sources
        if(type==='amp') return 1; // amps
        if(type==='mic') return 2; // mics
        if(type==='di') return 1.5; // DI boxes
        if(type==='fx') return 1.7; // FX
        if(type==='sampler') return 0.5; // samplers
        return 3; // others/channel endpoints
      };
      
      // Find the absolute start of the chain by walking backwards from selected item
      const findChainStart=(item)=>{
        const candidates=[];
        const seen=new Set();
        
        // Recursively find all items that route to this item
        const walkBack=(target)=>{
          if(seen.has(target.dataset.id)) return;
          seen.add(target.dataset.id);
          const incoming=allNodes.filter(n=> n.dataset.routeTo===target.dataset.id);
          if(incoming.length===0){
            candidates.push(target); // This is a potential start
          } else {
            incoming.forEach(src=> walkBack(src));
          }
        };
        
        walkBack(item);
        
        // Sort candidates by priority to get the true start (instrument before amp before mic)
        candidates.sort((a,b)=> typePriority(a) - typePriority(b));
        return candidates.length>0 ? candidates[0] : item;
      };
      
      const chainStart = findChainStart(selectedItem);
      
      // Walk forward from the true start to build the COMPLETE chain (don't stop at intermediate items with channels)
      let current=chainStart;
      const maxIterations=50; // safety limit
      let iterations=0;
      while(current && !visited.has(current) && iterations<maxIterations){
        iterations++;
        visited.add(current);
        chain.push(current);
        const nextId=current.dataset.routeTo;
        if(!nextId) break;
        const next=allNodes.find(n=> n.dataset.id===nextId);
        if(!next) break;
        // validate connection is allowed
        const allowed=effectiveTargets(current);
        if(!allowed.includes(next.dataset.type||'other')) break;
        current=next;
      }
      
      // Ensure selected item is in the chain
      if(!chain.includes(selectedItem)){
        chain.push(selectedItem);
      }
      
      // Always use chain display for consistency (even for single items)
      // Hide standard name input
      if(nameInp) nameInp.style.display='none';
      if(selLabel) selLabel.style.display='none';
      
      // Create chain display (single row, no wrap) - ALWAYS shown for consistency
      const chainDiv=document.createElement('div');
      chainDiv.className='connection-chain';
      chainDiv.style.cssText='display:flex;align-items:center;gap:6px;flex-wrap:nowrap;padding:6px 8px;background:#f3f4f6;border-radius:6px;overflow-x:auto;width:100%';
      
      chain.forEach((node,idx)=>{
        const isSelected = node===selectedItem;
        const isLast = idx===chain.length-1;
        
        // Item name field - fixed width for consistency
        const itemInput=document.createElement('input');
        itemInput.type='text';
        itemInput.value=findText(node)?.textContent || node.dataset.key||'Item';
        itemInput.style.cssText=`padding:4px 8px;border:2px solid ${isSelected?'#374151':'#d1d5db'};border-radius:4px;font-size:13px;font-weight:${isSelected?'700':'400'};background:${isSelected?'#e5e7eb':'#fff'};width:120px;flex-shrink:0`;
        itemInput.title='Name: '+itemInput.value;
        itemInput.addEventListener('change',()=>{
          const t=findText(node);
          if(t){ 
            t.textContent=itemInput.value; 
            saveAll(); 
            refreshStageLegend();
            if(node===selectedItem) syncInspectorFrom(node);
          }
        });
        chainDiv.appendChild(itemInput);
        
        // Arrow between items (only if there's actually a connection)
        if(!isLast){
          const arrow=document.createElement('span');
          arrow.textContent='‚Üí';
          arrow.style.cssText='color:#6b7280;font-size:14px;font-weight:bold;flex-shrink:0';
          chainDiv.appendChild(arrow);
        }
      });
      
      // Find which item in the chain can/should have the channel
      // Check all items in chain (backwards) to find one with channel capability
      let channelNode=null;
      
      // First check if any item already has a channel assigned
      for(let i=chain.length-1; i>=0; i--){
        const node=chain[i];
        if(node.dataset.channel && node.dataset.channel!==''){
          channelNode=node;
          break;
        }
      }
      
      // If no channel assigned, check if any item CAN have a channel (prefer last item)
      if(!channelNode){
        for(let i=chain.length-1; i>=0; i--){
          const node=chain[i];
          const targets=effectiveTargets(node);
          if(targets.includes('channel')){
            channelNode=node;
            break;
          }
        }
      }
      
      // ALWAYS add channel field if any item can have one (for consistent formatting)
      if(channelNode){
        const isStereo=(channelNode.dataset.key||'')==='stereoPair';
        const chInput=document.createElement('input');
        chInput.type='number';
        chInput.min='1';
        chInput.max=isStereo?'63':'64';
        chInput.placeholder='Ch';
        chInput.value=channelNode.dataset.channel||'';
        chInput.style.cssText='padding:4px 8px;border:2px solid #10b981;border-radius:4px;font-size:13px;font-weight:700;background:#d1fae5;width:70px;flex-shrink:0';
        chInput.title='Channel number (assigned to '+((findText(channelNode)?.textContent)||'this item')+')';
        
        chInput.addEventListener('change',()=>{
          const newCh=parseInt(chInput.value,10);
          if(!Number.isFinite(newCh) || newCh<1){
            delete channelNode.dataset.channel;
            channelNode.removeAttribute('data-channel');
          } else {
            // Check if channel is taken
            const taken=allNodes.find(n=> n!==channelNode && occupiesChannelHelper(n,newCh));
            if(taken){
              const takenName=findText(taken)?.textContent||'another item';
              if(!confirm(`Channel ${newCh} is used by ${takenName}. Reassign anyway? (This will disconnect ${takenName})`)){
                chInput.value=channelNode.dataset.channel||'';
                return;
              }
              delete taken.dataset.channel;
              taken.removeAttribute('data-channel');
            }
            channelNode.dataset.channel=String(newCh);
          }
          saveAll();
          refreshStageLegend();
          const stageSvg=channelNode.closest('svg');
          if(stageSvg) refreshCables(stageSvg);
        });
        
        chainDiv.appendChild(chInput);
      }
      
      // Insert chain display before the standard name input
      inspector.insertBefore(chainDiv, inspector.firstChild);
    }
    
    function occupiesChannelHelper(node,ch){
      if(!ch) return false;
      const a=parseInt(node.dataset.channel||'0',10);
      if(!a) return false;
      const isStereo=(node.dataset.key||'')==='stereoPair';
      if(isStereo){ return ch===a || ch===a+1; }
      return ch===a;
    }
    function syncInspectorFrom(g){ if(!g) return; const nameInp=document.getElementById('selName'); const sizeInp=document.getElementById('selSize'); if(nameInp){ const txt=findText(g); nameInp.value=txt? (txt.textContent||'') : ''; } if(sizeInp){ sizeInp.value=g.dataset.scale||'1'; } }
  document.getElementById('selName').addEventListener('change',()=>{ if(!selectedNode) return; const t=findText(selectedNode); if(t){ t.textContent=document.getElementById('selName').value; saveAll(); }});
  document.getElementById('selName').addEventListener('change',()=> refreshStageLegend());
  document.getElementById('selSize').addEventListener('input',()=>{ if(!selectedNode) return; const v=parseFloat(document.getElementById('selSize').value); const k=selectedNode.dataset.key||''; if(k==='arrow' || k==='label'){ const lbl=findText(selectedNode); if(lbl){ const base = (k==='arrow')?14:16; const fs=Math.max(8, Math.round(base*v)); lbl.setAttribute('font-size', String(fs)); } } else { selectedNode.dataset.scale=String(v); applyTransform(selectedNode); } saveAll(); });
  document.getElementById('selSize').addEventListener('change',()=>{ saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=>{ if(!selectedNode) return; selectedNode.remove(); selectedNode=null; document.getElementById('selName').value=''; saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=> refreshStageLegend());
  // Show label toggle
  const showLabelChk=document.getElementById('selShowLabel');
  const labelSizeControls=document.getElementById('labelSizeControls');
  const labelSizeSlider=document.getElementById('selLabelSize');
  if(showLabelChk){
    showLabelChk.addEventListener('change',()=>{
      if(!selectedNode) return; 
      selectedNode.dataset.showLabel= showLabelChk.checked ? '1':'0'; 
      const lbl=findText(selectedNode); 
      if(lbl){ 
        lbl.style.display= showLabelChk.checked ? 'block':'none'; 
        // Initialize label offset if not set
        if(!selectedNode.dataset.labelOffsetX) selectedNode.dataset.labelOffsetX='0';
        if(!selectedNode.dataset.labelOffsetY) selectedNode.dataset.labelOffsetY='0';
        if(!selectedNode.dataset.labelSize) selectedNode.dataset.labelSize='16';
        applyLabelTransform(selectedNode);
      }
      // Show/hide label size controls
      if(labelSizeControls){ labelSizeControls.style.display= showLabelChk.checked ? 'flex':'none'; }
      if(labelSizeSlider && showLabelChk.checked){ labelSizeSlider.value=selectedNode.dataset.labelSize||'16'; }
      saveAll(); refreshStageLegend();
    });
  }
  // Label size slider
  if(labelSizeSlider){
    labelSizeSlider.addEventListener('input',()=>{
      if(!selectedNode) return;
      const size=parseInt(labelSizeSlider.value,10);
      selectedNode.dataset.labelSize=String(size);
      const lbl=findText(selectedNode);
      if(lbl){ lbl.setAttribute('font-size',String(size)); }
      saveAll();
    });
  }
  // Duplicate button
  const dupBtn=document.getElementById('dupSel');
  if(dupBtn){ dupBtn.addEventListener('click',()=>{
    if(!selectedNode) return;
    const clone=selectedNode.cloneNode(true);
    const svg=selectedNode.closest('svg');
    initDatasetFromTransform(clone);
    clone.dataset.x=String(parseFloat(clone.dataset.x||'0')+40);
    clone.dataset.y=String(parseFloat(clone.dataset.y||'0')+40);
    applyTransform(clone);
    svg.appendChild(clone);
    enableSvgDrag(clone);
    selectNode(clone);
    refreshStageLegend(); saveAll();
  }); }
  // Global touch-based toolbox drag handling
  let activeToolTouch=null;
  window.addEventListener('touchmove',e=>{
    if(!activeToolTouch) return; const t=e.touches[0]; if(!t) return; activeToolTouch.x=t.clientX; activeToolTouch.y=t.clientY; }, {passive:true});
  window.addEventListener('touchend',e=>{
    if(!activeToolTouch) return; const stage=document.getElementById('stageSvgFull'); if(stage){ const rect=stage.getBoundingClientRect(); const x=activeToolTouch.x, y=activeToolTouch.y; if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){ // inside stage
        // detect target BEFORE adding new node
        const el=document.elementFromPoint(x, y);
        const dropTarget= el && el.closest && el.closest('g[data-draggable]');
        // convert to SVG coords
        const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
        const newNode=addGlyphFull(activeToolTouch.key, {x:Math.round(svgP.x), y:Math.round(svgP.y)});
        if(newNode) selectNode(newNode);
        if(dropTarget && newNode){
          if(connectEitherDirection(newNode, dropTarget)){
            const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
            refreshCables(stage);
          }
        }
        try{ snapshotStage(); }catch(_){ }
      } }
    activeToolTouch=null;
  });
  // Mouse / touchpad fallback drag (for environments where HTML5 drag doesn't fire)
  let activeToolMouse=null; // {key,x,y,started,ghost}
  document.addEventListener('mousedown',e=>{
    const btn=e.target.closest && e.target.closest('button.tool');
    if(!btn) return; if(e.button!==0) return; const key=btn.querySelector('img') ? (btn.dataset.key || btn.getAttribute('data-key') || btn.textContent.trim()) : (btn.dataset.key||btn.getAttribute('data-key'));
    // We stored key explicitly on custom images; for standard tools key derivation from dragstart handler's closure is harder; embed data-key at build time for reliability
    const explicit=btn.dataset.key; if(!explicit) return; activeToolMouse={key:explicit,x:e.clientX,y:e.clientY,started:false,ghost:null};
  });
  document.addEventListener('mousemove',e=>{
    if(!activeToolMouse) return; activeToolMouse.x=e.clientX; activeToolMouse.y=e.clientY;
    if(!activeToolMouse.started){ const dx=Math.abs(e.clientX - activeToolMouse.x), dy=Math.abs(e.clientY - activeToolMouse.y); /* dx/dy always 0 here; use distance from initial stored values */ }
  });
  // Refine: start drag after small movement threshold
  document.addEventListener('mousemove',e=>{
    if(!activeToolMouse) return; if(activeToolMouse.started){ if(activeToolMouse.ghost){ activeToolMouse.ghost.style.left=(e.clientX+12)+'px'; activeToolMouse.ghost.style.top=(e.clientY+12)+'px'; } return; }
    const dx=Math.abs(e.clientX - activeToolMouse.x), dy=Math.abs(e.clientY - activeToolMouse.y); if(dx+dy>6){
      activeToolMouse.started=true;
      const ghost=document.createElement('div'); ghost.style.position='fixed'; ghost.style.left=(e.clientX+12)+'px'; ghost.style.top=(e.clientY+12)+'px'; ghost.style.pointerEvents='none'; ghost.style.zIndex='99999'; ghost.style.padding='4px 6px'; ghost.style.background='rgba(31,41,55,0.85)'; ghost.style.color='#fff'; ghost.style.fontSize='11px'; ghost.style.borderRadius='4px'; ghost.style.boxShadow='0 2px 6px rgba(0,0,0,0.4)'; ghost.textContent='Place '+activeToolMouse.key; document.body.appendChild(ghost); activeToolMouse.ghost=ghost;
    }
  });
  document.addEventListener('mouseup',e=>{
    if(!activeToolMouse) return; const data=activeToolMouse; activeToolMouse=null; if(data.ghost){ data.ghost.remove(); }
    if(!data.started) return; const stage=document.getElementById('stageSvgFull'); if(!stage) return; const rect=stage.getBoundingClientRect(); const x=e.clientX, y=e.clientY; if(x<rect.left||x>rect.right||y<rect.top||y>rect.bottom) return;
    // detect target before adding
    const el=document.elementFromPoint(x,y); const dropTarget= el && el.closest && el.closest('g[data-draggable]');
    const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
    const newNode=addGlyphFull(data.key,{x:Math.round(svgP.x), y:Math.round(svgP.y)}); if(newNode) selectNode(newNode);
    if(dropTarget && newNode){ if(connectEitherDirection(newNode, dropTarget)){ const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); refreshCables(stage); } }
    saveAll(); try{ snapshotStage(); }catch(_){ }
  });
  function getStageGroups(){ const full=document.getElementById('stageSvgFull'); if(!full) return []; return Array.from(full.querySelectorAll('g[data-draggable]')); }
  // Draw curvy dotted cables between connected items (routeTo chains)
  function refreshCables(svg){ if(!svg) return; const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
    // ensure a dedicated layer
    let layer=svg.querySelector('g[data-layer="cables"]'); if(layer){ layer.remove(); }
    layer=document.createElementNS('http://www.w3.org/2000/svg','g'); layer.setAttribute('data-layer','cables'); layer.setAttribute('pointer-events','none'); svg.appendChild(layer);
    const byId=new Map(nodes.map(n=> [n.dataset.id, n]));
    function centerOf(n){ return {x:parseFloat(n.dataset.x||'0')||0, y:parseFloat(n.dataset.y||'0')||0}; }
    function nodeRadius(n){ const s=Math.max(0.3, parseFloat(n.dataset.scale||'1')||1); const k=n.dataset.key||''; const base=(k==='label'||k==='arrow')? 20 : 30; return base*s; }
    function sampleQuad(a,c,b,t){ const x=(1-t)*(1-t)*a.x + 2*(1-t)*t*c.x + t*t*b.x; const y=(1-t)*(1-t)*a.y + 2*(1-t)*t*c.y + t*t*b.y; return {x,y}; }
    function pickControl(a,b,initial, obstacles){ let c={x:initial.x,y:initial.y}; const clamp=(v,min,max)=> Math.max(min, Math.min(max,v)); const vb=svg.viewBox && svg.viewBox.baseVal; const bx={x:0,y:0,w:(vb?vb.width:1500),h:(vb?vb.height:900)};
      for(let it=0; it<3; it++){
        // sample along curve, compute repulsion from obstacles
        let rx=0, ry=0; const steps=10; for(let i=1;i<steps;i++){ const t=i/steps; const p=sampleQuad(a,c,b,t); obstacles.forEach(o=>{
            const dx=p.x-o.x, dy=p.y-o.y; const d=Math.hypot(dx,dy); const th=o.r+40; if(d<th && d>1e-3){ const f=(th-d)/th; rx += (dx/d)*f; ry += (dy/d)*f; }
        }); }
        // apply small push
        const push=30; c.x = clamp(c.x + rx*push, bx.x+4, bx.x+bx.w-4); c.y = clamp(c.y + ry*push, bx.y+4, bx.y+bx.h-4);
      }
      return c;
    }
    // build obstacle list (centers + radii)
    const obstacles = nodes.map(n=>{ const c=centerOf(n); return {x:c.x,y:c.y,r:nodeRadius(n)}; });
    nodes.forEach(src=>{
      const to=src.dataset.routeTo; if(!to) return; const dst=byId.get(to); if(!dst) return;
      // make sure the connection is allowed; use effectiveTargets if available
      try{ if(typeof effectiveTargets==='function'){ const ok=effectiveTargets(src).includes(dst.dataset.type||'other'); if(!ok) return; } }catch(_){ /* ignore */ }
      
      // Check if this is a mic-amp connection (either direction)
      const srcType=src.dataset.type||'other';
      const dstType=dst.dataset.type||'other';
      const isMicAmpConnection = (srcType==='amp' && dstType==='mic') || (srcType==='mic' && dstType==='amp');
      
      const a=centerOf(src), b=centerOf(dst); const dx=b.x-a.x, dy=b.y-a.y; const len=Math.hypot(dx,dy)||1; const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const nx=-dy/len, ny=dx/len; const baseK=30; const init={x:mx+nx*baseK, y:my+ny*baseK};
      
      if(isMicAmpConnection){
        // Draw straight arrow for mic-amp connection (no curve)
        const d=`M ${a.x} ${a.y} L ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','2'); 
        p.setAttribute('marker-end','url(#arrowhead)');
        layer.appendChild(p);
        
        // Ensure arrowhead marker exists
        let defs=svg.querySelector('defs');
        if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
        if(!defs.querySelector('#arrowhead')){
          const marker=document.createElementNS('http://www.w3.org/2000/svg','marker');
          marker.setAttribute('id','arrowhead');
          marker.setAttribute('markerWidth','10');
          marker.setAttribute('markerHeight','10');
          marker.setAttribute('refX','9');
          marker.setAttribute('refY','3');
          marker.setAttribute('orient','auto');
          const triangle=document.createElementNS('http://www.w3.org/2000/svg','polygon');
          triangle.setAttribute('points','0 0, 10 3, 0 6');
          triangle.setAttribute('fill','#111');
          marker.appendChild(triangle);
          defs.appendChild(marker);
        }
      } else {
        // Draw normal curved dotted cable
        const c=pickControl(a,b,init, obstacles);
        const d=`M ${a.x} ${a.y} Q ${c.x} ${c.y} ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','1.5'); 
        p.setAttribute('stroke-dasharray','4 3'); 
        layer.appendChild(p);
      }
    });
  }
  function refreshStageLegend(){
    const host=document.getElementById('stageLegend'); if(!host) return;
    const rows=getStageGroups();
    host.innerHTML='';
    // sort with priority processors first
    rows.sort((a,b)=>{
      const ta=a.dataset.type||'other', tb=b.dataset.type||'other';
      const pa=PRIORITY_TYPES.has(ta), pb=PRIORITY_TYPES.has(tb);
      if(pa&&!pb) return -1; if(pb&&!pa) return 1; return parseInt(a.dataset.id||'0')-parseInt(b.dataset.id||'0');
    });

    // helpers for channels and chains
    function isStereo(node){ return (node.dataset.key||'')==='stereoPair'; }
    function occupiesChannel(node, ch){ if(!ch) return false; const a=parseInt(node.dataset.channel||'0',10); if(!a) return false; if(isStereo(node)){ return ch===a || ch===a+1; } return ch===a; }
    function channelTaken(ch, except){ return rows.find(r=> r!==except && occupiesChannel(r, ch)); }
    function nextFreeChannel(start, dir, stereo){ let c=start; const upper=stereo?63:64; const lower=1; while(true){ if(c<lower || c>upper) return null; const occupied = channelTaken(c, null) || (stereo && channelTaken(c+1, null)); if(!occupied) return c; c += dir; }
    }
    // helper to build chain string
    function buildChain(from){
      const seen=new Set();
      const parts=[];
      let cur=from;
      while(cur){
        if(seen.has(cur)) { parts.push('[loop]'); break; }
        seen.add(cur);
        const t=findText(cur); const base=(t && t.textContent)||cur.dataset.key||'Item';
        parts.push(base);
        const nextId=cur.dataset.routeTo || '';
        if(!nextId) break;
        const next=rows.find(r=> r.dataset.id===nextId);
        if(!next) break;
        // validate that next type is an allowed target from current type
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(next.dataset.type||'other')===-1){ break; }
        cur=next;
      }
      const last=cur||from;
      if(last.dataset.channel){
        if(isStereo(last)){
          const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1));
        }else{
          parts.push('Ch '+last.dataset.channel);
        }
      }
      return parts.join(' - ');
    }

      // Build incoming map to identify roots (start of chains)
      const incoming=new Set(); rows.forEach(r=>{ const to=r.dataset.routeTo; if(to) incoming.add(to); });
      // Filter: hide annotations; compact view = only root items OR items that expose a channel directly
      const displayRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const targets=ROUTE_TARGETS[tp]||[];
        const exposesChannel=targets.includes('channel');
        const isRoot=!incoming.has(r.dataset.id);
        return isRoot || exposesChannel; // keep if chain start or endpoint with channel
      });
      // Identify unconnected items (no routeTo, no channel, not routed to by anyone, not utility annotations)
      const unconnectedRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const hasChannel = r.dataset.channel;
        const hasRouteTo = r.dataset.routeTo;
        const isRoutedTo = incoming.has(r.dataset.id);
        return !hasChannel && !hasRouteTo && !isRoutedTo;
      });
    // Precompute candidates map for routing dropdown population
    const byType={}; displayRows.forEach(r=>{ const t=r.dataset.type||'other'; (byType[t]||(byType[t]=[])).push(r); });

    // determine dynamic channel range (still consider all rows for occupancy logic)
    const assignedChannels=rows.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
    const maxChan=assignedChannels.length? Math.max(...assignedChannels):0;
      displayRows.forEach((g,i)=>{
      const item=document.createElement('div'); item.className='row';
      const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
      const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
      const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);

      const type=g.dataset.type||'other';
  const targets=effectiveTargets(g);
      // Routing (routeTo or channel) cell
      const routeCell=document.createElement('div');
      let chInput=null;
      // Channel editing is applied to the chain endpoint, not necessarily the current row
      const resolveEnd=(start)=>{ let s=new Set(); let cur=start; while(cur && !s.has(cur)){ s.add(cur); const nid=cur.dataset.routeTo||''; if(!nid) break; const nxt=rows.find(r=> r.dataset.id===nid); if(!nxt) break; const allowed=effectiveTargets(cur); if(allowed.indexOf(nxt.dataset.type||'other')===-1) break; cur=nxt; } return cur||start; };
      const endNode=resolveEnd(g);
      const endTargets=effectiveTargets(endNode);
      if(endTargets.includes('channel')){
        const stereo=isStereo(endNode);
        chInput=document.createElement('input'); chInput.type='number'; chInput.min='1'; chInput.max= stereo ? '63' : '64'; chInput.step='1'; chInput.placeholder='Ch'; chInput.style.width='56px'; chInput.value=endNode.dataset.channel||''; chInput.title='Right-click drag between items to auto-chain';
        let prevVal = endNode.dataset.channel||'';
        const applyChannel=(ch)=>{ if(!ch){ endNode.dataset.channel=''; delete endNode.dataset.channel2; saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } return; }
          // block if taken
          if(channelTaken(ch, endNode) || (stereo && channelTaken(ch+1, endNode))){ chInput.value = prevVal; return; }
          endNode.dataset.channel=String(ch); if(stereo){ endNode.dataset.channel2=String(ch+1); } else { delete endNode.dataset.channel2; }
          prevVal=String(ch); saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } };
        const onChanChange=()=>{ const v=parseInt(chInput.value||'0',10); if(!isFinite(v) || v<1){ applyChannel(null); }
          else { const val=Math.min(stereo?63:64, v); if(channelTaken(val, endNode) || (stereo && channelTaken(val+1, endNode))){ chInput.value=prevVal; return; } applyChannel(val); } };
        chInput.addEventListener('focus',()=>{ prevVal = chInput.value; });
        chInput.addEventListener('change', onChanChange);
        chInput.addEventListener('blur', onChanChange);
        chInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ onChanChange(); }
          if(e.key==='ArrowUp' || e.key==='ArrowDown'){ e.preventDefault(); const dir = e.key==='ArrowUp' ? 1 : -1; const cur=parseInt(chInput.value|| (prevVal||'0'),10) || 0; const start = Math.max(1, cur + dir); const nf = nextFreeChannel(start, dir, stereo); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } }
        });
        chInput.addEventListener('input', ()=>{ const cur=parseInt(chInput.value||'0',10)||0; const pv=parseInt(prevVal||'0',10)||0; const stereoNow=stereo; if(cur===pv+1 || cur===pv-1){ const dir = (cur>pv)?1:-1; const nf = nextFreeChannel(cur, dir, stereoNow); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } } });
        routeCell.appendChild(chInput);
      }
      // RouteTo select for processors / sources that can feed other processors
      if(targets.filter(t=> t!=='channel').length){
        const rtSel=document.createElement('select'); rtSel.className='routeSel'; rtSel.appendChild(new Option('‚Üí none',''));
        const elig=[]; targets.forEach(tt=>{ if(tt==='channel') return; const groups=byType[tt]; if(groups){ groups.forEach(gr=>{ if(gr!==g) elig.push(gr); }); } });
        elig.forEach(gr=>{ const name=findText(gr); const label=(name && name.textContent)||gr.dataset.key||('Item '+gr.dataset.id); rtSel.appendChild(new Option(label, gr.dataset.id)); });
        // sanitize existing route if invalid
        if(g.dataset.routeTo){ const curNext=rows.find(r=> r.dataset.id===g.dataset.routeTo); const allowed=effectiveTargets(g); if(!curNext || allowed.indexOf(curNext.dataset.type||'other')===-1){ g.dataset.routeTo=''; } }
        rtSel.value=g.dataset.routeTo||'';
        rtSel.addEventListener('change',()=>{ const dest=rows.find(r=> r.dataset.id===rtSel.value); const allowed=effectiveTargets(g); if(dest && allowed.indexOf(dest.dataset.type||'other')!==-1){ g.dataset.routeTo=rtSel.value; } else { g.dataset.routeTo=''; } saveAll(); refreshStageLegend(); });
        routeCell.appendChild(rtSel);
      }
      item.appendChild(routeCell);

      // Chain cell
  const chainCell=document.createElement('div'); chainCell.className='chain'; chainCell.style.textAlign='left'; chainCell.textContent=buildChain(g); item.appendChild(chainCell);

      host.appendChild(item);
    });
    // Add unconnected items section if any exist
    if(unconnectedRows.length>0){
      const divider=document.createElement('div'); divider.style.cssText='border-top:2px solid #d1d5db;margin:12px 0 8px 0;padding-top:8px;font-weight:600;color:#64748b;font-size:12px';
      divider.textContent='Unconnected Items (acoustic/props):';
      host.appendChild(divider);
      unconnectedRows.forEach((g,i)=>{
        const item=document.createElement('div'); item.className='row'; item.style.opacity='0.7';
        const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
        const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
        const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);
        const noteCell=document.createElement('div'); noteCell.style.cssText='font-size:11px;color:#64748b;font-style:italic'; noteCell.textContent='(no signal path)'; item.appendChild(noteCell);
        host.appendChild(item);
      });
    }
    // After legend rebuild, refresh visual cables on both editor and stored SVGs
    const svgFull=document.getElementById('stageSvgFull'); if(svgFull) refreshCables(svgFull);
    const svgSmall=document.getElementById('stageSvg'); if(svgSmall) refreshCables(svgSmall);
  }
  /* Filter system removed: icons now assumed to have proper transparency baked in. */

    // Print Tech Rider + Stage
  // Repurpose combined print button to open chooser; user can select Tech and/or Stage
  document.getElementById('printTech').addEventListener('click',()=>{
    openPrintChooser('tech');
    return;
    /* legacy combined flow retained below but unused */
      // Header
      const hdr=$('#hdrTech'); hdr.innerHTML='';
    if(gig.headerFlags?.band) hdr.append(el('div','band',(gig.band||'BAND')));
    if(gig.headerFlags?.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
    if(gig.headerFlags?.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
    if(gig.headerFlags?.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
      // Tech table clone
      const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table';
      const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>';
      const body=document.createElement('tbody');
      setlist.filter(x=>x.type==='song').forEach((s,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${s.tech||''}</td>`; body.appendChild(tr);
      });
      tbl.append(head,body); techOut.appendChild(tbl);
      // Stage SVG clone
      const stageOut=$('#stagePrint'); stageOut.innerHTML='';
  var svgEl=document.getElementById('stageSvg'); if(svgEl){ const svg=svgEl.cloneNode(true); svg.removeAttribute('id'); svg.setAttribute('preserveAspectRatio','xMidYMid meet'); svg.style.width='100%'; svg.style.height='auto'; svg.style.maxHeight='9in'; stageOut.appendChild(svg); }
  if(gearSummary){ const gdiv=document.createElement('div'); gdiv.style.marginTop='8px'; gdiv.textContent='Gear: '+gearSummary; stageOut.appendChild(gdiv); }
      // Show modal
      document.getElementById('modalTech').classList.add('open');
    });
    document.getElementById('closeTech').addEventListener('click',()=> document.getElementById('modalTech').classList.remove('open'));
      // Print Tech only (no stage)
      const printTechOnlyBtn=document.getElementById('printTechOnly');
      if(printTechOnlyBtn){ printTechOnlyBtn.addEventListener('click',()=>{
        // Header
        const hdr=$('#hdrTech'); hdr.innerHTML='';
        if(gig.headerFlags?.band) hdr.append(el('div','band',(gig.band||'BAND')));
        if(gig.headerFlags?.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
        if(gig.headerFlags?.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
        if(gig.headerFlags?.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
        // Tech table only
        const techOut=$('#techPrint'); techOut.innerHTML='';
        const stageOut=$('#stagePrint'); stageOut.innerHTML='';
        const tbl=document.createElement('table'); tbl.className='tech-table';
        const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>';
        const body=document.createElement('tbody');
        setlist.filter(x=>x.type==='song').forEach((s,i)=>{
          const tr=document.createElement('tr'); tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${s.tech||''}</td>`; body.appendChild(tr);
        });
        tbl.append(head,body); techOut.appendChild(tbl);
        document.getElementById('modalTech').classList.add('open');
      }); }

    // Save tech notes on edit (kept above); buildTechTableFull populates fullscreen modal

    // Small embedded stage removed. All interactions are in fullscreen editor.

    // Fullscreen toggle for stage
  // No inline fullscreen toggle button anymore

    // Fullscreen stage editor open/close (now inline, used for Stage Plot view)
    function openStageModal(){
      // ensure header reflects current gig
      try{
        refreshStageHeader();
        // ensure toolbox is populated
        try{ buildTools(); }catch(_){ /* ignore */ }
        // seed full editor from stored svg
        const store=document.getElementById('stageSvg');
        const full=document.getElementById('stageSvgFull');
        // enforce stage outline
        if(full && !full.classList.contains('bw')) full.classList.add('bw');
        const bg=full && full.querySelector('rect.stage-bg');
        if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        // initialize resize handles (corner-only interaction) and apply stored size
        (function initStageResize(){
          const frame=document.getElementById('stageFrame'); if(!frame||!full) return;
          // default size if not previously set
          const prevW=parseInt(full.style.width||'0',10); const prevH=parseInt(full.style.height||'0',10);
            if(prevW>0 && prevH>0){ frame.style.width=prevW+'px'; frame.style.height=prevH+'px'; }
            else { frame.style.width='1000px'; frame.style.height='600px'; full.style.width='1000px'; full.style.height='600px'; }
          const handles=frame.querySelectorAll('.stage-handle');
          handles.forEach(h=>{
            h.addEventListener('mousedown',e=>{
              if(e.button!==0) return; e.preventDefault();
              const startX=e.clientX, startY=e.clientY; const startW=frame.offsetWidth, startH=frame.offsetHeight; const pos=h.dataset.handle;
              function move(ev){
                let dx=ev.clientX-startX, dy=ev.clientY-startY; let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                newW=Math.max(600,newW); newH=Math.max(360,newH);
                frame.style.width=newW+'px'; frame.style.height=newH+'px'; full.style.width=newW+'px'; full.style.height=newH+'px';
              }
              function up(){ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); saveAll(); }
              document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
            });
            // Touch support for handles
            h.addEventListener('touchstart',e=>{
              e.preventDefault(); const t=e.touches[0]; if(!t) return;
              const startX=t.clientX, startY=t.clientY; const startW=frame.offsetWidth, startH=frame.offsetHeight; const pos=h.dataset.handle;
              function touchMove(ev){
                const tt=ev.touches[0]; if(!tt) return;
                let dx=tt.clientX-startX, dy=tt.clientY-startY; let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                newW=Math.max(600,newW); newH=Math.max(360,newH);
                frame.style.width=newW+'px'; frame.style.height=newH+'px'; full.style.width=newW+'px'; full.style.height=newH+'px';
                ev.preventDefault();
              }
              function touchEnd(){ document.removeEventListener('touchmove',touchMove); document.removeEventListener('touchend',touchEnd); saveAll(); }
              document.addEventListener('touchmove',touchMove,{passive:false}); document.addEventListener('touchend',touchEnd);
            },{passive:false});
          });
        })();
        if(!full){ throw new Error('Stage SVG not found'); }
        // reset children (keep first two nodes: bg rect and title)
        while(full.childNodes.length>2) full.removeChild(full.lastChild);
        if(store){
          Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
          var tnode=store.querySelector('#stageTitle'); var ttl=document.getElementById('stageTitleFull'); if(ttl){ ttl.textContent=(tnode && tnode.textContent) || ttl.textContent; }
        }
  // Ensure arrow markers are available
    ensureStageMarkers(full);
  // Filter defs removed (icons expected to be clean PNGs without white fill)
        // Migration: remove legacy background rects behind emojis/images
        Array.from(full.querySelectorAll('g[data-draggable]')).forEach(gr=>{
          // assign ids/types to legacy nodes
          if(!gr.dataset.id){ gr.dataset.id=String(_nextStageId++); }
          if(!gr.dataset.type){ const k=gr.dataset.key||''; gr.dataset.type=TYPE_MAP[k]||'other'; }
          if(!('showLabel' in gr.dataset)) gr.dataset.showLabel = (gr.dataset.key==='label' || gr.dataset.key==='arrow') ? '1':'0';
          const hasImg = !!gr.querySelector('image');
          const hadEmoji = !!gr.querySelector('text[data-role="emoji"]');
          if(hasImg || hadEmoji){ Array.from(gr.querySelectorAll('rect[data-bg]')).forEach(r=> r.remove()); }
          // Remove any legacy filter attributes
          Array.from(gr.querySelectorAll('image[filter]')).forEach(im=> im.removeAttribute('filter'));
        });
  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=>{
    enableSvgDrag(g);
    applyLabelTransform(g); // Apply saved label offsets and size
  });
  refreshCables(full);
        bindSelection(full);
        const modal=document.getElementById('stageModal'); if(!modal){ throw new Error('Stage modal not found'); }
        modal.classList.add('open');
        refreshStageLegend();
        // Clear any persisted selection so nothing glows by default
        selectNode(null);
      }catch(err){
        if(window && window.alert){ alert('Could not open Stage Plot editor. See console for details.'); }
        if(console && console.error) console.error(err);
      }
    }
    // Extract existing close logic into reusable function for toggle
    function closeStageModal(){
      // Sync full editor back to stored compact SVG so reopening reflects latest layout
      const full=document.getElementById('stageSvgFull');
      let small=document.getElementById('stageSvg');
      if(full){
        if(!small){
          const store=document.getElementById('stageStore');
          if(store){ small=full.cloneNode(true); small.id='stageSvg'; small.classList.add('bw'); store.appendChild(small); }
        }
        if(small){
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
          Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(gr=>{ const lbl=findText(gr); if(lbl){ lbl.style.display = gr.dataset.showLabel==='1' ? 'block':'none'; } });
          ensureStageMarkers(small); refreshCables(small);
          const fullTitle=document.getElementById('stageTitleFull');
          let smallTitle=document.getElementById('stageTitle');
          if(!smallTitle && small){ smallTitle=small.querySelector('#stageTitle'); }
          if(fullTitle){
            if(smallTitle){ smallTitle.textContent=fullTitle.textContent; }
            else {
              const t=document.createElementNS('http://www.w3.org/2000/svg','text');
              t.setAttribute('id','stageTitle'); t.setAttribute('x','500'); t.setAttribute('y','36'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','22'); t.setAttribute('font-weight','bold'); t.textContent=fullTitle.textContent; small.appendChild(t);
            }
          }
          const bg=small.querySelector('rect.stage-bg'); if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        }
      }
      saveAll();
      document.getElementById('stageModal').classList.remove('open');
    }
    // Unified toggle: Stage Plot <-> Lighting & FX
    function toggleStageAndNotes(){
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      const btn=document.getElementById('stageToggle');
      if(!stageModal || !notesModal || !btn) return;

      const showingStage = stageModal.classList.contains('open');

      if(showingStage){
        // currently Stage Plot -> switch to Lighting / FX view
        closeStageModal();
        buildTechTableFull();
        const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary||'';
        notesModal.classList.add('open');
        btn.textContent = 'Stage Plot';
        saveAll(); // persist after switching away
      } else {
        // currently Lighting / FX (or neither) -> switch to Stage Plot view
        notesModal.classList.remove('open');
        openStageModal();
        btn.textContent = 'Lighting / FX';
        saveAll(); // persist after opening stage
      }
    }
    window.toggleStageAndNotes = toggleStageAndNotes;
    window.openStageModal = openStageModal; // legacy safety
    // final safety: delegate click in case listeners were missed
    document.addEventListener('click',ev=>{
      const trg=ev.target && ev.target.closest ? ev.target.closest('#openStage') : null;
      if(trg){ ev.preventDefault(); openStageModal(); }
    });
    document.getElementById('closeStage').addEventListener('click',closeStageModal);
    // Clear full stage editor
    const clearStageBtn=document.getElementById('clearStage');
    if(clearStageBtn){ clearStageBtn.addEventListener('click',()=>{
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      // preserve background rect and title only
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll(); snapshotStage();
    }); }

    // Keyboard shortcuts in stage editor: Ctrl+D duplicate (undo/redo handled globally)
    document.addEventListener('keydown',e=>{
      const modal=document.getElementById('stageModal');
      if(!modal || !modal.classList.contains('open')) return;
      if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
      if(e.ctrlKey && !e.shiftKey && (e.key==='d' || e.key==='D')){
        e.preventDefault();
        const dupBtn=document.getElementById('dupSel');
        if(dupBtn) dupBtn.click();
      }
    });

    // Lighting notes now controlled via unified toggle; keep close button local only
  const closeNotesBtn=document.getElementById('closeNotes');
  if(closeNotesBtn){ closeNotesBtn.addEventListener('click',()=> document.getElementById('notesModal').classList.remove('open')); }

    // Stage Preset Management
    if(!gig.stagePresets) gig.stagePresets = [];
    
    function renderPresetList(){
      const list = document.getElementById('presetList');
      if(!list) return;
      list.innerHTML = '';
      if(!gig.stagePresets || gig.stagePresets.length === 0){
        list.innerHTML = '<div style="color:#6b7280;font-size:14px;padding:16px;text-align:center;border:2px dashed #d1d5db;border-radius:6px">No presets saved yet. Click "Save Current" to create one.</div>';
        return;
      }
      gig.stagePresets.forEach((preset, idx)=>{
        const row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;gap:8px;padding:8px;border:1px solid #e5e7eb;border-radius:6px;background:#f9fafb';
        const nameBtn = document.createElement('button');
        nameBtn.textContent = 'üìã ' + preset.name;
        nameBtn.className = 'btn';
        nameBtn.style.cssText = 'flex:1;text-align:left;padding:8px 12px;font-size:14px;background:#fff';
        nameBtn.title = 'Load this preset';
        nameBtn.addEventListener('click', ()=>{
          if(confirm(`Load preset "${preset.name}"? This will replace your current stage plot.`)){
            loadStagePreset(preset);
            document.getElementById('presetModal').style.display='none';
          }
        });
        const delBtn = document.createElement('button');
        delBtn.textContent = 'üóëÔ∏è';
        delBtn.className = 'btn danger';
        delBtn.style.cssText = 'padding:6px 12px;font-size:16px;min-width:40px';
        delBtn.title = 'Delete preset';
        delBtn.addEventListener('click', ()=>{
          if(confirm(`Delete preset "${preset.name}"?`)){
            gig.stagePresets.splice(idx, 1);
            saveAll();
            renderPresetList();
          }
        });
        row.append(nameBtn, delBtn);
        list.appendChild(row);
      });
    }
    
    function saveStagePreset(){
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      const defaultName = `${gig.band || 'Band'}_${gig.date || 'Date'}_StagePlot`.replace(/\s+/g, '_');
      const name = prompt('Preset name:', defaultName);
      if(!name || name.trim().length === 0) return;
      const preset = {
        name: name.trim(),
        date: new Date().toISOString(),
        stage: svg.outerHTML,
        gearSummary: gearSummary || ''
      };
      if(!gig.stagePresets) gig.stagePresets = [];
      gig.stagePresets.push(preset);
      saveAll();
      renderPresetList();
      alert(`Preset "${preset.name}" saved!`);
    }
    
    function loadStagePreset(preset){
      if(!preset || !preset.stage) return;
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      const parent = svg.parentNode;
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = preset.stage;
      const newSvg = tempDiv.querySelector('svg');
      if(!newSvg) return;
      newSvg.id = 'stageSvgFull';
      parent.replaceChild(newSvg, svg);
      if(preset.gearSummary !== undefined){
        gearSummary = preset.gearSummary;
        const gearEl = document.getElementById('gear');
        if(gearEl) gearEl.value = gearSummary;
      }
      saveAll();
      rebuildStageInteractions();
      alert(`Preset "${preset.name}" loaded!`);
    }
    
    function rebuildStageInteractions(){
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      svg.querySelectorAll('g[data-draggable]').forEach(enableSvgDrag);
      refreshStageLegend();
      refreshCables(svg);
    }
    
    const presetBtn = document.getElementById('stagePresetBtn');
    const presetModal = document.getElementById('presetModal');
    const closePresetBtn = document.getElementById('closePreset');
    const addPresetBtn = document.getElementById('addPresetBtn');
    
    if(presetBtn && presetModal){
      presetBtn.addEventListener('click', ()=>{
        renderPresetList();
        presetModal.style.display='flex';
      });
      presetModal.addEventListener('click', (e)=>{
        if(e.target === presetModal){
          presetModal.style.display='none';
        }
      });
    }
    if(closePresetBtn && presetModal){
      closePresetBtn.addEventListener('click', ()=>{
        presetModal.style.display='none';
      });
    }
    if(addPresetBtn){
      addPresetBtn.addEventListener('click', saveStagePreset);
    }

    // Drag from toolbox into full SVG at drop position
  const fullSvg=document.getElementById('stageSvgFull');
    let currentDragSource = null;
    fullSvg.addEventListener('dragover',ev=> ev.preventDefault());
    fullSvg.addEventListener('drop',ev=>{
      ev.preventDefault();
      const key=ev.dataTransfer.getData('text/plain');
      if(!key) return;
      
      // Check if this drag has already created an item
      if(currentDragSource && currentDragSource.dataset.getDragUsed && currentDragSource.dataset.getDragUsed()){
        return; // Already created one item from this drag
      }
      
      // Mark this drag as used
      if(currentDragSource && currentDragSource.dataset.setDragUsed){
        currentDragSource.dataset.setDragUsed();
      }
      
      // detect target under cursor BEFORE adding new glyph
      const el=document.elementFromPoint(ev.clientX, ev.clientY);
      const dropTarget= el && el.closest && el.closest('g[data-draggable]');
      const pt=fullSvg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=fullSvg.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
      const newNode=addGlyphFull(key,{x:Math.round(svgP.x), y:Math.round(svgP.y)});
      if(newNode) selectNode(newNode);
      if(dropTarget && newNode){
        if(connectEitherDirection(newNode, dropTarget)){
          const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
          refreshCables(fullSvg);
        }
      }
    });
    
    // Track drag source for duplicate prevention
    document.addEventListener('dragstart', (ev)=>{
      const toolBtn = ev.target.closest('.tool');
      if(toolBtn){
        currentDragSource = toolBtn;
      }
    });
    document.addEventListener('dragend', ()=>{
      currentDragSource = null;
    });

    // Arrow drawing: drag anywhere in SVG (hold Shift to draw over items)
    (function(){
      let drawing=null; // {x0,y0, preview}
      const svg=fullSvg;
      ensureStageMarkers(svg);
      function svgPointFromClient(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      function startDraw(x,y){ drawing={x0:x,y0:y, preview:document.createElementNS('http://www.w3.org/2000/svg','line')}; const ln=drawing.preview; ln.setAttribute('x1',String(x)); ln.setAttribute('y1',String(y)); ln.setAttribute('x2',String(x)); ln.setAttribute('y2',String(y)); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-dasharray','4,3'); ln.setAttribute('stroke-width','2'); ln.setAttribute('pointer-events','none'); svg.appendChild(ln); }
      function updateDraw(x,y){ if(!drawing) return; drawing.preview.setAttribute('x2',String(x)); drawing.preview.setAttribute('y2',String(y)); }
      function finishDraw(x1,y1){ if(!drawing){ return; } const {x0,y0, preview}=drawing; svg.removeChild(preview); drawing=null; const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy); if(dist<6){ // treat as click -> create label here
          // Ask first; cancel or empty -> abort (no stray labels)
          let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
          // Create label at point
          const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(x0)); gN.dataset.y=String(Math.round(y0)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
          const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
          applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
          const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
          if(!isMobile){ const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); } }
          _suppressBgClick=true;
          return;
        }
        // Create arrow group anchored at origin (x0,y0) pointing to (x1,y1)
        const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.dataset.x=String(Math.round(x0)); g.dataset.y=String(Math.round(y0)); g.dataset.scale='1'; g.setAttribute('data-draggable','1'); g.dataset.key='arrow'; g.dataset.type='other'; g.dataset.showLabel='1';
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line'); ln.setAttribute('x1','0'); ln.setAttribute('y1','0'); ln.setAttribute('x2',String(Math.round(dx))); ln.setAttribute('y2',String(Math.round(dy))); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrowHead)'); g.appendChild(ln);
        // Ask for arrow label; cancel or empty -> abort entire arrow creation
        let enteredA=prompt('Arrow label:',''); if(enteredA==null) return; enteredA=String(enteredA).trim(); if(!enteredA) return;
  const t=document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('x', (Math.abs(dx)>Math.abs(dy) ? (dx<0?-8:8) : 0) );
  const yOff = (dy<0? 14 : -10);
  t.setAttribute('y', String(yOff));
  t.setAttribute('font-size','14'); t.setAttribute('text-anchor','start'); t.setAttribute('dominant-baseline','alphabetic'); t.setAttribute('data-role','label');
  t.textContent=enteredA; g.appendChild(t);
        applyTransform(g); svg.appendChild(g); enableSvgDrag(g); selectNode(g); refreshStageLegend(); saveAll();
        _suppressBgClick=true;
      }
      // Mouse support (capture to preempt item drag when Shift is held)
      svg.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        // ignore UI controls outside svg content
        if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions')) return;
        const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]'));
        if(overItem && !e.shiftKey) return; // allow drawing over items only with Shift
        const p=svgPointFromClient(e.clientX,e.clientY); startDraw(p.x,p.y); e.stopImmediatePropagation(); e.preventDefault();
      }, {capture:true});
      svg.addEventListener('mousemove',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); updateDraw(p.x,p.y); }, {capture:true});
      window.addEventListener('mouseup',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); finishDraw(p.x,p.y); }, {capture:true});
      // Touch support (capture); only allow drawing from whitespace background
      svg.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions')) return; const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]')); const onBg = !!(e.target.closest && e.target.closest('.stage-bg')); if(overItem || !onBg) return; const p=svgPointFromClient(t.clientX,t.clientY); startDraw(p.x,p.y); e.preventDefault(); e.stopImmediatePropagation(); }, {passive:false, capture:true});
      window.addEventListener('touchmove',e=>{ if(!drawing) return; const t=e.touches[0]; if(!t) return; const p=svgPointFromClient(t.clientX,t.clientY); updateDraw(p.x,p.y); }, {passive:true});
      window.addEventListener('touchend',e=>{ if(!drawing) return; const ct=(e.changedTouches && e.changedTouches[0])|| (e.touches && e.touches[0]); if(!ct) return; const p=svgPointFromClient(ct.clientX, ct.clientY); finishDraw(p.x,p.y); }, {passive:true});
    })();

    // Removed legacy custom tool buttons (label/rect/default layout). New upload image flow below.
    const uploadBtn=document.getElementById('uploadImageBtn');
    const uploadInput=document.getElementById('uploadImageInput');
    function rebuildCustomImages(){
      const host=document.getElementById('customImages'); if(!host) return; host.innerHTML='';
      (gig.customImages||[]).forEach(ci=>{
        const b=document.createElement('button'); b.className='tool'; b.innerHTML=`<img src="${ci.data}" alt="${ci.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${ci.label}`; b.setAttribute('draggable','true'); b.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', ci.key); }); host.appendChild(b);
      });
    }
    if(uploadBtn && uploadInput){
      uploadBtn.addEventListener('click',()=> uploadInput.click());
      uploadInput.addEventListener('change',()=>{
        const file=uploadInput.files && uploadInput.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{
          const dataUrl=reader.result; const rawName=file.name.replace(/\.[^.]+$/,''); const label=prompt('Image label:', rawName)||rawName;
          const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl});
          saveAll(); rebuildCustomImages(); buildTools(); // add to toolbox drag list
        }; reader.readAsDataURL(file);
        uploadInput.value='';
      });
      // hydrate any existing
      rebuildCustomImages();
    }
    // New Icon drawing logic
    const newIconBtn=document.getElementById('newIconBtn');
    const iconModal=document.getElementById('iconMakerModal');
    const iconCanvas=document.getElementById('iconCanvas');
    const iconLineWidth=document.getElementById('iconLineWidth');
    const iconClear=document.getElementById('iconClear');
    const iconSave=document.getElementById('iconSave');
    const iconCancel=document.getElementById('iconCancel');
    let iconDrawing=false; let iconStrokes=[]; let currentStroke=null;
    function openIconModal(){ if(iconModal){ iconModal.style.display='block'; iconModal.classList.add('open'); iconStrokes=[]; redrawIcon(); } }
    function closeIconModal(){ if(iconModal){ iconModal.classList.remove('open'); iconModal.style.display='none'; } }
    function redrawIcon(){ if(!iconCanvas) return; const ctx=iconCanvas.getContext('2d'); ctx.clearRect(0,0,iconCanvas.width,iconCanvas.height); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle='#000'; iconStrokes.forEach(st=>{ ctx.lineWidth=st.w; ctx.beginPath(); st.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.stroke(); }); }
    function classifyStroke(pts){ if(pts.length<4) return 'line'; const first=pts[0], last=pts[pts.length-1]; const minX=Math.min(...pts.map(p=>p.x)), maxX=Math.max(...pts.map(p=>p.x)); const minY=Math.min(...pts.map(p=>p.y)), maxY=Math.max(...pts.map(p=>p.y)); const w=maxX-minX, h=maxY-minY; const closeDist=Math.hypot(last.x-first.x,last.y-first.y); const pathLen=pts.reduce((a,p,i)=> i? a+Math.hypot(p.x-pts[i-1].x,p.y-pts[i-1].y):0,0); if(pts.length<12) return 'line'; if(closeDist < Math.max(6,0.15*Math.max(w,h))){ const aspect=w/h; if(aspect>0.8 && aspect<1.25){ return 'ellipse'; } if(Math.abs(w-h)/Math.max(w,h) < 0.25){ return 'rect'; } }
      return 'line'; }
    function normalizeStrokes(){ // replace rough shapes with ideal forms
      iconStrokes=iconStrokes.map(st=>{ const kind=classifyStroke(st.pts); if(kind==='line'){ return st; } const minX=Math.min(...st.pts.map(p=>p.x)), maxX=Math.max(...st.pts.map(p=>p.x)); const minY=Math.min(...st.pts.map(p=>p.y)), maxY=Math.max(...st.pts.map(p=>p.y)); if(kind==='rect'){ return {w:st.w, pts:[{x:minX,y:minY},{x:maxX,y:minY},{x:maxX,y:maxY},{x:minX,y:maxY},{x:minX,y:minY}]}; } if(kind==='ellipse'){ const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const rx=(maxX-minX)/2, ry=(maxY-minY)/2; const steps=40; const pts=[]; for(let i=0;i<=steps;i++){ const a=(i/steps)*Math.PI*2; pts.push({x:cx+rx*Math.cos(a), y:cy+ry*Math.sin(a)}); } return {w:st.w, pts}; } return st; }); }
    function iconPointerDown(x,y){ iconDrawing=true; currentStroke={w:parseInt(iconLineWidth.value)||4, pts:[{x,y}]}; iconStrokes.push(currentStroke); redrawIcon(); }
    function iconPointerMove(x,y){ if(!iconDrawing || !currentStroke) return; currentStroke.pts.push({x,y}); redrawIcon(); }
    function iconPointerUp(){ if(!iconDrawing) return; iconDrawing=false; currentStroke=null; normalizeStrokes(); redrawIcon(); }
    if(iconCanvas){
      iconCanvas.addEventListener('mousedown',e=>{ const r=iconCanvas.getBoundingClientRect(); iconPointerDown(e.clientX-r.left,e.clientY-r.top); });
      window.addEventListener('mousemove',e=>{ if(!iconDrawing) return; const r=iconCanvas.getBoundingClientRect(); iconPointerMove(e.clientX-r.left,e.clientY-r.top); });
      window.addEventListener('mouseup',()=> iconPointerUp());
      iconCanvas.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; const r=iconCanvas.getBoundingClientRect(); iconPointerDown(t.clientX-r.left,t.clientY-r.top); e.preventDefault(); }, {passive:false});
      iconCanvas.addEventListener('touchmove',e=>{ const t=e.touches[0]; if(!t) return; const r=iconCanvas.getBoundingClientRect(); iconPointerMove(t.clientX-r.left,t.clientY-r.top); e.preventDefault(); }, {passive:false});
      iconCanvas.addEventListener('touchend',()=> iconPointerUp());
    }
    if(newIconBtn) newIconBtn.addEventListener('click', openIconModal);
    if(iconCancel) iconCancel.addEventListener('click', closeIconModal);
    if(iconClear) iconClear.addEventListener('click',()=>{ iconStrokes=[]; redrawIcon(); });
    if(iconSave) iconSave.addEventListener('click',()=>{ if(!iconCanvas) return; normalizeStrokes(); redrawIcon(); const label=prompt('Icon label:','Custom')||'Custom'; const dataUrl=iconCanvas.toDataURL('image/png'); const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl}); saveAll(); rebuildCustomImages(); buildTools(); closeIconModal(); });
    // (Removed default layout auto-placement code)

    // Shuffle playlist (guard if legacy button exists)
    (function(){ const sh=document.getElementById('shuffleBtn'); if(!sh) return; sh.addEventListener('click',()=>{
      const songs=setlist.filter(x=>x.type==='song');
      const others=setlist.filter(x=>x.type!=='song');
      const shuffled=shuffle(songs);
      // keep others in their relative positions (insert breaks/encore by index mapping)
      let i=0; setlist=setlist.map(x=> x.type==='song' ? shuffled[i++] : x);
      renderSet(); saveAll();
    }); })();

    // Persist gig band name as default as you type
    document.getElementById('gBand').addEventListener('change',()=>{ gig.band=document.getElementById('gBand').value; saveAll(); refreshStageHeader(); });
      document.getElementById('gVenue').addEventListener('change',()=>{ gig.venue=document.getElementById('gVenue').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gDate').addEventListener('change',()=>{ gig.date=document.getElementById('gDate').value; saveAll(); refreshStageHeader(); buildSheet('sheetInline'); });
      document.getElementById('gAddr').addEventListener('change',()=>{ gig.address=document.getElementById('gAddr').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gContact').addEventListener('change',()=>{ gig.contact=document.getElementById('gContact').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gNotes').addEventListener('change',()=>{ gig.notes=document.getElementById('gNotes').value; saveAll(); buildSheet('sheetInline'); });
    // Header flag persistence & listeners
    ;['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{
      const box=document.getElementById(id);
      if(box){
        box.addEventListener('change',()=>{
          if(!gig.headerFlags) gig.headerFlags={band:true,venue:true,sub:true,notes:true};
          if(id==='hdrBand') gig.headerFlags.band=box.checked;
          else if(id==='hdrVenue') gig.headerFlags.venue=box.checked;
          else if(id==='hdrSub') gig.headerFlags.sub=box.checked;
          else if(id==='hdrNotes') gig.headerFlags.notes=box.checked;
          saveAll();
          if(document.getElementById('modal').classList.contains('open')){ buildSheet(); }
        });
      }
    });
  // Font selection persistence
  const gFontEl=document.getElementById('gFont'); if(gFontEl){ gFontEl.addEventListener('change',()=>{ gig.font=gFontEl.value; saveAll(); buildSheet('sheetInline'); }); if(gig.font) gFontEl.value=gig.font; }
  // Logo upload/preview/clear
  const logoIn=document.getElementById('gLogo'); const logoPrev=document.getElementById('gLogoPrev'); const logoClear=document.getElementById('gLogoClear');
  function refreshLogoPreview(){ if(logoPrev){ if(gig.logo){ logoPrev.src=gig.logo; logoPrev.style.display='block'; } else { logoPrev.removeAttribute('src'); logoPrev.style.display='none'; } } }
  if(logoIn){ logoIn.addEventListener('change',()=>{ const f=logoIn.files && logoIn.files[0]; if(!f) return; const r=new FileReader(); r.onload=e=>{ gig.logo=String(e.target.result||''); saveAll(); refreshLogoPreview(); }; r.readAsDataURL(f); }); }
  if(logoClear){ logoClear.addEventListener('click',()=>{ gig.logo=''; if(logoIn) logoIn.value=''; saveAll(); refreshLogoPreview(); }); }
  refreshLogoPreview();
    // Gear summary persistence
  const gearEl2=document.getElementById('gear'); if(gearEl2){ gearEl2.addEventListener('input',()=>{ gearSummary=gearEl2.value; }); gearEl2.addEventListener('change',()=>{ gearSummary=gearEl2.value; saveAll(); }); }

    // Global print chooser wiring
    function openPrintChooser(pref){
      const dlg=document.getElementById('printChooser');
      // Close other modals so chooser is visible above everything and not printed with them
      ['stageModal','notesModal','modal','modalTech'].forEach(id=>{ const m=document.getElementById(id); if(m) m.classList.remove('open'); });
      const cSet=document.getElementById('pSet');
      const cStage=document.getElementById('pStage');
      const cTech=document.getElementById('pTech');
      // default: at least one checked
      const all=[cSet,cStage,cTech];
      all.forEach(c=> c.checked=false);
      if(pref==='set') cSet.checked=true; else if(pref==='stage') cStage.checked=true; else if(pref==='tech') cTech.checked=true; else cSet.checked=true;
      dlg.classList.add('open');
      validatePrintSelection();
    }
    function validatePrintSelection(){
      const btn=document.getElementById('doPrint');
      const any= document.getElementById('pSet').checked || document.getElementById('pStage').checked || document.getElementById('pTech').checked;
      btn.disabled = !any;
    }
    ['pSet','pStage','pTech'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('change',validatePrintSelection); }});
    const openPrintFab=document.getElementById('openPrintOptions');
    if(openPrintFab){ openPrintFab.addEventListener('click',()=> openPrintChooser()); }
    const openPrintTop=document.getElementById('openPrintOptionsTop');
    if(openPrintTop){ openPrintTop.addEventListener('click',()=> openPrintChooser()); }
    document.getElementById('closePrintChooser').addEventListener('click',()=> document.getElementById('printChooser').classList.remove('open'));
  document.getElementById('printTechModal').addEventListener('click',()=> openPrintChooser('tech'));

    async function printSelected(){
      // Ensure content is built even if user hasn't opened views yet
      try{ buildSheet('sheetInline'); }catch(_){}
      try{ prepHdrTech(); }catch(_){}
      const wantSet=document.getElementById('pSet').checked;
      const wantStage=document.getElementById('pStage').checked;
      const wantTech=document.getElementById('pTech').checked;
      const tasks=[];
      if(wantSet) tasks.push(()=> printSetOnce());
      if(wantStage) tasks.push(()=> printStageOnce());
      if(wantTech) tasks.push(()=> printTechOnlyOnce());
      // Close chooser before printing to prevent it from being captured by print
      document.getElementById('printChooser').classList.remove('open');
      for(const t of tasks){ await t(); }
    }
    document.getElementById('doPrint').addEventListener('click',printSelected);

    // PDF/ZIP download removed: users can use native browser print dialog for PDF saving.

    function makePdfFromCanvas(canvas, paper){
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p', 'pt', paper||'letter');
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      let imgW = pageW;
      let imgH = canvas.height * (imgW / canvas.width);
      if(imgH > pageH){ imgH = pageH; imgW = canvas.width * (imgH / canvas.height); }
      const x = (pageW - imgW)/2, y=(pageH - imgH)/2;
      pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
      return pdf.output('blob');
    }

    function withOffscreen(el, fn){
      // Ensure element AND its hidden ancestors are visible for layout so html2canvas gets real size
      const stack=[]; let node=el;
      while(node && node.nodeType===1){
        stack.push({node, style:{display:node.style.display, visibility:node.style.visibility, position:node.style.position, left:node.style.left, top:node.style.top}});
        node.style.display='block';
        node.style.visibility='visible';
        node = node.parentElement;
      }
      // Position target far offscreen to avoid flicker
      el.style.position='fixed'; el.style.left='-10000px'; el.style.top='0';
      return Promise.resolve(fn()).finally(()=>{
        // Restore styles in reverse order
        for(let i=0;i<stack.length;i++){
          const {node, style}=stack[i];
          node.style.display=style.display;
          node.style.visibility=style.visibility;
          node.style.position=style.position;
          node.style.left=style.left;
          node.style.top=style.top;
        }
      });
    }
    async function createSetlistPdfBlob(){
      // Use inline sheet for export (already WYSIWYG)
      buildSheet('sheetInline');
      const el=document.getElementById('sheetInline');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for setlist (mobile or missing PDF libs).');
        document.getElementById('modal').classList.add('open'); await printPromise(); window.print(); document.getElementById('modal').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, (el.classList.contains('a4')? 'a4' : 'letter'));
      return blob;
    }
    // Helper: obtain current stage SVG (fullscreen editor if open, else stored miniature)
    function getStageSource(){
      let src=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      if(!src){ const store=document.getElementById('stageStore'); if(store){ src=store.querySelector('svg'); } }
      return src;
    }
    // Helper: build channel-ordered legend + cloned stage (with border) identical to printStageOnce
    function buildStageExport(into){
      const stageOut = into; stageOut.innerHTML='';
      const src=getStageSource();
      // Clear any selection highlight before export so no blue glow prints
      document.querySelectorAll('g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      const legend=document.createElement('table'); legend.className='tech-table';
      const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Channel</th><th>Chain</th></tr>';
      const tbody=document.createElement('tbody');
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const isStereo=n=> (n.dataset.key||'')==='stereoPair';
        const typeOf=n=> n.dataset.type||'other';
        const findRoot=(end)=>{ let cur=end; const seen=new Set(); while(cur && !seen.has(cur)){ seen.add(cur); const prev=rows.find(r=> r.dataset.routeTo===cur.dataset.id && effectiveTargets(r).includes(typeOf(cur))); if(!prev) break; cur=prev; } return cur||end; };
        const buildChain=(from)=>{ const seen=new Set(); const parts=[]; let cur=from; while(cur){ if(seen.has(cur)) break; seen.add(cur); const t=cur.querySelector('text[data-role="label"]')||cur.querySelector('text'); const base=(t && t.textContent)||(cur.dataset.key||'Item'); parts.push(base); const nid=cur.dataset.routeTo||''; if(!nid) break; const next=rows.find(r=> r.dataset.id===nid); if(!next) break; const ok=effectiveTargets(cur).includes(typeOf(next)); if(!ok) break; cur=next; } const last=cur||from; if(last.dataset.channel){ if(isStereo(last)){ const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1)); } else { parts.push('Ch '+last.dataset.channel); } } return parts.join(' - '); };
        // Collect only endpoints that have an assigned channel (used channels only)
        const endpoints=rows.filter(r=> r.dataset.channel && r.dataset.channel!=='' && (parseInt(r.dataset.channel||'0',10)>0));
        const byCh = endpoints
          .map(n=> ({ node:n, ch: parseInt(n.dataset.channel||'0',10)||0 }))
          .filter(x=> x.ch>0)
          .sort((a,b)=> a.ch - b.ch);
        for(const {node:end, ch} of byCh){
          const tr=document.createElement('tr');
          const chCell=document.createElement('td');
          if(isStereo(end)) chCell.textContent = `${ch} & ${ch+1}`; else chCell.textContent=String(ch);
          const chainCell=document.createElement('td');
          const root=findRoot(end); chainCell.textContent = buildChain(root);
          tr.append(chCell, chainCell); tbody.appendChild(tr);
        }
      }
      legend.append(thead,tbody);
      // Add unconnected items section to print legend
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const typeOf=n=> n.dataset.type||'other';
        const UTILITY_TYPES=['label','arrow'];
        const unconnectedRows = rows.filter(g=>{
          const t=typeOf(g);
          if(UTILITY_TYPES.includes(t)) return false;
          const hasRouteTo = (g.dataset.routeTo||'').trim().length>0;
          const hasChannel = (g.dataset.channel||'').trim().length>0 && parseInt(g.dataset.channel||'0',10)>0;
          const routedTo = rows.some(r=> (r.dataset.routeTo===g.dataset.id) && effectiveTargets(r).includes(t));
          return !hasRouteTo && !hasChannel && !routedTo;
        });
        if(unconnectedRows.length>0){
          const dividerRow=document.createElement('tr');
          const dividerCell=document.createElement('td'); dividerCell.colSpan=2;
          dividerCell.style.cssText='border-top:2px solid #000;padding-top:8px;padding-bottom:4px;font-weight:600;font-size:11pt';
          dividerCell.textContent='Unconnected Items (acoustic/props): ';
          const itemNames = unconnectedRows.map(g=>{
            const tEl=g.querySelector('text[data-role="label"]')||g.querySelector('text');
            const key=g.dataset.key||'';
            const icon=ICON_ITEMS.find(x=>x.key===key);
            return (tEl && tEl.textContent) || (icon?icon.label:'Item');
          });
          const boldSpan=document.createElement('span');
          boldSpan.style.fontWeight='bold';
          boldSpan.textContent=itemNames.join(', ');
          dividerCell.appendChild(boldSpan);
          dividerRow.appendChild(dividerCell);
          tbody.appendChild(dividerRow);
        }
      }
      stageOut.appendChild(legend);
      if(src){
        const clone=src.cloneNode(true); 
        clone.removeAttribute('id'); 
        clone.setAttribute('preserveAspectRatio','xMidYMid meet');
        // Ensure viewBox is set properly for consistent scaling
        if(!clone.hasAttribute('viewBox')){
          const vb=src.viewBox && src.viewBox.baseVal;
          if(vb) clone.setAttribute('viewBox', `0 0 ${vb.width} ${vb.height}`);
          else clone.setAttribute('viewBox', '0 0 1500 900');
        }
        clone.style.width='100%'; 
        clone.style.height='auto'; 
        clone.style.maxHeight='6.5in';
        clone.style.maxWidth='100%';
        clone.style.display='block';
        try{ 
          const vb=clone.viewBox && clone.viewBox.baseVal; 
          if(vb){ 
            const br=document.createElementNS('http://www.w3.org/2000/svg','rect'); 
            br.setAttribute('x','1.5'); 
            br.setAttribute('y','1.5'); 
            br.setAttribute('width', String(vb.width-3)); 
            br.setAttribute('height', String(vb.height-3)); 
            br.setAttribute('fill','none'); 
            br.setAttribute('stroke','#000'); 
            br.setAttribute('stroke-width','3'); 
            br.setAttribute('pointer-events','none'); 
            br.setAttribute('data-print-border','1'); 
            clone.appendChild(br); 
          } 
        }catch(_){ }
        stageOut.appendChild(clone);
      }
      return stageOut;
    }
    async function inlineStageImages(svg){
      if(!svg) return;
      const images=Array.from(svg.querySelectorAll('image'));
      for(const im of images){
        const href=im.getAttribute('href')||im.getAttribute('xlink:href');
        if(!href || href.startsWith('data:')) continue;
        try{
          const resp=await fetch(href);
          if(!resp.ok) continue;
          const blob=await resp.blob();
          await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>{ im.setAttribute('href', fr.result); res(); }; fr.readAsDataURL(blob); });
        }catch(e){ /* ignore fetch failures (e.g. file:// restrictions) */ }
      }
    }
    async function createStagePdfBlob(){
      prepHdrTech(); const techOut=$('#techPrint'); techOut.innerHTML='';
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; buildStageExport(stageOut); // unified rendering identical to print
      // Keep legend with stage plot on same page for PDF
      const legend = stageOut.querySelector('table.tech-table');
      // Don't move legend, leave it in stageOut for single-page layout
      // Remove page breaks to fit everything on one page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      await inlineStageImages(stageOut.querySelector('svg'));
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for stage (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2, useCORS:true, allowTaint:true}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }
    async function createTechPdfBlob(){
      prepHdrTech(); const stageOut=$('#stagePrint'); stageOut.innerHTML=''; const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl);
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for tech sheet (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }

    function printPromise(){ return new Promise(res=> setTimeout(res, 150)); }
    async function printSetOnce(){ 
      buildSheet(); 
      const modal=document.getElementById('modal'); 
      
      // iOS/iPad fix: Explicitly hide all non-printable content
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      
      if(isIOS() || isMobileLike()){
        // Hide everything except the modal content
        if(wrap) wrap.style.display='none';
        if(brandBar) brandBar.style.display='none';
        if(printChooser) printChooser.style.display='none';
        if(stageModal) stageModal.style.display='none';
        if(notesModal) notesModal.style.display='none';
      }
      
      modal.classList.add('open'); 
      await printPromise(); 
      // Force layout recalculation on mobile devices
      const sheet=document.getElementById('sheet');
      if(sheet){ 
        sheet.style.display='none'; 
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block'; 
      }
      await printPromise(); 
      window.print(); 
      await printPromise();
      modal.classList.remove('open'); 
      
      // Restore visibility
      if(isIOS() || isMobileLike()){
        if(wrap) wrap.style.display='';
        if(brandBar) brandBar.style.display='';
        if(printChooser) printChooser.style.display='';
        if(stageModal) stageModal.style.display='';
        if(notesModal) notesModal.style.display='';
      }
      
      await printPromise(); 
    }
    function prepHdrTech(){
      const hdr=$('#hdrTech'); hdr.innerHTML='';
      const hf=(function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band&&!f.venue&&!f.sub&&!f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.append(el('div','band',(gig.band||'BAND')));
      if(hf.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
      if(hf.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
      if(hf.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
    }
    async function printStageOnce(){
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech();
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='none';
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; stageOut.style.display='block';
      buildStageExport(stageOut);
      // Force images to load before printing
      await inlineStageImages(stageOut.querySelector('svg'));
      // Keep legend with stage plot on same page
      const legend = stageOut.querySelector('table.tech-table');
      // Don't move legend, keep it in stageOut to stay on same page
      // Remove page breaks to fit everything on one page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      
      // iOS/iPad fix: Explicitly hide all non-printable content
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      if(isIOS() || isMobileLike()){
        // Hide everything except the tech/stage modal content
        if(wrap) wrap.style.display='none';
        if(brandBar) brandBar.style.display='none';
        if(printChooser) printChooser.style.display='none';
        if(setlistModal) setlistModal.style.display='none';
        if(stageModal) stageModal.style.display='none';
        if(notesModal) notesModal.style.display='none';
      }
      
      const modal=document.getElementById('modalTech');
      modal.classList.add('open');
      await printPromise();
      // Force layout recalculation for mobile reliability
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      await printPromise();
      window.print();
      await printPromise();
      modal.classList.remove('open');
      
      // Restore visibility
      if(isIOS() || isMobileLike()){
        if(wrap) wrap.style.display='';
        if(brandBar) brandBar.style.display='';
        if(printChooser) printChooser.style.display='';
        if(setlistModal) setlistModal.style.display='';
        if(stageModal) stageModal.style.display='';
        if(notesModal) notesModal.style.display='';
      }
      
      await printPromise();
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        // Re-render the current view by toggling stage/notes modals
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          // Stage was visible - reopen it
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          // Tech table was visible - rebuild it
          try{ buildTechTableFull(); }catch(_){}
        } else {
          // Neither was open, default to stage plot
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }
    async function printTechOnlyOnce(){ 
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech(); 
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; stageOut.style.display='none'; 
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='block';
      // Ensure no forced page break when printing tech-only
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl); 
      
      // iOS/iPad fix: Explicitly hide all non-printable content
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      if(isIOS() || isMobileLike()){
        // Hide everything except the tech modal content
        if(wrap) wrap.style.display='none';
        if(brandBar) brandBar.style.display='none';
        if(printChooser) printChooser.style.display='none';
        if(setlistModal) setlistModal.style.display='none';
        if(stageModal) stageModal.style.display='none';
        if(notesModal) notesModal.style.display='none';
      }
      
      const modal=document.getElementById('modalTech'); 
      modal.classList.add('open'); 
      await printPromise(); 
      // Force layout recalculation for mobile reliability
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      await printPromise();
      window.print(); 
      await printPromise();
      modal.classList.remove('open'); 
      
      // Restore visibility
      if(isIOS() || isMobileLike()){
        if(wrap) wrap.style.display='';
        if(brandBar) brandBar.style.display='';
        if(printChooser) printChooser.style.display='';
        if(setlistModal) setlistModal.style.display='';
        if(stageModal) stageModal.style.display='';
        if(notesModal) notesModal.style.display='';
      }
      
      await printPromise();
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          try{ buildTechTableFull(); }catch(_){}
        } else {
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }

    // Save/Load Profile (.BAND)
    const saveProfileBtn=document.getElementById('saveProfile');
    if(saveProfileBtn){ saveProfileBtn.addEventListener('click',()=>{
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      const stage = stageEl ? stageEl.outerHTML : '';
      const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
      const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
    }); }
    const loadProfileBtn=document.getElementById('loadProfile'); const loadProfileFile=document.getElementById('loadProfileFile');
    if(loadProfileBtn && loadProfileFile){
      loadProfileBtn.addEventListener('click',()=> loadProfileFile.click());
      loadProfileFile.addEventListener('change',()=>{
        const f=loadProfileFile.files && loadProfileFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && Array.isArray(obj.db)){
              // merge db by title+artist (case-insensitive)
              const keyOf=s=> ((s.title||'').toLowerCase().trim()+'|'+((s.artist||'Original').toLowerCase().trim()));
              const existing=new Set(db.map(keyOf));
              obj.db.forEach(s=>{
                const { audioData, ...rest } = s||{}; // drop any embedded audio from import
                const item={...rest};
                if(!item.id) item.id=Date.now()+Math.random();
                if(!item.artist) item.artist='Original';
                if(!item.length) item.length=3.5;
                if(!existing.has(keyOf(item))){ db.push(item); existing.add(keyOf(item)); }
              });
              renderDB();
            }
            if(obj && obj.gig){
              // merge gig fields only if missing
              const fields=['band','date','venue','address','contact','notes','font','logo'];
              fields.forEach(k=>{ if(!gig[k] && obj.gig[k]) gig[k]=obj.gig[k]; });
              if(obj.gig.headerFlags){ gig.headerFlags=Object.assign({band:true,venue:true,sub:true,notes:true}, gig.headerFlags, obj.gig.headerFlags); }
              // hydrate UI
              if(gig.band) document.getElementById('gBand').value=gig.band;
              if(gig.date) document.getElementById('gDate').value=gig.date;
              if(gig.venue) document.getElementById('gVenue').value=gig.venue;
              if(gig.address) document.getElementById('gAddr').value=gig.address;
              if(gig.contact) document.getElementById('gContact').value=gig.contact;
              if(gig.notes) document.getElementById('gNotes').value=gig.notes;
              const gFontElTmp=document.getElementById('gFont'); if(gFontElTmp && gig.font) gFontElTmp.value=gig.font;
              // header flags checkboxes
              ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
              refreshLogoPreview();
            }
            // hydrate gear and stage if present
            if(obj && 'gearSummary' in obj){ gearSummary = obj.gearSummary || ''; const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary; }
            if(obj && obj.stage){
              const container=document.getElementById('stageStore');
              if(container){
                container.innerHTML=obj.stage;
                const svg=container.querySelector('svg');
                if(svg){
                  svg.id='stageSvg';
                  svg.classList.add('bw');
                  try{ refreshCables(svg); }catch(_){ }
                }
              }
              // Overwrite existing full editor (if open) with loaded stage BEFORE any autosave can race
              const full=document.getElementById('stageSvgFull');
              const stageModal=document.getElementById('stageModal');
              const store=document.getElementById('stageSvg');
              if(full && store){
                try{
                  while(full.childNodes.length>2) full.removeChild(full.lastChild);
                  Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
                  ensureStageMarkers(full);
                  refreshCables(full);
                  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
                  bindSelection(full);
                  if(typeof refreshStageLegend==='function') refreshStageLegend();
                  if(typeof selectNode==='function') selectNode(null);
                  // Reset undo history baseline
                  if(Array.isArray(stageHistory)){
                    stageHistory.length=0; stageHistory.push(full.outerHTML); stageHistoryIndex=stageHistory.length-1;
                  }
                }catch(_){ /* non-fatal */ }
              }
              // If Tech/Stage tab is active and modal not open, auto-open it now to show restored layout
              const advPanel=document.getElementById('adv');
              const tabActive = advPanel && advPanel.style.display!=='none';
              if(tabActive && stageModal && !stageModal.classList.contains('open')){
                try{ if(typeof openStageModal==='function') openStageModal(); }catch(_){ }
              }
            }
            // Restore setlist & tech notes if present (current set)
            if(obj && Array.isArray(obj.setlist)){
              setlist = obj.setlist;
              try{ renderSet(); }catch(_){ }
            }
            if(obj && obj.techNotes && typeof obj.techNotes==='object'){
              techNotes = obj.techNotes;
            }
            saveAll();
          }catch(err){ alert('Failed to read .BAND file'); }
        };
        r.readAsText(f);
      });
    }

    // Zoom control for stage (applies to small canvas)
    // No inline zoom control anymore

    // Save .SET (export setlist only)
    const saveSetBtn=document.getElementById('saveSet'); if(saveSetBtn){ saveSetBtn.addEventListener('click',()=>{
      const data={version:1,type:'fastfast-set',setlist};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(gig.band? gig.band.replace(/\s+/g,'_')+'_' : '')+'setlist.set'; a.click(); URL.revokeObjectURL(a.href);
    }); }
    // Load .SET (import setlist only, keep current gig)
    const loadSetBtn=document.getElementById('loadSet'); const loadSetFile=document.getElementById('loadSetFile');
    if(loadSetBtn && loadSetFile){
      loadSetBtn.addEventListener('click',()=> loadSetFile.click());
      loadSetFile.addEventListener('change',()=>{
        const f=loadSetFile.files && loadSetFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && obj.setlist && Array.isArray(obj.setlist)){
              setlist=obj.setlist; renderSet(); saveAll();
            }else{ alert('Invalid .SET file'); }
          }catch(err){ alert('Failed to read .SET file'); }
        };
        r.readAsText(f);
      });
    }
    // --- Import (OCR / Paste) ---
    (function setupImport(){
      const txt=document.getElementById('importText');
      const file=document.getElementById('importFile');
      const parseBtn=document.getElementById('importParseBtn');
      const commitBtn=document.getElementById('importCommitBtn');
      const statusEl=document.getElementById('importStatus');
      const previewEl=document.getElementById('importPreview');
      if(!txt || !file || !parseBtn || !commitBtn) return;
      let parsed=[];
      function sanitizeLine(line){ return line.replace(/\s+/g,' ').trim(); }
      function detectCapo(str){ const m=str.match(/capo\s*(\d{1,2})/i); if(m){ const v=parseInt(m[1],10); if(Number.isInteger(v) && v>=0 && v<=24) return v; } return 0; }
      function detectKey(str){ // first standalone musical key token
        const m=str.match(/\b([A-G](?:#|b)?m?)\b/); return m? m[1] : ''; }
      function parseSongLines(text){
        const out=[]; const lines=text.split(/\r?\n/);
        for(let raw of lines){ let line=sanitizeLine(raw); if(!line) continue; const capo=detectCapo(line); if(capo) line=line.replace(/capo\s*\d{1,2}/i,'').trim(); const key=detectKey(line); let title=line; // remove key if separated by dash/pipe/colon or at end
          if(key){ const sepPattern=new RegExp('[-|:]?\s*'+key+'\s*$','i'); title=title.replace(sepPattern,'').trim(); if(title.toLowerCase().startsWith(key.toLowerCase()+' ')) title=title.slice(key.length).trim(); }
          // Remove trailing parentheses or brackets containing key or capo info
          title=title.replace(/\((?:capo|key)[^)]*\)$/i,'').trim();
          if(title) out.push({title, key, capo, length:3.5, artist:'Original'}); }
        return out; }
      function dedupe(list){ const seen=new Set(); return list.filter(s=>{ const k=(s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); if(seen.has(k)) return false; seen.add(k); return true; }); }
      function renderPreview(){ if(!parsed.length){ previewEl.innerHTML='<em>No parsed songs.</em>'; commitBtn.disabled=true; return; }
        // Build editable table
        const tbl=document.createElement('table'); tbl.style.width='100%'; tbl.style.borderCollapse='collapse';
        const thead=document.createElement('thead'); thead.innerHTML='<tr style="background:#e2e8f0"><th style="text-align:left;padding:4px 6px">Title</th><th style="text-align:left;padding:4px 6px">Key</th><th style="text-align:left;padding:4px 6px">Capo</th><th style="text-align:left;padding:4px 6px">Len (m)</th><th style="text-align:left;padding:4px 6px">Remove</th></tr>';
        const tbody=document.createElement('tbody');
        parsed.forEach((s,i)=>{
          const tr=document.createElement('tr');
          const tdTitle=document.createElement('td'); const inpTitle=document.createElement('input'); inpTitle.type='text'; inpTitle.value=s.title; inpTitle.style.width='100%'; inpTitle.addEventListener('input',()=>{ s.title=inpTitle.value.trim(); }); tdTitle.style.padding='4px 6px'; tdTitle.appendChild(inpTitle);
          const tdKey=document.createElement('td'); const inpKey=document.createElement('input'); inpKey.type='text'; inpKey.value=s.key||''; inpKey.placeholder='Key'; inpKey.style.width='70px'; inpKey.addEventListener('input',()=>{ s.key=inpKey.value.trim(); }); tdKey.style.padding='4px 6px'; tdKey.appendChild(inpKey);
          const tdCapo=document.createElement('td'); const inpCapo=document.createElement('input'); inpCapo.type='number'; inpCapo.min='0'; inpCapo.max='24'; inpCapo.value=String(Number.isInteger(s.capo)? s.capo:0); inpCapo.style.width='56px'; inpCapo.addEventListener('change',()=>{ let v=parseInt(inpCapo.value,10); if(!Number.isInteger(v)||v<0) v=0; if(v>24) v=24; s.capo=v; inpCapo.value=String(v); }); tdCapo.style.padding='4px 6px'; tdCapo.appendChild(inpCapo);
          const tdLen=document.createElement('td'); const inpLen=document.createElement('input'); inpLen.type='number'; inpLen.min='0.5'; inpLen.step='0.5'; inpLen.value=String(s.length||3.5); inpLen.style.width='70px'; inpLen.addEventListener('change',()=>{ let v=parseFloat(inpLen.value); if(!isFinite(v)||v<=0) v=3.5; s.length=v; inpLen.value=String(v); }); tdLen.style.padding='4px 6px'; tdLen.appendChild(inpLen);
          const tdRemove=document.createElement('td'); tdRemove.style.padding='4px 6px'; const btnRem=document.createElement('button'); btnRem.type='button'; btnRem.textContent='√ó'; btnRem.className='btn danger'; btnRem.style.padding='2px 8px'; btnRem.style.fontSize='14px'; btnRem.addEventListener('click',()=>{ parsed.splice(i,1); renderPreview(); }); tdRemove.appendChild(btnRem);
          tr.append(tdTitle,tdKey,tdCapo,tdLen,tdRemove); tbody.appendChild(tr);
        });
        tbl.append(thead,tbody); previewEl.innerHTML=''; previewEl.appendChild(tbl); commitBtn.disabled=false;
      }
      function addParsedToDb(){ const existingKeyOf=s=> (s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); const existing=new Set(db.map(existingKeyOf)); let added=0; parsed.forEach(s=>{ if(!existing.has(existingKeyOf(s))){ s.id=Date.now()+Math.random(); db.push(s); existing.add(existingKeyOf(s)); added++; } }); renderDB(); renderSongPool(); saveAll(); statusEl.textContent=`Imported ${added} new song${added===1?'':'s'}.`; }
      parseBtn.addEventListener('click',()=>{ parsed=dedupe(parseSongLines(txt.value||'')); statusEl.textContent=`Parsed ${parsed.length} song line${parsed.length===1?'':'s'}.`; renderPreview(); });
      commitBtn.addEventListener('click', addParsedToDb);
      async function ensurePdfJs(){ if(window.pdfjsLib) return; statusEl.textContent='Loading PDF.js‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); if(window.pdfjsLib){ window.pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; } }
      async function ensureTesseract(){ if(window.Tesseract) return; statusEl.textContent='Loading Tesseract‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); }
      file.addEventListener('change', async()=>{
        previewEl.innerHTML=''; parsed=[]; commitBtn.disabled=true; statusEl.textContent=''; const f=file.files && file.files[0]; if(!f) return;
        const type=f.type||''; const name=(f.name||'').toLowerCase();
        if(type.startsWith('text') || name.endsWith('.txt')){ const r=new FileReader(); r.onload=e=>{ parsed=dedupe(parseSongLines(String(e.target.result||''))); statusEl.textContent=`Parsed ${parsed.length} from text file.`; renderPreview(); }; r.readAsText(f); return; }
        if(name.endsWith('.pdf') || type==='application/pdf'){ try{ await ensurePdfJs(); statusEl.textContent='Reading PDF‚Ä¶'; const url=URL.createObjectURL(f); const doc=await window.pdfjsLib.getDocument(url).promise; let full=''; for(let p=1;p<=doc.numPages;p++){ const page=await doc.getPage(p); const txtC=await page.getTextContent(); full += txtC.items.map(i=> i.str).join(' ')+'\n'; } URL.revokeObjectURL(url); parsed=dedupe(parseSongLines(full)); statusEl.textContent=`Parsed ${parsed.length} from PDF.`; renderPreview(); }catch(err){ statusEl.textContent='PDF parsing failed.'; console.error(err); } return; }
        if(type.startsWith('image/')){ try{ await ensureTesseract(); statusEl.textContent='Running OCR‚Ä¶'; const { Tesseract }=window; const result=await Tesseract.recognize(f,'eng',{ logger:m=>{ if(m.status==='recognizing text'){ statusEl.textContent=`OCR: ${Math.round(m.progress*100)}%`; } } }); const text=result && result.data && result.data.text || ''; parsed=dedupe(parseSongLines(text)); statusEl.textContent=`Parsed ${parsed.length} from image OCR.`; renderPreview(); }catch(err){ statusEl.textContent='Image OCR failed.'; console.error(err); } return; }
        statusEl.textContent='Unsupported file type.';
      });
    })();
  </script>
  <!-- Lightweight libs for client PDF/ZIP export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Bottom brand bar -->
  <div class="brand-bar">
    FASTFAST SETLIST and STAGE DESIGNER (c) 2025 All Rights Reserved
  </div>
</body>
</html>
