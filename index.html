<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    :root{
      --bg:#f5f7fb; --card:#ffffff; --muted:#4b5563; --accent:#1f2937; --accent2:#374151; --danger:#374151;
      --paperText:#111; --paperRule:#444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-size:16px;font-family:Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif;background:#f3f4f6;color:#1f2937;overflow-x:hidden}
  .wrap{max-width:min(1600px,98vw);margin:0 auto;padding:24px;overflow-x:hidden}
    .hero{background:linear-gradient(135deg,#e0ecff 0%,#f0f7ff 60%,#e6fbff 100%);border:1px solid #dbeafe;border-radius:16px;padding:28px;text-align:center;color:#111;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .hero h1{margin:0 0 6px;font-size:32px}
  .tabs{display:flex;margin:16px 0;border-bottom:2px solid #e5e7eb;width:100%}
  .tab{flex:1;padding:14px 8px;background:transparent;border:none;color:#374151;font-weight:700;cursor:pointer;font-size:15px;text-align:center;white-space:nowrap}
    .tab.active{color:#111;border-bottom:3px solid var(--accent);background:#f0f9ff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;max-width:100%;overflow:visible}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:12px;padding:16px;max-width:100%;overflow:visible}
    .card h2{margin:0 0 12px;font-size:20px;color:#111}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>.field{flex:1;min-width:220px}
    .field{margin:8px 0}
    label{display:block;margin-bottom:6px;font-size:13px;color:#374151;font-weight:600}
    input,select,textarea{width:100%;padding:12px 12px;border-radius:10px;border:1px solid #d1d5db;background:#ffffff;color:#111;font-size:15px}
    input[type="checkbox"]{width:auto}
    .checks{display:flex;flex-wrap:wrap;gap:12px}
    .btn{padding:11px 16px;border-radius:10px;border:1px solid #374151;color:#f9fafb;background:#1f2937;cursor:pointer;font-weight:800}
    .btn.secondary{background:#6b7280;border-color:#4b5563}
    .btn.danger{background:#374151;border-color:#1f2937;color:#f9fafb}
    .list{display:grid;gap:10px;margin-top:12px}
  .song{display:flex;gap:12px;align-items:center;justify-content:space-between;background:#ffffff;border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .song.dragging{opacity:.6}
    .song .meta{font-size:13px;color:#4b5563}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;margin-right:6px}
  .handle{cursor:grab;color:#6b7280;font-size:18px;user-select:none;margin-right:6px}
  .handle:active{cursor:grabbing}

    /* Print preview (paper look) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:flex-start;justify-content:center;padding:24px;z-index:80;overflow:auto;pointer-events:none}
    .modal.open{display:flex;pointer-events:auto}
    .modal .modalbox{pointer-events:auto}
    .modal .sheet{pointer-events:auto}
    .sheet{width:8.5in;max-width:100%;min-height:11in;background:white;color:var(--paperText);border-radius:8px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:0.4in 0.5in;overflow:visible;margin:auto}
  @media (max-width:768px){
    .modal{align-items:flex-start;padding:10px}
    .modal .sheet{width:100%;height:auto;max-height:90vh;padding:16px;box-sizing:border-box}
  }
    .sheet.a4{width:210mm;min-height:277mm}
    .sheet.multipage{display:flex;flex-direction:column;gap:20px;height:auto}
    .sheet-page{width:100%;height:10.5in;min-height:10.5in;background:white;border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,.15);padding:0.15in 0.25in;page-break-after:always;display:flex;flex-direction:column;box-sizing:border-box}
    .sheet.a4 .sheet-page{height:277mm;min-height:277mm}
  .hdr{text-align:center;padding-bottom:4px;margin-bottom:6px;flex-shrink:0}
    .hdr .band{font-size:22pt;font-weight:900;letter-spacing:.6px}
    .hdr .venue{font-size:18pt;font-weight:800;letter-spacing:.5px;margin-top:1px}
  .hdr .sub{font-size:9pt;color:#444;margin-top:2px}
  .hdr .notes{font-size:9pt;color:#333;margin-top:1px;font-style:italic}
  .hdr .logo{display:block}
  .hdr .logo img{max-height:48pt;max-width:100%;height:auto}
    .songs{display:flex;flex-direction:column;gap:2px;flex:1;min-height:0}
  .line{display:grid;grid-template-columns:22px 1fr minmax(90px,120px) 40px;align-items:baseline;column-gap:8px;padding:1px 0}
  .line .no{font-weight:800;text-align:right;opacity:.85}
  .line .title{font-weight:900;letter-spacing:.1px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .title .notePrint{font-size:9pt;font-style:italic;font-weight:400;opacity:.75;margin-left:6px;white-space:nowrap}
  .line .key{font-size:10pt;color:#374151;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .time{font-size:10pt;text-align:right;opacity:.9}
  .line.dragging,.break.dragging{opacity:0.4}
  .line.dragging .title,.line.dragging .no,.line.dragging .time{cursor:grabbing!important}
  .break.dragging{cursor:grabbing!important}
  .break[draggable="true"]{cursor:grab}
    .no{font-weight:800;font-size:12pt;min-width:26px;text-align:right;color:#333}
  .title{flex:1;font-size:17pt;font-weight:900;letter-spacing:0.2px}
    .time{min-width:42px;text-align:right;font-size:10pt;color:#444}
  .subnotes{font-size:9pt;color:#4b5563;font-style:italic;margin-top:-2px;margin-left:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .break{font-weight:900;text-transform:uppercase;font-size:14pt;color:#7b1fa2;text-align:center;border:2px dashed #7b1fa2;padding:6px 8px;border-radius:8px;background:#f7efff}
  .total-time{flex-shrink:0;margin-top:auto}
  
  /* Editable header fields */
  .hdr [contenteditable="true"]{outline:none;transition:background 0.2s}
  .hdr [contenteditable="true"]:hover{background:rgba(59,130,246,0.05)}
  .hdr [contenteditable="true"]:focus{background:rgba(59,130,246,0.1);border-radius:4px}
  .hdr [contenteditable="true"]:empty:before{content:attr(data-placeholder);color:#9ca3af;font-style:italic}

  /* Small centered modal box for print options */
  .modalbox{background:white;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,.3);padding:24px;max-width:420px;width:90vw;max-height:80vh;overflow:auto}
  .modalbox .hdr{text-align:center;padding-bottom:12px;margin-bottom:16px;border-bottom:1px solid #e5e7eb}
  .modalbox .band{font-size:20px;font-weight:800}

  .tools{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:12px}
    .tools .paper{color:#374151}

  /* Floating Song Pool */
  .pool-flyout{position:fixed;top:76px;right:18px;width:320px;max-width:92vw;height:calc(100% - 100px);background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,.18);display:none;flex-direction:column;z-index:65}
  .pool-flyout.open{display:flex}
  .pool-head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #e5e7eb}
  .pool-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .pool-sec h4{margin:0 0 6px 0;font-size:13px;color:#6b7280;text-transform:uppercase;letter-spacing:.6px}
  /* Base pill chip styling (used in Song Pool) */
  .pill{display:inline-flex;align-items:center;gap:6px;border:2px solid #d1d5db;border-radius:999px;padding:8px 14px;background:#fff;font-size:14px;color:#111827;min-height:36px}
  .pool-sec .pill{cursor:grab}
  .pill.drag-touch{opacity:.55;outline:2px dashed #374151}
  .touch-target-highlight{box-shadow:inset 0 3px 0 #374151,inset 0 -3px 0 #374151}
  /* Live layout: no wrap on wide screens; wrap on narrow */
  #liveFlex{flex-wrap:nowrap;flex-direction:row}
  #liveLeftCol{flex:0 0 340px;min-width:340px}
  @media (max-width: 900px){ #liveFlex{flex-wrap:wrap;flex-direction:row} #liveLeftCol{flex:1 1 100%;min-width:260px} }
  /* Mood pastel chips */
  .pill.mood-upbeat{background:#FECACA;border-color:#FCA5A5}
  .pill.mood-happy{background:#FEF9C3;border-color:#FDE68A}
  .pill.mood-energetic{background:#CFFAFE;border-color:#A5F3FC}
  .pill.mood-mellow{background:#FFEDD5;border-color:#FED7AA}
  .pill.mood-sad{background:#DBEAFE;border-color:#BFDBFE}
  /* Drop indicator on preview sheet rows */
  .line.drop-before, .break.drop-before{box-shadow:inset 0 3px 0 0 #60a5fa}
  .line.drop-after, .break.drop-after{box-shadow:inset 0 -3px 0 0 #60a5fa}
  /* Tour date tabs */
  .tour-date-tab:hover{background:#f0f9ff !important;border-color:#0ea5e9 !important}
  /* Tour interest chips - draggable */
  .tour-interest-chip{
    display:flex;
    align-items:flex-start;
    gap:8px;
    padding:10px 12px;
    background:#fff;
    border:1px solid #d1d5db;
    border-radius:8px;
    cursor:move;
    font-size:13px;
    transition:all 0.2s;
    user-select:none;
    box-shadow:0 1px 3px rgba(0,0,0,0.1);
    min-width:250px;
    max-width:350px;
  }
  .tour-interest-chip:hover{
    box-shadow:0 4px 8px rgba(0,0,0,0.15);
    transform:translateY(-2px);
  }
  .tour-interest-chip.dragging{
    opacity:0.6;
    transform:scale(0.98);
  }
  .tour-interest-chip .chip-remove{
    background:none;
    border:none;
    color:#9ca3af;
    cursor:pointer;
    padding:0;
    font-size:20px;
    line-height:1;
    flex-shrink:0;
    margin-left:auto;
  }
  .tour-interest-chip .chip-remove:hover{
    color:#dc2626;
  }
  #tourInterestsDropZone.drag-over{
    background:#e0f2fe;
    border-color:#0ea5e9;
  }

    @media print{
      /* Universal print settings - works on Windows/Mac/iOS/Android */
      @page { 
        margin: 0.25in 0.35in; 
        size: letter; 
      }
      
      /* Force consistent rendering across platforms */
      body,*{
        background:transparent!important;
        overflow:visible!important;
        -webkit-print-color-adjust:exact!important;
        print-color-adjust:exact!important;
      }
      
      /* Hide all UI chrome */
      .wrap{display:none!important}
      .brand-bar{display:none!important}
      .global-actions{display:none!important}
      .tools{display:none!important}
      #printChooser{display:none!important}
      #songPoolFlyout{display:none!important}
      .print-fab{display:none!important}
      
      /* Show only modal content */
      .modal{position:static;display:none;background:none;padding:0;margin:0}
      .modal.open{display:block!important}
      
      /* Setlist print layout */
      .sheet{
        box-shadow:none!important;
        height:10.5in!important;
        min-height:10.5in!important;
        overflow:visible!important;
        padding:0.15in 0.25in!important;
        margin:0!important;
        width:100%!important;
        max-width:100%!important;
        display:flex!important;
        flex-direction:column!important;
      }
      .sheet.multipage{gap:0!important;height:auto!important}
      .sheet-page{
        box-shadow:none!important;
        padding:0.15in 0.25in!important;
        margin:0!important;
        page-break-after:always;
        page-break-inside:avoid;
        height:10.5in!important;
        min-height:10.5in!important;
        display:flex!important;
        flex-direction:column!important;
      }
      .sheet-page:last-child{page-break-after:auto}
      .hdr{flex-shrink:0!important}
      .songs{
        height:100%!important;
        min-height:0!important;
        flex:1!important;
        display:flex!important;
        flex-direction:column!important;
      }
      .total-time{flex-shrink:0!important;margin-top:auto!important}
      .break.pagebreak{page-break-after:always}
      
      /* Stage plot and tech table sizing */
      #stagePrint svg, #stagePrint canvas{
        max-width:100%!important;
        height:auto!important;
        page-break-inside:avoid!important;
      }
      
      /* Lyrics print container - ensure isolation */
      #lyricsPrintContainer{
        display:block!important;
        position:relative!important;
        z-index:999999!important;
      }
      #lyricsPrintContainer > div{
        page-break-after:always!important;
        page-break-inside:avoid!important;
      }
      #lyricsPrintContainer > div:last-child{
        page-break-after:auto!important;
      }
      
      /* Hide scrollbars in print */
      *::-webkit-scrollbar{display:none!important}
      *{scrollbar-width:none!important}
    }

  /* Fullscreen Stage Editor */
  /* Inline stage editor (converted from fullscreen) */
  .stage-modal{position:static;background:transparent;display:none;z-index:auto;margin-top:12px}
  .stage-modal.open{display:flex}
  .stage-editor{display:grid;grid-template-columns:340px 1fr;gap:16px;background:#fff;width:100%;min-height:640px}
  .stage-pane{padding:10px 12px 16px;overflow:hidden;border-right:1px solid #e5e7eb}
  .stage-pane .tool{white-space:nowrap}
  .stage-pane .toolbox-actions{display:flex;flex-wrap:wrap;gap:8px;margin:0 0 8px}
  .stage-pane .toolbox-actions button{padding:6px 10px;font-size:12px}
  .stage-canvas{padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;overflow:auto;position:relative}
  /* Preserve full-size stage canvas on desktop; limit height on tablets/phones */
  #stageSvgFull{width:100% !important;height:auto !important;aspect-ratio:1500/900;flex:0 0 auto;max-height:70vh}
  #stageFrame{max-width:100%;overflow:visible}
  @media (max-width:900px){
    #stageSvgFull{max-height:55vh;max-width:100%;aspect-ratio:1500/900!important;height:auto!important}
    #stageFrame{max-width:calc(100vw - 48px)}
    .stage-canvas{padding:6px}
  }
  .stage-legend{width:100%;border:1px solid #e5e7eb;background:#f9fafb;border-radius:6px;padding:4px;display:flex;flex-direction:column;gap:2px;font-size:11px;line-height:1.1}
  .stage-legend .row{display:grid;grid-template-columns:60px 1fr 110px 160px;align-items:center;gap:6px;padding:1px 4px;}
  .stage-legend .row:nth-child(odd){background:#fff}
  .stage-legend img{width:16px;height:16px;object-fit:contain;display:block;margin:0 auto}
  .stage-legend .nm{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:11px}
  .stage-legend select,.stage-legend input[type=number]{font-size:11px;padding:0 2px;height:18px}
  .stage-legend .chain{font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .tool[draggable="true"]{user-select:none}
  .stage-actions{position:absolute;top:10px;right:10px;display:flex;gap:8px}
  /* Hide close button in inline mode; Clear moved into toolbox footer */
  #closeStage{display:none}
  /* Tech / Stage: tech rider & stage plot (B&W) */
  .advanced-grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
  .tech-table{width:100%;border-collapse:collapse}
  .tech-table th,.tech-table td{border:1px solid #e5e7eb;padding:4px 6px;font-size:11px;line-height:1.2}
  .stage-wrap{border:1px solid #e5e7eb;border-radius:8px;background:#fff;padding:10px}
  .stage-tools{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}
  .tool{border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;padding:6px 8px;font-size:13px;cursor:pointer}
  .stage{width:100%;height:90vh;min-height:640px;border:1px dashed #cbd5e1;background:#ffffff}
  .stage svg{width:100%;height:100%;background:white}
  /* B&W outlines for glyphs, keep background white */
  .bw .stage-bg{fill:#fff;stroke:#000;stroke-width:2}
  /* Allow colored emoji backgrounds: only force outline for rects without data-bg */
  .bw rect:not([data-bg]){fill:none;stroke:#000}
  .bw path,.bw circle,.bw ellipse,.bw line,.bw polyline,.bw polygon{fill:none;stroke:#000}
  .bw text{fill:#000;stroke:none}
  /* selection visual (editor only; not printed) */
  g[data-draggable].selected path,
  g[data-draggable].selected rect,
  g[data-draggable].selected circle,
  g[data-draggable].selected ellipse,
  g[data-draggable].selected line,
  g[data-draggable].selected polyline,
  g[data-draggable].selected polygon{stroke:#374151}
  g[data-draggable].selected text{text-decoration:underline}
  g[data-draggable].selected{filter:drop-shadow(0 0 6px rgba(37,99,235,0.65));}
  .stage-inspector{display:flex;gap:10px;align-items:center;flex-wrap:wrap;position:relative;padding:8px;background:#fff;border:1px solid #e5e7eb;border-radius:6px}
  .stage-inspector .connection-chain{order:-1;flex-basis:100%;margin-bottom:4px}
  /* Stage frame & resize handles */
  #stageFrame{outline:3px solid #000;pointer-events:none}
  #stageFrame .stage-handle{position:absolute;width:16px;height:16px;background:#000;border:2px solid #fff;border-radius:4px;z-index:85;pointer-events:auto;box-shadow:0 0 0 1px #000}
  #stageFrame .stage-handle.tl{top:-10px;left:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle.tr{top:-10px;right:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.bl{bottom:-10px;left:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.br{bottom:-10px;right:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle:active{background:#374151}
  .drag-assign-handle{transition:all 0.2s ease}
  .drag-assign-handle:hover{transform:scale(1.1);box-shadow:0 4px 12px rgba(0,0,0,0.4) !important}
  .drag-assign-handle:active{transform:scale(0.95);cursor:grabbing !important}
  #stageSvgFull{pointer-events:auto}
  .stage-inspector .muted{color:#6b7280;font-size:13px}
  .gear-wrap{margin-top:8px}
  .gear-wrap textarea{width:100%;min-height:42px}
  /* Global print FAB */
  .print-fab{position:fixed;right:18px;bottom:18px;z-index:70;border-radius:999px;padding:12px 16px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
  @media print{ .print-fab{display:none} }
  /* Print-specific tweaks for tech/stage so content stays on page */
  @media print{
    #sheetTech{width:8.5in;max-width:8.5in;padding:0.5in}
    #sheetTech .tech-table th,#sheetTech .tech-table td{font-size:9pt;padding:3px 4px}
    #stagePrint svg{max-height:6.5in;max-width:7.5in;width:100%;height:auto}
    #stagePrint{overflow:hidden}
  }
  /* Touch optimizations */
  #stageSvgFull{ touch-action:none; }
  .stage-canvas{ -webkit-user-select:none; user-select:none; }
  /* Global sticky actions (top-left) */
  .global-actions{position:sticky;top:0;z-index:60;display:flex;gap:8px;flex-wrap:wrap;padding:6px 0 4px 0;margin:0 0 8px 0;background:rgba(249,250,251,0.96);backdrop-filter:blur(2px);min-height:44px}
  @media print{ .global-actions{display:none} }
  /* Database: horizontal scroll on narrow screens */
  @media (max-width: 768px){
    #dbList{overflow-x:auto;overflow-y:visible}
    .db-row{min-width:900px}
    /* Setlist page: stack columns vertically on mobile with scroll */
    #set{overflow:visible !important;max-height:none !important;height:auto !important}
    #setlistLayout{flex-wrap:wrap !important;overflow:visible !important;height:auto !important;align-items:stretch !important}
    #poolCol{flex:1 1 100% !important;min-width:100% !important;max-height:40vh !important;overflow-y:auto !important;border:2px solid #e5e7eb;border-radius:8px;padding:12px;margin-bottom:12px;background:#f9fafb;position:relative !important;top:auto !important;align-self:auto !important}
    #previewCol{flex:1 1 100% !important;min-width:100% !important;max-width:100% !important;position:relative !important;max-height:none !important;height:auto !important;top:auto !important;align-self:auto !important}
    #optionsCol{flex:1 1 100% !important;position:relative !important;top:auto !important;align-self:auto !important;margin-top:16px;padding-top:16px;border-top:2px solid #e5e7eb;height:auto !important;max-height:none !important}
  }
  /* Missing songs list */
  .missing{margin:8px 0 6px 0;display:flex;flex-wrap:wrap;gap:6px}
  .missing .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #d1d5db;border-radius:999px;padding:4px 8px;background:#fff;font-size:12px;color:#111827}
  .missing .pill .add{background:#065f46;color:#fff;border:none;border-radius:999px;padding:2px 8px;cursor:pointer}
  .missing .pill .add:hover{background:#064e3b}
  /* Tabs styling */
  .tabs{display:flex;gap:4px;margin-bottom:10px;border-bottom:1px solid #374151}
  .tab{border:none;padding:6px 12px;font-size:14px;background:#6b7280;color:#f9fafb;border-top-left-radius:6px;border-top-right-radius:6px;cursor:pointer}
  .tab.active{background:#1f2937;color:#f9fafb}
  .tab:not(.active):hover{background:#4b5563}
  /* Bottom brand bar */
  .brand-bar{position:fixed;bottom:0;left:0;right:0;height:20px;background:#1f2937;color:#e5e7eb;font-size:11px;display:flex;align-items:center;justify-content:center;z-index:80}
  .brand-bar a{color:inherit;text-decoration:none}
  .brand-bar a:hover{text-decoration:underline}
  /* Keep global actions visible in live mode to prevent layout jump */
  /* Live fullscreen lyrics */
  .live-lyrics-overlay{position:fixed;inset:0;background:#020617;color:#e5e7eb;z-index:90;display:none;flex-direction:column}
  .live-lyrics-overlay.open{display:flex}
  .live-lyrics-header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:#0b1120;border-bottom:1px solid #1f2937}
  .live-lyrics-title{font-weight:700;font-size:16px;margin-right:auto;margin-left:10px}
  .live-lyrics-main{flex:1 1 auto;overflow:auto;padding:16px;display:flex;align-items:flex-start;justify-content:center}
  .live-lyrics-body{white-space:pre-wrap;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;font-size:20px;line-height:1.5;text-align:center;max-width:1100px;margin:0 auto}
  .live-lyrics-play{padding:8px 14px;border-radius:999px;border:none;background:#22c55e;color:#022c22;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-stop{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer;margin-right:8px}
  .live-lyrics-exit{padding:8px 14px;border-radius:999px;border:none;background:#374151;color:#f9fafb;font-weight:700;cursor:pointer}
  @media (max-width:768px){
    .live-lyrics-body{font-size:18px}
  }
  /* Live tab theming */
  body.live-dark #live{background:#020617;color:#e5e7eb}
  body.live-dark #liveList{background:#020617;border-color:#1f2937}
  body.live-dark #liveList .live-row{border-bottom-color:#111827}
  body.live-dark #liveLyrics{background:#020617;border-color:#1f2937;color:#e5e7eb}
  body.live-dark .tab[data-tab="live"].active{background:#0f172a;color:#f9fafb}
  /* Desktop inline live controls stick to top while scrolling */
  #liveLyrics{position:relative}
  #liveLyrics #liveInlineControls{position:sticky;top:0;z-index:2;padding:6px 4px;margin:-12px -12px 8px -12px;border-bottom:1px solid #e5e7eb;background:linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0));backdrop-filter:saturate(1.2) blur(2px)}
  body.live-dark #liveLyrics #liveInlineControls{border-bottom-color:#1f2937;background:linear-gradient(180deg, rgba(2,6,23,0.96), rgba(2,6,23,0))}
  /* Live mode: hide brand bar and any open stage/notes modals for distraction-free view */
  body.live-mode .brand-bar{display:none}
  body.live-mode #stageModal, body.live-mode #notesModal{display:none !important}
  
  /* Global date selector header strip */
  .date-header{
    position:sticky;
    top:0;
    z-index:70;
    background:linear-gradient(135deg,#1e293b 0%,#334155 100%);
    border-bottom:2px solid #0ea5e9;
    padding:6px 12px;
    display:flex;
    align-items:center;
    gap:12px;
    overflow-x:auto;
    overflow-y:hidden;
    box-shadow:0 2px 8px rgba(0,0,0,0.15);
    position:relative;
  }
  /* Date box context menu */
  .date-context-menu{
    position:fixed;
    background:#fff;
    border:1px solid #d1d5db;
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
    z-index:10000;
    min-width:180px;
    padding:6px 0;
  }
  .date-context-menu button{
    display:block;
    width:100%;
    padding:10px 16px;
    border:none;
    background:none;
    text-align:left;
    cursor:pointer;
    font-size:14px;
    color:#1f2937;
    transition:background 0.15s;
  }
  .date-context-menu button:hover{
    background:#f3f4f6;
  }
  .date-context-menu button.danger{
    color:#dc2626;
  }
  .date-context-menu button.danger:hover{
    background:#fee2e2;
  }
  
  /* Activity chips and timeline */
  .activity-chip{
    user-select:none;
    transition:all 0.2s;
    touch-action:none;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
  }
  .activity-chip:active{
    transform:scale(0.95);
    opacity:0.8;
  }
  .activity-chip.touch-dragging{
    position:fixed;
    z-index:99999;
    pointer-events:none;
    opacity:0.9;
    transform:scale(1.1);
    box-shadow:0 8px 24px rgba(0,0,0,0.3);
  }
  .timeline-slot.touch-drop-target{
    background:#bfdbfe !important;
    box-shadow:inset 0 0 0 2px #3b82f6;
  }
  .timeline-slot:hover{
    background:#f9fafb !important;
  }
  .itinerary-item{
    overflow:hidden;
  }
  .itinerary-item:hover{
    z-index:20 !important;
  }
  
  .date-header-label{
    color:#e5e7eb;
    font-size:12px;
    font-weight:700;
    white-space:nowrap;
    flex-shrink:0;
  }
  .current-date-display{
    color:#0ea5e9;
    font-size:14px;
    font-weight:800;
    white-space:nowrap;
    flex-shrink:0;
    padding:4px 12px;
    background:rgba(14,165,233,0.15);
    border-radius:6px;
    border:1px solid rgba(14,165,233,0.3);
  }
  /* Act selector styling */
  .act-selector{
    font-weight:600;
    padding:4px 10px;
    border-radius:6px;
    transition:background 0.15s;
  }
  .act-selector:hover{
    background:rgba(255,255,255,0.15);
  }
  .date-boxes-container{
    display:flex;
    gap:4px;
    flex:1;
    overflow-x:auto;
    padding:2px 0;
    scroll-behavior:smooth;
  }
  .date-box{
    min-width:70px;
    width:70px;
    height:48px;
    background:#f8fafc;
    border:2px solid #cbd5e1;
    border-radius:6px;
    cursor:pointer;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    font-size:10px;
    font-weight:600;
    color:#1e293b;
    position:relative;
    transition:all 0.15s;
    flex-shrink:0;
    padding:3px;
  }
  .date-box:hover{
    background:#e0f2fe;
    border-color:#0ea5e9;
    transform:translateY(-2px);
    box-shadow:0 2px 6px rgba(14,165,233,0.3);
  }
  .date-box.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    font-weight:800;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.has-gig{
    border-color:#22c55e;
    background:#d1fae5;
  }
  .date-box.has-gig.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  /* Status-based coloring */
  .date-box.status-complete{
    background:#d1fae5;
    border-color:#22c55e;
  }
  .date-box.status-complete.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-incomplete{
    background:#fed7aa;
    border-color:#fb923c;
  }
  .date-box.status-incomplete.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-cancelled{
    background:#fee2e2;
    border:2px dashed #dc2626;
    opacity:0.7;
  }
  .date-box.status-cancelled.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-today{
    background:#dbeafe;
    border-color:#3b82f6;
    box-shadow:0 0 0 2px #93c5fd;
  }
  .date-box.status-today.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.status-past{
    background:#f1f5f9;
    border-color:#cbd5e1;
    opacity:0.6;
  }
  .date-box.status-past.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-gig{
    background:#d1fae5;
    border-color:#22c55e;
  }
  .date-box.tour-gig.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-drive{
    background:#fef08a;
    border-color:#facc15;
  }
  .date-box.tour-drive.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-rest{
    background:#fed7aa;
    border-color:#fb923c;
  }
  .date-box.tour-rest.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-home{
    background:#f8fafc;
    border-color:#cbd5e1;
  }
  .date-box.tour-home.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box.tour-rehearse,
  .date-box.tour-party,
  .date-box.tour-record,
  .date-box.tour-radio,
  .date-box.tour-tv,
  .date-box.tour-dj,
  .date-box.tour-audition,
  .date-box.tour-dressrehearsal,
  .date-box.tour-custom{
    background:#e9d5ff;
    border-color:#a855f7;
  }
  .date-box.tour-rehearse.active,
  .date-box.tour-party.active,
  .date-box.tour-record.active,
  .date-box.tour-radio.active,
  .date-box.tour-tv.active,
  .date-box.tour-dj.active,
  .date-box.tour-audition.active,
  .date-box.tour-dressrehearsal.active,
  .date-box.tour-custom.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  /* Cancelled shows */
  .date-box.tour-cancelled{
    background:#fee2e2;
    border:2px dashed #dc2626;
    opacity:0.7;
  }
  .date-box.tour-cancelled.active{
    background:#22c55e;
    border-color:#16a34a;
    color:#052e16;
    opacity:1;
    transform:scale(1.1);
    box-shadow:0 0 12px 4px rgba(34,197,94,0.5), 0 4px 12px rgba(0,0,0,0.2);
    z-index:10;
  }
  .date-box .date-icon{
    font-size:14px;
    line-height:1;
    margin-top:2px;
  }
  .drive-line{
    position:absolute;
    top:50%;
    left:-4px;
    right:-4px;
    height:3px;
    background:#facc15;
    z-index:-1;
  }
  .date-box .date-num{
    font-size:14px;
    line-height:1;
    margin-bottom:1px;
  }
  .date-box .date-month{
    font-size:8px;
    line-height:1;
    text-transform:uppercase;
    opacity:0.75;
  }
  .date-box .date-symbol{
    position:absolute;
    top:2px;
    right:2px;
    font-size:10px;
    line-height:1;
  }
  .date-box .date-count{
    position:absolute;
    bottom:2px;
    right:3px;
    font-size:9px;
    line-height:1;
    background:#374151;
    color:#f9fafb;
    border-radius:999px;
    min-width:14px;
    height:14px;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 3px;
  }
  .date-box.has-gig .date-count{
    background:#16a34a;
    color:#f0fdf4;
  }
  .date-box .date-city{
    font-size:8px;
    line-height:1.1;
    text-align:center;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    max-width:100%;
    margin-top:1px;
  }
  .date-box.dragging{
    opacity:0.5;
    transform:scale(0.95);
    cursor:grabbing;
  }
  .date-box.drag-over{
    outline:3px dashed #0ea5e9;
    outline-offset:2px;
  }
  .date-boxes-container::-webkit-scrollbar{
    height:6px;
  }
  .date-boxes-container::-webkit-scrollbar-track{
    background:#475569;
    border-radius:3px;
  }
  .date-boxes-container::-webkit-scrollbar-thumb{
    background:#0ea5e9;
    border-radius:3px;
  }
  @media print{
    .date-header{display:none}
  }
  </style>
</head>
<body>
  <!-- Global date selector strip: permanently visible across top -->
  <div class="date-header">
    <span class="act-selector" id="actSelector" style="cursor:pointer;font-weight:600;color:#60a5fa;padding:4px 12px;border-radius:6px" title="Click to switch band">Select Band...</span>
    <div class="date-boxes-container" id="dateBoxesContainer">
      <!-- Date boxes populated by JS -->
    </div>
  </div>
  
  <div class="wrap" style="padding-bottom:28px">
    <!-- Global sticky actions: always available top-left -->
    <div class="global-actions">
      <button class="btn" id="gearBtn" title="Show save/load tools" style="background:#065f46;border-color:#064e3b">‚öôÔ∏è</button>
      <button class="btn" id="openPrintOptionsTop" title="Print‚Ä¶" style="background:#065f46;border-color:#064e3b">Print‚Ä¶</button>
      <button class="btn" id="shareBtn" title="Share Database" style="background:#065f46;border-color:#064e3b">üì§ Share</button>
      <button class="btn" id="helpBtn" title="Help / Tutorial" style="background:#065f46;border-color:#064e3b">?</button>
      <div id="gearPanel" style="display:none;gap:8px;flex-wrap:wrap;margin-left:12px">
        <button class="btn" id="saveProfile" style="background:#065f46;border-color:#064e3b">Save Profile (.BAND)</button>
        <button class="btn" id="loadProfile" style="background:#065f46;border-color:#064e3b">Load Profile (.BAND)</button>
        <input type="file" id="loadProfileFile" accept=".band,application/json" style="display:none" />
        <button class="btn" id="saveSet" style="background:#065f46;border-color:#064e3b">Save .SET</button>
        <button class="btn" id="loadSet" style="background:#065f46;border-color:#064e3b">Load .SET</button>
        <input type="file" id="loadSetFile" accept=".set,application/json" style="display:none" />
      </div>
    </div>

    <div style="display:flex;align-items:center;gap:8px;margin:16px 0">
      <div class="tabs" style="margin:0;flex:1">
        <button class="tab active" data-tab="tour">Calendar</button>
        <button class="tab" data-tab="db">Song Database</button>
        <button class="tab" data-tab="set">Setlist</button>
        <button class="tab" data-tab="adv">Tech / Stage</button>
        <button class="tab" data-tab="live">Live</button>
      </div>
      <button id="globalThemeToggle" type="button" title="Toggle light/dark mode" style="border-radius:999px;border:none;width:38px;height:38px;display:flex;align-items:center;justify-content:center;font-size:20px;background:#0f172a;color:#fbbf24;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,0.15)">üåô</button>
    </div>

    <div class="grid">
      <div class="card" id="db" style="grid-column:1 / -1; width:100%; max-width:100%; overflow:hidden;">
        <h2>Song Database</h2>
          <div style="margin:12px 0;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <input type="text" id="dbSearch" placeholder="Search songs..." style="flex:1 1 200px;padding:8px;border:1px solid #d1d5db;border-radius:4px;font-size:14px">
            <label style="font-size:12px;color:#64748b">Sort by:</label>
            <select id="dbSort" style="padding:6px 8px;border:1px solid #d1d5db;border-radius:4px">
              <option value="added">Order Added</option>
              <option value="alpha" selected>Alpha by Song</option>
              <option value="band">Alpha by Band</option>
              <option value="mood">Mood Order</option>
              <option value="rating">Audience Rating</option>
              <option value="mostUsed">Most Selected</option>
              <option value="leastUsed">Least Selected</option>
            </select>
          </div>
          <div style="margin:8px 0;display:flex;flex-wrap:wrap;gap:12px;align-items:center;font-size:13px">
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterCovers"> Covers</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterOriginals"> Originals</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasLyrics"> Has Lyrics</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterKaraoke"> Karaoke</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasAudio"> Has Audio</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHasURL"> Has URL</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterInSet"> In Current Set</label>
            <label style="font-size:12px;color:#64748b;margin-left:8px">Mood:</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterUpbeat"> Upbeat</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterHappy"> Happy</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterEnergetic"> Energetic</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterMellow"> Mellow</label>
            <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="filterSad"> Sad</label>
            <span id="customMoodFilters"></span>
          </div>
        <!-- Profile buttons moved to global-actions -->
        <div class="list" id="dbList" style="width:100%; overflow-x:auto; max-width:100%;"></div>
        <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
          <button class="btn" id="addCustomColumn" style="background:#065f46;color:#f9fafb;border:1px solid #064e3b">+ Add Custom Column</button>
          <div style="display:flex;gap:12px;align-items:center">
            <label style="display:flex;align-items:center;gap:6px;cursor:pointer"><input type="checkbox" id="clearDBLock" style="width:18px;height:18px"><span style="font-size:14px">üîì Unlock Clear</span></label>
            <button class="btn danger" id="clearDB" style="background:#374151;color:#f9fafb">Clear Database</button>
          </div>
        </div>
        <div class="import-block" id="importBlock" style="margin-top:22px;padding:14px;border:1px solid #e2e8f0;border-radius:8px;background:#f8fafc">
          <h3 style="margin:0 0 10px;font-size:18px">Import Songs (OCR / Paste)</h3>
          <textarea id="importText" rows="4" placeholder="Paste lines e.g.\nSong Title - Am (Capo 2)\nAnother Song G Capo 3\nThird Song - F#m" style="width:100%;resize:vertical;font-family:monospace"></textarea>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center">
            <input type="file" id="importFile" accept=".txt,.pdf,.csv,.xls,.xlsx,.ods,image/*,audio/*,video/*,.mp3,.wav,.flac,.m4a,.aac,.ogg,.wma,.mp4,.avi,.mov,.mkv" multiple webkitdirectory="false" style="flex:1 1 240px" />
            <label><input type="checkbox" id="importFolder" style="width:auto;margin-right:4px">Folder</label>
            <button class="btn" id="importParseBtn" type="button">Parse Text & Preview</button>
            <button class="btn secondary" id="importCommitBtn" type="button" disabled>Add Parsed Songs</button>
          </div>
          <div id="importStatus" style="margin-top:8px;font-size:12px;color:#64748b"></div>
          <div id="importPreview" style="margin-top:10px;font-size:13px;line-height:1.4"></div>
          <div style="margin-top:10px;font-size:11px;color:#94a3b8">Supports: text files, PDF (OCR), images (OCR with enhanced handwriting detection), audio files (MP3/WAV/FLAC/M4A/AAC/OGG/WMA extracts title/artist/duration/embedded lyrics), video files (MP4/AVI/MOV/MKV extracts metadata), spreadsheets (CSV/XLS/XLSX/ODS). <strong>Smart matching:</strong> When scanning folders, automatically matches lyrics files (TXT/PDF/images) with audio files by name and merges them. Keys & capo detected heuristically. Review before importing.</div>
        </div>
      </div>

      <!-- Combined Setlist + Generator Tab -->
      <div class="card" id="set" style="display:none;grid-column:1 / -1;width:100%;overflow:auto;max-height:calc(100vh - 140px)">
        <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
          <h2 style="margin:0">Setlist</h2>
          <button id="saveSetlistPresetBtn" class="btn" style="padding:6px 12px;font-size:13px;background:#c2410c;color:#fff" title="Save current setlist as a reusable preset">‚≠ê Preset</button>
        </div>
        <div id="setlistLayout" style="display:flex;flex-wrap:nowrap;gap:24px;align-items:flex-start;margin-top:12px;width:100%">
          <div id="poolCol" style="flex:0 0 260px;display:flex;flex-direction:column;gap:12px;align-items:flex-start">
            <h3 style="margin:0">Song Pool</h3>
            <div id="poolControls" style="display:flex;flex-direction:column;gap:6px;width:100%">
              <input type="text" id="poolSearch" placeholder="Search songs..." style="width:100%;padding:6px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Type</label>
                <select id="poolType" style="flex:1 1 auto;min-width:120px">
                  <option value="all" selected>All</option>
                  <option value="originals">Originals</option>
                  <option value="covers">Covers</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Sort</label>
                <select id="poolSort" style="flex:1 1 auto;min-width:140px">
                  <option value="alpha" selected>Alphabetical</option>
                  <option value="band">Band Name</option>
                  <option value="mood">Mood Order</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Mood</label>
                <select id="poolMood" style="flex:1 1 auto;min-width:140px">
                  <option value="all" selected>All</option>
                  <option value="upbeat">Upbeat</option>
                  <option value="happy">Happy</option>
                  <option value="energetic">Energetic</option>
                  <option value="mellow">Mellow</option>
                  <option value="sad">Sad</option>
                </select>
              </div>
            </div>
            <div id="poolOriginals" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolCoversHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Covers</h4>
            <div id="poolCovers" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolBreaksHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Break</h4>
            <div id="poolBreaks" style="display:flex;flex-direction:column;gap:6px"></div>
          </div>
          <div id="previewCol" style="flex:1 1 auto;min-width:560px;max-width:880px;position:sticky;top:12px;align-self:flex-start;max-height:calc(100vh - 24px);display:flex;flex-direction:column">
            <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
              <h3 style="margin:0">Preview</h3>
              <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#64748b;cursor:pointer" title="Lock setlist to prevent accidental edits">
                <input type="checkbox" id="setlistLockCheckbox" style="cursor:pointer" />
                üîí Lock
              </label>
            </div>
            <div style="position:relative">
              <div id="setlistDragHandle" class="drag-assign-handle" title="Drag to assign this setlist to a calendar date" style="position:absolute;top:8px;right:8px;width:32px;height:32px;background:#000;border:2px solid #fff;border-radius:6px;cursor:grab;display:flex;align-items:center;justify-content:center;z-index:100;box-shadow:0 2px 8px rgba(0,0,0,0.3);pointer-events:auto">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M18 8.5V8a2 2 0 0 0-4 0v1M14 9.5V7a2 2 0 0 0-4 0v4M10 11V4a2 2 0 0 0-4 0v10.5" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M18 8.5a2 2 0 0 1 2 2v1.5c0 4.5-3 8-8 8s-6-3-7-5l-2.5-4a1.5 1.5 0 0 1 2.5-1.5L7 12" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </div>
              <div class="sheet" id="sheetInline" style="overflow:auto;flex:1 1 auto;height:auto;max-height:calc(100vh - 100px)">
                <div class="hdr" id="hdrInline"></div>
                <div class="songs" id="songsInline"></div>
              </div>
            </div>
            <div style="margin-top:10px;font-size:12px;color:#64748b">Drag songs from the pool directly into the preview. Drag rows to reorder. Double‚Äëclick a title to add/edit notes. Drag a Break chip to insert a break.</div>
          </div>
          
          <!-- Display Options moved to right column -->
          <div id="optionsCol" style="flex:0 0 320px;display:flex;flex-direction:column;gap:12px;position:sticky;top:12px;align-self:flex-start">
            <!-- Generator Settings -->
            <div style="padding:14px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb">
              <h4 style="margin:0 0 10px;font-size:16px">Generator Settings</h4>
              <div style="display:flex;flex-direction:column;gap:8px">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
                  <div class="field"><label style="font-size:12px">Set length (min)</label><input id="gLen" type="number" min="10" value="60" style="width:100%"></div>
                  <div class="field"><label style="font-size:12px">Break length (min)</label><input id="gBreakLen" type="number" min="5" value="15" style="width:100%"></div>
                </div>
                <div class="field"><label style="font-size:12px">Cover ratio</label>
                  <select id="gCover" style="width:100%">
                    <option value="0">100% Originals</option>
                    <option value="25">25% Covers</option>
                    <option value="50" selected>50/50</option>
                    <option value="75">75% Covers</option>
                    <option value="90">90% Covers</option>
                    <option value="100">100% Covers</option>
                  </select>
                </div>
                <div class="field"><label style="font-size:12px">Breaks</label>
                  <select id="gBreaks" style="width:100%">
                    <option value="0">No breaks</option>
                    <option value="1">1 break</option>
                    <option value="2">2 breaks</option>
                    <option value="3">3 breaks</option>
                  </select>
                </div>
                <div class="field"><label style="font-size:12px">Mood</label>
                  <select id="gMood" style="width:100%">
                    <option value="mixed">Mixed</option>
                    <option value="upbeat">Upbeat</option>
                    <option value="happy">Happy</option>
                    <option value="mellow">Mellow</option>
                    <option value="energetic">Energetic</option>
                    <option value="sad">Sad</option>
                  </select>
                </div>
                <div class="field"><label style="display:inline-flex;align-items:center;gap:4px;font-size:12px"><input type="checkbox" id="gEncore"> Include Encore</label></div>
                <div class="field">
                  <label style="font-size:12px;font-weight:600;margin-bottom:4px;display:block">Grouping Rules</label>
                  <div style="display:flex;flex-direction:column;gap:4px;font-size:12px">
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepCovers"> Keep Covers Together</label>
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepKeys"> Keep Keys Together</label>
                    <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="gKeepMoods"> Keep Moods Together</label>
                  </div>
                </div>
              </div>
              <div style="margin-top:12px;display:flex;gap:8px">
                <button class="btn" id="genBtn" style="flex:1">Generate</button>
                <button class="btn" id="newSetBtn" type="button" style="flex:1">New Setlist</button>
                <button class="btn danger" id="clearSet" type="button" style="flex:1">Clear</button>
              </div>
              <div id="genStats" style="margin-top:8px;color:#64748b;font-size:11px"></div>
            </div>
            
            <!-- Setlist Display Options -->
            <div style="padding:14px;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb">
              <h4 style="margin:0 0 10px;font-size:16px">Setlist Display Options</h4>
          
          <div style="margin-bottom:12px">
            <label style="font-weight:600;font-size:13px;margin-bottom:6px;display:block">Display Columns</label>
            <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:13px">
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_artist" checked> Artist</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_key"> Key</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_capo"> Capo</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_bpm"> BPM</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_notes" checked> Notes</label>
              <label style="display:inline-flex;align-items:center;gap:4px"><input type="checkbox" id="setCol_lyrics"> Lyrics Preview</label>
              <span id="setColCustom"></span>
            </div>
          </div>
          
          <div style="margin-bottom:12px">
            <label style="font-weight:600;font-size:13px;margin-bottom:6px;display:block">Page Layout</label>
            <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;font-size:13px">
              <label style="display:inline-flex;align-items:center;gap:6px">
                Paper: 
                <select id="paperFormat" style="padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
                  <option value="letter">Letter 8.5√ó11</option>
                  <option value="a4">A4 210√ó297mm</option>
                </select>
              </label>
              <label style="display:inline-flex;align-items:center;gap:6px">
                Pages: 
                <select id="pageCount" style="padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
                  <option value="1">1 page</option>
                  <option value="2">2 pages</option>
                  <option value="3">3 pages</option>
                  <option value="4">4 pages</option>
                </select>
              </label>
              <label style="display:inline-flex;align-items:center;gap:6px">
                Songs per page: 
                <select id="songsPerPage" style="padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px">
                  <option value="20">20</option>
                  <option value="25" selected>25</option>
                  <option value="30">30</option>
                  <option value="35">35</option>
                  <option value="40">40</option>
                </select>
              </label>
            </div>
          </div>
          
              <div style="margin-top:8px;font-size:11px;color:#64748b">Control which fields appear in the setlist preview and print output.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="adv" style="display:none;padding-top:6px;margin-top:8px">
        <div class="row" style="gap:8px;margin-bottom:4px;padding:0 4px">
          <button class="btn" id="stageToggle" onclick="toggleStageAndNotes()">Stage Plot</button>
          <button class="btn" id="stagePresetBtnTop" style="padding:4px 10px;font-size:12px;background:#065f46;color:#f9fafb;border:1px solid #064e3b">PRESET</button>
        </div>
      </div>

      <!-- Tour Manager: date-based scheduling, itinerary, and location services -->
      <div id="tour" style="display:none;grid-column:1 / -1;width:100%;margin-top:12px">
        
        <!-- Large Date/Venue Header with Day Navigation -->
        <div style="background:#fff;border:1px solid #e5e7eb;border-radius:8px;padding:20px;margin-bottom:16px">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:20px">
            <!-- Large Date and Venue Display -->
            <div style="flex:1">
              <div id="tourHeaderDate" style="font-size:32px;font-weight:700;color:#111827;line-height:1.2;margin-bottom:4px">Select a date</div>
              <div id="tourHeaderVenue" style="font-size:24px;font-weight:500;color:#64748b;line-height:1.3">No venue</div>
            </div>
            
            <!-- Yesterday / Tomorrow Buttons -->
            <div style="display:flex;gap:8px;align-items:center">
              <button id="tourYesterdayBtn" class="btn" style="padding:12px 20px;font-size:16px;font-weight:600">‚óÄ Yesterday</button>
              <button id="tourTomorrowBtn" class="btn" style="padding:12px 20px;font-size:16px;font-weight:600">Tomorrow ‚ñ∂</button>
              <button id="tourAddDate" class="btn primary" style="padding:12px 20px;font-size:14px;margin-left:12px">+ Add Date</button>
            </div>
          </div>
        </div>
        
        <!-- Main Tour Content: Compact Layout -->
        <div id="tourContent" style="display:flex;flex-direction:column;gap:12px">
          
          <!-- Row 1: Gig Details (1) + Map (2) -->
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            
            <!-- 1. Gig Details - Compact Form -->
            <div class="card" style="padding:12px">
              <div style="font-size:13px;font-weight:600;margin-bottom:8px;color:var(--accent)">üìç Gig Details</div>
              <div id="tourNoSelection" style="color:#64748b;font-size:12px">Select or add a date</div>
              <div id="tourDateDetails" style="display:none">
                <div style="display:flex;flex-direction:column;gap:6px">
                  <input type="date" id="tourDate" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <input type="text" id="tourVenue" placeholder="Venue name" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <input type="text" id="tourAddress" placeholder="Address" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px">
                    <input type="time" id="tourLoadIn" placeholder="Load-In" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                    <input type="time" id="tourShowTime" placeholder="Show Time" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  </div>
                  <input type="text" id="tourBand" placeholder="Band/Artist (click header to switch)" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px" />
                  <select id="tourSetlistSelect" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px">
                    <option value="current">Use Current Setlist</option>
                    <option value="custom">Custom Setlist</option>
                  </select>
                  <select id="tourStagePlotSelect" style="width:100%;padding:6px;border:1px solid #d1d5db;border-radius:4px;font-size:12px">
                    <option value="current">Use Current Stage</option>
                    <option value="custom">Custom Stage</option>
                  </select>
                  <div style="display:flex;gap:6px;margin-top:4px">
                    <button id="tourSaveDate" class="btn primary" style="flex:1;padding:6px;font-size:12px">Save</button>
                    <button id="tourDeleteDate" class="btn danger" style="padding:6px;font-size:12px">Delete</button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 2. Map -->
            <div class="card" style="padding:12px">
              <div style="font-size:13px;font-weight:600;margin-bottom:8px">üó∫Ô∏è Location</div>
              <div id="tourMapPlaceholder" style="width:100%;height:200px;background:#f1f5f9;border-radius:4px;display:flex;align-items:center;justify-content:center;color:#64748b;font-size:12px">
                Map loads when address is entered
              </div>
            </div>
          </div>
          
          <!-- Row 2: Itinerary (3) + Right Column (4/5/6) -->
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            
            <!-- 3. Itinerary -->
            <div class="card" style="padding:12px">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
                <div style="font-size:13px;font-weight:600">üóìÔ∏è Daily Itinerary</div>
              </div>
              <div id="tourItineraryContent">
                <div id="tourItineraryTimeline" style="overflow-y:auto;max-height:400px;padding-left:26px;position:relative">
                  <!-- Timeline items -->
                </div>
              </div>
            </div>
            
            <!-- Right Column: 4. Chips, 5. Stage, 6. Setlist -->
            <div style="display:flex;flex-direction:column;gap:12px">
              
              <!-- 4. Activity Chips -->
              <div class="card" style="padding:12px">
                <div style="font-size:13px;font-weight:600;margin-bottom:8px">üìã Activity Chips</div>
                
                <!-- Tour Activities -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">GIG DAY</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="rehearsal" data-duration="120" data-color="#8b5cf6" style="padding:4px 8px;background:#ede9fe;border:1px solid #c4b5fd;border-radius:4px;font-size:10px;cursor:move">üé∏ Rehearsal</div>
                    <div class="activity-chip" draggable="true" data-activity="soundcheck" data-duration="60" data-color="#3b82f6" style="padding:4px 8px;background:#dbeafe;border:1px solid #93c5fd;border-radius:4px;font-size:10px;cursor:move">üéöÔ∏è Soundcheck</div>
                    <div class="activity-chip" draggable="true" data-activity="loadin" data-duration="45" data-color="#6366f1" style="padding:4px 8px;background:#e0e7ff;border:1px solid #a5b4fc;border-radius:4px;font-size:10px;cursor:move">üì¶ Load-In</div>
                    <div class="activity-chip" draggable="true" data-activity="gig" data-duration="180" data-color="#ec4899" style="padding:4px 8px;background:#fce7f3;border:1px solid #f9a8d4;border-radius:4px;font-size:10px;cursor:move">üé§ Gig</div>
                  </div>
                </div>
                
                <!-- Travel -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">TRAVEL</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="drive" data-duration="120" data-color="#f59e0b" style="padding:4px 8px;background:#fef3c7;border:1px solid #fcd34d;border-radius:4px;font-size:10px;cursor:move">üöó Drive</div>
                    <div class="activity-chip" draggable="true" data-activity="home" data-duration="0" data-color="#10b981" style="padding:4px 8px;background:#d1fae5;border:1px solid #6ee7b7;border-radius:4px;font-size:10px;cursor:move">üè† Home</div>
                    <div class="activity-chip" draggable="true" data-activity="sleep" data-duration="480" data-color="#64748b" style="padding:4px 8px;background:#f1f5f9;border:1px solid #cbd5e1;border-radius:4px;font-size:10px;cursor:move">üò¥ Sleep</div>
                  </div>
                </div>
                
                <!-- Meals -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">MEALS</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="breakfast" data-duration="45" data-color="#fbbf24" style="padding:4px 8px;background:#fef3c7;border:1px solid #fde047;border-radius:4px;font-size:10px;cursor:move">ü•ê Breakfast</div>
                    <div class="activity-chip" draggable="true" data-activity="lunch" data-duration="60" data-color="#f97316" style="padding:4px 8px;background:#ffedd5;border:1px solid#fdba74;border-radius:4px;font-size:10px;cursor:move">üçî Lunch</div>
                    <div class="activity-chip" draggable="true" data-activity="dinner" data-duration="90" data-color="#dc2626" style="padding:4px 8px;background:#fee2e2;border:1px solid #fca5a5;border-radius:4px;font-size:10px;cursor:move">üçΩÔ∏è Dinner</div>
                    <div class="activity-chip" draggable="true" data-activity="snacks" data-duration="15" data-color="#84cc16" style="padding:4px 8px;background:#ecfccb;border:1px solid #bef264;border-radius:4px;font-size:10px;cursor:move">üçø Snacks</div>
                  </div>
                </div>
                
                <!-- Social -->
                <div style="margin-bottom:8px">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">SOCIAL</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap">
                    <div class="activity-chip" draggable="true" data-activity="meeting" data-duration="60" data-color="#06b6d4" style="padding:4px 8px;background:#cffafe;border:1px solid#67e8f9;border-radius:4px;font-size:10px;cursor:move">üíº Meeting</div>
                    <div class="activity-chip" draggable="true" data-activity="party" data-duration="180" data-color="#d946ef" style="padding:4px 8px;background:#fae8ff;border:1px solid #f0abfc;border-radius:4px;font-size:10px;cursor:move">üéâ Party</div>
                  </div>
                </div>
                
                <!-- Places Search -->
                <div style="margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb">
                  <div style="font-size:10px;color:#64748b;margin-bottom:4px;font-weight:600">FIND PLACES</div>
                  <div style="display:flex;gap:3px;flex-wrap:wrap;margin-bottom:6px">
                    <button class="btn" data-search="hotels" style="padding:3px 6px;font-size:9px">Hotels</button>
                    <button class="btn" data-search="music stores" style="padding:3px 6px;font-size:9px">Music</button>
                    <button class="btn" data-search="rehearsal studios" style="padding:3px 6px;font-size:9px">Rehearsal</button>
                    <button class="btn" data-search="recording studios" style="padding:3px 6px;font-size:9px">Recording</button>
                    <button class="btn" data-search="radio stations" style="padding:3px 6px;font-size:9px">Radio</button>
                    <button class="btn" data-search="tv stations" style="padding:3px 6px;font-size:9px">TV</button>
                    <button class="btn" data-search="bars" style="padding:3px 6px;font-size:9px">Bars</button>
                    <button class="btn" data-search="restaurants" style="padding:3px 6px;font-size:9px">Food</button>
                    <button class="btn" data-search="cafes" style="padding:3px 6px;font-size:9px">Cafes</button>
                    <button class="btn" data-search="gas stations" style="padding:3px 6px;font-size:9px">Gas</button>
                    <button class="btn" data-search="print shops" style="padding:3px 6px;font-size:9px">Print</button>
                    <button class="btn" data-search="instrument repair" style="padding:3px 6px;font-size:9px">Repair</button>
                    <button class="btn" data-search="pa rentals" style="padding:3px 6px;font-size:9px">PA Rental</button>
                    <button class="btn" data-search="pharmacies" style="padding:3px 6px;font-size:9px">Pharmacy</button>
                  </div>
                  <div style="display:flex;gap:3px;margin-bottom:6px">
                    <input type="text" id="tourSearchLocation" placeholder="Search..." style="flex:1;padding:4px;border:1px solid #d1d5db;border-radius:4px;font-size:10px" />
                    <button id="tourSearchBtn" class="btn" style="padding:4px 12px;font-size:10px;font-weight:600">Search</button>
                    <button id="tourAddCustomBtn" class="btn" style="padding:4px 8px;font-size:14px;font-weight:600" title="Add custom search button">+</button>
                  </div>
                  <div id="customSearchButtons" style="display:flex;gap:3px;flex-wrap:wrap;margin-bottom:6px">
                    <!-- Custom search buttons -->
                  </div>
                  <div id="tourSearchResults" style="display:flex;flex-direction:column;gap:3px;max-height:100px;overflow-y:auto">
                    <!-- Search results chips -->
                  </div>
                </div>
              </div>
              
              <!-- 5 & 6. Stage Plot + Setlist Preview (side by side) -->
              <div class="card" style="padding:12px">
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
                  <!-- Stage Plot -->
                  <div style="cursor:pointer" title="Double-click to edit">
                    <div style="font-size:12px;font-weight:600;margin-bottom:6px">üé∏ Stage</div>
                    <div id="tourStagePreview" style="display:flex;justify-content:center;align-items:center;min-height:100px;max-height:120px;overflow:hidden;border:1px solid #e5e7eb;border-radius:4px;padding:4px">
                      <div style="color:#64748b;font-size:10px">No stage plot</div>
                    </div>
                  </div>
                  
                  <!-- Setlist -->
                  <div style="cursor:pointer" title="Double-click to edit">
                    <div style="font-size:12px;font-weight:600;margin-bottom:6px">üéµ Setlist</div>
                    <div id="tourSetlistPreview" style="max-height:120px;overflow-y:auto;font-size:10px;line-height:1.4;border:1px solid #e5e7eb;border-radius:4px;padding:4px">
                      <div style="color:#64748b">No setlist</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          
          <!-- Calendar Tools Row -->
          <div class="card" style="padding:12px">
            <div style="display:flex;align-items:center;gap:12px">
              <label style="display:flex;align-items:center;gap:6px;font-size:12px">
                <input type="checkbox" id="tourLockCalendar" />
                üîí Lock Calendar (prevent edits)
              </label>
              <button id="tourClearCalendar" class="btn danger" style="margin-left:auto;padding:6px 12px;font-size:12px">üóëÔ∏è Clear Calendar</button>
            </div>
          </div>
          
          <!-- OLD CONTENT HIDDEN BELOW -->
          <div style="display:none">
            <div class="card" style="width:100%">
              <h3 style="margin:0 0 12px 0">Find Nearby Services (OLD)</h3>
              
              <!-- Default Search Buttons -->
              <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:12px">
                <button class="btn" data-search="hotels">üè® Hotels</button>
                <button class="btn" data-search="music stores">üé∏ Music Stores</button>
                <button class="btn" data-search="rehearsal studios">üéµ Rehearsal</button>
                <button class="btn" data-search="bars">üç∫ Bars</button>
                <button class="btn" data-search="restaurants">üçΩÔ∏è Food</button>
                <button class="btn" data-search="cafes">‚òï Cafes</button>
                <button class="btn" data-search="gas stations">‚õΩ Gas</button>
                <button class="btn" data-search="print shops">üñ®Ô∏è Print</button>
                <button class="btn" data-search="guitar repair">üîß Repairs</button>
                <button class="btn" data-search="pharmacies">üíä Pharmacy</button>
              </div>
              
              <!-- Custom Search -->
              <div style="margin-bottom:12px">
                <label class="muted" style="font-size:12px;margin-bottom:4px;display:block">Custom Search (e.g., "Vegan", "BBQ", "Bike Repair")</label>
                <div style="display:flex;gap:6px">
                  <input type="text" id="tourCustomSearch" placeholder="Enter custom search term" style="flex:1;padding:8px;border:1px solid #d1d5db;border-radius:4px;font-size:13px" />
                  <button id="tourCustomSearchBtn" class="btn primary" style="white-space:nowrap">üîç Search</button>
                </div>
              </div>
              
              <!-- Inline Map -->
              <div id="tourMapEmbed" style="width:100%;height:300px;border:1px solid #e5e7eb;border-radius:6px;margin-bottom:12px;overflow:hidden;background:#f9fafb;display:flex;align-items:center;justify-content:center;color:#64748b;font-size:13px">
                Click a search button to view map and find businesses
              </div>
              
              <!-- Search Results Chips -->
              <div style="font-size:12px;font-weight:600;color:#374151;margin-bottom:6px">Drag chips to itinerary or saved places:</div>
              <div id="tourSearchResults" style="display:flex;flex-wrap:wrap;gap:8px;padding:12px;border:1px solid #e5e7eb;border-radius:6px;min-height:120px;max-height:300px;overflow-y:auto;align-content:flex-start;background:#ffffff">
                <div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">
                  Search results will appear here
                </div>
              </div>
            </div>
            
            <!-- Saved Interests / Places -->
            <div class="card" style="width:100%" id="tourSavedInterests">
              <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
                <h3 style="margin:0">Saved Places & Interests</h3>
                <button id="tourClearInterests" class="btn danger" style="padding:4px 8px;font-size:12px">Clear All</button>
              </div>
              <div id="tourInterestsDropZone" style="min-height:100px;border:2px dashed #d1d5db;border-radius:8px;padding:12px;background:#f9fafb;display:flex;flex-wrap:wrap;gap:8px;align-items:flex-start;align-content:flex-start">
                <div style="width:100%;text-align:center;color:#64748b;font-size:13px;padding:20px" id="tourInterestsPlaceholder">
                  Drag search result chips here to save places of interest for this tour date
                </div>
              </div>
            </div>
            
          </div>
        </div>
      </div>
      


      <!-- Live Mode: full-screen, touch-first setlist + lyrics viewer -->
      <div id="live" style="display:none;grid-column:1 / -1;width:100%;margin-top:12px">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:4px">
              <h2 style="margin:0">Live Mode</h2>
              <button id="liveThemeToggle" type="button" title="Toggle light/dark" style="margin-left:auto;border-radius:999px;border:none;width:34px;height:34px;display:flex;align-items:center;justify-content:center;font-size:18px;background:#0f172a;color:#fbbf24;cursor:pointer">üåô</button>
            </div>
        <div id="liveFlex" style="display:flex;gap:12px;min-height:60vh">
          <div id="liveLeftCol" style="display:flex;flex-direction:column;gap:6px;max-height:80vh">
            <div style="display:flex;align-items:center;gap:8px">
              <button id="armAllBtn" type="button" title="Arm local audio files for this set" class="btn">Arm All</button>
            </div>
            <input id="armAllDir" type="file" webkitdirectory directory multiple style="display:none" />
            <input id="armSongFile" type="file" accept="audio/*" style="display:none" />
            <div id="liveList" style="flex:1 1 auto;border:1px solid #e5e7eb;border-radius:8px;padding:8px;overflow:auto">
            <!-- live setlist rows injected here -->
          </div>
          </div>
          <div id="liveLyrics" style="flex:2 1 360px;min-width:280px;border:1px solid #e5e7eb;border-radius:8px;padding:12px;max-height:80vh;overflow:auto;font-size:16px;line-height:1.4">
            <div id="liveInlineControls" style="display:flex;align-items:center;gap:10px;margin-bottom:8px">
              <button id="liveInlinePlay" class="live-lyrics-play" type="button">Play</button>
              <button id="liveInlineStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
              <div style="display:flex;align-items:center;gap:6px;margin-left:auto">
                <span style="font-size:11px;color:#64748b">Zoom</span>
                <input id="liveInlineZoom" type="range" min="16" max="32" value="20" step="1" style="width:140px">
              </div>
              <div style="display:flex;align-items:center;gap:4px">
                <span style="font-size:11px;color:#64748b">Speed</span>
                <button id="liveInlineSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
                <span id="liveInlineSpeedDisplay" style="font-size:14px;color:#111;font-weight:bold;min-width:12px;text-align:center">5</span>
                <button id="liveInlineSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:14px;font-weight:bold">+</button>
              </div>
              <button id="metronomeBtn" type="button" title="Metronome: Tap once=flash, twice=click, thrice=off. Hold to set BPM" style="padding:6px 12px;border-radius:4px;border:2px solid #d1d5db;background:#fff;color:#111;cursor:pointer;font-size:16px;font-weight:bold;margin-left:8px">‚ô©</button>
            </div>
            <div id="liveLyricsTitle" style="font-weight:bold;font-size:20px;margin-bottom:8px"></div>
            <pre id="liveLyricsBody" style="white-space:pre-wrap;font-family:inherit"></pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help / Tutorial Modal -->
  <div class="modal" id="helpModal" style="display:none">
    <div class="sheet" style="max-width:760px;height:auto">
      <h2>Jiffykit Setlist ‚Äì Quick Tutorial</h2>
      <ol style="font-size:14px;line-height:1.6;margin-left:20px">
        <li><strong>Song Database</strong>: Add every tune you might play. Mark moods & cover status so the generator can balance energy and originals/covers for you.</li>
        <li><strong>Lyrics / Chords</strong>: Paste lyrics or chords into the song, or hit ‚ÄúSearch Lyrics / Chords‚Äù to open a web search and copy from the site you trust.</li>
        <li><strong>Setlist</strong>: Enter gig details (band, venue, date, notes) and click Generate, or drag songs in manually from the Song Pool. Reorder with the handle (‚ãÆ‚ãÆ) and type notes inline ‚Äì notes appear under the title in the print-friendly sheet.</li>
        <li><strong>Breaks & Events</strong>: Drag Break, Encore, and custom event chips into the set to mark intermissions, announcements, raffles and more. The preview always shows your real running order and total time.</li>
        <li><strong>Tour Manager</strong>: Plan your tour dates with the scalable timeline (week/month/year view). Add gigs, manage itineraries, set load-in/show times, and search for nearby hotels, music stores, rehearsal spaces, and more. Custom search terms let you always find your favorite spots on the road.</li>
        <li><strong>Live Mode</strong>: On show night, switch to the Live tab. Tap a song to see big, high-contrast lyrics. On phone/tablet, tap again for fullscreen; the Play button gently auto-scrolls based on song length so you reach the bottom of the page about 75% through the song.</li>
        <li><strong>Tech / Stage</strong>: Use the Toolbox icons to build a clean, black-and-white stage plot. Drag to move, double‚Äëclick labels to rename, assign channels in the legend, and use Clear Stage (at the bottom of the toolbox) only when you really want to start over.</li>
        <li><strong>Lighting / FX</strong>: Switch to ‚ÄúLighting / FX‚Äù from Tech / Stage to type per‚Äësong notes (e.g., ‚ÄúBlue wash, delay on chorus‚Äù). These print alongside the stage plot in the tech rider.</li>
        <li><strong>Printing</strong>: Use the Print‚Ä¶ button at the top to choose Setlist, Stage Plot, and Tech Notes. Each prints separately so you can give the band, engineer and lighting tech exactly what they need.</li>
        <li><strong>Profiles & Sets</strong>: Save Profile (.BAND) to back up your whole song database and settings. Save .SET when you like a particular set order so you can reload it later.</li>
        <li><strong>Autosave & Safety</strong>: The app saves as you go, even while dragging things around. You can also duplicate stage items with Ctrl+D and step through recent stage changes with Ctrl+Z / Ctrl+Y.</li>
      </ol>
      <div style="margin-top:16px;font-size:14px;background:#f1f5f9;padding:12px;border-radius:8px">
        The app is free. If it saves you time and you‚Äôd like to support development, you can donate:
        <p style="margin:10px 0"><a href="https://paypal.me/jamesmulvale" target="_blank" rel="noopener" class="btn" style="text-decoration:none">Donate via PayPal</a></p>
        Thank you and have a great show!
      </div>
      <div style="margin-top:18px;display:flex;gap:10px;justify-content:flex-end">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <!-- Floating Song Pool Flyout -->
  <div class="pool-flyout" id="songPoolFlyout">
    <div class="pool-head">
      <strong>Song Pool</strong>
      <button class="btn secondary" id="closePool" type="button">Close</button>
    </div>
    <div class="pool-body">
      <div class="pool-sec">
        <h4>Originals</h4>
        <div id="poolOriginals" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Covers</h4>
        <div id="poolCovers" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Breaks</h4>
        <div id="poolBreaks" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
    </div>
  </div>

  <!-- Global Print FAB removed; using top-row Print button for consistency -->

  <!-- Stage Fullscreen Modal -->
  <div class="stage-modal" id="stageModal">
    <div class="stage-editor">
      <div class="stage-pane">
  <h3>Toolbox <span style="font-weight:400;font-size:12px;color:#6b7280">(Drag and drop items)</span></h3>
        <div class="stage-tools" id="stageToolsFull"></div>
        <div style="margin-top:10px">
          <h4>Custom</h4>
          <button class="tool" id="uploadImageBtn">Upload Image</button>
          <input type="file" id="uploadImageInput" accept="image/*" style="display:none" />
          <button class="tool" id="newIconBtn">New Icon</button>
          <div id="customImages" style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px"></div>
        </div>
        <div style="margin-top:14px;display:flex;justify-content:flex-end;align-items:center;gap:8px">
          <button class="btn" id="newStageBtn" type="button" title="Save current as preset and start fresh stage plot">New Stage</button>
          <button class="btn danger" id="clearStage" type="button" title="Clear stage plot (keeps background & title)">Clear</button>
        </div>
      </div>
      <div class="stage-canvas">
        <!-- Date/Band/Venue Header Bar -->
        <div id="stageHeaderBar" style="background:#fef08a;padding:12px 16px;margin-bottom:12px;border-radius:6px;display:flex;align-items:center;justify-content:space-between;gap:16px">
          <div style="display:flex;align-items:center;gap:16px;font-weight:600;font-size:16px">
            <span id="stageHeaderDate" style="color:#854d0e">No date selected</span>
            <span style="color:#a16207">‚Ä¢</span>
            <span id="stageHeaderBand" style="color:#854d0e">Band</span>
            <span style="color:#a16207">‚Ä¢</span>
            <span id="stageHeaderVenue" style="color:#854d0e">Venue</span>
          </div>
          <div style="display:flex;align-items:center;gap:12px">
            <label style="display:flex;align-items:center;gap:4px;font-size:12px;color:#854d0e;cursor:pointer;font-weight:500" title="Lock stage plot to prevent accidental edits">
              <input type="checkbox" id="stageLockCheckbox" style="cursor:pointer" />
              üîí Lock
            </label>
            <div id="stageDragHandle" class="drag-assign-handle" draggable="true" title="Drag to assign this stage plot to a calendar date" style="width:32px;height:32px;background:#000;border:2px solid #fff;border-radius:6px;cursor:grab;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,0.3)">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M18 8.5V8a2 2 0 0 0-4 0v1M14 9.5V7a2 2 0 0 0-4 0v4M10 11V4a2 2 0 0 0-4 0v10.5" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M18 8.5a2 2 0 0 1 2 2v1.5c0 4.5-3 8-8 8s-6-3-7-5l-2.5-4a1.5 1.5 0 0 1 2.5-1.5L7 12" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
          </div>
        </div>
        <div class="stage-inspector" id="stageInspector" style="margin-bottom:8px;display:flex;min-height:42px;background:#f3f4f6;padding:8px 12px;border-radius:6px;align-items:center;gap:12px">
          <span class="muted" id="selLabel">Selected: (none)</span>
          <input id="selName" placeholder="Click an item to select" style="min-width:220px" disabled />
          <label class="muted" for="selSize">Size</label>
          <input id="selSize" type="range" min="0.3" max="5" step="0.05" value="1" style="width:160px" disabled />
          <label class="muted" for="selRotation">Rotate</label>
          <input id="selRotation" type="range" min="0" max="360" step="1" value="0" style="width:160px" disabled />
          <span id="selRotationValue" class="muted" style="min-width:35px">0¬∞</span>
          
          <label class="muted" for="selShowLabel" style="display:flex;align-items:center;gap:4px"><input type="checkbox" id="selShowLabel" disabled /> Show Label</label>
          <span id="labelSizeControls" style="display:none;align-items:center;gap:6px">
            <label class="muted" for="selLabelSize">Label Size</label>
            <input id="selLabelSize" type="range" min="8" max="32" step="1" value="16" style="width:120px" />
          </span>
          <button class="btn danger" id="delSel" disabled>Delete</button>
          <button class="btn" id="dupSel" type="button" disabled>Duplicate</button>
        </div>
        <div style="position:relative;display:inline-block;">
          <div id="stageFrame" style="position:relative;display:inline-block;">
            <svg id="stageSvgFull" class="bw" viewBox="0 0 1500 900" xmlns="http://www.w3.org/2000/svg" style="display:block;">
              <rect class="stage-bg" x="1" y="1" width="1498" height="898"/>
              <text x="750" y="50" text-anchor="middle" font-size="26" font-weight="bold" id="stageTitleFull">Band ‚Ä¢ Date</text>
            </svg>
            <div class="stage-handle tl" data-handle="tl"></div>
            <div class="stage-handle tr" data-handle="tr"></div>
            <div class="stage-handle bl" data-handle="bl"></div>
            <div class="stage-handle br" data-handle="br"></div>
          </div>
        </div>
        <div id="stageLegend" class="stage-legend"></div>
        <div class="stage-actions">
            <button class="btn secondary" id="closeStage">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- New Icon Drawing Modal -->
  <div class="modal" id="iconMakerModal" style="display:none">
    <div class="sheet" style="max-width:480px">
      <h3 style="margin-top:0">Create New Icon</h3>
      <canvas id="iconCanvas" width="400" height="400" style="border:1px solid #d1d5db;background:transparent;display:block;width:400px;height:400px;touch-action:none"></canvas>
      <div style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <label style="font-size:12px;color:#64748b">Line Width
          <input id="iconLineWidth" type="range" min="2" max="6" step="1" value="4" style="width:160px">
        </label>
        <button class="btn" id="iconClear">Clear</button>
        <button class="btn" id="iconSave">Save Icon</button>
        <button class="btn secondary" id="iconCancel">Cancel</button>
      </div>
      <div style="margin-top:6px;font-size:11px;color:#64748b">Draw with mouse or touch. Rough shapes will auto-normalize into lines, rectangles, or ellipses where recognized.</div>
    </div>
  </div>

  <!-- Lighting Notes Fullscreen Modal -->
  <!-- Stage Preset Modal - Created dynamically via showPresetModal() -->

  <div class="stage-modal" id="notesModal">
    <div class="stage-editor" style="grid-template-columns:1fr">
      <div class="stage-pane" style="border-right:none">
        <h3>Lighting Notes</h3>
        <table class="tech-table">
          <thead><tr><th>#</th><th>Song</th><th>Notes (e.g., Blue fade to orange, Delays in chorus)</th></tr></thead>
          <tbody id="techBodyFull"></tbody>
        </table>
        <div class="gear-wrap">
          <label>Gear list (printed under stage)</label>
          <textarea id="gear" placeholder="e.g., DI x3 ‚Ä¢ Guitar amp x2 ‚Ä¢ Vox x3 ‚Ä¢ Wireless x2"></textarea>
        </div>
        <div class="stage-actions">
          <button class="btn secondary" id="closeNotes">Close</button>
          <button class="btn" id="printTech">Print Tech Rider + Stage</button>
          <button class="btn" id="printTechOnly">Print Tech Only</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Print Modal -->
  <div class="modal" id="modal">
    <div class="sheet" id="sheet">
      <div class="hdr" id="hdr"></div>
      <div class="songs" id="songs"></div>
    </div>
    <div class="tools">
      <span class="paper">Paper:</span>
      <select id="paperSel">
        <option value="letter">Letter 8.5√ó11</option>
        <option value="a4">A4 210√ó297mm</option>
      </select>
  <button class="btn" id="printSheet">Print</button>
      <button class="btn secondary" id="closeModal">Close</button>
    </div>
  </div>

  <!-- Tech/Stage Print Modal -->
  <div class="modal" id="modalTech">
    <div class="sheet" id="sheetTech">
      <div class="hdr" id="hdrTech"></div>
      <div id="techPrint"></div>
      <div id="stagePrint"></div>
    </div>
    <div class="tools">
      <button class="btn" id="printTechModal">Print</button>
      <button class="btn secondary" id="closeTech">Close</button>
    </div>
  </div>

  <!-- Print Options Modal -->
  <div class="modal" id="printChooser">
    <div class="modalbox">
      <div class="hdr"><div class="band">Print Options</div></div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <label class="chip"><input type="checkbox" id="pSet"> Setlist</label>
        <label class="chip"><input type="checkbox" id="pStage"> Stage Plot</label>
        <label class="chip"><input type="checkbox" id="pTech"> Lighting / Tech Notes</label>
        <label class="chip"><input type="checkbox" id="pLyrics"> Lyrics</label>
        <label class="chip"><input type="checkbox" id="pItinerary"> Itinerary</label>
        <div class="muted">Select one or more. Each prints separately.</div>
        
        <!-- Song selector for lyrics (shown when pLyrics is checked) -->
        <div id="lyricsSongSelector" style="display:none;margin-top:10px;padding:10px;background:#f9fafb;border:1px solid #e5e7eb;border-radius:6px;max-height:200px;overflow-y:auto">
          <div style="font-size:13px;font-weight:600;margin-bottom:8px">Select songs to print lyrics:</div>
          <div id="lyricsSongList" style="display:flex;flex-direction:column;gap:6px"></div>
        </div>
      </div>
      <div class="tools" style="justify-content:flex-end">
        <button class="btn" id="doPrint">Print Selected</button>
        <button class="btn secondary" id="closePrintChooser">Close</button>
      </div>
    </div>
  </div>

  <!-- Hidden storage for Stage SVG (used for save/print) -->
  <div id="stageStore" style="display:none">
    <svg id="stageSvg" class="bw" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
      <rect class="stage-bg" x="1" y="1" width="998" height="598"/>
      <text x="500" y="36" text-anchor="middle" font-size="22" font-weight="bold" id="stageTitle">Band ‚Ä¢ Date</text>
    </svg>
  </div>

  <!-- Live fullscreen lyrics overlay (phone / tablet / desktop) -->
  <div id="liveLyricsOverlay" class="live-lyrics-overlay">
    <div class="live-lyrics-header">
      <button id="liveLyricsPlay" class="live-lyrics-play" type="button">Play</button>
      <button id="liveLyricsStop" class="live-lyrics-stop" type="button" style="display:none">Stop</button>
      <div id="liveLyricsOverlayTitle" class="live-lyrics-title"></div>
      <div style="display:flex;align-items:center;gap:6px;margin-right:10px">
        <span style="font-size:11px;color:#9ca3af">Zoom</span>
        <input id="liveLyricsZoom" type="range" min="16" max="96" value="20" step="1" style="width:180px">
      </div>
      <div style="display:flex;align-items:center;gap:4px;margin-right:10px">
        <span style="font-size:11px;color:#9ca3af">Speed</span>
        <button id="liveSpeedDown" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">‚àí</button>
        <span id="liveSpeedDisplay" style="font-size:14px;color:#e5e7eb;font-weight:bold;min-width:12px;text-align:center">5</span>
        <button id="liveSpeedUp" type="button" style="padding:4px 8px;border-radius:4px;border:1px solid #444;background:#1f2937;color:#e5e7eb;cursor:pointer;font-size:14px;font-weight:bold">+</button>
      </div>
      <button id="metronomeBtnOverlay" type="button" title="Metronome: Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM." style="padding:6px 12px;border-radius:4px;border:2px solid #444;background:#1f2937;color:#fbbf24;cursor:pointer;font-size:18px;font-weight:bold;margin-right:12px">‚ô©</button>
      <button id="liveLyricsExit" class="live-lyrics-exit" type="button">Back to Setlist</button>
    </div>
    <div id="liveLyricsOverlayMain" class="live-lyrics-main">
      <pre id="liveLyricsOverlayBody" class="live-lyrics-body"></pre>
    </div>
  </div>

  <script>
    // Data
  const db = []; // {id,title,artist,length,key,isCover,isUpbeat,isHappy,isMellow,isEnergetic,isSad,customMoods?:string[]}
  let setlist = []; // array of {type:'song'|'break'|'encore', ...}
  let gig = { band:'', date:'', venue:'', address:'', contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[], hiddenIcons:[], liveDark:false };
  let gearSummary = '';
  // Tech notes persist independently of the current set (keyed by song id)
  let techNotes = {};
  // Band presets: array of {id, name, defaultStage:'', logo:''}
  let bandPresets = [];
  let currentBandPresetId = null;
  // Stage plot presets: array of {name, svg} - persisted globally across all dates
  let stagePresets = [];
  // Setlist presets: array of {name, setlist:[], date:ISO, thumbnail:string} - persisted globally
  let setlistPresets = [];
  // Last used setlist: most recent non-empty setlist for quick reload
  let lastUsedSetlist = null;
  // Tour dates: array of {id, date, venue, address, loadIn, showTime, band, setlist:[], stage:string, gig:{}, itinerary:[], tourType:'gig'|'hotel'|'travel'|'home', city:'', bandPresetId:null}
  let tourDates = [];
  let selectedTourDateId = null; // Currently selected date in tour manager
  let tourViewMode = 'month'; // 'week' | 'month' | 'year'
  let tourViewDate = new Date(); // Current view period anchor
  let tourCustomSearchTerms = ''; // User-defined search terms
  let currentDateDirty = false; // Track unsaved changes for current date
  // Setlist display column preferences
  let setlistColumns = {artist:true, capo:false, key:false, notes:true, bpm:false, lyrics:false};
  // Page layout preferences
  let pageLayout = {format:'letter', pageCount:1, songsPerPage:25};
  // Live audio playback handles
  let _liveAudioEl=null; // <audio> reused element
  let _liveAudioWin=null; // external window (YouTube/Spotify)
  let _liveLastExternalUrl=null; // last non-stream URL opened (avoid duplicate popups)
  const armedAudio = {}; // session-only object URLs keyed by song id
  // App-wide undo/redo history (setlist + stage); max 25
  const appHistory=[]; let appHistoryIndex=-1; let _restoring=false;
  // Enhanced platform detection for print optimization
  function isIOS(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return /ipad|iphone|ipod/.test(ua) || (/macintosh/.test(ua) && 'ontouchend' in document);
  }
  function isAndroid(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('android');
  }
  function isWindows(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('windows') || ua.includes('win32') || ua.includes('win64');
  }
  function isMac(){
    const ua=(navigator.userAgent||'').toLowerCase();
    return ua.includes('macintosh') || ua.includes('mac os');
  }
  function isMobileLike(){ return isIOS() || isAndroid(); }
  
  // Detect paper size preference (US = Letter, rest = A4)
  function getPreferredPaperSize(){
    const locale = navigator.language || navigator.userLanguage || 'en-US';
    // US, Canada, Mexico use Letter (8.5x11), rest of world uses A4 (210x297mm)
    return locale.startsWith('en-US') || locale.startsWith('en-CA') ? 'letter' : 'a4';
  }
  function getStageHTML(){
    const el=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
    return el ? el.outerHTML : '';
  }
  function deepCopySetlist(src){ try{ return JSON.parse(JSON.stringify(src||[])); }catch(_){ return []; } }
  function makeSnapshot(){ return { setlist: deepCopySetlist(setlist), stage: getStageHTML() }; }
  function snapshotSignature(s){ return JSON.stringify({s:s.setlist, h:(s.stage||'').length}); }
  function pushAppHistory(reason){ if(_restoring) return; const snap=makeSnapshot(); const sig=snapshotSignature(snap); const cur= appHistoryIndex>=0? appHistory[appHistoryIndex] : null; if(cur && cur.sig===sig) return; appHistory.splice(appHistoryIndex+1); appHistory.push({ ...snap, sig }); if(appHistory.length>25){ appHistory.shift(); } appHistoryIndex=appHistory.length-1; }
  function applySnapshot(snap){ if(!snap) return; _restoring=true; try{
      // restore setlist
      setlist = deepCopySetlist(snap.setlist||[]);
      try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(_){ }
      // restore stage
      const html = snap.stage||'';
      if(html){
        const modal=document.getElementById('stageModal');
        if(modal && modal.classList.contains('open')){
          const full=document.getElementById('stageSvgFull'); if(full){ const parent=full.parentNode; const tmp=document.createElement('div'); tmp.innerHTML=html; const fresh=tmp.querySelector('svg'); if(fresh && parent){ parent.replaceChild(fresh, full); fresh.id='stageSvgFull'; Array.from(fresh.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag); ensureStageMarkers(fresh); refreshCables(fresh); bindSelection(fresh); } }
        } else {
          const store=document.getElementById('stageStore'); if(store){ store.innerHTML=html; const svg=store.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); refreshCables(svg); } }
        }
      }
      saveAll();
    }finally{ _restoring=false; }
  }
  function undoApp(){ if(appHistoryIndex>0){ appHistoryIndex--; applySnapshot(appHistory[appHistoryIndex]); } }
  function redoApp(){ if(appHistoryIndex>=0 && appHistoryIndex<appHistory.length-1){ appHistoryIndex++; applySnapshot(appHistory[appHistoryIndex]); } }
  // Global undo/redo keybindings (Ctrl+Z / Ctrl+Y, Shift+Ctrl+Z)
  document.addEventListener('keydown', e=>{
    const key = e.key || '';
    const mod = e.ctrlKey || e.metaKey;
    const isUndo = mod && !e.shiftKey && (key==='z' || key==='Z');
    const isRedo = (mod && (key==='y' || key==='Y')) || (mod && e.shiftKey && (key==='z' || key==='Z'));
    if(!(isUndo || isRedo)) return;
    if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
    e.preventDefault();
    if(isUndo) undoApp(); else redoApp();
  });
  const DEFAULT_MOODS = ['upbeat','happy','energetic','mellow','sad'];
  const moodLabel = (k)=> k.charAt(0).toUpperCase()+k.slice(1);
  const getAllMoods = ()=> [...DEFAULT_MOODS, ...((gig.customMoods||[]).filter(x=>!DEFAULT_MOODS.includes(x)))].slice(0,12);
  
  // Utility: Extract first lyric line (skip chords, section headers, tablature)
  const findFirstLyricLine=(txt)=>{ const lines=(txt||'').split('\n'); for(let l of lines){ const t=l.trim(); if(!t) continue; if(t.startsWith('[') && t.includes(']')) continue; if(t.startsWith('|')) continue; if(/^[A-G]([#b]?m?|add\d|maj|min|sus|dim|aug|\d)*[\s\/]+/.test(t)) continue; return t; } return ''; };
  
  // Utility: Prompt with trim
  const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
  function renderAddMoodsUI(){
    const host=document.getElementById('addCustomMoods'); if(!host) return;
    host.innerHTML='';
    (gig.customMoods||[]).forEach(k=>{
      const lab=document.createElement('label'); lab.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id='cm-'+k;
      lab.appendChild(cb); lab.appendChild(document.createTextNode(' '+moodLabel(k)));
      host.appendChild(lab);
    });
  }

  // Storage
  const STORE_KEY='fastfast-setlist-v1';
  function saveAll(){
    try{
      // Prefer full editor SVG if open; fallback to stored small one
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      let stageHTML='';
      if(stageEl){
        const clone=stageEl.cloneNode(true);
        clone.querySelectorAll('g[data-draggable].selected').forEach(n=> n.classList.remove('selected'));
        stageHTML=clone.outerHTML;
        // Keep compact stored svg synchronized when full editor present
        const full=document.getElementById('stageSvgFull');
        const small=document.getElementById('stageSvg');
        if(full && small){
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
          Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
        }
      }
      
      // Save stage, setlist, gearSummary, and techNotes to current tour date if one is selected
      // Each date can have its own unique stage plot (including blank)
      if(typeof selectedTourDateId !== 'undefined' && selectedTourDateId && typeof tourDates !== 'undefined'){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(tourDate){
          // Always save current stage state to tour date (can be blank)
          tourDate.stage = stageHTML;
          tourDate.setlist = [...setlist];
          tourDate.gig = {...gig};
          if(typeof gearSummary !== 'undefined') tourDate.gearSummary = gearSummary;
          if(typeof techNotes !== 'undefined') tourDate.techNotes = techNotes;
        }
      }
      
      // Strip any embedded audioData before persisting to storage
      const dbOut = db.map(s=>{ const { audioData, ...rest } = s || {}; return rest; });
      // Track last used setlist if current setlist is non-empty
      if(setlist && setlist.length > 0){
        lastUsedSetlist = {setlist: JSON.parse(JSON.stringify(setlist)), gig: JSON.parse(JSON.stringify(gig)), date: new Date().toISOString()};
      }
      const payload={db:dbOut,setlist,gig,gearSummary,techNotes,stage:stageHTML,setlistColumns,pageLayout,tourDates,tourCustomSearchTerms,customSearchButtons,selectedTourDateId,activeTab:previousTab,bandPresets,currentBandPresetId,stagePresets,setlistPresets,lastUsedSetlist};
      localStorage.setItem(STORE_KEY, JSON.stringify(payload));
    }catch(e){ console.error('saveAll failed', e); }
  }

  function findSongById(id){ return db.find(x=> x.id===id); }
  function findSongByTitle(title){ return db.find(x=> (x.title||'').trim()===String(title||'').trim()); }
  function ensureLiveAudioEl(){ if(!_liveAudioEl){ _liveAudioEl=new Audio(); _liveAudioEl.preload='auto'; _liveAudioEl.crossOrigin='anonymous'; } return _liveAudioEl; }
  function stopSongAudio(){ try{ if(_liveAudioEl){ _liveAudioEl.pause(); _liveAudioEl.currentTime=0; } }catch(_){ }
    try{ if(_liveAudioWin && !(_liveAudioWin.closed)){ _liveAudioWin.close(); } }catch(_){ }
    _liveAudioWin=null;
  }
  function preloadSongAudioFor(setItem){
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return;
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    if(armed){ const a=ensureLiveAudioEl(); if(a.src!==armed){ a.src=armed; } try{ a.load(); }catch(_){ } return; }
    if(url){ const lower=url.toLowerCase(); const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream'); if(isStream){ const a=ensureLiveAudioEl(); if(a.src!==url){ a.src=url; } try{ a.load(); }catch(_){ } }
    }
  }
  function playSongAudioFor(setItem){
    // Prefer looking up canonical song in db to access latest audio fields
    let song=null; if(setItem && setItem.id!=null){ song=findSongById(setItem.id); }
    if(!song){ song=findSongByTitle(setItem && setItem.title); }
    if(!song) return; // nothing to play
    const armed=(song.id!=null && armedAudio[song.id]); const url=(song.audioUrl||'').trim();
    // Armed local file or URL (session)
    if(armed){
      // Always stop any other playback before starting
      stopSongAudio();
      // Check if armed value is a URL string (http/https) or blob URL
      const armedValue = armedAudio[song.id];
      const isExternalUrl = typeof armedValue==='string' && (armedValue.startsWith('http://') || armedValue.startsWith('https://'));
      if(isExternalUrl){
        // Armed URL - treat as external link
        const lower=armedValue.toLowerCase();
        const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
        if(isStream){
          const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
        } else {
          // External provider (YouTube/Spotify/etc.)
          if(_liveAudioWin && !_liveAudioWin.closed){
            if(_liveLastExternalUrl===armedValue){ return; }
            try{ _liveAudioWin.location.href=armedValue; _liveLastExternalUrl=armedValue; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
          }
          try{ _liveAudioWin = window.open(armedValue,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=armedValue; }catch(_){ _liveAudioWin=null; }
        }
      } else {
        // Armed local file (blob URL)
        const a=ensureLiveAudioEl(); a.src=armedValue; a.play().catch(()=>{});
      }
      return;
    }
    if(url){
      const lower=url.toLowerCase();
      const isStream= lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      if(isStream){
        // Stop any previous audio before starting this stream
        stopSongAudio();
        const a=ensureLiveAudioEl(); a.src=url; a.play().catch(()=>{}); return;
      }
      // External provider (YouTube/Spotify/etc.): reuse single popup and avoid re-opening if same URL
      if(_liveAudioWin && !_liveAudioWin.closed){
        if(_liveLastExternalUrl===url){ return; }
        try{ _liveAudioWin.location.href=url; _liveLastExternalUrl=url; return; }catch(e){ try{ _liveAudioWin.close(); }catch(_){} }
      }
      try{ _liveAudioWin = window.open(url,'liveAudio','width=560,height=420,noopener'); _liveLastExternalUrl=url; }catch(_){ _liveAudioWin=null; }
      return;
    }
  }

  // Capture a snapshot of the current full stage SVG for undo/redo
  function snapshotStage(){
    try{ pushAppHistory('stage'); }catch(_){ }
  }
  // Throttled save for high-frequency drag updates
  let _savePending=false; let _lastSaveTs=0; const SAVE_MIN_INTERVAL=250; // ms
  function queueSave(){
    const now=Date.now();
    if(!_savePending && (now-_lastSaveTs)>=SAVE_MIN_INTERVAL){
      _savePending=true;
      requestAnimationFrame(()=>{
        _savePending=false; _lastSaveTs=Date.now(); saveAll();
        // Update calendar preview if we're in a tour date
        if(typeof selectedTourDateId !== 'undefined' && selectedTourDateId && typeof tourDates !== 'undefined' && typeof renderTourPreviews === 'function'){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate) renderTourPreviews(tourDate);
        }
      });
    }
  }
  // Track if there are unsaved changes worth prompting about
  let hasUnsavedChanges = false;
  function markUnsaved(){ hasUnsavedChanges = true; }
  
  // Persist on navigation away with save prompt
  window.addEventListener('beforeunload', (e)=>{
    try{ for(const k in armedAudio){ try{ URL.revokeObjectURL(armedAudio[k]); }catch(_){} } }catch(_){}
    saveAll();
    // Only prompt if there's meaningful data
    const hasData = (db && db.length > 0) || (setlist && setlist.length > 0) || (tourDates && tourDates.length > 0);
    if(hasData){
      // Browser will show native "Leave site?" prompt
      e.preventDefault();
      e.returnValue = 'You have unsaved work. Make sure to export your BAND or SET file!';
      return e.returnValue;
    }
  });
    
    // Add custom column button
    const addCustomColumnBtn=document.getElementById('addCustomColumn');
    if(addCustomColumnBtn){ addCustomColumnBtn.addEventListener('click', ()=>{
      const name = prompt('Custom column name (e.g., Genre, Language, Tempo):');
      if(!name || name.trim().length === 0) return;
      const key = name.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if(!gig.customColumns) gig.customColumns = [];
      if(gig.customColumns.find(c => c.key === key)){
        alert('Column already exists.');
        return;
      }
      // Ask if they want to push this field to setlist
      const pushToSet = confirm('Push this field data to setlist display?\n\nClick OK to show this column in the printed setlist alongside song titles.\nClick Cancel to keep it database-only.');
      gig.customColumns.push({key, name: name.trim(), pushToSetlist: pushToSet});
      // Add to column order
      if(!gig.dbColumns.order) gig.dbColumns.order = ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      // Insert before actions
      const actionsIdx = gig.dbColumns.order.indexOf('actions');
      if(actionsIdx > -1){
        gig.dbColumns.order.splice(actionsIdx, 0, key);
      } else {
        gig.dbColumns.order.push(key);
      }
      saveAll();
      renderDB();
      buildSheet('sheetInline');
    }); }
    
    // Clear database
    const clearDBBtn=document.getElementById('clearDB');
    const clearDBLock=document.getElementById('clearDBLock');
    if(clearDBBtn){ clearDBBtn.addEventListener('click',()=>{
      if(!db.length) return;
      if(clearDBLock && !clearDBLock.checked){ alert('Please check the unlock checkbox first to enable clearing the database.'); return; }
      // Offer to save a .BAND backup first
      try{
        if(confirm('Download a .BAND backup before clearing the database? Click OK to Save, or Cancel to skip.')){
          var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
          const stage = stageEl ? stageEl.outerHTML : '';
          const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
          const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
          const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
        }
      }catch(_){ /* ignore */ }
      if(!confirm('Clear entire song database now? This cannot be undone (unless you reload a .BAND profile).')) return;
      db.splice(0,db.length); renderDB(); saveAll();
    }); }
    // Clear setlist
    const clearSetBtn=document.getElementById('clearSet');
    if(clearSetBtn){ clearSetBtn.addEventListener('click',()=>{ if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; } if(!setlist.length) return; if(!confirm('Clear current setlist?')) return; setlist=[]; buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll(); }); }
    
    // Save Setlist as Preset button - now shows menu with Load/Save/Cancel
    const saveSetlistPresetBtn=document.getElementById('saveSetlistPresetBtn');
    if(saveSetlistPresetBtn){ saveSetlistPresetBtn.addEventListener('click', showSetlistPresetMenu); }
    
    // New Setlist button
    const newSetBtn=document.getElementById('newSetBtn');
    if(newSetBtn){ newSetBtn.addEventListener('click',()=>{
      if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; }
      if(!setlist.length){
        alert('Setlist is already empty!');
        return;
      }
      const save = confirm('Save current setlist as a preset before starting fresh?\n\nOK = Save as preset\nCancel = Just clear (lose current setlist)');
      if(save){
        saveSetlistAsPreset();
      }
      setlist = [];
      buildSheet('sheetInline');
      attachPreviewInteractions();
      renderSongPool();
      saveAll();
    }); }
    // Help modal open/close and Gear panel
    const helpBtn=document.getElementById('helpBtn'); const helpModal=document.getElementById('helpModal'); const closeHelp=document.getElementById('closeHelp');
    if(helpBtn && helpModal){ helpBtn.addEventListener('click',()=>{ helpModal.style.display='flex'; helpModal.classList.add('open'); }); }
    if(closeHelp){ closeHelp.addEventListener('click',()=>{ helpModal.classList.remove('open'); helpModal.style.display='none'; }); }
    if(helpModal){
      helpModal.addEventListener('click',e=>{
        if(e.target===helpModal){ helpModal.classList.remove('open'); helpModal.style.display='none'; }
      });
    }
    const gearBtn=document.getElementById('gearBtn');
    const gearPanel=document.getElementById('gearPanel');
    if(gearBtn && gearPanel){
      gearBtn.addEventListener('click',()=>{
        const show=gearPanel.style.display==='none' || !gearPanel.style.display;
        gearPanel.style.display= show ? 'flex' : 'none';
      });
    }

    // Page layout controls
    (function setupPageLayout(){
      const formatSel=document.getElementById('paperFormat');
      const pageSel=document.getElementById('pageCount');
      const songsPerPageSel=document.getElementById('songsPerPage');
      if(formatSel){
        formatSel.value = pageLayout.format || 'letter';
        formatSel.addEventListener('change',()=>{
          pageLayout.format = formatSel.value;
          saveAll();
          buildSheet('sheetInline');
        });
      }
      if(pageSel){
        pageSel.value = String(pageLayout.pageCount || 1);
        pageSel.addEventListener('change',()=>{
          pageLayout.pageCount = parseInt(pageSel.value,10) || 1;
          saveAll();
          buildSheet('sheetInline');
        });
      }
      if(songsPerPageSel){
        songsPerPageSel.value = String(pageLayout.songsPerPage || 25);
        songsPerPageSel.addEventListener('change',()=>{
          pageLayout.songsPerPage = parseInt(songsPerPageSel.value,10) || 25;
          saveAll();
          buildSheet('sheetInline');
        });
      }
    })();

    // Setlist display column checkboxes
    (function setupSetlistColumns(){
      ['artist','capo','key','notes','bpm','lyrics'].forEach(k=>{
        const cb=document.getElementById('setCol_'+k);
        if(!cb) return;
        cb.checked = !!setlistColumns[k];
        cb.addEventListener('change',()=>{
          setlistColumns[k] = cb.checked;
          saveAll();
          buildSheet('sheetInline');
        });
      });
      // Add custom column checkboxes
      const customHost=document.getElementById('setColCustom');
      if(customHost && gig.customColumns){
        gig.customColumns.forEach(cc=>{
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const cb=document.createElement('input');
          cb.type='checkbox';
          cb.id='setCol_custom_'+cc.key;
          if(!setlistColumns[cc.key]) setlistColumns[cc.key] = !!cc.pushToSetlist;
          cb.checked = !!setlistColumns[cc.key];
          cb.addEventListener('change',()=>{
            setlistColumns[cc.key] = cb.checked;
            saveAll();
            buildSheet('sheetInline');
          });
          lbl.appendChild(cb);
          lbl.appendChild(document.createTextNode(' '+cc.name));
          customHost.appendChild(lbl);
        });
      }
    })();

    // Lyrics helpers: search popup (user chooses source)
    (function setupLyricsHelpers(){
      const searchBtn=document.getElementById('searchLyricsBtn');
      if(searchBtn){
        searchBtn.addEventListener('click',()=>{
          const titleEl=document.getElementById('t');
          const artistEl=document.getElementById('a');
          const title=(titleEl && titleEl.value.trim())||'';
          const artist=(artistEl && artistEl.value.trim())||'';
          if(!title){ alert('Enter a song title first to build a search.'); return; }
          const q=encodeURIComponent([title, artist, 'lyrics chords'].filter(Boolean).join(' '));
          const url='https://www.google.com/search?q='+q;
          window.open(url,'lyricsSearch','noopener');
        });
      }
    })();
  function loadAll(){
    try{
      const raw=localStorage.getItem(STORE_KEY); if(!raw) return;
    const {db:dbIn,setlist:setIn,gig:gigIn,gearSummary:gearIn,techNotes:tnIn,stage,setlistColumns:setColIn,pageLayout:pageLayoutIn,tourDates:tourIn,tourCustomSearchTerms:tourSearchIn,selectedTourDateId:selectedIdIn,activeTab:activeTabIn,bandPresets:bandPresetsIn,currentBandPresetId:currentBandPresetIdIn,stagePresets:stagePresetsIn,setlistPresets:setlistPresetsIn,lastUsedSetlist:lastUsedSetlistIn}=JSON.parse(raw);
      if(Array.isArray(dbIn)) db.push(...dbIn);
      if(Array.isArray(setIn)) setlist=setIn;
      if(gigIn) gig=Object.assign(gig,gigIn);
      if(gearIn) { gearSummary = gearIn; }
  if(tnIn && typeof tnIn==='object') { techNotes = tnIn; }
  if(setColIn && typeof setColIn==='object') { setlistColumns = Object.assign(setlistColumns, setColIn); }
  if(pageLayoutIn && typeof pageLayoutIn==='object') { pageLayout = Object.assign(pageLayout, pageLayoutIn); }
  if(Array.isArray(tourIn)) { tourDates = tourIn; }
  if(typeof tourSearchIn === 'string') { tourCustomSearchTerms = tourSearchIn; }
  if(selectedIdIn) { selectedTourDateId = selectedIdIn; }
  if(activeTabIn) { previousTab = activeTabIn; }
  if(Array.isArray(bandPresetsIn)) { bandPresets = bandPresetsIn; }
  if(currentBandPresetIdIn) { currentBandPresetId = currentBandPresetIdIn; }
  if(Array.isArray(stagePresetsIn)) { stagePresets = stagePresetsIn; }
  if(Array.isArray(setlistPresetsIn)) { setlistPresets = setlistPresetsIn; }
  if(lastUsedSetlistIn && lastUsedSetlistIn.setlist) { lastUsedSetlist = lastUsedSetlistIn; }
      // Gig info now edited directly on sheet header
      const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value = gearSummary || '';
      renderDB(); buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool();
      if(stage){ const container=document.getElementById('stageStore'); container.innerHTML=stage; const svg=container.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); refreshCables(svg); }
      }
    }catch(e){/* ignore */}
  }

    // Helpers
    const $ = s=>document.querySelector(s);
    const el = (t,cls,txt)=>{const n=document.createElement(t); if(cls) n.className=cls; if(txt!=null) n.textContent=txt; return n;}
    const shuffle = a=>{const r=[...a]; for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[r[i],r[j]]=[r[j],r[i]];} return r}

    // Title shortening: trims, collapses, removes parentheticals, limits words, ensures width via characters
    function shorten(title, maxChars=48){
      if(!title) return '';
      // Keep original wording; only trim whitespace and optional parentheticals for clutter
      let t=title.replace(/\s+/g,' ').trim();
      t=t.replace(/\s*\([^\)]*\)\s*/g,' '); // remove (feat), (live), etc
      if(t.length>maxChars) t=t.slice(0,maxChars-1)+'‚Ä¶';
      return t;
    }

    function minutes(sum){ return `${sum.toFixed(1)}m`; }

    // Tabs
    let previousTab = 'tour'; // Track previous tab
    document.querySelectorAll('.tab').forEach(btn=>btn.addEventListener('click',e=>{
      // Setlist tab: check if date has setlist
      if(btn.dataset.tab === 'set'){
        if(selectedTourDateId){
          const td = tourDates.find(t => t.id === selectedTourDateId);
          if(td && td.setlist && td.setlist.length > 0){
            // Has setlist: auto-edit mode
            window.setlistEditMode = 'edit';
            setlist = JSON.parse(JSON.stringify(td.setlist));
            buildSheet('sheetInline');
            attachPreviewInteractions();
            renderSongPool();
          } else {
            // No setlist: show 4-option dialog
            e.preventDefault();
            showSetlistOptionsDialog(td, btn);
            return;
          }
        } else {
          // No date selected: show 4-option dialog
          e.preventDefault();
          showSetlistOptionsDialog(null, btn);
          return;
        }
      }
      
      // Save Calendar data when leaving Calendar tab
      if(previousTab === 'tour' && btn.dataset.tab !== 'tour'){
        try { if(typeof saveTourDateData === 'function') saveTourDateData(); } catch(err) { console.log('Save tour data:', err); }
      }
      
      // Save Tech/Stage data when leaving Tech/Stage tab
      if(previousTab === 'adv' && btn.dataset.tab !== 'adv'){
        if(selectedTourDateId){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate){
            tourDate.stage = getStageHTML();
            tourDate.gearSummary = gearSummary;
            tourDate.techNotes = techNotes;
          }
        }
        const stageModal = document.getElementById('stageModal');
        if(stageModal && stageModal.classList.contains('open')){
          try{ closeStageModal(); }catch(_){ stageModal.classList.remove('open'); }
        }
        saveAll();
      }
      
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      document.getElementById(btn.dataset.tab).style.display='block';
      
      // Reload Calendar data when entering Calendar tab
      if(btn.dataset.tab === 'tour'){
        try { if(typeof reloadCalendarData === 'function') reloadCalendarData(); } catch(err) { console.log('Reload calendar data:', err); }
      }
      
      previousTab = btn.dataset.tab;
      // Only Tech/Stage tab should show stage or lighting sections
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      document.body.classList.toggle('live-mode', btn.dataset.tab==='live');
      if(btn.dataset.tab==='adv'){
        if(stageModal && !stageModal.classList.contains('open') && notesModal && !notesModal.classList.contains('open')){
          // Default to Stage Plot view when entering Tech/Stage
          toggleStageAndNotes();
        }
      } else if(btn.dataset.tab==='live'){
        // Closing any stage/notes modals for distraction-free live view
        if(stageModal && stageModal.classList.contains('open')){ try{ closeStageModal(); }catch(_){ stageModal.classList.remove('open'); } }
        if(notesModal && notesModal.classList.contains('open')){ notesModal.classList.remove('open'); }
        // Refresh live view when switching to Live tab
        try{ renderLive(); }catch(_){ }
        // Notify listeners we entered live to trigger auto-arm prompt
        try{ document.dispatchEvent(new Event('live-enter')); }catch(_){ }
      } else {
        // Leaving Tech/Stage: if stage editor open, perform full sync via closeStageModal (ensures compact svg updated)
        if(stageModal && stageModal.classList.contains('open')){
          closeStageModal();
        } else if(stageModal){
          saveAll(); stageModal.classList.remove('open');
        }
        if(notesModal) notesModal.classList.remove('open');
      }
    }));

    // Prefill date today
    (function prefill(){
      const d=$('#gDate'); if(d && !d.value){ const t=new Date(); const iso=new Date(t.getTime()-t.getTimezoneOffset()*60000).toISOString().slice(0,10); d.value=iso; }
      loadAll();
      // Build initial inline preview
      try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){ }
      try{ renderAddMoodsUI(); }catch(_){ }
      try{ renderLive(); }catch(_){ }
      // Apply saved live theme
      if(gig && gig.liveDark){ document.body.classList.add('live-dark'); }
      
      // Restore last active tab and selected tour date
      const restoreTab = previousTab || 'tour';
      document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
      const tabToActivate = document.querySelector(`.tab[data-tab="${restoreTab}"]`);
      if(tabToActivate) {
        tabToActivate.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id => {
          const el = document.getElementById(id);
          if(el) el.style.display = 'none';
        });
        const tabContent = document.getElementById(restoreTab);
        if(tabContent) tabContent.style.display = 'block';
      }
      
      // Smart date selection on load: prioritize today or future dates, never load past dates
      if(restoreTab === 'tour') {
        const today = new Date();
        today.setHours(0,0,0,0);
        const todayStr = today.toISOString().split('T')[0];
        
        let dateToSelect = null;
        
        // First, check if there's a date for today
        const todayDate = tourDates.find(td => td.date === todayStr);
        if(todayDate) {
          dateToSelect = todayDate;
        } else if(selectedTourDateId) {
          // Check if last selected date is today or in the future
          const lastTourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(lastTourDate) {
            const lastDate = new Date(lastTourDate.date);
            lastDate.setHours(0,0,0,0);
            if(lastDate >= today) {
              dateToSelect = lastTourDate;
            }
          }
        }
        
        // If no valid date yet, find the next incomplete future date
        if(!dateToSelect) {
          const futureDates = tourDates
            .filter(td => {
              const tdDate = new Date(td.date);
              tdDate.setHours(0,0,0,0);
              return tdDate >= today;
            })
            .sort((a, b) => new Date(a.date) - new Date(b.date));
          
          // Find first incomplete date (missing venue or setlist/stage)
          const incompleteDate = futureDates.find(td => {
            const hasVenue = td.venue && td.venue.trim() !== '';
            const hasSetlist = td.setlist && td.setlist.length > 0;
            const hasStagePlot = td.stage && td.stage.trim() !== '';
            return !hasVenue || (!hasSetlist && !hasStagePlot);
          });
          
          dateToSelect = incompleteDate || futureDates[0];
        }
        
        // Select the determined date
        if(dateToSelect) {
          try {
            if(typeof selectTourDate === 'function') {
              selectTourDate(dateToSelect);
            }
          } catch(e) {
            console.log('Could not restore tour date:', e);
          }
        }
      }
      
      // Prompt for band name if not set (new user or first launch)
      setTimeout(()=>{
        if(!gig.band || gig.band.trim() === '' || gig.band.trim() === 'Enter Band Name'){
          showBandPresetModal();
        }
      }, 300);
    })();
    
    // Setlist Options Dialog - shown when clicking Setlist tab with no existing setlist
    function showSetlistOptionsDialog(tourDate, tabBtn){
      let modal = document.getElementById('setlistOptionsModal');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistOptionsModal';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      const hasLastUsed = lastUsedSetlist && lastUsedSetlist.setlist && lastUsedSetlist.setlist.length > 0;
      const hasPresets = setlistPresets && setlistPresets.length > 0;
      
      modal.innerHTML = `
        <div style="background:#1f2937;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">Open Setlist</h3>
          <p style="margin:0 0 20px;color:#9ca3af;font-size:14px">Choose how to start your setlist:</p>
          <div style="display:flex;flex-direction:column;gap:12px">
            <button id="setOptNew" style="padding:14px 16px;background:#065f46;color:#fff;border:none;border-radius:8px;font-size:15px;cursor:pointer;text-align:left;display:flex;align-items:center;gap:12px">
              <span style="font-size:20px">üìù</span>
              <div><strong>New</strong><br><span style="font-size:12px;color:#d1fae5">Start fresh setlist with current date/venue</span></div>
            </button>
            <button id="setOptLastUsed" style="padding:14px 16px;background:${hasLastUsed ? '#1e40af' : '#374151'};color:${hasLastUsed ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasLastUsed ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasLastUsed ? '' : 'disabled'}>
              <span style="font-size:20px">üïê</span>
              <div><strong>Last Used</strong><br><span style="font-size:12px;color:${hasLastUsed ? '#bfdbfe' : '#6b7280'}">${hasLastUsed ? 'Load most recent setlist' : 'No previous setlist saved'}</span></div>
            </button>
            <button id="setOptLoad" style="padding:14px 16px;background:#7c3aed;color:#fff;border:none;border-radius:8px;font-size:15px;cursor:pointer;text-align:left;display:flex;align-items:center;gap:12px">
              <span style="font-size:20px">üìÇ</span>
              <div><strong>Load</strong><br><span style="font-size:12px;color:#e9d5ff">Import from .SET file</span></div>
            </button>
            <button id="setOptPreset" style="padding:14px 16px;background:${hasPresets ? '#c2410c' : '#374151'};color:${hasPresets ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasPresets ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasPresets ? '' : 'disabled'}>
              <span style="font-size:20px">‚≠ê</span>
              <div><strong>Preset</strong><br><span style="font-size:12px;color:${hasPresets ? '#fed7aa' : '#6b7280'}">${hasPresets ? setlistPresets.length + ' saved preset(s)' : 'No presets saved yet'}</span></div>
            </button>
          </div>
          <div style="margin-top:20px;text-align:right">
            <button id="setOptCancel" style="padding:10px 20px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      function proceedToTab(){
        document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
        tabBtn.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
        document.getElementById('set').style.display='block';
        previousTab = 'set';
        buildSheet('sheetInline');
        attachPreviewInteractions();
        renderSongPool();
      }
      
      // New - blank setlist with current date info
      modal.querySelector('#setOptNew').onclick = ()=>{
        closeModal();
        window.setlistEditMode = 'new';
        setlist = [];
        if(tourDate){
          gig.venue = tourDate.venue || '';
          gig.address = tourDate.address || '';
          gig.notes = tourDate.notes || '';
        }
        proceedToTab();
      };
      
      // Last Used
      if(hasLastUsed){
        modal.querySelector('#setOptLastUsed').onclick = ()=>{
          closeModal();
          window.setlistEditMode = 'new';
          setlist = JSON.parse(JSON.stringify(lastUsedSetlist.setlist));
          if(tourDate){
            gig.venue = tourDate.venue || gig.venue;
            gig.address = tourDate.address || gig.address;
          }
          proceedToTab();
        };
      }
      
      // Load from file
      modal.querySelector('#setOptLoad').onclick = ()=>{
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.set,.json';
        input.onchange = ev=>{
          const file = ev.target.files[0];
          if(!file) return;
          const reader = new FileReader();
          reader.onload = re=>{
            try{
              const data = JSON.parse(re.target.result);
              if(data.setlist && Array.isArray(data.setlist)){
                setlist = data.setlist;
                if(data.gig) Object.assign(gig, data.gig);
                window.setlistEditMode = 'new';
                closeModal();
                proceedToTab();
              } else {
                alert('Invalid .SET file format');
              }
            }catch(err){
              alert('Error reading file: ' + err.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };
      
      // Preset picker
      if(hasPresets){
        modal.querySelector('#setOptPreset').onclick = ()=>{
          closeModal();
          showSetlistPresetPicker(tourDate, tabBtn);
        };
      }
      
      // Cancel
      modal.querySelector('#setOptCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Setlist Preset Picker - shows saved presets with thumbnails
    function showSetlistPresetPicker(tourDate, tabBtn){
      let modal = document.getElementById('setlistPresetPicker');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetPicker';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      let presetsHTML = setlistPresets.map((p, idx)=>{
        const songCount = p.setlist ? p.setlist.length : 0;
        const preview = p.setlist ? p.setlist.slice(0,5).map(s=>s.title || 'Untitled').join(', ') : '';
        const dateStr = p.date ? new Date(p.date).toLocaleDateString() : '';
        return `
          <div class="preset-item" data-idx="${idx}" style="padding:12px;border:1px solid #374151;border-radius:8px;background:#1f2937;cursor:pointer;display:flex;flex-direction:column;gap:6px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong style="color:#fff">${p.name || 'Unnamed'}</strong>
              <button class="delete-preset" data-idx="${idx}" style="background:#991b1b;color:#fff;border:none;border-radius:4px;padding:4px 8px;font-size:11px;cursor:pointer">‚úï</button>
            </div>
            <div style="font-size:12px;color:#9ca3af">${songCount} songs ‚Ä¢ ${dateStr}</div>
            <div style="font-size:11px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${preview}...</div>
          </div>
        `;
      }).join('');
      
      modal.innerHTML = `
        <div style="background:#111827;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Setlist Presets</h3>
          <div style="display:flex;flex-direction:column;gap:10px">${presetsHTML || '<p style="color:#6b7280">No presets saved</p>'}</div>
          <div style="margin-top:20px;display:flex;gap:10px;justify-content:flex-end">
            <button id="presetPickerBack" style="padding:10px 16px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Back</button>
            <button id="presetPickerCancel" style="padding:10px 16px;background:#991b1b;color:#fff;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      function proceedToTab(){
        document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
        tabBtn.classList.add('active');
        ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
        document.getElementById('set').style.display='block';
        previousTab = 'set';
        buildSheet('sheetInline');
        attachPreviewInteractions();
        renderSongPool();
      }
      
      // Click on preset item to load
      modal.querySelectorAll('.preset-item').forEach(item=>{
        item.onclick = e=>{
          if(e.target.classList.contains('delete-preset')) return;
          const idx = parseInt(item.dataset.idx);
          const preset = setlistPresets[idx];
          if(preset && preset.setlist){
            setlist = JSON.parse(JSON.stringify(preset.setlist));
            window.setlistEditMode = 'new';
            if(tourDate){
              gig.venue = tourDate.venue || gig.venue;
              gig.address = tourDate.address || gig.address;
            }
            closeModal();
            proceedToTab();
          }
        };
      });
      
      // Delete preset
      modal.querySelectorAll('.delete-preset').forEach(btn=>{
        btn.onclick = e=>{
          e.stopPropagation();
          const idx = parseInt(btn.dataset.idx);
          if(confirm('Delete preset "' + (setlistPresets[idx]?.name || 'Unnamed') + '"?')){
            setlistPresets.splice(idx, 1);
            saveAll();
            closeModal();
            if(setlistPresets.length > 0){
              showSetlistPresetPicker(tourDate, tabBtn);
            } else {
              showSetlistOptionsDialog(tourDate, tabBtn);
            }
          }
        };
      });
      
      modal.querySelector('#presetPickerBack').onclick = ()=>{ closeModal(); showSetlistOptionsDialog(tourDate, tabBtn); };
      modal.querySelector('#presetPickerCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Show Preset menu with Load/Save/Cancel options
    function showSetlistPresetMenu(){
      let modal = document.getElementById('setlistPresetMenu');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetMenu';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      const hasPresets = setlistPresets && setlistPresets.length > 0;
      const hasSetlist = setlist && setlist.length > 0;
      
      modal.innerHTML = `
        <div style="background:#1f2937;color:#e5e7eb;border-radius:12px;padding:24px;max-width:400px;width:90%">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Setlist Presets</h3>
          <div style="display:flex;flex-direction:column;gap:12px">
            <button id="presetMenuSave" style="padding:14px 16px;background:${hasSetlist ? '#065f46' : '#374151'};color:${hasSetlist ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasSetlist ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasSetlist ? '' : 'disabled'}>
              <span style="font-size:20px">üíæ</span>
              <div><strong>Save Preset</strong><br><span style="font-size:12px;color:${hasSetlist ? '#d1fae5' : '#6b7280'}">Save current setlist as reusable preset</span></div>
            </button>
            <button id="presetMenuLoad" style="padding:14px 16px;background:${hasPresets ? '#c2410c' : '#374151'};color:${hasPresets ? '#fff' : '#6b7280'};border:none;border-radius:8px;font-size:15px;cursor:${hasPresets ? 'pointer' : 'not-allowed'};text-align:left;display:flex;align-items:center;gap:12px" ${hasPresets ? '' : 'disabled'}>
              <span style="font-size:20px">üìÇ</span>
              <div><strong>Load Preset</strong><br><span style="font-size:12px;color:${hasPresets ? '#fed7aa' : '#6b7280'}">${hasPresets ? setlistPresets.length + ' preset(s) available' : 'No presets saved yet'}</span></div>
            </button>
          </div>
          <div style="margin-top:20px;text-align:right">
            <button id="presetMenuCancel" style="padding:10px 20px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      
      if(hasSetlist){
        modal.querySelector('#presetMenuSave').onclick = ()=>{
          closeModal();
          saveSetlistAsPreset();
        };
      }
      
      if(hasPresets){
        modal.querySelector('#presetMenuLoad').onclick = ()=>{
          closeModal();
          // Get current tab button for preset picker
          const tabBtn = document.querySelector('.tab[data-tab="set"]');
          showSetlistPresetPickerInline();
        };
      }
      
      modal.querySelector('#presetMenuCancel').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Inline preset picker (for when already on setlist tab)
    function showSetlistPresetPickerInline(){
      let modal = document.getElementById('setlistPresetPicker');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'setlistPresetPicker';
      modal.className = 'modal open';
      modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center;z-index:9999;pointer-events:auto';
      
      let presetsHTML = setlistPresets.map((p, idx)=>{
        const songCount = p.setlist ? p.setlist.length : 0;
        const preview = p.setlist ? p.setlist.slice(0,5).map(s=>s.title || 'Untitled').join(', ') : '';
        const dateStr = p.date ? new Date(p.date).toLocaleDateString() : '';
        return `
          <div class="preset-item" data-idx="${idx}" style="padding:12px;border:1px solid #374151;border-radius:8px;background:#1f2937;cursor:pointer;display:flex;flex-direction:column;gap:6px">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong style="color:#fff">${p.name || 'Unnamed'}</strong>
              <button class="delete-preset" data-idx="${idx}" style="background:#991b1b;color:#fff;border:none;border-radius:4px;padding:4px 8px;font-size:11px;cursor:pointer">‚úï</button>
            </div>
            <div style="font-size:12px;color:#9ca3af">${songCount} songs ‚Ä¢ ${dateStr}</div>
            <div style="font-size:11px;color:#6b7280;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${preview}...</div>
          </div>
        `;
      }).join('');
      
      modal.innerHTML = `
        <div style="background:#111827;color:#e5e7eb;border-radius:12px;padding:24px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
          <h3 style="margin:0 0 16px;font-size:20px;color:#fff">‚≠ê Load Setlist Preset</h3>
          <div style="display:flex;flex-direction:column;gap:10px">${presetsHTML || '<p style="color:#6b7280">No presets saved</p>'}</div>
          <div style="margin-top:20px;text-align:right">
            <button id="presetPickerCancelInline" style="padding:10px 16px;background:#374151;color:#e5e7eb;border:none;border-radius:6px;cursor:pointer">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      function closeModal(){ modal.remove(); }
      
      // Click on preset item to load
      modal.querySelectorAll('.preset-item').forEach(item=>{
        item.onclick = e=>{
          if(e.target.classList.contains('delete-preset')) return;
          const idx = parseInt(item.dataset.idx);
          const preset = setlistPresets[idx];
          if(preset && preset.setlist){
            if(setlist && setlist.length > 0){
              if(!confirm('Replace current setlist with preset "' + preset.name + '"?')) return;
            }
            setlist = JSON.parse(JSON.stringify(preset.setlist));
            buildSheet('sheetInline');
            attachPreviewInteractions();
            renderSongPool();
            saveAll();
            closeModal();
          }
        };
      });
      
      // Delete preset
      modal.querySelectorAll('.delete-preset').forEach(btn=>{
        btn.onclick = e=>{
          e.stopPropagation();
          const idx = parseInt(btn.dataset.idx);
          if(confirm('Delete preset "' + (setlistPresets[idx]?.name || 'Unnamed') + '"?')){
            setlistPresets.splice(idx, 1);
            saveAll();
            closeModal();
            if(setlistPresets.length > 0){
              showSetlistPresetPickerInline();
            }
          }
        };
      });
      
      modal.querySelector('#presetPickerCancelInline').onclick = closeModal;
      modal.onclick = e=>{ if(e.target === modal) closeModal(); };
    }
    
    // Save current setlist as preset
    function saveSetlistAsPreset(){
      if(!setlist || setlist.length === 0){
        alert('Cannot save empty setlist as preset');
        return;
      }
      const name = prompt('Name this setlist preset:', gig.venue || 'Setlist ' + new Date().toLocaleDateString());
      if(name && name.trim()){
        setlistPresets.push({
          name: name.trim(),
          setlist: JSON.parse(JSON.stringify(setlist)),
          date: new Date().toISOString()
        });
        saveAll();
        alert('Setlist saved as preset: ' + name.trim());
      }
    }
    
    // Band Preset Modal - shows on first launch or when no band name is set
    function showBandPresetModal(){
      // Always remove and rebuild to ensure fresh event listeners
      let modal = document.getElementById('bandPresetModal');
      if(modal) modal.remove();
      
      modal = document.createElement('div');
      modal.id = 'bandPresetModal';
      modal.className = 'modal open';
      modal.style.zIndex = '9999';
      modal.innerHTML = `
        <div class="modalbox" style="background:white;border-radius:12px;padding:24px;width:400px;max-width:90vw;box-shadow:0 10px 40px rgba(0,0,0,0.3);margin-top:60px;touch-action:manipulation">
          <h2 style="margin:0 0 16px;font-size:20px;font-weight:600">üé∏ Welcome! Enter Your Band Name</h2>
          <p style="margin:0 0 16px;color:#666;font-size:13px">This will be used on your setlists, stage plots, and calendar dates.</p>
          
          <div style="margin-bottom:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Band/Artist Name</label>
            <input type="text" id="bandPresetNameInput" placeholder="e.g., The Kildeers" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:16px;touch-action:manipulation;-webkit-appearance:none" />
          </div>
          
          ${bandPresets.length > 0 ? `
          <div style="margin-bottom:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Or Select Existing Band</label>
            <select id="bandPresetSelect" style="width:100%;padding:12px;border:1px solid #d1d5db;border-radius:6px;font-size:16px;touch-action:manipulation;-webkit-appearance:menulist">
              <option value="">-- New Band --</option>
              ${bandPresets.map(bp => `<option value="${bp.id}">${bp.name}</option>`).join('')}
            </select>
          </div>
          ` : ''}
          
          <div style="display:flex;gap:8px;justify-content:flex-end">
            <button id="bandPresetSkip" type="button" class="btn" style="padding:12px 20px;font-size:14px;touch-action:manipulation;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0.1)">Skip for Now</button>
            <button id="bandPresetSave" type="button" class="btn primary" style="padding:12px 20px;font-size:14px;touch-action:manipulation;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0.1)">Save & Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Save handler function
      function saveBandPreset(){
        const nameInput = document.getElementById('bandPresetNameInput');
        const select = document.getElementById('bandPresetSelect');
        
        if(select && select.value){
          // Use existing preset
          const preset = bandPresets.find(bp => bp.id == select.value);
          if(preset){
            gig.band = preset.name;
            currentBandPresetId = preset.id;
          }
        } else if(nameInput && nameInput.value.trim()){
          // Create new preset
          const newName = nameInput.value.trim();
          gig.band = newName;
          const newPreset = {
            id: Date.now(),
            name: newName,
            defaultStage: '',
            logo: ''
          };
          bandPresets.push(newPreset);
          currentBandPresetId = newPreset.id;
        } else {
          alert('Please enter a band name or select an existing band.');
          return;
        }
        
        // Update UI and save
        const sheetBandEl = document.querySelector('.header .band');
        if(sheetBandEl) sheetBandEl.textContent = gig.band;
        const calBandInput = document.getElementById('tourBand');
        if(calBandInput) calBandInput.value = gig.band;
        // Update current tour date's band
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(tourDate) tourDate.band = gig.band;
        saveAll();
        if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
        if(typeof updateActDisplay === 'function') updateActDisplay();
        if(typeof refreshStageHeader === 'function') refreshStageHeader();
        modal.remove(); // Remove modal from DOM completely
        try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
      }
      
      // Event listeners - use both click and touchend for mobile compatibility
      const saveBtn = document.getElementById('bandPresetSave');
      const skipBtn = document.getElementById('bandPresetSkip');
      
      function handleSave(e){
        e.preventDefault();
        e.stopPropagation();
        saveBandPreset();
      }
      
      function handleSkip(e){
        e.preventDefault();
        e.stopPropagation();
        modal.remove();
      }
      
      saveBtn.addEventListener('click', handleSave);
      saveBtn.addEventListener('touchend', handleSave);
      skipBtn.addEventListener('click', handleSkip);
      skipBtn.addEventListener('touchend', handleSkip);
      
      // Prevent ghost clicks on touch
      saveBtn.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive: true});
      skipBtn.addEventListener('touchstart', (e)=>{ e.stopPropagation(); }, {passive: true});
      
      // Enter key to save
      const nameInput = document.getElementById('bandPresetNameInput');
      if(nameInput){
        nameInput.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){
            e.preventDefault();
            saveBandPreset();
          }
        });
      }
      
      // If existing band selected, populate name field
      const selectEl = document.getElementById('bandPresetSelect');
      if(selectEl){
        selectEl.addEventListener('change', ()=>{
          if(selectEl.value){
            const preset = bandPresets.find(bp => bp.id == selectEl.value);
            if(preset && nameInput) nameInput.value = preset.name;
          }
        });
      }
      
      // Show modal and focus input
      setTimeout(()=>{ 
        if(nameInput) nameInput.focus(); 
      }, 150);
    }
    
    // Function to add/manage band presets (can be called from UI)
    function openBandPresetManager(){
      showBandPresetModal();
    }
    
    // Band Preset Manager Modal - for editing/deleting presets
    function showBandPresetManagerModal(){
      let modal = document.getElementById('bandPresetManagerModal');
      if(modal) modal.remove(); // Always rebuild to refresh list
      
      modal = document.createElement('div');
      modal.id = 'bandPresetManagerModal';
      modal.className = 'modal open';
      modal.style.zIndex = '9999';
      modal.innerHTML = `
        <div class="modalbox" style="background:white;border-radius:12px;padding:24px;width:450px;max-width:90vw;box-shadow:0 10px 40px rgba(0,0,0,0.3);max-height:80vh;overflow-y:auto;margin-top:60px">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
            <h2 style="margin:0;font-size:18px;font-weight:600">üé∏ Manage Band Presets</h2>
            <button id="bandPresetManagerClose" style="background:none;border:none;font-size:18px;cursor:pointer">‚úï</button>
          </div>
          
          <p style="margin:0 0 16px;color:#666;font-size:13px">Switch between bands for multi-artist management. Each band can have its own setlists and stage plots on your calendar.</p>
          
          <div id="bandPresetList" style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px">
            ${bandPresets.length === 0 ? '<div style="color:#888;font-size:12px;text-align:center;padding:16px">No band presets saved yet</div>' : 
              bandPresets.map(bp => `
                <div class="band-preset-item" data-id="${bp.id}" style="display:flex;align-items:center;gap:8px;padding:10px;border:1px solid #e5e7eb;border-radius:6px;${currentBandPresetId === bp.id ? 'background:#e0f2fe;border-color:#0ea5e9' : 'background:#f9fafb'}">
                  <span style="flex:1;font-weight:500">${bp.name}</span>
                  <button class="band-preset-use btn primary" data-id="${bp.id}" style="padding:4px 10px;font-size:11px">Use</button>
                  <button class="band-preset-delete btn danger" data-id="${bp.id}" style="padding:4px 8px;font-size:11px">üóëÔ∏è</button>
                </div>
              `).join('')}
          </div>
          
          <div style="border-top:1px solid #e5e7eb;padding-top:16px">
            <label style="display:block;font-size:12px;font-weight:600;margin-bottom:4px">Add New Band</label>
            <div style="display:flex;gap:8px">
              <input type="text" id="newBandPresetName" placeholder="Band name" style="flex:1;padding:8px;border:1px solid #d1d5db;border-radius:6px;font-size:13px" />
              <button id="addNewBandPreset" class="btn primary" style="padding:8px 16px;font-size:12px">Add</button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('bandPresetManagerClose').addEventListener('click', ()=>{
        modal.classList.remove('open');
      });
      
      // Use band buttons
      modal.querySelectorAll('.band-preset-use').forEach(btn => {
        btn.addEventListener('click', ()=>{
          const id = parseInt(btn.dataset.id);
          const preset = bandPresets.find(bp => bp.id === id);
          if(preset){
            gig.band = preset.name;
            currentBandPresetId = preset.id;
            const tourBandInput = document.getElementById('tourBand');
            if(tourBandInput) tourBandInput.value = preset.name;
            const sheetBandEl = document.querySelector('.header .band');
            if(sheetBandEl) sheetBandEl.textContent = preset.name;
            const tourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(tourDate) tourDate.band = preset.name;
            saveAll();
            // Refresh dropdown and act display
            if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
            if(typeof updateActDisplay === 'function') updateActDisplay();
            // Refresh stage header with new band
            try{ if(typeof refreshStageHeader === 'function') refreshStageHeader(); }catch(_){}
            modal.classList.remove('open');
            try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
          }
        });
      });
      
      // Delete band buttons
      modal.querySelectorAll('.band-preset-delete').forEach(btn => {
        btn.addEventListener('click', ()=>{
          const id = parseInt(btn.dataset.id);
          const preset = bandPresets.find(bp => bp.id === id);
          if(!preset) return;
          if(!confirm(`Delete band preset "${preset.name}"?`)) return;
          bandPresets = bandPresets.filter(bp => bp.id !== id);
          if(currentBandPresetId === id) currentBandPresetId = null;
          saveAll();
          if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
          showBandPresetManagerModal(); // Refresh
        });
      });
      
      // Add new band
      document.getElementById('addNewBandPreset').addEventListener('click', ()=>{
        const input = document.getElementById('newBandPresetName');
        const name = input?.value?.trim();
        if(!name){
          alert('Enter a band name');
          return;
        }
        if(bandPresets.find(bp => bp.name.toLowerCase() === name.toLowerCase())){
          alert(`"${name}" already exists`);
          return;
        }
        const newPreset = { id: Date.now(), name, defaultStage: '', logo: '' };
        bandPresets.push(newPreset);
        saveAll();
        if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
        showBandPresetManagerModal(); // Refresh
      });
      
      modal.classList.add('open');
    }

    // Add new song inline at top of database
    function addNewSongRow(){
      const newSong = {
        id: Date.now(),
        title: '',
        artist: 'Original',
        length: 3.5,
        key: '',
        capo: 0,
        bpm: 0,
        lyrics: '',
        audienceRating: 2,
        usageCount: 0,
        isCover: false,
        isUpbeat: false,
        isHappy: false,
        isMellow: false,
        isEnergetic: false,
        isSad: false,
        customMoods: []
      };
      db.unshift(newSong); // Add to start of array
      renderDB();
      saveAll();
      // Focus the title field of the new row
      setTimeout(() => {
        const list = document.getElementById('dbList');
        if(list) {
          const firstRow = list.querySelector('.db-row');
          if(firstRow) {
            const titleInput = firstRow.querySelector('input[placeholder="Title"]');
            if(titleInput) titleInput.focus();
          }
        }
      }, 50);
    }

    // DB Column configuration - persisted widths and order
    if(!gig.dbColumns){
      gig.dbColumns={
        order:['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'],
        widths:{add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120}
      };
    }

    function renderDB(){
      const list=$('#dbList'); list.innerHTML='';
      if(!db.length){ list.textContent='No songs yet.'; return; }
      
      // Ensure dbColumns exists (may have been lost during date switch)
      if(!gig.dbColumns){
        gig.dbColumns={
          order:['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'],
          widths:{add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120}
        };
      }
      
      // Column headers with resizing and reordering
      const hdrRow=document.createElement('div'); hdrRow.style.cssText='display:flex;gap:4px;align-items:center;padding:4px;background:#f3f4f6;font-weight:600;font-size:11px;border-bottom:2px solid #d1d5db;position:relative';
      
      const colOrder = gig.dbColumns.order || ['add','cover','title','artist','len','key','capo','bpm','mood','lyrics','audio','rating','actions'];
      const colWidths = gig.dbColumns.widths || {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
      const hiddenCols = gig.dbColumns.hidden || [];
      if(!gig.customColumns) gig.customColumns = [];
      
      const colDefs = {
        add: {text:'', isButton:true, sortKey:null},
        cover: {text:'Cover', sortKey:'cover'},
        title: {text:'Title', sortKey:'alpha'},
        artist: {text:'Artist', sortKey:'band'},
        len: {text:'Len', sortKey:'length'},
        key: {text:'Key', sortKey:'key'},
        capo: {text:'Capo', sortKey:'capo'},
        bpm: {text:'BPM', sortKey:'bpm'},
        mood: {text:'Moods', sortKey:'mood'},
        lyrics: {text:'Lyrics / Preview', sortKey:null, flex:true},
        audio: {text:'Audio / URL', sortKey:null, flex:true},
        rating: {text:'Rate', sortKey:'rating'},
        actions: {text:'', sortKey:null}
      };
      // Add custom columns to definitions
      gig.customColumns.forEach(cc=>{
        colDefs[cc.key] = {text:cc.name, sortKey:null, isCustom:true};
        if(!colWidths[cc.key]) colWidths[cc.key] = 100;
      });
      
      colOrder.forEach((colKey,colIndex)=>{
        const def = colDefs[colKey];
        if(!def || hiddenCols.includes(colKey)) return;
        const width = colWidths[colKey] || 100;
        
        const hdr = document.createElement('div');
        hdr.dataset.colKey = colKey;
        hdr.style.cssText = `position:relative;flex-shrink:0;text-align:center;cursor:${def.sortKey?'pointer':'default'};user-select:none;${def.flex?`flex:1 1 auto;min-width:${width}px;max-width:${width+100}px`:`width:${width}px`}`;
        
        // Add button special case
        if(colKey==='add'){
          const addBtn=document.createElement('button'); 
          addBtn.textContent='+'; 
          addBtn.type='button'; 
          addBtn.title='Add new song'; 
          addBtn.style.cssText='width:24px;height:24px;border:2px solid #374151;border-radius:4px;background:#fff;color:#374151;font-size:18px;font-weight:bold;cursor:pointer;display:flex;align-items:center;justify-content:center;padding:0';
          addBtn.addEventListener('click', addNewSongRow);
          hdr.appendChild(addBtn);
        } else {
          hdr.textContent = def.text;
        }
        
        // Triple-click to restore default width
        let clickCount = 0;
        let clickTimer = null;
        hdr.addEventListener('click', (e)=>{
          if(e.target.style.cursor==='col-resize' || e.target.classList.contains('resizer')) return;
          clickCount++;
          if(clickTimer) clearTimeout(clickTimer);
          if(clickCount === 3){
            // Triple click - restore default width
            const defaultWidths = {add:24,cover:18,title:150,artist:150,len:50,key:50,capo:35,bpm:50,mood:28,lyrics:250,audio:250,rating:60,actions:120};
            if(defaultWidths[colKey]){
              colWidths[colKey] = defaultWidths[colKey];
              saveAll();
              renderDB();
            }
            clickCount = 0;
          } else if(clickCount === 2 && def.sortKey){
            // Double-click to sort
            const sortSel = document.getElementById('dbSort');
            if(sortSel){ sortSel.value = def.sortKey; renderDB(); }
            clickCount = 0;
          } else {
            clickTimer = setTimeout(()=>{ clickCount = 0; }, 500);
          }
        });
        hdr.title = (def.sortKey ? 'Double-click to sort by ' + def.text + ', ' : '') + 'Triple-click to restore default width';
        
        // Column reorder by dragging header (long-hold for touch)
        if(!def.isButton){
          let dragTimer = null;
          let isDraggingCol = false;
          let startY = 0;
          let startX = 0;
          let currentY = 0;
          let hasDraggedUp = false;
          const startColDrag = (clientY, clientX)=>{
            if(dragTimer) return;
            startY = clientY;
            startX = clientX;
            currentY = clientY;
            hasDraggedUp = false;
            dragTimer = setTimeout(()=>{
              isDraggingCol = true;
              hdr.style.opacity = '0.5';
              hdr.style.cursor = 'move';
            }, 400);
          };
          const trackMove = (clientY, clientX)=>{
            if(!isDraggingCol && !dragTimer) return;
            currentY = clientY;
            const deltaY = startY - currentY; // positive = dragging up
            const deltaX = Math.abs(startX - clientX);
            // If dragged up 50px or more, mark for hide
            if(deltaY >= 50 && deltaX < 30){
              hasDraggedUp = true;
              hdr.style.opacity = '0.3';
              hdr.style.transform = 'translateY(-10px)';
            }
          };
          const endColDrag = ()=>{
            if(dragTimer){ clearTimeout(dragTimer); dragTimer=null; }
            hdr.style.transform = '';
            if(isDraggingCol){
              hdr.style.opacity = '';
              hdr.style.cursor = '';
              isDraggingCol = false;
            }
            // Hide column if dragged up 50px
            if(hasDraggedUp){
              if(!gig.dbColumns.hidden) gig.dbColumns.hidden = [];
              if(!gig.dbColumns.hidden.includes(colKey)){
                gig.dbColumns.hidden.push(colKey);
                saveAll();
                renderDB();
              }
            }
            startY = 0;
            startX = 0;
            currentY = 0;
            hasDraggedUp = false;
          };
          
          // Mouse drag tracking
          hdr.addEventListener('mousedown',(e)=>{
            if(e.target.style.cursor==='col-resize') return; // Don't interfere with resize
            startColDrag(e.clientY, e.clientX);
            const onMouseMove = (e2)=>{
              trackMove(e2.clientY, e2.clientX);
            };
            const onMouseUp = ()=>{
              document.removeEventListener('mousemove', onMouseMove);
              document.removeEventListener('mouseup', onMouseUp);
              endColDrag();
            };
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
          });
          
          // Touch drag tracking
          hdr.addEventListener('touchstart',(e)=>{
            const touch = e.touches[0];
            if(touch) startColDrag(touch.clientY, touch.clientX);
            const onTouchMove = (e2)=>{
              const t = e2.touches[0];
              if(t) trackMove(t.clientY, t.clientX);
            };
            const onTouchEnd = ()=>{
              document.removeEventListener('touchmove', onTouchMove);
              document.removeEventListener('touchend', onTouchEnd);
              endColDrag();
            };
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd);
          });
          
          // Drag events for reordering columns
          hdr.setAttribute('draggable', true);
          hdr.addEventListener('dragstart',(e)=>{
            if(!isDraggingCol) return e.preventDefault();
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', colKey);
            hdr.style.opacity = '0.4';
          });
          hdr.addEventListener('dragend',(e)=>{
            hdr.style.opacity = '';
            isDraggingCol = false;
          });
          hdr.addEventListener('dragover',(e)=>{
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
          });
          hdr.addEventListener('drop',(e)=>{
            e.preventDefault();
            const draggedKey = e.dataTransfer.getData('text/plain');
            if(!draggedKey || draggedKey===colKey) return;
            const fromIndex = colOrder.indexOf(draggedKey);
            const toIndex = colOrder.indexOf(colKey);
            if(fromIndex===-1 || toIndex===-1) return;
            // Reorder array
            colOrder.splice(fromIndex, 1);
            colOrder.splice(toIndex, 0, draggedKey);
            gig.dbColumns.order = colOrder;
            saveAll();
            renderDB();
          });
        }
        
        // Resizer handle (right edge)
        if(!def.isButton && colKey!=='actions'){
          const resizer = document.createElement('div');
          resizer.style.cssText='position:absolute;right:-6px;top:-8px;bottom:-8px;width:12px;cursor:col-resize;z-index:10;background:rgba(209,213,219,0.5);touch-action:none';resizer.title='Drag to resize';
          resizer.classList.add('resizer');
          
          // Mouse resize
          resizer.addEventListener('mousedown',(e)=>{
            e.stopPropagation();
            const startX = e.clientX;
            const startWidth = width;
            const onMove = (e2)=>{
              const delta = e2.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              saveAll();
              renderDB();
            };
            const onUp = ()=>{
              document.removeEventListener('mousemove', onMove);
              document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
          });
          
          // Touch resize
          resizer.addEventListener('touchstart',(e)=>{
            e.preventDefault();
            e.stopPropagation();
            const touch = e.touches[0];
            if(!touch) return;
            const startX = touch.clientX;
            const startWidth = width;
            let isResizing = true;
            const onMove = (e2)=>{
              e2.preventDefault();
              if(!isResizing) return;
              const t = e2.touches[0];
              if(!t) return;
              const delta = t.clientX - startX;
              const newWidth = Math.max(20, startWidth + delta);
              colWidths[colKey] = newWidth;
              hdr.style.width = newWidth + 'px';
            };
            const onUp = ()=>{
              isResizing = false;
              document.removeEventListener('touchmove', onMove, {passive:false});
              document.removeEventListener('touchend', onUp);
              document.removeEventListener('touchcancel', onUp);
              saveAll();
              renderDB();
            };
            document.addEventListener('touchmove', onMove, {passive:false});
            document.addEventListener('touchend', onUp);
            document.addEventListener('touchcancel', onUp);
          });
          
          hdr.appendChild(resizer);
        }
        
        hdrRow.appendChild(hdr);
      });
      
      // Hidden Columns eye emoji button on header row
      if(hiddenCols.length > 0){
        const eyeHdr = document.createElement('div');
        eyeHdr.style.cssText = 'position:relative;flex-shrink:0;width:40px;text-align:center;cursor:pointer;user-select:none';
        const restoreBtn = document.createElement('button');
        restoreBtn.textContent = 'üëÄ';
        restoreBtn.type = 'button';
        restoreBtn.title = `${hiddenCols.length} hidden column${hiddenCols.length>1?'s':''}`;
        restoreBtn.style.cssText = 'padding:2px 4px;border:none;background:transparent;font-size:20px;cursor:pointer;position:relative';
        const popup = document.createElement('div');
        popup.style.cssText = 'display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:240px;top:100%;right:0;margin-top:2px';
        hiddenCols.forEach(colKey=>{
          const def = colDefs[colKey];
          if(!def) return;
          const rowDiv = document.createElement('div');
          rowDiv.style.cssText = 'display:flex;align-items:center;gap:6px;margin:2px 0';
          const showBtn = document.createElement('button');
          showBtn.textContent = `Show ${def.text || colKey}`;
          showBtn.type = 'button';
          showBtn.style.cssText = 'flex:1;padding:4px 8px;border:1px solid #d1d5db;border-radius:3px;background:#f9fafb;cursor:pointer;text-align:left;font-size:12px';
          showBtn.addEventListener('click', (e)=>{
            e.stopPropagation();
            const idx = hiddenCols.indexOf(colKey);
            if(idx > -1){
              hiddenCols.splice(idx, 1);
              gig.dbColumns.hidden = hiddenCols;
              saveAll();
              renderDB();
            }
          });
          // Only show delete checkbox for custom columns
          const isCustom = def.isCustom || (gig.customColumns && gig.customColumns.find(c => c.key === colKey));
          if(isCustom){
            const delChk = document.createElement('input');
            delChk.type = 'checkbox';
            delChk.title = 'Delete column permanently';
            delChk.style.cssText = 'width:16px;height:16px;cursor:pointer';
            const delLbl = document.createElement('label');
            delLbl.textContent = 'üóëÔ∏è';
            delLbl.title = 'Delete permanently';
            delLbl.style.cssText = 'cursor:pointer;font-size:14px';
            delChk.addEventListener('change', ()=>{
              if(delChk.checked && confirm(`Permanently delete custom column "${def.text || colKey}"? This will remove all data in this column from all songs.`)){
                // Remove from hidden columns
                const hiddenIdx = hiddenCols.indexOf(colKey);
                if(hiddenIdx > -1){
                  hiddenCols.splice(hiddenIdx, 1);
                  gig.dbColumns.hidden = hiddenCols;
                }
                // Remove from column order
                const orderIdx = gig.dbColumns.order.indexOf(colKey);
                if(orderIdx > -1){
                  gig.dbColumns.order.splice(orderIdx, 1);
                }
                // Remove from custom columns
                if(gig.customColumns){
                  const customIdx = gig.customColumns.findIndex(c => c.key === colKey);
                  if(customIdx > -1){
                    gig.customColumns.splice(customIdx, 1);
                  }
                }
                // Remove column width
                if(gig.dbColumns.widths && gig.dbColumns.widths[colKey]){
                  delete gig.dbColumns.widths[colKey];
                }
                // Remove data from all songs
                db.forEach(song => {
                  if(song.customFields && song.customFields[colKey]){
                    delete song.customFields[colKey];
                  }
                });
                saveAll();
                renderDB();
              } else {
                delChk.checked = false;
              }
            });
            rowDiv.append(showBtn, delChk, delLbl);
          } else {
            rowDiv.appendChild(showBtn);
          }
          popup.appendChild(rowDiv);
        });
        restoreBtn.addEventListener('mouseenter', ()=>{ popup.style.display = 'block'; });
        restoreBtn.addEventListener('mouseleave', ()=>{ popup.style.display = 'none'; });
        restoreBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); popup.style.display = popup.style.display==='block'?'none':'block'; });
        popup.addEventListener('click', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchstart', (e)=>{ e.stopPropagation(); });
        popup.addEventListener('touchend', (e)=>{ e.stopPropagation(); });
        restoreBtn.appendChild(popup);
        eyeHdr.appendChild(restoreBtn);
        hdrRow.appendChild(eyeHdr);
      }
      
      list.appendChild(hdrRow);
      // Filters / sort
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const sortVal=(sSel&&sSel.value)||'alpha';
      const searchTerm=(searchInput&&searchInput.value)||'';
      const filterCovers=document.getElementById('filterCovers')?.checked;
      const filterOriginals=document.getElementById('filterOriginals')?.checked;
      const filterHasLyrics=document.getElementById('filterHasLyrics')?.checked;
      const filterKaraoke=document.getElementById('filterKaraoke')?.checked;
      const filterHasAudio=document.getElementById('filterHasAudio')?.checked;
      const filterHasURL=document.getElementById('filterHasURL')?.checked;
      const filterInSet=document.getElementById('filterInSet')?.checked;
      const filterUpbeat=document.getElementById('filterUpbeat')?.checked;
      const filterHappy=document.getElementById('filterHappy')?.checked;
      const filterEnergetic=document.getElementById('filterEnergetic')?.checked;
      const filterMellow=document.getElementById('filterMellow')?.checked;
      const filterSad=document.getElementById('filterSad')?.checked;
      const used=(arr)=>arr.filter(Boolean);
      const hasMood=(song, key)=>{
        if(DEFAULT_MOODS.includes(key)){
          return (key==='upbeat'&&song.isUpbeat) || (key==='happy'&&song.isHappy) || (key==='energetic'&&song.isEnergetic) || (key==='mellow'&&song.isMellow) || (key==='sad'&&song.isSad);
        }
        const cm = song.customMoods||[]; return cm.includes(key);
      };
      const songMood=(song)=>{
        if(song.isUpbeat) return 'upbeat'; if(song.isHappy) return 'happy'; if(song.isEnergetic) return 'energetic'; if(song.isMellow) return 'mellow'; if(song.isSad) return 'sad';
        const cm=(song.customMoods||[])[0]; return cm||'none';
      };
      const rankMap={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:99};
      getAllMoods().forEach((m,i)=>{ if(!(m in rankMap)) rankMap[m]=50+i; });
      let rows=db.slice();
      if(filterCovers) rows = rows.filter(s=> s.isCover);
      if(filterOriginals) rows = rows.filter(s=> !s.isCover);
      if(filterHasLyrics) rows = rows.filter(s=> (s.lyrics||'').trim().length>0);
      if(filterKaraoke) rows = rows.filter(s=> (s.lyrics||'').toLowerCase().includes('karaoke'));
      if(filterHasAudio) rows = rows.filter(s=> (s.audioFileName||'').length>0 || (armedAudio[s.id]));
      if(filterHasURL) rows = rows.filter(s=> (s.audioUrl||'').trim().length>0);
      if(filterInSet) rows = rows.filter(s=> setlist.some(x=>x.id===s.id));
      if(filterUpbeat) rows = rows.filter(s=> s.isUpbeat);
      if(filterHappy) rows = rows.filter(s=> s.isHappy);
      if(filterEnergetic) rows = rows.filter(s=> s.isEnergetic);
      if(filterMellow) rows = rows.filter(s=> s.isMellow);
      if(filterSad) rows = rows.filter(s=> s.isSad);
      if(searchTerm){
        try{
          const regex = new RegExp(searchTerm, 'i');
          rows = rows.filter(s=> regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||''));
        }catch(e){ rows = rows.filter(s=> (s.title||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.artist||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.composer||'').toLowerCase().includes(searchTerm.toLowerCase()) || (s.lyrics||'').toLowerCase().includes(searchTerm.toLowerCase())); }
      }
      const byAdded=(a,b)=> a.id - b.id;
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (rankMap[songMood(a)] - rankMap[songMood(b)]) || a.title.localeCompare(b.title);
      const byRating=(a,b)=> (b.audienceRating||0) - (a.audienceRating||0) || a.title.localeCompare(b.title);
      const byMostUsed=(a,b)=> (b.usageCount||0) - (a.usageCount||0) || a.title.localeCompare(b.title);
      const byLeastUsed=(a,b)=> (a.usageCount||0) - (b.usageCount||0) || a.title.localeCompare(b.title);
      const sorter = sortVal==='added'? byAdded : sortVal==='band'? byBand : sortVal==='mood'? byMood : sortVal==='rating'? byRating : sortVal==='mostUsed'? byMostUsed : sortVal==='leastUsed'? byLeastUsed : byAlpha;
      rows.sort(sorter);
      rows.forEach(s=>{
        const row=document.createElement('div'); row.className='db-row'; row.style.display='flex'; row.style.gap='4px'; row.style.alignItems='center'; row.style.padding='4px'; row.style.border='1px solid #e5e7eb'; row.style.borderRadius='4px'; row.style.margin='4px 0';
        
        // Cover checkbox
        const coverChk=document.createElement('input'); coverChk.type='checkbox'; coverChk.checked=!!s.isCover; coverChk.title='Cover song'; coverChk.style.cssText='width:18px;height:18px;margin:0;cursor:pointer';
        coverChk.addEventListener('change',()=>{ 
          s.isCover=!!coverChk.checked; 
          if(!s.isCover){ s.artist='Original'; artist.value=''; artist.disabled=true; artist.style.opacity='0.5'; } 
          else { artist.disabled=false; artist.style.opacity='1'; } 
          saveAll(); renderSongPool(); 
        });
        
        // Title (reduced width)
        const title=document.createElement('input'); title.value=s.title||''; title.placeholder='Title'; title.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px';
        title.addEventListener('change',()=>{ s.title=title.value.trim()||s.title; saveAll(); buildSheet('sheetInline'); renderSongPool(); });
        
        // Artist (reduced width)
        const artist=document.createElement('input'); artist.placeholder='Artist'; artist.value=(s.isCover? (s.artist||'') : ''); artist.style.cssText='width:120px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px;opacity:'+(s.isCover?'1':'0.5'); artist.disabled=!s.isCover;
        artist.addEventListener('change',()=>{ s.artist = coverChk.checked ? (artist.value.trim()||s.artist||'') : 'Original'; saveAll(); });
        
        // Length (5 chars width)
        const len=document.createElement('input'); len.type='number'; len.step='0.5'; len.min='0.5'; len.value=String(s.length||3.5); len.title='Length (min)'; len.style.cssText='width:58px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center;color:#0f172a';
        len.addEventListener('change',()=>{ const v=parseFloat(len.value); if(v>0) s.length=v; saveAll(); buildSheet('sheetInline'); });
        
        // Key (3 chars width)
        const key=document.createElement('input'); key.placeholder='Key'; key.value=s.key||''; key.style.cssText='width:35px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        key.addEventListener('change',()=>{ s.key=key.value.trim(); saveAll(); buildSheet('sheetInline'); });
        
        // Capo (2 chars width)
        const capo=document.createElement('input'); capo.type='number'; capo.min='0'; capo.max='24'; capo.value=String(Number.isInteger(s.capo)? s.capo : 0); capo.title='Capo'; capo.style.cssText='width:30px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        capo.addEventListener('change',()=>{ let v=parseInt(capo.value,10); if(!Number.isInteger(v) || v<0) v=0; if(v>24) v=24; s.capo=v; capo.value=String(v); saveAll(); buildSheet('sheetInline'); });
        
        // BPM
        const bpm=document.createElement('input'); bpm.type='number'; bpm.min='30'; bpm.max='300'; bpm.value=String(Number.isInteger(s.bpm) && s.bpm>0 ? s.bpm : ''); bpm.placeholder='BPM'; bpm.title='Beats per minute'; bpm.style.cssText='width:40px;padding:2px 3px;border:1px solid #d1d5db;border-radius:3px;font-size:12px;text-align:center';
        bpm.addEventListener('change',()=>{ let v=parseInt(bpm.value,10); if(!Number.isInteger(v) || v<30) v=0; if(v>300) v=300; s.bpm=v||0; bpm.value=v>0?String(v):''; saveAll(); buildSheet('sheetInline'); });
        
        // Custom columns rendering
        const customColInputs = {};
        gig.customColumns.forEach(cc=>{
          const custInput = document.createElement('input');
          custInput.placeholder = cc.name;
          if(!s.customFields) s.customFields = {};
          custInput.value = s.customFields[cc.key] || '';
          custInput.style.cssText = `width:${colWidths[cc.key]||100}px;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:13px`;
          custInput.addEventListener('change', ()=>{
            if(!s.customFields) s.customFields = {};
            s.customFields[cc.key] = custInput.value.trim();
            saveAll();
            buildSheet('sheetInline');
          });
          customColInputs[cc.key] = custInput;
        });
        
        // Mood submenu (hoverable)
        const moodEmojis = {upbeat:'‚ö°',happy:'üòä',energetic:'üî•',mellow:'üòå',sad:'üò¢'};
        let topMood = '';
        if(s.isUpbeat) topMood = '‚ö°';
        else if(s.isHappy) topMood = 'üòä';
        else if(s.isEnergetic) topMood = 'üî•';
        else if(s.isMellow) topMood = 'üòå';
        else if(s.isSad) topMood = 'üò¢';
        else if(s.customMoods && s.customMoods.length>0) topMood = 'üéµ';
        const moodBtn=document.createElement('button'); moodBtn.textContent=topMood||'‚ô´'; moodBtn.type='button'; moodBtn.title='Moods'; moodBtn.style.cssText='padding:2px 6px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;position:relative;font-size:14px;width:28px;height:24px';
        const moodMenu=document.createElement('div'); moodMenu.style.cssText='display:none;position:absolute;z-index:100;background:#fff;border:1px solid #d1d5db;border-radius:4px;padding:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);min-width:140px;top:100%;left:0;margin-top:2px;text-align:left';
        const moodChecks=['upbeat','happy','energetic','mellow','sad'].map(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=s['is'+m.charAt(0).toUpperCase()+m.slice(1)]; chk.addEventListener('change',()=>{ s['is'+m.charAt(0).toUpperCase()+m.slice(1)]=chk.checked; saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); return lbl; });
        moodChecks.forEach(c=>moodMenu.appendChild(c));
        // Add custom moods
        (gig.customMoods||[]).forEach(m=>{ const lbl=document.createElement('label'); lbl.style.cssText='display:block;margin:4px 0;white-space:nowrap;text-align:left'; const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=(s.customMoods||[]).includes(m); chk.addEventListener('change',()=>{ if(!s.customMoods) s.customMoods=[]; const idx=s.customMoods.indexOf(m); if(chk.checked && idx===-1){ s.customMoods.push(m); } else if(!chk.checked && idx>-1){ s.customMoods.splice(idx,1); } saveAll(); }); lbl.appendChild(chk); lbl.appendChild(document.createTextNode(' '+m.charAt(0).toUpperCase()+m.slice(1))); moodMenu.appendChild(lbl); });
        // Add "+ Add Mood" button at bottom of mood menu
        const addMoodDiv=document.createElement('div'); addMoodDiv.style.cssText='margin-top:8px;padding-top:8px;border-top:1px solid #e5e7eb';
        const addMoodBtn=document.createElement('button'); addMoodBtn.type='button'; addMoodBtn.textContent='+ Add Mood'; addMoodBtn.style.cssText='width:100%;padding:4px 8px;border:1px solid #d1d5db;border-radius:4px;background:#f9fafb;cursor:pointer;font-size:12px;font-weight:500;color:#0f172a';
        addMoodBtn.addEventListener('click',(e)=>{
          e.stopPropagation();
          const name = prompt('New mood name (max 16 chars).'); 
          if(name==null) return; 
          const n=name.trim(); 
          if(!n){ return; }
          const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
          const DEFAULT_MOODS=['upbeat','happy','energetic','mellow','sad'];
          const all=[...DEFAULT_MOODS,...(gig.customMoods||[])];
          if(all.length>=12){ alert('Max 12 moods reached.'); return; }
          if(all.includes(key)){ alert('Mood already exists.'); return; }
          gig.customMoods = gig.customMoods || []; 
          gig.customMoods.push(key);
          saveAll();
          // Re-render database to show new mood in all menus
          renderDB(); 
          renderSongPool();
          // Add custom mood filter checkbox
          const filterContainer=document.getElementById('customMoodFilters');
          if(filterContainer){
            const lbl=document.createElement('label');
            lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
            const chk=document.createElement('input');
            chk.type='checkbox';
            chk.id='filter-'+key;
            chk.addEventListener('change', renderDB);
            lbl.appendChild(chk);
            const moodLabel=(k)=>{const caps=k.split('-').map(w=>w.charAt(0).toUpperCase()+w.slice(1)).join(' '); return caps;};
            lbl.appendChild(document.createTextNode(moodLabel(key)));
            filterContainer.appendChild(lbl);
          }
        });
        addMoodDiv.appendChild(addMoodBtn);
        moodMenu.appendChild(addMoodDiv);
        moodBtn.appendChild(moodMenu);
        moodBtn.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodBtn.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        moodMenu.addEventListener('mouseenter',()=>{ moodMenu.style.display='block'; });
        moodMenu.addEventListener('mouseleave',()=>{ moodMenu.style.display='none'; });
        // Lyrics / chords quick edit (collapsed textarea)
        const lyricsWrap=document.createElement('div'); lyricsWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const lyrBtn=document.createElement('button'); lyrBtn.textContent='Lyrics'; lyrBtn.className='btn'; lyrBtn.type='button'; lyrBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0;background:#3b82f6;color:#f9fafb;border-color:#2563eb'; lyrBtn.title='Edit lyrics / chords for this song';
        const lyricsPreview=document.createElement('div'); lyricsPreview.style.cssText='font-size:10px;color:#64748b;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1 1 auto';
        const firstLine=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=firstLine? (firstLine.length>25? firstLine.substring(0,25)+'...' : firstLine) : '';
        lyricsWrap.append(lyrBtn,lyricsPreview);
        const lyrBox=document.createElement('textarea'); lyrBox.rows=3; lyrBox.style.width='100%'; lyrBox.style.marginTop='4px'; lyrBox.style.display='none'; lyrBox.placeholder='Lyrics / chords'; lyrBox.value=s.lyrics||'';
        lyrBtn.addEventListener('click',()=>{
          const showing = lyrBox.style.display!=='none';
          // If cover song with no lyrics, search for them
          if(!showing && s.isCover && (!s.lyrics || s.lyrics.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' ' + (s.artist||'') + ' lyrics chords');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          lyrBox.style.display = showing ? 'none' : 'block';
        });
        lyrBox.addEventListener('change',()=>{ s.lyrics=lyrBox.value; const fl=findFirstLyricLine(s.lyrics); lyricsPreview.textContent=fl? (fl.length>25? fl.substring(0,25)+'...' : fl) : ''; saveAll(); });
        // Audio attach / link with inline URL preview/edit
        const audioWrap=document.createElement('div'); audioWrap.style.cssText='display:flex;flex-direction:row;gap:6px;align-items:center;flex:1 1 auto;min-width:100px;max-width:180px';
        const audioBtn=document.createElement('button'); audioBtn.textContent='Audio'; audioBtn.className='btn'; audioBtn.type='button'; audioBtn.style.cssText='padding:2px 6px;font-size:10px;border-radius:3px;flex-shrink:0;background:#3b82f6;color:#f9fafb;border-color:#2563eb'; audioBtn.title='Attach MP3/WAV or link a URL (YouTube, Spotify, etc.)';
        const audioInline=document.createElement('input'); audioInline.type='url'; audioInline.placeholder='URL or file path...'; audioInline.value=s.audioUrl||s.audioFileName||''; audioInline.style.cssText='flex:1 1 auto;padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;font-size:10px';
        audioInline.addEventListener('change',()=>{ s.audioUrl=audioInline.value.trim(); saveAll(); });
        audioWrap.append(audioBtn,audioInline);
        const audioBox=document.createElement('div'); audioBox.style.display='none'; audioBox.style.width='100%'; audioBox.style.marginTop='4px'; audioBox.style.padding='8px'; audioBox.style.border='1px solid #e5e7eb'; audioBox.style.borderRadius='6px';
        const audioUrlIn=document.createElement('input'); audioUrlIn.type='url'; audioUrlIn.placeholder='https:// link to audio, YouTube, or Spotify'; audioUrlIn.style.width='60%'; audioUrlIn.value = s.audioUrl||'';
        const saveUrlBtn=document.createElement('button'); saveUrlBtn.className='btn'; saveUrlBtn.textContent='Save URL'; saveUrlBtn.type='button'; saveUrlBtn.style.marginLeft='8px';
        const fileIn=document.createElement('input'); fileIn.type='file'; fileIn.accept='audio/*'; fileIn.style.marginLeft='12px'; fileIn.title='Choose local audio file (session only)';
        const fileRefIn=document.createElement('input'); fileRefIn.type='text'; fileRefIn.placeholder='Preferred filename for Arm All (e.g., 01 - Imagine.mp3)'; fileRefIn.style.marginLeft='12px'; fileRefIn.style.flex='1 1 220px'; fileRefIn.value = s.audioFileName||'';
        const saveRefBtn=document.createElement('button'); saveRefBtn.className='btn'; saveRefBtn.textContent='Save File Ref'; saveRefBtn.type='button';
        const infoSpan=document.createElement('span'); infoSpan.style.marginLeft='8px'; infoSpan.style.fontSize='12px'; infoSpan.style.color='#64748b';
        const clearBtn=document.createElement('button'); clearBtn.className='btn danger'; clearBtn.textContent='Remove Audio'; clearBtn.type='button'; clearBtn.style.marginLeft='auto';
        const rowCtl=document.createElement('div'); rowCtl.style.display='flex'; rowCtl.style.alignItems='center'; rowCtl.style.gap='8px';
        rowCtl.append(audioUrlIn, saveUrlBtn, fileIn, fileRefIn, saveRefBtn, clearBtn, infoSpan);
        audioBox.append(rowCtl);
        audioBtn.addEventListener('click',()=>{ 
          const showing = audioBox.style.display!=='none';
          if(!showing && s.isCover && (!s.audioUrl || s.audioUrl.trim().length===0)){
            const query = encodeURIComponent((s.title||'') + ' by ' + (s.artist||'') + ' Karaoke Backing Track');
            window.open('https://www.google.com/search?q='+query, '_blank', 'width=900,height=700');
          }
          audioBox.style.display = showing ? 'none' : 'block'; 
        });
        function updateAudioInfo(){
          const armed = (s.id!=null && armedAudio[s.id]);
          if(armed){ infoSpan.textContent = 'Armed file (session)'; return; }
          const linked = (s.audioUrl && s.audioUrl.trim());
          infoSpan.textContent = linked ? ('Linked: '+(s.audioUrl||'')) : '(no audio)';
        }
        updateAudioInfo();
        saveUrlBtn.addEventListener('click',()=>{ const v=(audioUrlIn.value||'').trim(); s.audioUrl = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved audio URL.' : 'Audio URL cleared.'); });
        saveRefBtn.addEventListener('click',()=>{ const v=(fileRefIn.value||'').trim(); s.audioFileName = v || ''; saveAll(); updateAudioInfo(); alert(v? 'Saved file reference.' : 'File reference cleared.'); });
        clearBtn.addEventListener('click',()=>{ s.audioUrl=''; if(s.id!=null && armedAudio[s.id]){ try{ URL.revokeObjectURL(armedAudio[s.id]); }catch(_){} delete armedAudio[s.id]; } updateAudioInfo(); saveAll(); });
        fileIn.addEventListener('change',()=>{
          const f=fileIn.files && fileIn.files[0]; if(!f || s.id==null) return;
          try{ if(armedAudio[s.id]){ URL.revokeObjectURL(armedAudio[s.id]); } }catch(_){ }
          const objUrl = URL.createObjectURL(f);
          armedAudio[s.id] = objUrl;
          s.audioName = f.name||'audio'; s.audioFileName = f.name||s.audioFileName||'';
          // do not embed or persist the file; session only
          updateAudioInfo();
          alert('Audio armed for this session: '+(s.title||'song'));
        });
        
        // Audience rating (0-3: thumbs down, sideways, up, double up) - click to cycle, default 2
        if(s.audienceRating===undefined || s.audienceRating===null) s.audienceRating=2;
        const rating = s.audienceRating;
        const ratingIcons = ['üëé','üëà','üëç','üëç‚Ääüëç'];
        const ratingBtn=document.createElement('button'); ratingBtn.type='button'; ratingBtn.textContent=ratingIcons[rating]; ratingBtn.style.cssText='padding:2px 4px;border:1px solid #d1d5db;border-radius:3px;background:#fff;cursor:pointer;font-size:14px;min-width:32px;height:24px'; ratingBtn.title='Rating: '+rating+' (click to cycle)';
        ratingBtn.addEventListener('click',()=>{ s.audienceRating=((s.audienceRating||0)+1)%4; saveAll(); renderDB(); });
        
        const toSetBtn=document.createElement('button'); toSetBtn.className='btn'; toSetBtn.textContent='To Set'; toSetBtn.style.cssText='margin-left:auto;padding:2px 8px;font-size:11px;border-radius:3px;min-width:56px;background:#065f46;border-color:#064e3b;color:#f9fafb'; toSetBtn.title='Add this song to the end of the current setlist';
        toSetBtn.addEventListener('click',()=>{ 
          if(setlist.some(x=>x.type==='song' && x.id===s.id)){ 
            alert('Song already in setlist.'); 
            return; 
          } 
          setlist.push({...s,type:'song',notes:''}); 
          currentDateDirty = true;
          saveAll(); 
          buildSheet('sheetInline'); 
          attachPreviewInteractions();
          renderSongPool(); 
          alert('Added "'+s.title+'" to setlist.'); 
        });
        const del=document.createElement('button'); del.className='btn danger'; del.textContent='Del'; del.style.cssText='padding:2px 8px;font-size:11px;border-radius:3px;min-width:50px;background:#dc2626;border-color:#b91c1c;color:#f9fafb'; del.addEventListener('click',()=>{ const i=db.findIndex(x=>x.id===s.id); if(i>-1){ db.splice(i,1); renderDB(); renderSongPool(); saveAll(); } });
        
        // Append in column order, applying widths
        const cellMap = {
          add: (() => {
            const addPlaceholder = document.createElement('div');
            addPlaceholder.style.cssText='width:24px;height:24px;flex-shrink:0';
            return addPlaceholder;
          })(),
          cover: coverChk,
          title: title,
          artist: artist,
          len: len,
          key: key,
          capo: capo,
          bpm: bpm,
          mood: moodBtn,
          lyrics: lyricsWrap,
          audio: audioWrap,
          rating: ratingBtn,
          actions: (() => {
            const actionsWrap = document.createElement('div');
            actionsWrap.style.cssText='display:flex;gap:4px;margin-left:auto;width:'+colWidths.actions+'px';
            actionsWrap.append(toSetBtn,del);
            return actionsWrap;
          })()
        };
        // Add custom column cells to cellMap
        gig.customColumns.forEach(cc=>{
          cellMap[cc.key] = customColInputs[cc.key];
        });
        
        colOrder.forEach(colKey=>{
          if(hiddenCols.includes(colKey)) return; // Skip hidden columns
          const cell = cellMap[colKey];
          if(!cell) return;
          const width = colWidths[colKey];
          // Apply width to cell if fixed-width column
          if(colKey!=='lyrics' && colKey!=='audio' && colKey!=='actions'){
            cell.style.width = width+'px';
            cell.style.flexShrink = '0';
          } else if(colKey==='lyrics' || colKey==='audio'){
            cell.style.flex = `1 1 auto`;
            cell.style.minWidth = width+'px';
            cell.style.maxWidth = (width+100)+'px';
          }
          row.appendChild(cell);
        });
        
        list.appendChild(row);
        list.appendChild(lyrBox);
        list.appendChild(audioBox);
      });
      try{ renderSongPool(); }catch(_){ }
    }

    // Generate fresh set each click (ignores current setlist)
    $('#genBtn').addEventListener('click', ()=>{
      if(isSetlistLocked()){ alert('Setlist is locked. Uncheck the lock to make changes.'); return; }
      const setLen = parseFloat($('#gLen').value || '60') || 60;
      const coverRatio=parseInt($('#gCover').value)||0;
      const breaks=parseInt($('#gBreaks').value)||0; // retained in gig but not auto-inserted
      const breakLen=parseFloat($('#gBreakLen').value)||15;
      const encore=$('#gEncore').checked;
      const mood=$('#gMood').value;

      // Update gig settings (band/venue/address/notes now edited directly on sheet header)
      gig.breaks = breaks;
      gig.breakLen = breakLen;
      gig.encore = encore;
      if(!db.length){ alert('Add some songs first.'); return; }

      // Filter pool by mood
      let pool=[...db];
      if(mood!=='mixed'){
        const keyMap={upbeat:'isUpbeat',happy:'isHappy',mellow:'isMellow',energetic:'isEnergetic',sad:'isSad'};
        pool=pool.filter(s=>s[keyMap[mood]]);
        if(!pool.length){ alert('No songs match this mood.'); return; }
      }

      const totalBreakTime = (breaks>0 ? (breaks * breakLen) : 0);
      const musicTime = Math.max(0, setLen - totalBreakTime);
      if(musicTime<=0){ alert('Set length must exceed total break time.'); return; }
      const covers=pool.filter(s=>s.isCover);
      const originals=pool.filter(s=>!s.isCover);
      let plan=[]; let total=0; const targetCover=(musicTime*coverRatio)/100;
      let coverSum=0, origSum=0;
      for(const s of shuffle(covers)){
        if(coverSum + s.length <= targetCover && total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); coverSum+=s.length; total+=s.length; }
      }
      for(const s of shuffle(originals)){
        if(total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); origSum+=s.length; total+=s.length; }
      }
      plan=shuffle(plan);
      // Apply optional grouping rules
      const keepCovers = (document.getElementById('gKeepCovers') && document.getElementById('gKeepCovers').checked) || false;
      const keepKeys   = (document.getElementById('gKeepKeys') && document.getElementById('gKeepKeys').checked) || false;
      const keepMoods  = (document.getElementById('gKeepMoods') && document.getElementById('gKeepMoods').checked) || false;
      if(keepCovers || keepKeys || keepMoods){
        const songMoodOf=(s)=>{ if(s.isUpbeat) return 'upbeat'; if(s.isHappy) return 'happy'; if(s.isEnergetic) return 'energetic'; if(s.isMellow) return 'mellow'; if(s.isSad) return 'sad'; const cm=(s.customMoods||[])[0]; return cm||'none'; };
        const applyGrouping=(arr)=>{
          const songs=arr.filter(x=>x.type==='song');
          const others=arr.filter(x=>x.type!=='song');
          if(songs.length){
            songs.sort((a,b)=>{
              if(keepCovers){ const ca=(a.isCover?1:0), cb=(b.isCover?1:0); if(ca!==cb) return ca-cb; }
              if(keepKeys){ const ka=(a.key||''), kb=(b.key||''); if(ka!==kb) return ka.localeCompare(kb); }
              if(keepMoods){ const ma=songMoodOf(a), mb=songMoodOf(b); if(ma!==mb) return ma.localeCompare(mb); }
              return 0;
            });
          }
          // Rebuild segment by replacing song slots with sorted songs in order, preserving non-song positions
          let si=0; return arr.map(x=> x.type==='song' ? songs[si++] : x);
        };
        const encIdx=plan.findIndex(x=>x.type==='encore');
        if(encIdx>-1){
          const before=applyGrouping(plan.slice(0,encIdx));
          const after=applyGrouping(plan.slice(encIdx+1));
          const hdr=plan[encIdx];
          plan=[...before, hdr, ...after];
        }else{
          plan=applyGrouping(plan);
        }
      }
      if(encore){
        // Insert Encore break before last 3 songs
        const songIndices = [];
        plan.forEach((item, idx) => {
          if(item.type === 'song') songIndices.push(idx);
        });
        
        if(songIndices.length >= 3){
          // Get position of 3rd-to-last song
          const encorePosition = songIndices[songIndices.length - 3];
          plan.splice(encorePosition, 0, {type:'encore', title:'Encore'});
        }
      }
      // Trim overflow if any
      while(total>musicTime){ const last=plan.map((x,i)=>({x,i})).filter(y=>y.x.type==='song').map(y=>y.i).pop(); if(last==null) break; total-=plan[last].length; plan.splice(last,1); }

      // Automatic break insertion based on requested count (by cumulative music time)
      (function autoBreaks(){
        if(!breaks || breakLen<=0) return;
        const encoreIdx=plan.findIndex(x=>x.type==='encore');
        const songIndices=[]; let cum=0; const songLengths=[];
        plan.forEach((p,i)=>{ if(p.type==='song' && (encoreIdx===-1 || i<encoreIdx)){ cum += (p.length||0); songIndices.push(i); songLengths.push(cum); } });
        const totalSongLen=songLengths[songLengths.length-1]||0;
        if(totalSongLen < breakLen*0.75) return; // too short to bother
        let fracs=[];
        if(breaks===1) fracs=[0.5];
        else if(breaks===2) fracs=[0.5, 2/3];
        else if(breaks>=3) fracs=[0.25,0.5,0.75];
        const targets=fracs.map(f=> totalSongLen*f);
        const inserted=new Set();
        for(let tIdx=0; tIdx<targets.length; tIdx++){
          const tgt=targets[tIdx]; if(tgt<=0) continue;
          // Find first song index with cumulative >= target
          let songPos=-1;
          for(let j=0;j<songLengths.length;j++){ if(songLengths[j] >= tgt){ songPos=songIndices[j]; break; } }
          if(songPos===-1) continue;
          // Avoid duplicate insertion near previous breaks
          if(inserted.has(songPos)) continue;
          // Do not insert at very beginning
          if(songPos<=0) continue;
          // If previous element already a break, skip
          if(plan[songPos-1] && plan[songPos-1].type==='break') continue;
          plan.splice(songPos,0,{type:'break',title:'Break',length:breakLen});
          inserted.add(songPos);
          // Shift later songPositions automatically due to splice; recalc cumulative references minimal by adding length to later songLengths
          for(let k=0;k<songLengths.length;k++){ if(songIndices[k] >= songPos){ songIndices[k] += 1; } }
        }
      })();

      setlist=plan;
      
      // Update current tour date if in edit mode
      if(selectedTourDateId && window.setlistEditMode === 'edit'){
        const td = tourDates.find(t => t.id === selectedTourDateId);
        if(td){
          td.setlist = JSON.parse(JSON.stringify(setlist));
          td.setlistType = 'custom';
        }
      }
      
      const actualMusic = setlist.filter(x=>x.type==='song').reduce((a,b)=>a+(b.length||0),0);
      const breakCount=setlist.filter(x=>x.type==='break').length;
      $('#genStats').textContent=`Songs: ${setlist.filter(x=>x.type==='song').length} ‚Ä¢ Music: ${actualMusic.toFixed(1)}m (‚â§ target ${musicTime.toFixed(1)}m) ‚Ä¢ Covers ${coverSum.toFixed(1)}m / Originals ${origSum.toFixed(1)}m${breakCount? ' ‚Ä¢ Breaks '+breakCount+' √ó '+breakLen+'m':''}${encore? ' ‚Ä¢ Encore':''}`;
      rebuildPreview(); renderSongPool();
    });

    // renderSet removed - element #setList does not exist, using inline preview only
    

    // Preview (guarded if button exists)
    (function(){ const pb=document.getElementById('previewBtn'); if(pb){ pb.addEventListener('click', ()=>{ 
      // Build inline first to ensure layout is calculated, then copy to print modal
      buildSheet('sheetInline');
      buildSheet('sheet'); 
      document.getElementById('modal').classList.add('open'); 
    }); } })();
  $('#closeModal').addEventListener('click', ()=> $('#modal').classList.remove('open'));
    $('#paperSel').addEventListener('change', ()=>{
      const sheet=$('#sheet');
      if($('#paperSel').value==='a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
    });
  // Setlist modal print opens print chooser for consistency
  document.getElementById('printSheet').addEventListener('click',()=> openPrintChooser('set'));

    // Live Mode rendering
    let _pendingArmSongId=null;
    function renderLive(){
      const listEl=document.getElementById('liveList'); if(!listEl) return;
      const titleEl=document.getElementById('liveLyricsTitle');
      const bodyEl=document.getElementById('liveLyricsBody');
      const themeBtn=document.getElementById('liveThemeToggle');
      const songArmInput=document.getElementById('armSongFile');
      // Wire per-song arm input once
      if(songArmInput && !songArmInput._wired){
        songArmInput.addEventListener('change',()=>{
          if(!_pendingArmSongId) return;
          const file = songArmInput.files && songArmInput.files[0];
            if(!file){ _pendingArmSongId=null; songArmInput.value=''; return; }
            const song=findSongById(_pendingArmSongId);
            if(song){
              try{ if(armedAudio[song.id]) URL.revokeObjectURL(armedAudio[song.id]); }catch(_){ }
              armedAudio[song.id]=URL.createObjectURL(file);
              song.audioFileName=file.name;
              saveAll();
              try{ renderLive(); }catch(_){ }
            }
            _pendingArmSongId=null; songArmInput.value='';
        });
        songArmInput._wired=true;
      }
      if(themeBtn){
        const dark=!!gig.liveDark;
        document.body.classList.toggle('live-dark', dark);
        themeBtn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
        themeBtn.style.background = dark ? '#fef3c7' : '#0f172a';
        themeBtn.style.color = dark ? '#92400e' : '#fbbf24';
      }
      listEl.innerHTML='';
      if(!setlist.length){ listEl.textContent='No setlist yet.'; if(titleEl) titleEl.textContent=''; if(bodyEl) bodyEl.textContent=''; return; }
      let songNum=0;
      let liveHoldTimer=null;
      let liveDragIndex=null;
      setlist.forEach((it,i)=>{
        const row=document.createElement('div');
        row.className='live-row';
        row.dataset.index=i;
        row.dataset.type=it.type;
        row.style.padding='10px 8px';
        row.style.borderBottom='1px solid #e5e7eb';
        row.style.display='flex';
        row.style.alignItems='center';
        row.style.gap='8px';
        row.style.cursor='pointer';
        row.style.transition='background 0.2s, transform 0.2s';
        
        // Handle breaks and encores as buttons
        if(it.type==='break'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚è∏'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=it.title||'Break'; ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#374151';
          const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280'; meta.textContent=it.length+'m';
          main.append(ttl,meta);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        if(it.type==='encore'){
          const numSpan=document.createElement('span'); numSpan.textContent='‚≠ê'; numSpan.style.minWidth='24px'; numSpan.style.fontSize='18px';
          const main=document.createElement('div'); main.style.flex='1 1 auto';
          const ttl=document.createElement('div'); ttl.textContent=(it.title||'ENCORE').toUpperCase(); ttl.style.fontWeight='600'; ttl.style.fontSize='16px'; ttl.style.color='#1f2937';
          main.append(ttl);
          row.append(numSpan,main);
          // No lyrics, just show as button - long hold to reorder
          setupLiveRowReorder(row,i);
          listEl.appendChild(row);
          return;
        }
        
        // Song rows
        const numSpan=document.createElement('span'); numSpan.textContent=String(++songNum)+'.'; numSpan.style.minWidth='24px';
        const main=document.createElement('div'); main.style.flex='1 1 auto';
        const ttl=document.createElement('div'); ttl.textContent=it.title||''; ttl.style.fontWeight='600'; ttl.style.fontSize='16px';
        const meta=document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#6b7280';
        const keyBits=[]; if(it.artist) keyBits.push(it.artist); if(it.key) keyBits.push(it.key); if(Number.isInteger(it.capo) && it.capo>0) keyBits.push('Capo '+it.capo); if(Number.isInteger(it.bpm) && it.bpm>0) keyBits.push(it.bpm+' BPM');
        meta.textContent=keyBits.join(' ‚Ä¢ ');
        // audio badge + per-song arm (show Arm button for any URL or file reference)
        try{
          const baseSong = findSongById(it.id) || findSongByTitle(it.title);
          const hasFileRef = baseSong && ((baseSong.audioFileName||'').trim());
          const hasUrl = baseSong && ((baseSong.audioUrl||'').trim());
          const isArmed = baseSong && armedAudio[baseSong.id];
          if(baseSong && (isArmed || hasUrl || hasFileRef)){
            const badge=document.createElement('span'); badge.textContent='üîä'; badge.title=isArmed? 'Audio armed' : (hasUrl? 'Audio URL linked' : 'Audio file referenced'); badge.style.marginLeft='6px'; ttl.appendChild(badge);
          }
          // Show Arm button: if URL exists, just arm it; if file ref exists, prompt for file
          if(baseSong && (hasFileRef || hasUrl) && !isArmed){
            const armBtn=document.createElement('button'); armBtn.type='button'; armBtn.textContent='Arm'; 
            if(hasUrl && !hasFileRef){
              // URL only - just arm it without file prompt
              armBtn.title='Arm this URL for playback';
              armBtn.addEventListener('click',e=>{ 
                e.stopPropagation(); 
                if(baseSong.id!=null){
                  try{ if(armedAudio[baseSong.id]) URL.revokeObjectURL(armedAudio[baseSong.id]); }catch(_){ }
                  armedAudio[baseSong.id]=baseSong.audioUrl;
                  armBtn.textContent='Armed';
                  armBtn.disabled=true;
                  armBtn.style.opacity='0.5';
                  saveAll();
                  renderLive();
                }
              });
            } else {
              // Has file reference - prompt for file selection
              armBtn.title='Select local audio file for this song';
              armBtn.addEventListener('click',e=>{ e.stopPropagation(); _pendingArmSongId=baseSong.id; songArmInput.click(); });
            }
            armBtn.style.fontSize='11px'; armBtn.style.padding='4px 8px'; armBtn.style.border='1px solid #d1d5db'; armBtn.style.background='#fff'; armBtn.style.borderRadius='4px'; armBtn.style.cursor='pointer';
            row.appendChild(armBtn);
          }
        }catch(_){ }
        main.append(ttl,meta);
        row.append(numSpan,main);
        // Track if we're dragging to prevent click during drag
        let clickAllowed=true;
        let clickTimer=null;
        row.addEventListener('touchstart',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('mousedown',()=>{ 
          clickAllowed=true; 
          if(clickTimer) clearTimeout(clickTimer);
          clickTimer=setTimeout(()=>{clickAllowed=false;},500); 
        });
        row.addEventListener('touchend',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('mouseup',()=>{ 
          if(clickTimer){ clearTimeout(clickTimer); clickTimer=null; }
          setTimeout(()=>{clickAllowed=true;},100); 
        });
        row.addEventListener('click',()=>{
          if(!clickAllowed) return; // Prevent click during long-hold drag
          document.querySelectorAll('#liveList .live-row').forEach(r=> r.style.background='');
          const dark = document.body.classList.contains('live-dark');
          row.style.background = dark ? '#0b3a59' : '#e0f2fe';
          if(titleEl) titleEl.textContent=it.title||'';
          if(bodyEl){
            bodyEl.textContent=it.lyrics || '';
            bodyEl.style.paddingTop='50vh';
            // Add rating UI at bottom
            const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
            const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:18px';
            const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:10px';
            const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
            const updateRatingButtons=()=>{
              ratingBtns.innerHTML='';
              [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:8px 16px;border:2px solid '+(it.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(it.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:24px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(it.id)||findSongByTitle(it.title); if(baseSong){ baseSong.audienceRating=r; it.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
            };
            updateRatingButtons();
            ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
          }
          const lyrMain=document.getElementById('liveLyrics'); if(lyrMain){ lyrMain.scrollTop=0; }
          const zoom=document.getElementById('liveInlineZoom'); if(zoom){ zoom.value=String(liveZoomPx); }
          const body=document.getElementById('liveLyricsBody'); if(body){ body.style.fontSize=liveZoomPx+'px'; }
          try{ stopLiveInlineAutoScroll(); }catch(_){ }
          try{ preloadSongAudioFor(it); }catch(_){ }
          // Show Play button again for new selection; keep Stop hidden until audio/scroll actions
          const pBtn=document.getElementById('liveInlinePlay'); const sBtn=document.getElementById('liveInlineStop');
          if(pBtn){ pBtn.style.display=''; }
          if(sBtn){ sBtn.style.display='none'; }
          // On phones/tablets, single tap opens fullscreen. Desktop uses double‚Äëclick.
          const isNarrow = window.matchMedia && window.matchMedia('(max-width: 900px)').matches;
          if(isNarrow){ openLiveLyricsOverlay(it); }
        });
        // Desktop: double‚Äëclick to open fullscreen lyrics
        // Mobile: handle double-tap gesture
        let lastTap = 0;
        row.addEventListener('touchend', (e) => {
          const now = Date.now();
          const DOUBLE_TAP_DELAY = 300;
          if (now - lastTap < DOUBLE_TAP_DELAY) {
            e.preventDefault();
            openLiveLyricsOverlay(it);
            lastTap = 0;
          } else {
            lastTap = now;
          }
        });
        row.addEventListener('dblclick',()=>{ openLiveLyricsOverlay(it); });
        // Setup long-hold reorder for songs
        setupLiveRowReorder(row,i);
        listEl.appendChild(row);
      });
      
      // Setup long-hold reordering for all rows
      function setupLiveRowReorder(row,index){
        let holdTimer=null;
        let isDragging=false;
        let dragReady=false; // Hold completed, ready to drag
        let startY=0;
        let currentY=0;
        let placeholder=null;
        
        const startHold=(e)=>{
          if(holdTimer) return;
          dragReady=false;
          holdTimer=setTimeout(()=>{
            dragReady=true; // Hold completed - now ready to activate drag on move
          }, 500);
        };
        
        const activateDrag=()=>{
          if(isDragging) return;
          isDragging=true;
          row.style.opacity='0.7';
          row.style.transform='scale(1.05)';
          row.style.zIndex='1000';
          row.style.position='relative';
          // Create placeholder
          placeholder=document.createElement('div');
          placeholder.style.height=row.offsetHeight+'px';
          placeholder.style.background='#dbeafe';
          placeholder.style.border='2px dashed #374151';
          placeholder.style.borderRadius='4px';
          placeholder.style.margin='4px 0';
          row.parentNode.insertBefore(placeholder, row.nextSibling);
        };
        
        const endHold=()=>{
          if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }
          dragReady=false;
          if(isDragging){
            // Get the current index from the dataset (in case it changed)
            const currentIndex = parseInt(row.dataset.index, 10);
            if(!isFinite(currentIndex) || currentIndex<0){ 
              // Cleanup and bail
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
              isDragging=false;
              return;
            }
            
            // Find where the placeholder is positioned
            const allChildren=Array.from(listEl.children);
            let placeholderPos=-1;
            for(let i=0; i<allChildren.length; i++){
              if(allChildren[i]===placeholder){
                placeholderPos=i;
                break;
              }
            }
            
            // Map DOM position back to setlist index by counting rows before placeholder
            let targetSetlistIndex=0;
            for(let i=0; i<placeholderPos; i++){
              const child=allChildren[i];
              if(child.classList && child.classList.contains('live-row')){
                targetSetlistIndex++;
              }
            }
            
            if(targetSetlistIndex!==currentIndex){
              // Move in setlist array
              const item=setlist.splice(currentIndex,1)[0];
              const finalIndex = targetSetlistIndex > currentIndex ? targetSetlistIndex-1 : targetSetlistIndex;
              setlist.splice(finalIndex,0,item);
              saveAll();
              rebuildPreview();
              renderLive();
            } else {
              // No change, just cleanup
              if(placeholder && placeholder.parentNode){ placeholder.parentNode.removeChild(placeholder); }
              row.style.opacity=''; row.style.transform=''; row.style.zIndex=''; row.style.position='';
            }
            isDragging=false;
          }
        };
        
        const moveWhileDragging=(e)=>{
          // Only activate drag if hold completed AND user is moving
          if(dragReady && !isDragging){
            activateDrag();
          }
          if(!isDragging) return;
          e.preventDefault();
          const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
          const deltaY = clientY - startY;
          row.style.transform=`translateY(${deltaY}px) scale(1.05)`;
          // Move placeholder based on position
          const rows=Array.from(listEl.querySelectorAll('.live-row')).filter(r=>r!==placeholder);
          let insertBefore=null;
          rows.forEach(r=>{
            const rect=r.getBoundingClientRect();
            const mid=rect.top+rect.height/2;
            if(clientY < mid && !insertBefore){ insertBefore=r; }
          });
          if(insertBefore && placeholder){
            listEl.insertBefore(placeholder, insertBefore);
          } else if(placeholder && !insertBefore){
            listEl.appendChild(placeholder);
          }
        };
        
        // Touch events
        row.addEventListener('touchstart',(e)=>{
          startY = e.touches[0].clientY;
          startHold(e);
        });
        row.addEventListener('touchmove',(e)=>{
          moveWhileDragging(e);
        });
        row.addEventListener('touchend',(e)=>{
          endHold();
        });
        row.addEventListener('touchcancel',(e)=>{
          endHold();
        });
        
        // Mouse events for desktop - attach move/up to document to prevent losing grip
        const onMouseMove=(e)=>{
          moveWhileDragging(e);
        };
        const onMouseUp=(e)=>{
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          endHold();
        };
        row.addEventListener('mousedown',(e)=>{
          startY = e.clientY;
          startHold(e);
          // Attach global listeners when drag starts
          setTimeout(()=>{
            if(isDragging){
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            }
          }, 510); // Just after the 500ms hold timer
        });
      }
    }

    // Global theme toggle wiring (next to tabs, visible on all pages)
    (function wireGlobalThemeToggle(){
      const btn=document.getElementById('globalThemeToggle');
      if(!btn) return;
      
      // Initialize button state from saved preference
      const dark=!!gig.liveDark;
      document.body.classList.toggle('live-dark', dark);
      btn.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
      btn.style.background = dark ? '#fef3c7' : '#0f172a';
      btn.style.color = dark ? '#92400e' : '#fbbf24';
      
      btn.addEventListener('click',()=>{
        gig.liveDark = !gig.liveDark;
        document.body.classList.toggle('live-dark', gig.liveDark);
        btn.textContent = gig.liveDark ? '‚òÄÔ∏è' : 'üåô';
        btn.style.background = gig.liveDark ? '#fef3c7' : '#0f172a';
        btn.style.color = gig.liveDark ? '#92400e' : '#fbbf24';
        // Also update Live mode theme button if visible
        const liveBtn=document.getElementById('liveThemeToggle');
        if(liveBtn){
          liveBtn.textContent = gig.liveDark ? '‚òÄÔ∏è' : 'üåô';
          liveBtn.style.background = gig.liveDark ? '#fef3c7' : '#0f172a';
          liveBtn.style.color = gig.liveDark ? '#92400e' : '#fbbf24';
        }
        // Re-render live to refresh colors
        try{ renderLive(); }catch(_){ }
        saveAll();
      });
    })();

    // Live theme toggle wiring
    (function wireLiveThemeToggle(){
      const btn=document.getElementById('liveThemeToggle');
      if(!btn) return;
      btn.addEventListener('click',()=>{
        gig.liveDark = !gig.liveDark;
        document.body.classList.toggle('live-dark', gig.liveDark);
        // Update both buttons
        btn.textContent = gig.liveDark ? '‚òÄÔ∏è' : 'üåô';
        btn.style.background = gig.liveDark ? '#fef3c7' : '#0f172a';
        btn.style.color = gig.liveDark ? '#92400e' : '#fbbf24';
        const globalBtn=document.getElementById('globalThemeToggle');
        if(globalBtn){
          globalBtn.textContent = gig.liveDark ? '‚òÄÔ∏è' : 'üåô';
          globalBtn.style.background = gig.liveDark ? '#fef3c7' : '#0f172a';
          globalBtn.style.color = gig.liveDark ? '#92400e' : '#fbbf24';
        }
        // Re-render live to refresh colors and icon
        try{ renderLive(); }catch(_){ }
        saveAll();
      });
    })();

    // Arm All: batch-arm audio by selecting a folder and matching filenames
    (function wireArmAll(){
      const armBtn=document.getElementById('armAllBtn');
      const armDir=document.getElementById('armAllDir');
      if(!armBtn || !armDir) return;
      const matchAndArm=(fileList)=>{
        if(!fileList || !fileList.length) return 0;
        const map=new Map();
        for(const f of fileList){ map.set((f.name||'').toLowerCase(), f); }
        let armed=0;
        const targetSongs = setlist.filter(x=>x.type==='song');
        targetSongs.forEach(it=>{
          const base = (findSongById(it.id) || findSongByTitle(it.title)); if(!base) return;
          // Try to match by filename first
          const want=(base.audioFileName||'').toLowerCase().trim();
          let file=null;
          if(want){ file = map.get(want) || null; }
          if(!file){
            // heuristic: try title match
            const t=(base.title||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
            if(t){ for(const [nm,f] of map){ if(nm.replace(/[^a-z0-9]+/g,' ').includes(t)){ file=f; break; } }
            }
          }
          // If file found OR has URL, arm it
          if(base.id!=null){
            if(file){
              // Arm with local file
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=URL.createObjectURL(file);
              armed++;
            } else if((base.audioUrl||'').trim()){
              // Arm with URL (mark as armed by setting a flag)
              try{ if(armedAudio[base.id]) URL.revokeObjectURL(armedAudio[base.id]); }catch(_){ }
              armedAudio[base.id]=base.audioUrl; // store URL directly
              armed++;
            }
          }
        });
        return armed;
      };
      armBtn.addEventListener('click',()=> armDir.click());
      armDir.addEventListener('change',()=>{
        const n=matchAndArm(armDir.files||[]);
        alert(n? ('Armed '+n+' audio track'+(n===1?'':'s')+' (files and URLs) for this set.') : 'No matching files found. Add audio files or URLs to songs in Database.');
      });
    })();

    // Live fullscreen lyrics: timed auto-scroll to ~75% of song length
    let liveScrollTimer=null;
    let liveScrollStart=null;
    let liveScrollDurationMs=0;
    let liveZoomPx=20; // inline lyrics zoom (desktop pane)
    let liveOverlayZoomPx=20; // fullscreen overlay zoom
    let liveScrollSpeed=5; // user-adjustable scroll speed (0-9, default 5, 0=stopped, 9=fastest)
    let liveManualScrollOffset=0; // manual scroll adjustment during playback
    // Compute scroll duration based on lines-per-minute model
    function computeScrollDuration(container, bodyEl, zoomPx, speedSetting){
      try{
        if(!container || !bodyEl) return 0;
        const lineHeightPx = zoomPx * 1.4; // approximate line-height factor
        const totalLines = Math.max(1, Math.round(bodyEl.scrollHeight / lineHeightPx));
        const visibleLines = Math.max(1, Math.round(container.clientHeight / lineHeightPx));
        const linesToScroll = Math.max(1, totalLines - visibleLines);
        if(speedSetting===0) return 0;
        // Base lines per minute scaling; speed 9 roughly 2x previous max
        const baseLinesPerMin = 30 + speedSetting * 10; // 1=>40, 9=>120
        // Bigger zoom => fewer lines visible, scroll proportionally faster
        const linesPerMin = baseLinesPerMin * (zoomPx / 20);
        const durationMs = (linesToScroll / linesPerMin) * 60000;
        return durationMs;
      }catch(e){ return 0; }
    }
    // Inline (desktop) auto-scroll
    let liveInlineScrollTimer=null;
    let liveInlineScrollStart=null;
    let liveInlineScrollDurationMs=0;
    let liveInlineManualScrollOffset=0;
    function stopLiveAutoScroll(){
      if(liveScrollTimer){ cancelAnimationFrame(liveScrollTimer); liveScrollTimer=null; }
      liveScrollStart=null; liveScrollDurationMs=0;
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function stopLiveInlineAutoScroll(){
      if(liveInlineScrollTimer){ cancelAnimationFrame(liveInlineScrollTimer); liveInlineScrollTimer=null; }
      liveInlineScrollStart=null; liveInlineScrollDurationMs=0;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='';
      if(stopBtn) stopBtn.style.display='none';
    }
    function openLiveLyricsOverlay(item){
      const overlay=document.getElementById('liveLyricsOverlay');
      const titleEl=document.getElementById('liveLyricsOverlayTitle');
      const bodyEl=document.getElementById('liveLyricsOverlayBody');
      if(!overlay || !titleEl || !bodyEl) return;
      stopLiveAutoScroll();
      overlay.classList.add('open');
      titleEl.textContent=item.title || '';
      bodyEl.textContent=item.lyrics || '';
      bodyEl.style.paddingTop='50vh';
      // Add rating UI at bottom
      const ratingDiv=document.createElement('div'); ratingDiv.style.cssText='margin-top:40px;padding:20px;text-align:center;border-top:2px solid #d1d5db';
      const ratingLabel=document.createElement('div'); ratingLabel.textContent='Rate this performance:'; ratingLabel.style.cssText='font-weight:600;margin-bottom:12px;font-size:24px';
      const ratingBtns=document.createElement('div'); ratingBtns.style.cssText='display:flex;justify-content:center;gap:12px';
      const ratingIcons = ['\ud83d\udc4e','\ud83d\udc48','\ud83d\udc4d','\ud83d\udc4d\u200a\ud83d\udc4d'];
      const updateRatingButtons=()=>{
        ratingBtns.innerHTML='';
        [0,1,2,3].forEach(r=>{ const btn=document.createElement('button'); btn.type='button'; btn.textContent=ratingIcons[r]; btn.style.cssText='padding:10px 20px;border:2px solid '+(item.audienceRating===r? '#374151':'#d1d5db')+';border-radius:8px;background:'+(item.audienceRating===r? '#e5e7eb':'#fff')+';cursor:pointer;font-size:32px;touch-action:manipulation'; btn.title='Rating: '+r; btn.addEventListener('click',(e)=>{ e.stopPropagation(); const baseSong=findSongById(item.id)||findSongByTitle(item.title); if(baseSong){ baseSong.audienceRating=r; item.audienceRating=r; saveAll(); updateRatingButtons(); } }); ratingBtns.appendChild(btn); });
      };
      updateRatingButtons();
      ratingDiv.append(ratingLabel,ratingBtns); bodyEl.appendChild(ratingDiv);
      const main=document.getElementById('liveLyricsOverlayMain');
      if(main){ main.scrollTop=0; }
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(zoomSlider){
        zoomSlider.value=String(liveOverlayZoomPx);
      }
      const body=document.getElementById('liveLyricsOverlayBody');
      if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
      // Reset play visibility for new overlay song
      const pBtn=document.getElementById('liveLyricsPlay'); const sBtn=document.getElementById('liveLyricsStop');
      if(pBtn){ pBtn.style.display=''; }
      if(sBtn){ sBtn.style.display='none'; }
    }
    function closeLiveLyricsOverlay(){
      const overlay=document.getElementById('liveLyricsOverlay');
      if(overlay){ overlay.classList.remove('open'); }
      stopLiveAutoScroll();
    }
    function startLiveAutoScroll(){
      const overlay=document.getElementById('liveLyricsOverlay');
      const main=document.getElementById('liveLyricsOverlayMain');
      if(!overlay || !main || !overlay.classList.contains('open')) return;
      const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsOverlayBody');
      liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
      if(liveScrollDurationMs<=0) liveScrollDurationMs=15000; // fallback
      const maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveScrollStart = performance.now();
      liveManualScrollOffset = 0; // reset manual offset for new scroll
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      let lastComputedTop = startTop;
      function step(now){
        if(!liveScrollStart){ return; }
        const elapsed = now - liveScrollStart;
        const t = Math.min(1, elapsed / liveScrollDurationMs);
        // Compute target position for this frame
        const targetTop = startTop + (maxTop - startTop) * t;
        // Detect user manual scroll: if actual position differs from last computed, update offset
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){ 
          liveManualScrollOffset = actualTop - targetTop;
        }
        // Apply target + offset and remember for next frame
        lastComputedTop = targetTop + liveManualScrollOffset;
        main.scrollTop = lastComputedTop;
        if(t<1){ liveScrollTimer = requestAnimationFrame(step); }
        else { stopLiveAutoScroll(); }
      }
      liveScrollTimer = requestAnimationFrame(step);
    }
    // Schedule scroll start after Play; immediate for armed/local or stream, delayed for external popup providers
    function scheduleOverlayScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200; // small delay for direct audio, longer for external to allow manual play
      setTimeout(()=>{ try{ startLiveAutoScroll(); }catch(_){ } }, delay);
    }
    function startLiveInlineAutoScroll(){
      const main=document.getElementById('liveLyrics');
      if(!main) return;
      const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
      const song=setlist.find(x=> x.type==='song' && x.title===titleText);
      const body=document.getElementById('liveLyricsBody');
      liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
      if(liveInlineScrollDurationMs<=0) liveInlineScrollDurationMs=15000;
      const maxTop = main.scrollHeight - main.clientHeight;
      if(maxTop<=0){ return; }
      const startTop = 0;
      main.scrollTop = startTop;
      liveInlineScrollStart = performance.now();
      liveInlineManualScrollOffset = 0;
      let lastComputedTop = startTop;
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      if(playBtn) playBtn.style.display='none';
      if(stopBtn) stopBtn.style.display='';
      function step(now){
        if(!liveInlineScrollStart){ return; }
        const elapsed = now - liveInlineScrollStart;
        const t = Math.min(1, elapsed / liveInlineScrollDurationMs);
        const targetTop = startTop + (maxTop - startTop) * t;
        const actualTop = main.scrollTop;
        if(Math.abs(actualTop - lastComputedTop) > 2){
          liveInlineManualScrollOffset = actualTop - targetTop;
        }
        lastComputedTop = targetTop + liveInlineManualScrollOffset;
        main.scrollTop = lastComputedTop;
        if(t<1){ liveInlineScrollTimer = requestAnimationFrame(step); }
        else { stopLiveInlineAutoScroll(); }
      }
      liveInlineScrollTimer = requestAnimationFrame(step);
    }
    function scheduleInlineScroll(song){
      if(!song) return;
      const armed = song.id!=null && armedAudio[song.id];
      const url=(song.audioUrl||'').trim();
      const lower=url.toLowerCase();
      const isStream= armed || lower.endsWith('.mp3') || lower.endsWith('.wav') || lower.endsWith('.ogg') || lower.includes('stream');
      const delay = isStream ? 100 : 1200;
      setTimeout(()=>{ try{ startLiveInlineAutoScroll(); }catch(_){ } }, delay);
    }
    (function wireLiveOverlayControls(){
      const playBtn=document.getElementById('liveLyricsPlay');
      const stopBtn=document.getElementById('liveLyricsStop');
      const scrollBtn=document.getElementById('liveLyricsScroll');
      const exitBtn=document.getElementById('liveLyricsExit');
      const main=document.getElementById('liveLyricsOverlayMain');
      const zoomSlider=document.getElementById('liveLyricsZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsOverlayTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleOverlayScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveAutoScroll); }
      if(exitBtn){ exitBtn.addEventListener('click',closeLiveLyricsOverlay); }
      if(main){ main.addEventListener('click',closeLiveLyricsOverlay); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveOverlayZoomPx=Math.min(96, Math.max(16, v));
          const body=document.getElementById('liveLyricsOverlayBody');
          if(body){ body.style.fontSize=liveOverlayZoomPx+'px'; }
          // Zoom change should not restart scrolling or audio
        });
      }
      const speedDownBtn=document.getElementById('liveSpeedDown');
      const speedUpBtn=document.getElementById('liveSpeedUp');
      const speedDisplay=document.getElementById('liveSpeedDisplay');
      if(speedDownBtn){
        speedDownBtn.addEventListener('click',()=>{
          if(liveScrollSpeed > 0) liveScrollSpeed--;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveScrollTimer && liveScrollStart){
            const elapsed = performance.now() - liveScrollStart;
            const oldT = Math.min(1, elapsed / liveScrollDurationMs);
            const main=document.getElementById('liveLyricsOverlayMain');
            const body=document.getElementById('liveLyricsOverlayBody');
            liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
            liveScrollStart = performance.now() - (oldT * liveScrollDurationMs);
          }
        });
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('click',()=>{
          if(liveScrollSpeed < 9) liveScrollSpeed++;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveScrollTimer && liveScrollStart){
            const elapsed = performance.now() - liveScrollStart;
            const oldT = Math.min(1, elapsed / liveScrollDurationMs);
            const main=document.getElementById('liveLyricsOverlayMain');
            const body=document.getElementById('liveLyricsOverlayBody');
            liveScrollDurationMs = computeScrollDuration(main, body, liveOverlayZoomPx, liveScrollSpeed);
            liveScrollStart = performance.now() - (oldT * liveScrollDurationMs);
          }
        });
      }
    })();

    // Desktop inline Live controls
    (function wireLiveInlineControls(){
      const playBtn=document.getElementById('liveInlinePlay');
      const stopBtn=document.getElementById('liveInlineStop');
      const scrollBtn=document.getElementById('liveInlineScroll');
      const zoomSlider=document.getElementById('liveInlineZoom');
      if(playBtn){
        playBtn.addEventListener('click',()=>{
          const titleText=document.getElementById('liveLyricsTitle')?.textContent || '';
          const song=setlist.find(x=> x.type==='song' && x.title===titleText);
          // Only play audio if armed - URLs must be armed to play (for live performance mode)
          const armed=(song && song.id!=null && armedAudio[song.id]);
          if(armed){
            try{ if(song) playSongAudioFor(song); }catch(_){ }
          }
          scheduleInlineScroll(song);
          // Only hide Play for armed audio/streams
          if(song && armed){
            playBtn.style.display='none';
            if(stopBtn) stopBtn.style.display='';
          }
        });
      }
      if(stopBtn){
        stopBtn.addEventListener('click',()=>{
          stopLiveInlineAutoScroll();
          try{ stopSongAudio(); }catch(_){ }
          if(playBtn) playBtn.style.display='';
          stopBtn.style.display='none';
        });
      }
      if(scrollBtn){ scrollBtn.addEventListener('click',startLiveInlineAutoScroll); }
      if(zoomSlider){
        zoomSlider.addEventListener('input',()=>{
          const v=parseInt(zoomSlider.value,10);
          if(!isFinite(v)) return;
          liveZoomPx=Math.min(32, Math.max(16, v));
          const body=document.getElementById('liveLyricsBody');
          if(body){ body.style.fontSize=liveZoomPx+'px'; }
          // Zoom change should not restart scrolling or touch audio
        });
        // initialize to current zoom
        try{ zoomSlider.value=String(liveZoomPx); }catch(_){ }
      }
      const speedDownBtn=document.getElementById('liveInlineSpeedDown');
      const speedUpBtn=document.getElementById('liveInlineSpeedUp');
      const speedDisplay=document.getElementById('liveInlineSpeedDisplay');
      if(speedDownBtn){
        speedDownBtn.addEventListener('click',()=>{
          if(liveScrollSpeed > 0) liveScrollSpeed--;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveInlineScrollTimer && liveInlineScrollStart){
            const elapsed = performance.now() - liveInlineScrollStart;
            const oldT = Math.min(1, elapsed / liveInlineScrollDurationMs);
            const main=document.getElementById('liveLyrics');
            const body=document.getElementById('liveLyricsBody');
            liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
            liveInlineScrollStart = performance.now() - (oldT * liveInlineScrollDurationMs);
          }
        });
      }
      if(speedUpBtn){
        speedUpBtn.addEventListener('click',()=>{
          if(liveScrollSpeed < 9) liveScrollSpeed++;
          if(speedDisplay) speedDisplay.textContent = liveScrollSpeed;
          if(liveInlineScrollTimer && liveInlineScrollStart){
            const elapsed = performance.now() - liveInlineScrollStart;
            const oldT = Math.min(1, elapsed / liveInlineScrollDurationMs);
            const main=document.getElementById('liveLyrics');
            const body=document.getElementById('liveLyricsBody');
            liveInlineScrollDurationMs = computeScrollDuration(main, body, liveZoomPx, liveScrollSpeed);
            liveInlineScrollStart = performance.now() - (oldT * liveInlineScrollDurationMs);
          }
        });
      }
    })();

    // Metronome functionality with tap tempo (4+ taps) & overlay support
    (function(){
      let metronomeState = 0; // 0=off, 1=flash, 2=flash+click
      let metronomeInterval = null;
      let metronomeBPM = 120;
      let metronomeHoldTimer = null;
      let tapTimes=[]; let lastClickTime=0;
      const btns=[document.getElementById('metronomeBtn'), document.getElementById('metronomeBtnOverlay')].filter(Boolean);
      if(!btns.length) return;

      // Create audio context for click sound
      let audioCtx = null;
      const getAudioContext = () => {
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        return audioCtx;
      };
      const playClick = () => {
        try {
          const ctx = getAudioContext();
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.value = 1000;
          gain.gain.value = 0.3;
          osc.start();
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
          osc.stop(ctx.currentTime + 0.05);
        } catch(e) {}
      };

      const flashButtons = () => {
        btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#fbbf24':'#fbbf24'; b.style.transform='scale(1.12)'; });
        setTimeout(()=>{ btns.forEach(b=>{ b.style.background = b.id==='metronomeBtnOverlay'? '#1f2937':'#fff'; b.style.transform='scale(1)'; }); },110);
      };

      const updateTitles=()=>{
        btns.forEach(b=>{
          if(metronomeState===0){ b.title='Metronome OFF - Tap (4+) to set tempo. Pause then click cycles mode. Hold to set BPM.'; b.style.border=b.id==='metronomeBtnOverlay'?'2px solid #444':'2px solid #d1d5db'; }
          else { b.title=metronomeBPM+' BPM - '+(metronomeState===1?'Flash':'Flash + Click'); b.style.border='2px solid #065f46'; }
        });
      };
      const startMetronome=()=>{
        if(metronomeInterval) clearInterval(metronomeInterval);
        const intervalMs=60000/metronomeBPM;
        metronomeInterval=setInterval(()=>{ flashButtons(); if(metronomeState===2) playClick(); }, intervalMs);
        updateTitles();
      };

      const stopMetronome=()=>{ if(metronomeInterval) clearInterval(metronomeInterval); metronomeInterval=null; updateTitles(); };

      const persistSongBPM=(bpm)=>{
        const titleEl=document.getElementById('liveLyricsTitle');
        if(titleEl && titleEl.textContent){
          const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
          const baseSong=song?(findSongById(song.id)||findSongByTitle(song.title)):null;
          if(baseSong){ baseSong.bpm=bpm; song.bpm=bpm; saveAll(); }
        }
      };
      const handleTap=(e)=>{
        // Cancel hold timer immediately on quick tap
        if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; }
        
        const now=performance.now();
        const gap=now-lastClickTime;
        lastClickTime=now;
        
        // Long pause (>1200ms) = mode cycle
        if(gap>1200){
          tapTimes=[];
          metronomeState=(metronomeState+1)%3;
          if(metronomeState===0){ stopMetronome(); }
          else {
            // adopt song bpm if exists
            const titleEl=document.getElementById('liveLyricsTitle');
            if(titleEl && titleEl.textContent){
              const song=setlist.find(x=>x.type==='song' && x.title===titleEl.textContent);
              if(song && song.bpm && song.bpm>0) metronomeBPM=song.bpm;
            }
            startMetronome();
          }
          updateTitles();
          return;
        }
        
        // Tap tempo: collect tap times
        tapTimes.push(now);
        
        // After 4+ taps, calculate BPM from intervals
        if(tapTimes.length>=4){
          const intervals=[];
          for(let i=1;i<tapTimes.length;i++){ 
            const dt=tapTimes[i]-tapTimes[i-1]; 
            if(dt>0 && dt<2000) intervals.push(dt); 
          }
          if(intervals.length>=3){
            const recent=intervals.slice(-Math.min(8, intervals.length)); // use last 8 intervals max
            const avg=recent.reduce((a,b)=>a+b,0)/recent.length;
            let bpm=Math.round(60000/avg); 
            if(bpm<30)bpm=30; 
            if(bpm>300)bpm=300;
            metronomeBPM=bpm;
            persistSongBPM(bpm);
            // Start metronome with new BPM immediately
            if(metronomeState===0){ metronomeState=1; }
            stopMetronome();
            startMetronome();
          }
        }
        updateTitles();
      };
      
      btns.forEach(btn=>{
        btn.addEventListener('click', handleTap);
        btn.addEventListener('mousedown', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0; // reset tap state
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('mouseup', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('mouseleave', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
        btn.addEventListener('touchstart', (e)=>{
          metronomeHoldTimer=setTimeout(()=>{
            tapTimes=[]; lastClickTime=0;
            const newBPM=prompt('Enter BPM (30-300):', String(metronomeBPM));
            if(newBPM){ 
              const bpm=parseInt(newBPM,10); 
              if(bpm>=30 && bpm<=300){ 
                metronomeBPM=bpm; 
                persistSongBPM(bpm); 
                if(metronomeState>0){ stopMetronome(); startMetronome(); } 
              } 
            }
            updateTitles();
          },800);
        });
        btn.addEventListener('touchend', ()=>{ if(metronomeHoldTimer){ clearTimeout(metronomeHoldTimer); metronomeHoldTimer=null; } });
      });
      updateTitles();
    })();

    // ============================================================================
    // TOUR MANAGER
    // ============================================================================
    (function initTourManager(){
      const tourViewModeSelect = document.getElementById('tourViewMode');
      const tourTodayBtn = document.getElementById('tourToday');
      const tourPrevBtn = document.getElementById('tourPrev');
      const tourNextBtn = document.getElementById('tourNext');
      const tourAddDateBtn = document.getElementById('tourAddDate');
      const tourPeriodLabel = document.getElementById('tourPeriodLabel');
      const tourTimeline = document.getElementById('tourTimeline');
      const tourNoSelection = document.getElementById('tourNoSelection');
      const tourDateDetails = document.getElementById('tourDateDetails');
      const tourItineraryContent = document.getElementById('tourItineraryContent');
      
      // Date form fields
      const tourDateInput = document.getElementById('tourDate');
      const tourVenueInput = document.getElementById('tourVenue');
      const tourAddressInput = document.getElementById('tourAddress');
      const tourLoadInInput = document.getElementById('tourLoadIn');
      const tourShowTimeInput = document.getElementById('tourShowTime');
      const tourBandInput = document.getElementById('tourBand');
      const tourSetlistSelect = document.getElementById('tourSetlistSelect');
      const tourStagePlotSelect = document.getElementById('tourStagePlotSelect');
      const tourSaveDateBtn = document.getElementById('tourSaveDate');
      const tourDeleteDateBtn = document.getElementById('tourDeleteDate');
      
      // Band preset dropdown removed - now using header Act selector
      // Keep updateBandPresetDropdown as a no-op for backward compatibility
      window.updateBandPresetDropdown = function(){};
      
      // Map & services
      const tourSearchLocationBtn = document.getElementById('tourSearchLocation');
      const tourMapPlaceholder = document.getElementById('tourMapPlaceholder');
      const tourMapContainer = document.getElementById('tourMapContainer');
      const tourCustomSearchInput = document.getElementById('tourCustomSearch');
      const tourExpediaLink = document.getElementById('tourExpediaLink');
      const tourGoogleMapsLink = document.getElementById('tourGoogleMapsLink');
      const tourGoogleTrafficLink = document.getElementById('tourGoogleTrafficLink');
      
      // Itinerary
      const tourAddItineraryBtn = document.getElementById('tourAddItineraryItem');
      const tourItineraryTimeline = document.getElementById('tourItineraryTimeline');
      
      // Global date header
      const dateBoxesContainer = document.getElementById('dateBoxesContainer');
      let currentDateView = 14; // Always show 14 days or until first gig
      
      // Utility: Generate unique ID
      function generateId(){ return 'tour_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9); }
      
      // Helper: Parse time string (e.g. "4pm", "16:00", "4:30pm") to 24h format
      function parseTimeToHHMM(timeStr){
        if(!timeStr) return null;
        const cleaned = timeStr.toLowerCase().replace(/\s/g, '');
        let hours, minutes;
        
        const match1 = cleaned.match(/^(\d{1,2}):(\d{2})(am|pm)?$/);
        const match2 = cleaned.match(/^(\d{1,4})(am|pm)?$/);
        
        if(match1){
          hours = parseInt(match1[1]);
          minutes = parseInt(match1[2]);
          if(match1[3] === 'pm' && hours < 12) hours += 12;
          if(match1[3] === 'am' && hours === 12) hours = 0;
        } else if(match2){
          const num = match2[1];
          if(num.length <= 2){
            hours = parseInt(num);
            minutes = 0;
          } else {
            hours = parseInt(num.slice(0, -2));
            minutes = parseInt(num.slice(-2));
          }
          if(match2[2] === 'pm' && hours < 12) hours += 12;
          if(match2[2] === 'am' && hours === 12) hours = 0;
        } else {
          return null;
        }
        
        if(hours >= 24) hours = hours % 24;
        return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
      }
      
      // Helper: Sync times to itinerary - creates/updates itinerary entries for load-in, soundcheck, showtime
      function syncTimesToItinerary(tourDate){
        if(!tourDate) return;
        if(!tourDate.itinerary) tourDate.itinerary = [];
        
        // Remove existing auto-generated entries (we'll recreate them)
        tourDate.itinerary = tourDate.itinerary.filter(item => !item.autoGenerated);
        
        // Add load-in time
        if(tourDate.loadIn){
          const time = parseTimeToHHMM(tourDate.loadIn);
          if(time){
            tourDate.itinerary.push({
              time: time,
              title: 'üì¶ Load-In',
              notes: '',
              duration: 45,
              color: '#6366f1',
              autoGenerated: true
            });
          }
        }
        
        // Add showtime
        if(tourDate.showTime){
          const time = parseTimeToHHMM(tourDate.showTime);
          if(time){
            tourDate.itinerary.push({
              time: time,
              title: 'üé∏ Show Time',
              notes: '',
              duration: 90,
              color: '#22c55e',
              autoGenerated: true
            });
          }
        }
        
        // Parse soundcheck from gig notes if present (pattern: "Soundcheck 5pm" or "SC 5pm")
        if(tourDate.gig && tourDate.gig.notes){
          const scMatch = tourDate.gig.notes.match(/sound\s*check\s*[@:]?\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)/i);
          if(scMatch){
            const time = parseTimeToHHMM(scMatch[1]);
            if(time){
              tourDate.itinerary.push({
                time: time,
                title: 'üé§ Soundcheck',
                notes: '',
                duration: 60,
                color: '#f59e0b',
                autoGenerated: true
              });
            }
          }
          
          // Parse load-out (pattern: "Load-out 11pm" or "LO 11pm")
          const loMatch = tourDate.gig.notes.match(/load[\s-]*out\s*[@:]?\s*(\d{1,2}(?::\d{2})?\s*(?:am|pm)?)/i);
          if(loMatch){
            const time = parseTimeToHHMM(loMatch[1]);
            if(time){
              tourDate.itinerary.push({
                time: time,
                title: 'üì¶ Load-Out',
                notes: '',
                duration: 45,
                color: '#dc2626',
                autoGenerated: true
              });
            }
          }
        }
        
        // Sort itinerary by time
        tourDate.itinerary.sort((a, b) => (a.time || '').localeCompare(b.time || ''));
      }
      
      // Helper: Prompt for time in 30-minute increments
      function promptForTime(defaultTime){
        const timeStr = prompt('Enter time (e.g., 2:30pm, 14:30, or just 230)\nUses 30-minute increments:', defaultTime || '');
        if(!timeStr) return null;
        
        // Parse various time formats
        let hours, minutes;
        const cleaned = timeStr.toLowerCase().replace(/\s/g, '');
        
        // Handle formats like "2:30pm", "14:30", "230", "2pm"
        const match1 = cleaned.match(/^(\d{1,2}):(\d{2})(am|pm)?$/);
        const match2 = cleaned.match(/^(\d{1,4})(am|pm)?$/);
        
        if(match1){
          hours = parseInt(match1[1]);
          minutes = parseInt(match1[2]);
          if(match1[3] === 'pm' && hours < 12) hours += 12;
          if(match1[3] === 'am' && hours === 12) hours = 0;
        } else if(match2){
          const num = match2[1];
          if(num.length <= 2){
            hours = parseInt(num);
            minutes = 0;
          } else {
            hours = parseInt(num.slice(0, -2));
            minutes = parseInt(num.slice(-2));
          }
          if(match2[2] === 'pm' && hours < 12) hours += 12;
          if(match2[2] === 'am' && hours === 12) hours = 0;
        } else {
          alert('Invalid time format. Try: 2:30pm, 14:30, or 230');
          return null;
        }
        
        // Round to nearest 30 minutes
        if(minutes < 15) minutes = 0;
        else if(minutes < 45) minutes = 30;
        else { minutes = 0; hours += 1; }
        
        if(hours >= 24) hours = hours % 24;
        
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
      }
      
      // Helper: Estimate drive time between two locations using coordinates
      function estimateDriveTime(fromLat, fromLon, toLat, toLon){
        if(!fromLat || !fromLon || !toLat || !toLon) return null;
        
        // Calculate straight-line distance (Haversine formula)
        const R = 6371; // Earth's radius in km
        const dLat = (toLat - fromLat) * Math.PI / 180;
        const dLon = (toLon - fromLon) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(fromLat * Math.PI / 180) * Math.cos(toLat * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distanceKm = R * c;
        
        // Estimate driving time: assume 1.4x straight-line distance for roads, average 80 km/h
        const drivingDistanceKm = distanceKm * 1.4;
        const hours = drivingDistanceKm / 80;
        
        // Round to nearest 30 minutes
        const roundedHours = Math.round(hours * 2) / 2;
        return roundedHours;
      }
      
      // Helper: Add hours to a time string
      function addHoursToTime(timeStr, hoursToAdd){
        if(!timeStr) return null;
        const [h, m] = timeStr.split(':').map(Number);
        let newHours = h + Math.floor(hoursToAdd);
        let newMinutes = m + ((hoursToAdd % 1) * 60);
        
        if(newMinutes >= 60){
          newHours += 1;
          newMinutes -= 60;
        }
        
        newHours = newHours % 24;
        return `${String(newHours).padStart(2, '0')}:${String(Math.round(newMinutes)).padStart(2, '0')}`;
      }
      
      // Save current date data before switching
      function saveCurrentDateData(){
        if(!selectedTourDateId) return;
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        // Save current setlist, stage, gig, gear, and tech notes to tour date
        tourDate.setlist = [...setlist];
        // Get stage from full editor if open, otherwise from stored SVG
        // SAFETY: Only save if has content - never overwrite existing data with blank
        const stageHTML = getStageHTML();
        if(stageHTML && stageHTML.length > 0){
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = stageHTML;
          const svg = tempDiv.querySelector('svg');
          const hasItems = svg ? svg.querySelectorAll('g[data-draggable]').length > 0 : false;
          if(hasItems || !tourDate.stage){
            tourDate.stage = stageHTML;
          }
        }
        // Sync gig details to tour date AND calendar fields
        tourDate.gig = {...gig};
        tourDate.venue = gig.venue || '';
        tourDate.address = gig.address || '';
        tourDate.band = gig.band || '';
        tourDate.loadIn = gig.loadIn || '';
        tourDate.showTime = gig.showTime || '';
        tourDate.gearSummary = gearSummary;
        tourDate.techNotes = techNotes;
        currentDateDirty = false;
      }
      
      // Load date data into current context
      function loadDateData(tourDate){
        if(!tourDate) return;
        
        // Restore setlist
        if(tourDate.setlist && Array.isArray(tourDate.setlist)){
          setlist = [...tourDate.setlist];
        } else {
          setlist = [];
        }
        
        // Restore stage - always load the date's stage (blank if no stage)
        const container = document.getElementById('stageStore');
        const fullSvg = document.getElementById('stageSvgFull');
        if(tourDate.stage && tourDate.stage.length > 0){
          // Has stage data - load it
          if(container){
            container.innerHTML = tourDate.stage;
            const svg = container.querySelector('svg');
            if(svg){
              svg.id = 'stageSvg';
              svg.classList.add('bw');
              try{ refreshCables(svg); }catch(e){}
            }
          }
          if(fullSvg){
            // Also update full editor if open
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = tourDate.stage;
            const srcSvg = tempDiv.querySelector('svg');
            if(srcSvg){
              // Clear existing draggables
              fullSvg.querySelectorAll('g[data-draggable]').forEach(n => n.remove());
              // Copy draggables from stored stage and enable drag
              srcSvg.querySelectorAll('g[data-draggable]').forEach(g => {
                const clone = g.cloneNode(true);
                fullSvg.appendChild(clone);
                if(typeof enableSvgDrag === 'function') enableSvgDrag(clone);
              });
              try{ refreshCables(fullSvg); }catch(e){}
              // Bind selection to the full SVG
              if(typeof bindSelection === 'function') bindSelection(fullSvg);
            }
          }
        } else {
          // No stage data - show blank stage
          if(container){
            container.innerHTML = '<svg id="stageSvg" class="bw" viewBox="0 0 500 300" xmlns="http://www.w3.org/2000/svg"><rect class="stage-bg" x="1" y="1" width="498" height="298"/><text x="250" y="40" text-anchor="middle" font-size="16" font-weight="bold" id="stageTitle">Band ‚Ä¢ Date</text></svg>';
          }
          if(fullSvg){
            // Clear all draggables from full editor
            fullSvg.querySelectorAll('g[data-draggable]').forEach(n => n.remove());
          }
        }
        
        // Restore gig data - but PRESERVE settings that should persist across all dates
        const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band) : gig.band;
        // Save settings that should persist across date changes (not per-date)
        const persistentSettings = {
          dbColumns: gig.dbColumns,
          customColumns: gig.customColumns,
          customMoods: gig.customMoods,
          customImages: gig.customImages,
          hiddenIcons: gig.hiddenIcons,
          font: gig.font,
          logo: gig.logo,
          headerFlags: gig.headerFlags,
          liveDark: gig.liveDark
        };
        if(tourDate.gig){
          gig = {...tourDate.gig};
        } else {
          gig.venue = tourDate.venue || '';
          gig.address = tourDate.address || '';
          gig.band = tourDate.band || '';
          gig.date = tourDate.date || '';
        }
        // Restore persistent settings that should NOT change per date
        Object.keys(persistentSettings).forEach(key => {
          if(persistentSettings[key] !== undefined) gig[key] = persistentSettings[key];
        });
        // Always use the Act selector band as authoritative source
        if(currentBandName) gig.band = currentBandName;
        
        // Restore gear and tech notes
        if(tourDate.gearSummary !== undefined){
          gearSummary = tourDate.gearSummary;
          const gearEl = document.getElementById('gear');
          if(gearEl) gearEl.value = gearSummary;
        } else {
          gearSummary = '';
          const gearEl = document.getElementById('gear');
          if(gearEl) gearEl.value = '';
        }
        
        if(tourDate.techNotes !== undefined){
          techNotes = typeof tourDate.techNotes === 'object' ? tourDate.techNotes : {};
        } else {
          techNotes = {};
        }
        
        // Update displays
        try{ renderDB(); buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(e){}
      }
      
      // Prompt for new tour date details
      function promptNewTourDate(dateStr){
        const typePrompt = 'What kind of day?\n\n1. Gig\n2. Drive\n3. Rest\n4. Home\n5. Rehearse\n6. Party\n7. Record\n8. Radio\n9. TV\n10. DJ\n11. Audition\n12. Dress Rehearsal\n13. Custom\n\nEnter number or name:';
        const typeInput = prompt(typePrompt, '1');
        if(!typeInput) return null;
        
        const typeMap = {
          '1': 'gig', 'gig': 'gig',
          '2': 'drive', 'drive': 'drive',
          '3': 'rest', 'rest': 'rest',
          '4': 'home', 'home': 'home',
          '5': 'rehearse', 'rehearse': 'rehearse',
          '6': 'party', 'party': 'party',
          '7': 'record', 'record': 'record',
          '8': 'radio', 'radio': 'radio',
          '9': 'tv', 'tv': 'tv',
          '10': 'dj', 'dj': 'dj',
          '11': 'audition', 'audition': 'audition',
          '12': 'dressrehearsal', 'dress rehearsal': 'dressrehearsal',
          '13': 'custom', 'custom': 'custom'
        };
        
        let finalType = typeMap[typeInput.toLowerCase()] || 'custom';
        let customLabel = '';
        
        if(finalType === 'custom'){
          customLabel = prompt('Enter custom day type:', '');
          if(!customLabel) return null;
        }
        
        let venue = '';
        let address = '';
        
        if(finalType === 'gig'){
          venue = prompt('Enter venue name:', '');
          if(!venue) return null;
          address = prompt('Enter venue address/city:', '');
        } else if(finalType === 'drive'){
          venue = 'Travel Day';
          address = prompt('Destination city:', '');
        } else if(finalType === 'rest'){
          venue = 'Rest Day';
          address = prompt('Hotel/Location:', '');
        } else if(finalType === 'home'){
          venue = 'Home';
          address = 'Home';
        } else {
          venue = customLabel || finalType.charAt(0).toUpperCase() + finalType.slice(1);
          address = prompt('Location:', '') || '';
        }
        
        const copyData = confirm('Copy current setlist and stage plot?\n\nOK = Copy current data\nCancel = Start fresh');
        
        const newDate = {
          id: generateId(),
          date: dateStr,
          venue: venue,
          address: address,
          city: address.split(',')[0].trim(), // Extract city from address
          loadIn: '',
          showTime: '',
          band: gig.band || '',
          setlist: copyData ? [...setlist] : [],
          stage: copyData ? getStageHTML() : '',
          gig: copyData ? {...gig, venue, address, date:dateStr} : {band:gig.band||'', venue, address, date:dateStr, contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[], hiddenIcons:[], liveDark:false},
          itinerary: [],
          tourType: finalType
        };
        
        return newDate;
      }
      
      // Drag state for date boxes
      let dragSourceBox = null;
      let dragSourceDate = null;
      let dragStartTime = 0;
      let dragHoldTimer = null;
      let isDragCopy = false;
      let dateHeaderInitialized = false; // Track if we've done initial scroll
      
      // Render global date header strip
      function renderDateHeader(preserveScroll = true){
        if(!dateBoxesContainer) return;
        
        // Save current scroll position before re-rendering
        const savedScrollLeft = preserveScroll ? dateBoxesContainer.scrollLeft : 0;
        
        dateBoxesContainer.innerHTML = '';
        const today = new Date();
        today.setHours(0,0,0,0);
        
        // Always generate 120 days for scrolling (30 days before today, 90 after)
        // But only 14 are visible at a time
        const daysToShow = 120;
        const daysBefore = 30; // Days to show before today
        
        // Calculate box width so exactly 14 fit in the container
        const containerWidth = dateBoxesContainer.offsetWidth || dateBoxesContainer.parentElement.offsetWidth || 1000;
        const gap = 4; // Gap between boxes
        const boxWidth = Math.floor((containerWidth - (13 * gap)) / 14); // 13 gaps between 14 boxes
        const finalBoxWidth = Math.max(boxWidth, 50); // Minimum 50px
        
        // Generate date range starting from daysBefore days ago
        const startDate = new Date(today);
        startDate.setDate(startDate.getDate() - daysBefore);
        
        for(let i = 0; i < daysToShow; i++){
          const date = new Date(startDate);
          date.setDate(date.getDate() + i);
          
          const dateStr = date.toISOString().split('T')[0];
          const tourDate = tourDates.find(td => td.date === dateStr);
          const isToday = date.getTime() === today.getTime();
          
          const box = document.createElement('div');
          box.className = 'date-box';
          box.style.width = finalBoxWidth + 'px';
          box.style.minWidth = finalBoxWidth + 'px';
          box.draggable = true;
          box.dataset.date = dateStr;
          
          // Dragstart: allow dragging date to another date
          box.addEventListener('dragstart', (e) => {
            if(tourDate){
              e.dataTransfer.setData('text/plain', 'dateTransfer');
              e.dataTransfer.setData('sourceDateStr', dateStr);
              e.dataTransfer.effectAllowed = 'copy';
              box.style.opacity = '0.5';
            } else {
              e.preventDefault();
            }
          });
          
          box.addEventListener('dragend', (e) => {
            box.style.opacity = '1';
          });
          
          // Drop handlers for setlist/stage plot assignment AND date transfer
          box.addEventListener('dragover', (e) => {
            const hasAssignType = e.dataTransfer.types.includes('assigntype') || e.dataTransfer.types.includes('text/plain');
            if(hasAssignType){
              e.preventDefault();
              e.dataTransfer.dropEffect = 'copy';
              box.style.outline = '3px solid #f59e0b';
              box.style.outlineOffset = '2px';
            }
          });
          
          box.addEventListener('dragleave', (e) => {
            box.style.outline = '';
            box.style.outlineOffset = '';
          });
          
          box.addEventListener('drop', (e) => {
            let assignType = e.dataTransfer.getData('assignType');
            if(!assignType) assignType = e.dataTransfer.getData('text/plain');
            
            // Handle date-to-date transfer
            if(assignType === 'dateTransfer'){
              const sourceDateStr = e.dataTransfer.getData('sourceDateStr');
              if(!sourceDateStr || sourceDateStr === dateStr) return;
              
              e.preventDefault();
              box.style.outline = '';
              box.style.outlineOffset = '';
              
              const sourceTd = tourDates.find(t => t.date === sourceDateStr);
              if(!sourceTd) return;
              
              // Prompt for what to copy
              const copyPrompt = prompt(
                'Copy from ' + new Date(sourceDateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + 
                ' to ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + 
                '\n\nEnter what to copy (comma-separated):\n' +
                '  set = Setlist\n' +
                '  plot = Stage Plot\n' +
                '  venue = Venue & Address\n' +
                '  times = Load-in & Show Time\n' +
                '  notes = Gear & Tech Notes\n' +
                '  all = Everything\n\n' +
                'Example: set, plot, times',
                'all'
              );
              if(!copyPrompt) return;
              
              const copyParts = copyPrompt.toLowerCase().split(',').map(s => s.trim());
              const copyAll = copyParts.includes('all');
              const copySet = copyAll || copyParts.includes('set') || copyParts.includes('setlist');
              const copyPlot = copyAll || copyParts.includes('plot') || copyParts.includes('stage');
              const copyVenue = copyAll || copyParts.includes('venue');
              const copyTimes = copyAll || copyParts.includes('times') || copyParts.includes('loadin') || copyParts.includes('load-in');
              const copyNotes = copyAll || copyParts.includes('notes') || copyParts.includes('gear') || copyParts.includes('tech');
              
              // Find or create target date
              let targetTd = tourDates.find(t => t.date === dateStr);
              if(!targetTd){
                targetTd = {
                  id: generateId(),
                  date: dateStr,
                  venue: '',
                  address: '',
                  loadIn: '',
                  showTime: '',
                  band: sourceTd.band || gig.band || '',
                  setlistType: 'custom',
                  stagePlotType: 'custom',
                  itinerary: [],
                  interests: [],
                  setlist: [],
                  stage: '',
                  gearSummary: '',
                  techNotes: {},
                  gig: {venue: '', address: '', band: sourceTd.band || '', date: dateStr}
                };
                tourDates.push(targetTd);
                tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
              }
              
              // Copy selected data
              if(copySet && sourceTd.setlist){
                targetTd.setlist = JSON.parse(JSON.stringify(sourceTd.setlist));
                targetTd.setlistType = 'custom';
              }
              if(copyPlot && sourceTd.stage){
                targetTd.stage = sourceTd.stage;
                targetTd.stagePlotType = 'custom';
              }
              if(copyVenue){
                targetTd.venue = sourceTd.venue || '';
                targetTd.address = sourceTd.address || '';
                if(targetTd.gig){
                  targetTd.gig.venue = targetTd.venue;
                  targetTd.gig.address = targetTd.address;
                }
              }
              if(copyTimes){
                targetTd.loadIn = sourceTd.loadIn || '';
                targetTd.showTime = sourceTd.showTime || '';
              }
              if(copyNotes){
                targetTd.gearSummary = sourceTd.gearSummary || '';
                targetTd.techNotes = JSON.parse(JSON.stringify(sourceTd.techNotes || {}));
              }
              
              // If venue not copied, prompt for it
              if(!copyVenue){
                const venueInput = prompt('Enter venue name for ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {month:'short', day:'numeric'}) + ' (or leave blank):', '');
                if(venueInput && venueInput.trim()){
                  targetTd.venue = venueInput.trim();
                  if(targetTd.gig) targetTd.gig.venue = venueInput.trim();
                }
                
                const addressInput = prompt('Enter venue address (optional):', '');
                if(addressInput && addressInput.trim()){
                  targetTd.address = addressInput.trim();
                  if(targetTd.gig) targetTd.gig.address = addressInput.trim();
                }
              }
              
              const copied = [];
              if(copySet) copied.push('Setlist');
              if(copyPlot) copied.push('Stage Plot');
              if(copyVenue) copied.push('Venue');
              if(copyTimes) copied.push('Times');
              if(copyNotes) copied.push('Notes');
              
              saveAll();
              renderDateHeader();
              alert('‚úì Copied ' + copied.join(', ') + ' to ' + new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric'}));
              return;
            }
            
            if(!assignType || (assignType !== 'setlist' && assignType !== 'stagePlot')) return;
            
            e.preventDefault();
            box.style.outline = '';
            box.style.outlineOffset = '';
            
            console.log('‚úì Drop detected:', assignType, 'on date:', dateStr);
            
            // Find or create tour date for this dateStr
            let td = tourDates.find(t => t.date === dateStr);
            const isNew = !td;
            
            if(!td){
              // Create new tour date
              td = {
                id: generateId(),
                date: dateStr,
                venue: '',
                address: '',
                loadIn: '',
                showTime: '',
                band: gig.band || '',
                setlistType: 'custom',
                stagePlotType: 'custom',
                itinerary: [],
                interests: [],
                setlist: [],
                stage: '',
                gearSummary: '',
                techNotes: {},
                gig: {venue: '', address: '', band: gig.band || '', date: dateStr}
              };
              tourDates.push(td);
              tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
            }
            
            // Assign setlist or stage plot (copy songs only)
            if(assignType === 'setlist'){
              td.setlist = JSON.parse(JSON.stringify(setlist));
              td.setlistType = 'custom';
            } else if(assignType === 'stagePlot'){
              // Get current stage plot HTML from the editor
              const currentStageHTML = getStageHTML();
              if(currentStageHTML && currentStageHTML.length > 0){
                td.stage = currentStageHTML;
                td.stagePlotType = 'custom';
              } else {
                alert('No stage plot to copy. Create a stage plot first.');
                return;
              }
            }
            
            // Save immediately
            saveAll();
            
            // Wizard: Prompt for gig details
            if(!td.venue || td.venue.trim() === ''){
              const venueInput = prompt('Step 1/5: Enter venue name:', '');
              if(venueInput && venueInput.trim()){
                td.venue = venueInput.trim();
                if(td.gig) td.gig.venue = venueInput.trim();
              }
            }
            
            if(!td.address || td.address.trim() === ''){
              const addressInput = prompt('Step 2/5: Enter venue address (optional):', '');
              if(addressInput && addressInput.trim()){
                td.address = addressInput.trim();
                if(td.gig) td.gig.address = addressInput.trim();
              }
            }
            
            if(!td.loadIn || td.loadIn.trim() === ''){
              const loadInInput = prompt('Step 3/5: Enter load-in time (e.g., 4pm):', '');
              if(loadInInput && loadInInput.trim()){
                td.loadIn = loadInInput.trim();
                if(td.gig) td.gig.loadIn = loadInInput.trim();
              }
            }
            
            if(!td.showTime || td.showTime.trim() === ''){
              const showTimeInput = prompt('Step 4/5: Enter start time (e.g., 7pm):', '');
              if(showTimeInput && showTimeInput.trim()){
                td.showTime = showTimeInput.trim();
                if(td.gig) td.gig.showTime = showTimeInput.trim();
              }
            }
            
            // Optional: Soundcheck/Load-out in notes or itinerary
            const additionalTimes = prompt('Step 5/5: Add soundcheck/load-out times? (e.g., "Soundcheck 5pm, Load-out 11pm") Leave blank to skip:', '');
            if(additionalTimes && additionalTimes.trim()){
              if(!td.gig) td.gig = {};
              if(!td.gig.notes) td.gig.notes = '';
              td.gig.notes += (td.gig.notes ? '\n' : '') + additionalTimes.trim();
            }
            
            // Sync times to itinerary
            syncTimesToItinerary(td);
            
            // Switch to this date and load it FIRST
            gig.date = dateStr;
            selectedTourDateId = td.id;
            
            // Update gig object with wizard values before loading
            gig.venue = td.venue || '';
            gig.address = td.address || '';
            gig.loadIn = td.loadIn || '';
            gig.showTime = td.showTime || '';
            gig.band = td.band || '';
            if(td.gig && td.gig.notes) gig.notes = td.gig.notes;
            
            // Save with all details
            saveAll();
            
            // Now load the date data (which will populate form fields from td)
            loadDateData(td);
            selectTourDate(td);
            renderDateHeader();
            
            // Stay on current tab and update display
            const currentTab = document.querySelector('.tab.active');
            if(currentTab && currentTab.dataset.tab === 'set'){
              // Rebuild sheet with updated gig info
              buildSheet('sheetInline');
              attachPreviewInteractions();
            }
            
            const dateDisplay = new Date(dateStr + 'T12:00:00').toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric'});
            alert(`‚úì ${assignType === 'setlist' ? 'Setlist' : 'Stage plot'} assigned to ${dateDisplay}\n\nVenue: ${td.venue || 'Not set'}\nAddress: ${td.address || 'Not set'}\nLoad-in: ${td.loadIn || 'Not set'}\nStart: ${td.showTime || 'Not set'}`);
            console.log(`‚úì ${assignType} assigned to ${dateDisplay}`);
          });
          
          // Mark active if matches gig.date
          if(gig.date && dateStr === gig.date){
            box.classList.add('active');
          }
          
          // Check if this is today (isToday already defined above)
          const isPast = date < today && !isToday;
          
          // Apply status-based coloring for dates with data
          if(tourDate){
            if(tourDate.tourType === 'cancelled'){
              box.classList.add('status-cancelled');
            } else if(isToday){
              box.classList.add('status-today');
            } else if(isPast){
              box.classList.add('status-past');
            } else {
              // Check completion: has venue AND (has setlist OR has stage plot)
              const hasVenue = tourDate.venue && tourDate.venue.trim() !== '';
              const hasSetlist = tourDate.setlist && tourDate.setlist.length > 0;
              const hasStagePlot = tourDate.stage && tourDate.stage.trim() !== '';
              
              if(hasVenue && (hasSetlist || hasStagePlot)){
                box.classList.add('status-complete');
              } else if(hasVenue || hasSetlist || hasStagePlot){
                box.classList.add('status-incomplete');
              }
            }
            
            // Apply tour type styling (for non-gig types)
            if(tourDate.tourType && tourDate.tourType !== 'gig'){
              box.classList.add(`tour-${tourDate.tourType}`);
            }
          }
          
          const dayNum = date.getDate();
          const monthAbbr = date.toLocaleDateString('en-US', {month:'short'});
          
          let contentHtml = '';
          if(tourDate && tourDate.tourType){
            const tourType = tourDate.tourType;
            const iconMap = {
              'gig': '',
              'drive': 'üöö',
              'rest': 'üõèÔ∏è',
              'home': 'üè†',
              'rehearse': 'üéµ',
              'party': 'üéâ',
              'record': 'üéôÔ∏è',
              'radio': 'üìª',
              'tv': 'üì∫',
              'dj': 'üéß',
              'audition': 'üé≠',
              'dressrehearsal': 'üëî',
              'custom': '‚≠ê'
            };
            
            const icon = iconMap[tourType] || '';
            
            if(tourType === 'gig' && tourDate.venue){
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-city">${tourDate.venue.substring(0, 8)}</span>`;
            } else if(tourType === 'drive' || tourType === 'rest' || tourType === 'home'){
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-icon">${icon}</span>`;
            } else {
              contentHtml = `<span class="date-num">${dayNum}</span><span class="date-city">${tourDate.venue || tourType}</span>`;
            }
          } else {
            contentHtml = `<span class="date-num">${dayNum}</span><span class="date-month">${monthAbbr}</span>`;
          }
          
          box.innerHTML = contentHtml;
          
          // Single click: preview only and center on selected date
          box.addEventListener('click', (e) => {
            if(e.defaultPrevented) return;
            
            const td = tourDates.find(t => t.date === dateStr);
            
            if(td){
              // Preview existing date
              if(currentDateDirty && selectedTourDateId){
                if(confirm('You have unsaved changes. Save before switching dates?')){
                  saveCurrentDateData();
                  saveAll();
                }
              }
              
              if(selectedTourDateId){
                saveCurrentDateData();
              }
              
              gig.date = dateStr;
              selectedTourDateId = td.id;
              loadDateData(td);
              selectTourDate(td);
              
              // Update boxes and center on selected date (don't preserve scroll)
              renderDateHeader(false);
              saveAll();
              
              // Reload current tab's data for this date
              const currentTab = document.querySelector('.tab.active');
              if(currentTab){
                const tabName = currentTab.dataset.tab;
                if(tabName === 'set'){
                  // Reload setlist preview
                  buildSheet('sheetInline');
                  attachPreviewInteractions();
                  renderSongPool();
                } else if(tabName === 'adv'){
                  // Reload stage plot if in stage view
                  const stageModal = document.getElementById('stageModal');
                  if(stageModal && stageModal.classList.contains('open')){
                    try{ closeStageModal(); openStageModal(); }catch(e){ console.log('Stage reload:', e); }
                  }
                } else if(tabName === 'live'){
                  // Reload Live Mode with new day's setlist
                  try{ if(typeof renderLive === 'function') renderLive(); }catch(e){ console.log('Live reload:', e); }
                }
                // For other tabs, data is already loaded by loadDateData
              }
            } else {
              // Blank date - prompt to create new entry
              const td = promptNewTourDate(dateStr);
              if(!td) {
                // User cancelled - just preview as FREE day without creating
                gig.date = dateStr;
                selectedTourDateId = null;
                gig.venue = '';
                gig.address = '';
                gig.loadIn = '';
                gig.showTime = '';
                gig.notes = '';
                try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(e){}
                renderDateHeader(false);
                return;
              }
              
              // Create the new tour date
              tourDates.push(td);
              tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
              
              gig.date = dateStr;
              selectedTourDateId = td.id;
              loadDateData(td);
              selectTourDate(td);
              
              renderDateHeader(false);
              saveAll();
              
              // Update current tab
              const currentTab = document.querySelector('.tab.active');
              if(currentTab){
                const tabName = currentTab.dataset.tab;
                if(tabName === 'set'){
                  buildSheet('sheetInline');
                  attachPreviewInteractions();
                  renderSongPool();
                } else if(tabName === 'live'){
                  // Reload Live Mode with new day's setlist
                  try{ if(typeof renderLive === 'function') renderLive(); }catch(e){ console.log('Live reload:', e); }
                }
              }
            }
          });
          
          // Double click: edit existing date (same as click for blank)
          box.addEventListener('dblclick', (e) => {
            e.preventDefault();
            
            let td = tourDates.find(t => t.date === dateStr);
            
            if(!td){
              // Already handled by click - create new date
              return;
            }
            
            // Edit existing date - just select it (click already does this)
            gig.date = dateStr;
            selectedTourDateId = td.id;
            loadDateData(td);
            selectTourDate(td);
            renderDateHeader();
            saveAll();
          });
          
          // Long press for context menu
          let longPressTimer = null;
          let longPressTriggered = false;
          
          box.addEventListener('mousedown', (e) => {
            if(e.button !== 0) return; // Only left click
            longPressTriggered = false;
            longPressTimer = setTimeout(() => {
              longPressTriggered = true;
              showDateContextMenu(e.clientX, e.clientY, dateStr, box);
            }, 600); // 600ms hold
          });
          
          box.addEventListener('mouseup', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          box.addEventListener('mouseleave', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          box.addEventListener('touchstart', (e) => {
            longPressTriggered = false;
            longPressTimer = setTimeout(() => {
              longPressTriggered = true;
              const touch = e.touches[0];
              showDateContextMenu(touch.clientX, touch.clientY, dateStr, box);
            }, 600);
          });
          
          box.addEventListener('touchend', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          box.addEventListener('touchmove', () => {
            if(longPressTimer){
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
          });
          
          dateBoxesContainer.appendChild(box);
        }
        
        // Center the active date box in the container
        function centerActiveDate(){
          const activeBox = dateBoxesContainer.querySelector('.date-box.active');
          if(activeBox){
            const containerWidth = dateBoxesContainer.offsetWidth;
            const boxLeft = activeBox.offsetLeft;
            const boxWidth = activeBox.offsetWidth;
            // Center the active box in the container
            const scrollTo = boxLeft - (containerWidth / 2) + (boxWidth / 2);
            dateBoxesContainer.scrollLeft = Math.max(0, scrollTo);
          }
        }
        
        // Handle scrolling: restore position, center active date, or scroll to today on first load
        setTimeout(() => {
          if(preserveScroll && savedScrollLeft > 0){
            // Restore previous scroll position
            dateBoxesContainer.scrollLeft = savedScrollLeft;
          } else if(gig.date){
            // Center the active/selected date
            centerActiveDate();
            dateHeaderInitialized = true;
          } else if(!dateHeaderInitialized){
            // First load with no selection - scroll to today
            const todayBox = dateBoxesContainer.querySelector(`[data-date="${today.toISOString().split('T')[0]}"]`);
            if(todayBox){
              const containerWidth = dateBoxesContainer.offsetWidth;
              const boxLeft = todayBox.offsetLeft;
              const boxWidth = todayBox.offsetWidth;
              const scrollTo = boxLeft - (containerWidth / 2) + (boxWidth / 2);
              dateBoxesContainer.scrollLeft = Math.max(0, scrollTo);
            }
            dateHeaderInitialized = true;
          }
        }, 50);
      }
      
      // Context menu for date boxes
      function showDateContextMenu(x, y, dateStr, box){
        // Remove any existing menu
        const existing = document.querySelector('.date-context-menu');
        if(existing) existing.remove();
        
        const menu = document.createElement('div');
        menu.className = 'date-context-menu';
        
        const td = tourDates.find(t => t.date === dateStr);
        const [year, month, day] = dateStr.split('-');
        const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
        const displayDate = dateObj.toLocaleDateString('en-US', {weekday:'long', month:'long', day:'numeric', year:'numeric'});
        
        // Create/Edit Event
        const createBtn = document.createElement('button');
        createBtn.innerHTML = td ? '‚úèÔ∏è Edit Event' : '‚ûï Create Event';
        createBtn.onclick = () => {
          menu.remove();
          if(!td){
            const newTd = promptNewTourDate(dateStr);
            if(!newTd) return;
            tourDates.push(newTd);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
          }
          const tourDate = tourDates.find(t => t.date === dateStr);
          if(tourDate){
            gig.date = dateStr;
            selectedTourDateId = tourDate.id;
            loadDateData(tourDate);
            selectTourDate(tourDate);
            renderDateHeader();
            saveAll();
          }
        };
        menu.appendChild(createBtn);
        
        if(td){
          // Duplicate
          const dupBtn = document.createElement('button');
          dupBtn.innerHTML = 'üìã Duplicate to...';
          dupBtn.onclick = () => {
            menu.remove();
            const targetDate = prompt('Enter target date (YYYY-MM-DD):');
            if(!targetDate) return;
            
            const copiedDate = {
              id: generateId(),
              date: targetDate,
              venue: td.venue,
              address: td.address,
              city: td.city || '',
              tourType: td.tourType || 'gig',
              loadIn: td.loadIn || '',
              showTime: td.showTime || '',
              band: td.band || '',
              setlistType: td.setlistType || 'current',
              stagePlotType: td.stagePlotType || 'current',
              setlist: td.setlist ? JSON.parse(JSON.stringify(td.setlist)) : [],
              stage: td.stage || '',
              gig: td.gig ? JSON.parse(JSON.stringify(td.gig)) : null,
              itinerary: td.itinerary ? JSON.parse(JSON.stringify(td.itinerary)) : [],
              interests: td.interests ? JSON.parse(JSON.stringify(td.interests)) : [],
              chipData: td.chipData || null
            };
            
            if(copiedDate.gig) copiedDate.gig.date = targetDate;
            tourDates.push(copiedDate);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
            renderDateHeader();
            saveAll();
            alert(`Duplicated to ${targetDate}`);
          };
          menu.appendChild(dupBtn);
          
          // Cancel (mark as cancelled)
          const cancelBtn = document.createElement('button');
          const isCancelled = td.tourType === 'cancelled';
          cancelBtn.innerHTML = isCancelled ? '‚úÖ Restore Show' : '‚ùå Cancel Show';
          cancelBtn.onclick = () => {
            menu.remove();
            if(isCancelled){
              td.tourType = 'gig';
            } else {
              if(confirm(`Mark ${displayDate} as CANCELLED?\n\nThe date will remain in your calendar but marked as cancelled.`)){
                td.tourType = 'cancelled';
              }
            }
            renderDateHeader();
            saveAll();
          };
          menu.appendChild(cancelBtn);
          
          // Print
          const printBtn = document.createElement('button');
          printBtn.innerHTML = 'üñ®Ô∏è Print';
          printBtn.onclick = () => {
            menu.remove();
            // Load this date's data and trigger print
            gig.date = dateStr;
            selectedTourDateId = td.id;
            loadDateData(td);
            selectTourDate(td);
            renderDateHeader();
            saveAll();
            // Trigger print after a brief delay to ensure rendering
            setTimeout(() => {
              window.print();
            }, 100);
          };
          menu.appendChild(printBtn);
          
          // Delete
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.innerHTML = 'üóëÔ∏è Delete';
          delBtn.onclick = () => {
            menu.remove();
            if(confirm(`Delete tour date ${displayDate}?`)){
              const idx = tourDates.findIndex(t => t.date === dateStr);
              if(idx !== -1){
                tourDates.splice(idx, 1);
                if(selectedTourDateId === td.id){
                  selectedTourDateId = null;
                  selectTourDate(null);
                }
                saveAll();
                renderDateHeader();
                renderTimeline();
              }
            }
          };
          menu.appendChild(delBtn);
        }
        
        // Cancel button
        const cancelMenuBtn = document.createElement('button');
        cancelMenuBtn.innerHTML = '‚ùå Cancel';
        cancelMenuBtn.onclick = () => menu.remove();
        menu.appendChild(cancelMenuBtn);
        
        // Position menu
        document.body.appendChild(menu);
        const rect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        let left = x;
        let top = y;
        
        // Adjust if menu goes off-screen
        if(left + rect.width > viewportWidth) left = viewportWidth - rect.width - 10;
        if(top + rect.height > viewportHeight) top = viewportHeight - rect.height - 10;
        if(left < 10) left = 10;
        if(top < 10) top = 10;
        
        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
        
        // Close menu when clicking outside (after 3s delay so users can tap)
        setTimeout(() => {
          const closeHandler = (e) => {
            if(!menu.contains(e.target)){
              menu.remove();
              document.removeEventListener('click', closeHandler);
            }
          };
          document.addEventListener('click', closeHandler);
        }, 3000);
      }
      
      // Act selector - click to show band preset dropdown
      const actSelector = document.getElementById('actSelector');
      if(actSelector){
        // Update display with current band
        function updateActDisplay(){
          const bandName = gig.band && gig.band.trim() && gig.band.trim() !== 'Enter Band Name' ? gig.band : null;
          if(bandName){
            actSelector.textContent = bandName;
            actSelector.style.color = '#60a5fa'; // Bright blue
          } else {
            actSelector.textContent = 'Select Band...';
            actSelector.style.color = '#94a3b8'; // Gray
          }
        }
        updateActDisplay();
        
        // Make globally accessible
        window.updateActDisplay = updateActDisplay;
        
        actSelector.addEventListener('click', (e)=>{
          e.stopPropagation();
          // Show dropdown of band presets
          let dropdown = document.getElementById('actDropdown');
          if(dropdown){
            dropdown.remove();
            return;
          }
          
          // Get position of selector for dropdown placement
          const rect = actSelector.getBoundingClientRect();
          
          dropdown = document.createElement('div');
          dropdown.id = 'actDropdown';
          dropdown.style.cssText = `position:fixed;top:${rect.bottom + 4}px;left:${rect.left}px;background:white;border:1px solid #d1d5db;border-radius:6px;box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:99999;min-width:180px;max-height:300px;overflow-y:auto`;
          
          // Add "New Band" option
          const newOpt = document.createElement('div');
          newOpt.textContent = '‚ûï Add New Band...';
          newOpt.style.cssText = 'padding:10px 14px;cursor:pointer;font-size:13px;border-bottom:1px solid #e5e7eb;color:#059669;font-weight:500';
          newOpt.addEventListener('mouseenter', ()=> newOpt.style.background = '#f0fdf4');
          newOpt.addEventListener('mouseleave', ()=> newOpt.style.background = '');
          newOpt.addEventListener('click', ()=>{
            dropdown.remove();
            showBandPresetModal();
          });
          dropdown.appendChild(newOpt);
          
          // List existing presets
          if(bandPresets.length > 0){
            bandPresets.forEach(bp => {
              const opt = document.createElement('div');
              opt.textContent = bp.name;
              opt.style.cssText = 'padding:10px 14px;cursor:pointer;font-size:13px;' + (currentBandPresetId === bp.id ? 'background:#e0f2fe;font-weight:600' : '');
              opt.addEventListener('mouseenter', ()=> opt.style.background = currentBandPresetId === bp.id ? '#bae6fd' : '#f1f5f9');
              opt.addEventListener('mouseleave', ()=> opt.style.background = currentBandPresetId === bp.id ? '#e0f2fe' : '');
              opt.addEventListener('click', ()=>{
                gig.band = bp.name;
                currentBandPresetId = bp.id;
                updateActDisplay();
                // Update ALL UI elements with band name
                const sheetBandEl = document.querySelector('.header .band');
                if(sheetBandEl) sheetBandEl.textContent = bp.name;
                const calBandInput = document.getElementById('tourBand');
                if(calBandInput) calBandInput.value = bp.name;
                const tourDate = tourDates.find(td => td.id === selectedTourDateId);
                if(tourDate) tourDate.band = bp.name;
                if(typeof updateBandPresetDropdown === 'function') updateBandPresetDropdown();
                // Refresh stage plot header
                if(typeof refreshStageHeader === 'function') refreshStageHeader();
                saveAll();
                dropdown.remove();
                try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
              });
              dropdown.appendChild(opt);
            });
          } else {
            const empty = document.createElement('div');
            empty.textContent = 'No bands saved yet';
            empty.style.cssText = 'padding:10px 14px;color:#94a3b8;font-size:12px;font-style:italic';
            dropdown.appendChild(empty);
          }
          
          document.body.appendChild(dropdown);
          
          // Close on outside click
          setTimeout(()=>{
            document.addEventListener('click', function closeDropdown(e){
              if(!dropdown.contains(e.target) && e.target !== actSelector){
                dropdown.remove();
                document.removeEventListener('click', closeDropdown);
              }
            });
          }, 10);
        });
      }
      
      // Context menu for date boxes
      function showDateContextMenu(x, y, dateStr, box){
        // Remove any existing menu
        const existing = document.querySelector('.date-context-menu');
        if(existing) existing.remove();
        
        const menu = document.createElement('div');
        menu.className = 'date-context-menu';
        
        const td = tourDates.find(t => t.date === dateStr);
        const [year, month, day] = dateStr.split('-');
        const dateObj = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
        const displayDate = dateObj.toLocaleDateString('en-US', {weekday:'long', month:'long', day:'numeric', year:'numeric'});
        
        // Create/Edit Event
        const createBtn = document.createElement('button');
        createBtn.innerHTML = td ? '‚úèÔ∏è Edit Event' : '‚ûï Create Event';
        createBtn.onclick = () => {
          menu.remove();
          if(!td){
            const newTd = promptNewTourDate(dateStr);
            if(!newTd) return;
            tourDates.push(newTd);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
          }
          const tourDate = tourDates.find(t => t.date === dateStr);
          if(tourDate){
            gig.date = dateStr;
            selectedTourDateId = tourDate.id;
            loadDateData(tourDate);
            selectTourDate(tourDate);
            renderDateHeader();
            saveAll();
          }
        };
        menu.appendChild(createBtn);
        
        if(td){
          // Duplicate
          const dupBtn = document.createElement('button');
          dupBtn.innerHTML = 'üìã Duplicate to...';
          dupBtn.onclick = () => {
            menu.remove();
            const targetDate = prompt('Enter target date (YYYY-MM-DD):');
            if(!targetDate) return;
            
            const copiedDate = {
              id: generateId(),
              date: targetDate,
              venue: td.venue,
              address: td.address,
              city: td.city || '',
              tourType: td.tourType || 'gig',
              loadIn: td.loadIn || '',
              showTime: td.showTime || '',
              band: td.band || '',
              setlistType: td.setlistType || 'current',
              stagePlotType: td.stagePlotType || 'current',
              setlist: td.setlist ? JSON.parse(JSON.stringify(td.setlist)) : [],
              stage: td.stage || '',
              gig: td.gig ? JSON.parse(JSON.stringify(td.gig)) : null,
              itinerary: td.itinerary ? JSON.parse(JSON.stringify(td.itinerary)) : [],
              interests: td.interests ? JSON.parse(JSON.stringify(td.interests)) : [],
              chipData: td.chipData || null
            };
            
            if(copiedDate.gig) copiedDate.gig.date = targetDate;
            tourDates.push(copiedDate);
            tourDates.sort((a,b) => new Date(a.date) - new Date(b.date));
            renderDateHeader();
            saveAll();
            alert(`Duplicated to ${targetDate}`);
          };
          menu.appendChild(dupBtn);
          
          // Cancel (mark as cancelled)
          const cancelBtn = document.createElement('button');
          const isCancelled = td.tourType === 'cancelled';
          cancelBtn.innerHTML = isCancelled ? '‚úÖ Restore Show' : '‚ùå Cancel Show';
          cancelBtn.onclick = () => {
            menu.remove();
            if(isCancelled){
              td.tourType = 'gig';
            } else {
              if(confirm(`Mark ${displayDate} as CANCELLED?\n\nThe date will remain in your calendar but marked as cancelled.`)){
                td.tourType = 'cancelled';
              }
            }
            renderDateHeader();
            saveAll();
          };
          menu.appendChild(cancelBtn);
          
          // Print
          const printBtn = document.createElement('button');
          printBtn.innerHTML = 'üñ®Ô∏è Print';
          printBtn.onclick = () => {
            menu.remove();
            // Load this date's data and trigger print
            gig.date = dateStr;
            selectedTourDateId = td.id;
            loadDateData(td);
            selectTourDate(td);
            renderDateHeader();
            saveAll();
            // Trigger print after a brief delay to ensure rendering
            setTimeout(() => {
              window.print();
            }, 100);
          };
          menu.appendChild(printBtn);
          
          // Delete
          const delBtn = document.createElement('button');
          delBtn.className = 'danger';
          delBtn.innerHTML = 'üóëÔ∏è Delete';
          delBtn.onclick = () => {
            menu.remove();
            if(confirm(`Delete tour date ${displayDate}?`)){
              const idx = tourDates.findIndex(t => t.date === dateStr);
              if(idx !== -1){
                tourDates.splice(idx, 1);
                if(selectedTourDateId === td.id){
                  selectedTourDateId = null;
                  selectTourDate(null);
                }
                saveAll();
                renderDateHeader();
                renderTimeline();
              }
            }
          };
          menu.appendChild(delBtn);
        }
        
        // Cancel button
        const cancelMenuBtn = document.createElement('button');
        cancelMenuBtn.innerHTML = '‚ùå Cancel';
        cancelMenuBtn.onclick = () => menu.remove();
        menu.appendChild(cancelMenuBtn);
        
        // Position menu
        document.body.appendChild(menu);
        const rect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        let left = x;
        let top = y;
        
        // Adjust if menu goes off-screen
        if(left + rect.width > viewportWidth) left = viewportWidth - rect.width - 10;
        if(top + rect.height > viewportHeight) top = viewportHeight - rect.height - 10;
        if(left < 10) left = 10;
        if(top < 10) top = 10;
        
        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
        
        // Close menu when clicking outside (after 3s delay so users can tap)
        setTimeout(() => {
          const closeHandler = (e) => {
            if(!menu.contains(e.target)){
              menu.remove();
              document.removeEventListener('click', closeHandler);
            }
          };
          document.addEventListener('click', closeHandler);
        }, 3000);
      }
      
      // Render timeline based on view mode
      function renderTimeline(){
        if(!tourTimeline) return;
        tourTimeline.innerHTML = '';
        
        const today = new Date();
        today.setHours(0,0,0,0);
        
        let dates = [];
        const anchor = new Date(tourViewDate);
        anchor.setHours(0,0,0,0);
        
        if(tourViewMode === 'week'){
          // Show 7 days starting from anchor (Monday-Sunday)
          const dayOfWeek = anchor.getDay();
          const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
          anchor.setDate(anchor.getDate() + mondayOffset);
          
          for(let i=0; i<7; i++){
            const d = new Date(anchor);
            d.setDate(d.getDate() + i);
            dates.push(d);
          }
          
          const weekStart = dates[0].toLocaleDateString('en-US', {month:'short', day:'numeric'});
          const weekEnd = dates[6].toLocaleDateString('en-US', {month:'short', day:'numeric', year:'numeric'});
          if(tourPeriodLabel) tourPeriodLabel.textContent = `${weekStart} - ${weekEnd}`;
          
        } else if(tourViewMode === 'month'){
          // Show all days in month
          const year = anchor.getFullYear();
          const month = anchor.getMonth();
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          
          for(let i=1; i<=daysInMonth; i++){
            dates.push(new Date(year, month, i));
          }
          
          if(tourPeriodLabel) tourPeriodLabel.textContent = anchor.toLocaleDateString('en-US', {month:'long', year:'numeric'});
          
        } else if(tourViewMode === 'year'){
          // Show 12 months
          const year = anchor.getFullYear();
          for(let m=0; m<12; m++){
            dates.push(new Date(year, m, 1));
          }
          
          if(tourPeriodLabel) tourPeriodLabel.textContent = year.toString();
        }
        
        // Render date tabs
        dates.forEach(date => {
          const dateStr = date.toISOString().split('T')[0];
          const hasGig = tourDates.some(td => td.date === dateStr);
          const isSelected = selectedTourDateId && tourDates.find(td => td.id === selectedTourDateId && td.date === dateStr);
          const isToday = date.getTime() === today.getTime();
          
          const tab = document.createElement('button');
          tab.className = 'tour-date-tab';
          tab.style.cssText = 'min-width:60px;padding:8px 12px;border:1px solid #d1d5db;border-radius:4px;background:#fff;cursor:pointer;display:flex;flex-direction:column;align-items:center;gap:2px;font-size:12px;transition:all 0.2s';
          
          if(isSelected){
            tab.style.background = '#0ea5e9';
            tab.style.color = '#fff';
            tab.style.borderColor = '#0284c7';
          } else if(hasGig){
            tab.style.background = '#f0f9ff';
            tab.style.borderColor = '#0ea5e9';
          }
          
          if(isToday){
            tab.style.fontWeight = 'bold';
            tab.style.boxShadow = '0 0 0 2px #fbbf24';
          }
          
          const dayName = tourViewMode === 'year' ? date.toLocaleDateString('en-US', {month:'short'}) : date.toLocaleDateString('en-US', {weekday:'short'});
          const dayNum = tourViewMode === 'year' ? '' : date.getDate();
          
          tab.innerHTML = `<span style="font-size:10px;color:${isSelected?'#fff':'#64748b'}">${dayName}</span>${dayNum ? `<span style="font-size:14px;font-weight:600">${dayNum}</span>` : ''}${hasGig ? '<span style="font-size:16px">üéµ</span>' : ''}`;
          
          tab.addEventListener('click', () => {
            const existing = tourDates.find(td => td.date === dateStr);
            if(existing){
              selectTourDate(existing);
            } else {
              // Save current date before creating new one
              if(selectedTourDateId){
                saveCurrentDateData();
              }
              
              // Get current band from Act selector (authoritative source)
              const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || '') : (gig.band || '');
              
              // Create new BLANK date - user will fill in details
              const newDate = {
                id: generateId(),
                date: dateStr,
                venue: '',
                address: '',
                loadIn: '',
                showTime: '',
                band: currentBandName,
                setlistType: 'current',
                stagePlotType: 'current',
                itinerary: [],
                interests: [],
                setlist: [],
                stage: '',
                gearSummary: '',
                techNotes: {},
                gig: {venue:'', address:'', band: currentBandName, date:dateStr}
              };
              
              tourDates.push(newDate);
              selectTourDate(newDate);
              saveAll();
              renderTimeline();
            }
          });
          
          tourTimeline.appendChild(tab);
        });
      }
      
      // Select a tour date
      function selectTourDate(tourDate){
        // Save current date data before switching
        if(selectedTourDateId){
          saveCurrentDateData();
        }
        
        if(!tourDate || !tourDate.id){
          selectedTourDateId = null;
          if(tourNoSelection) tourNoSelection.style.display = '';
          if(tourDateDetails) tourDateDetails.style.display = 'none';
          if(tourItineraryContent) tourItineraryContent.style.display = 'none';
          return;
        }
        
        selectedTourDateId = tourDate.id;
        
        // Load the new date's data
        loadDateData(tourDate);
        
        // Rebuild sheet with new date's gig data (band name, venue, etc.)
        try{ buildSheet('sheetInline'); attachPreviewInteractions(); }catch(_){}
        
        if(tourNoSelection) tourNoSelection.style.display = 'none';
        if(tourDateDetails) tourDateDetails.style.display = '';
        if(tourItineraryContent) tourItineraryContent.style.display = '';
        
        // Populate form
        if(tourDateInput) tourDateInput.value = tourDate.date || '';
        if(tourVenueInput) tourVenueInput.value = tourDate.venue || '';
        if(tourAddressInput) tourAddressInput.value = tourDate.address || '';
        // Only set time inputs if value is valid HH:mm format (prevents console warnings)
        const validTimeFormat = /^\d{2}:\d{2}$/;
        if(tourLoadInInput) tourLoadInInput.value = (tourDate.loadIn && validTimeFormat.test(tourDate.loadIn)) ? tourDate.loadIn : '';
        if(tourShowTimeInput) tourShowTimeInput.value = (tourDate.showTime && validTimeFormat.test(tourDate.showTime)) ? tourDate.showTime : '';
        if(tourBandInput) tourBandInput.value = tourDate.band || gig.band || '';
        if(tourSetlistSelect) tourSetlistSelect.value = tourDate.setlistType || 'current';
        if(tourStagePlotSelect) tourStagePlotSelect.value = tourDate.stagePlotType || 'current';
        
        renderItinerary(tourDate);
        renderTimeline();
        renderDateHeader();
        renderTourPreviews(tourDate);
        renderAdjacentDays(tourDate);
        
        // Update large header display
        const headerDate = document.getElementById('tourHeaderDate');
        const headerVenue = document.getElementById('tourHeaderVenue');
        if(headerDate && tourDate.date){
          const dateObj = new Date(tourDate.date + 'T12:00:00');
          headerDate.textContent = dateObj.toLocaleDateString('en-US', {weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'});
        }
        if(headerVenue){
          headerVenue.textContent = tourDate.venue || 'No venue set';
        }
        
        // Reload map from venue address (prefer tourDate.address, fallback to gig.address)
        const addressToUse = tourDate.address || gig.address || '';
        if(addressToUse && addressToUse.trim()){
          loadMap(addressToUse);
        }
      }
      
      // Render setlist and stage previews - shows tour date specific data
      function renderTourPreviews(tourDate){
        const setlistPreview = document.getElementById('tourSetlistPreview');
        const stagePreview = document.getElementById('tourStagePreview');
        
        // Setlist preview - show tour date's setlist (or current if selected)
        if(setlistPreview){
          const dateSetlist = (tourDate && tourDate.id === selectedTourDateId) ? setlist : (tourDate?.setlist || []);
          if(dateSetlist && dateSetlist.length){
            setlistPreview.innerHTML = dateSetlist.map((song, idx) => 
              `<div style="padding:4px 0;border-bottom:1px solid #f3f4f6">${idx + 1}. <strong>${song.title || 'Untitled'}</strong> ${song.band ? `<span style="color:#64748b;font-size:10px">‚Äî ${song.band}</span>` : ''}</div>`
            ).join('');
          } else {
            setlistPreview.innerHTML = '<div style="color:#64748b;font-size:11px">No setlist</div>';
          }
          
          // Double-click to edit
          setlistPreview.parentElement.ondblclick = () => {
            document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
            const setTab = document.querySelector('.tab[data-tab="set"]');
            if(setTab) setTab.classList.add('active');
            ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
            const setEl = document.getElementById('set');
            if(setEl) setEl.style.display='block';
          };
        }
        
        // Stage preview - show tour date's stage plot
        if(stagePreview){
          // Get stage from tour date or current DOM if selected
          let stageHTML = null;
          if(tourDate && tourDate.id === selectedTourDateId){
            const storedSvg = document.getElementById('stageSvg') || document.getElementById('stageSvgFull');
            stageHTML = storedSvg ? storedSvg.outerHTML : tourDate.stage;
          } else {
            stageHTML = tourDate?.stage;
          }
          
          if(stageHTML){
            // Parse and scale it down for preview
            try {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = stageHTML;
              const svg = tempDiv.querySelector('svg');
              if(svg){
                svg.style.width = '100%';
                svg.style.maxWidth = '100%';
                svg.style.height = 'auto';
                svg.removeAttribute('id');
                stagePreview.innerHTML = svg.outerHTML;
              } else {
                stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
              }
            } catch(err) {
              console.error('Error rendering stage:', err);
              stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
            }
          } else {
            stagePreview.innerHTML = '<div style="color:#64748b;font-size:10px">No stage plot</div>';
          }
          
          // Double-click to edit
          stagePreview.parentElement.ondblclick = () => {
            document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
            const stageTab = document.querySelector('.tab[data-tab="adv"]');
            if(stageTab) stageTab.classList.add('active');
            ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
            const advEl = document.getElementById('adv');
            if(advEl) advEl.style.display='block';
            // Open stage modal
            const stageModal = document.getElementById('stageModal');
            if(stageModal && !stageModal.classList.contains('open')){
              toggleStageAndNotes();
            }
          };
        }
      }
      
      // Render yesterday and tomorrow cards
      function renderAdjacentDays(tourDate){
        if(!tourDate) return;
        
        const yesterdayDiv = document.getElementById('tourYesterday');
        const tomorrowDiv = document.getElementById('tourTomorrow');
        
        if(!yesterdayDiv || !tomorrowDiv) return;
        
        const currentDate = new Date(tourDate.date + 'T12:00:00');
        
        // Yesterday
        const yesterday = new Date(currentDate);
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toISOString().split('T')[0];
        const yesterdayTour = tourDates.find(td => td.date === yesterdayStr);
        
        const yesterdayDateEl = document.getElementById('tourYesterdayDate');
        const yesterdayVenueEl = document.getElementById('tourYesterdayVenue');
        if(yesterdayDateEl) yesterdayDateEl.textContent = yesterday.toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'});
        if(yesterdayVenueEl) yesterdayVenueEl.textContent = yesterdayTour ? (yesterdayTour.venue || 'No venue') : 'No event';
        
        yesterdayDiv.onclick = () => {
          if(yesterdayTour){
            // Save current before switching
            if(selectedTourDateId && selectedTourDateId !== yesterdayTour.id){
              saveCurrentDateData();
            }
            selectTourDate(yesterdayTour);
            gig.date = yesterdayStr;
            renderDateHeader();
            renderTourPreviews(yesterdayTour);
          }
        };
        
        // Tomorrow
        const tomorrow = new Date(currentDate);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const tomorrowStr = tomorrow.toISOString().split('T')[0];
        const tomorrowTour = tourDates.find(td => td.date === tomorrowStr);
        
        const tomorrowDateEl = document.getElementById('tourTomorrowDate');
        const tomorrowVenueEl = document.getElementById('tourTomorrowVenue');
        if(tomorrowDateEl) tomorrowDateEl.textContent = tomorrow.toLocaleDateString('en-US', {weekday:'short', month:'short', day:'numeric'});
        if(tomorrowVenueEl) tomorrowVenueEl.textContent = tomorrowTour ? (tomorrowTour.venue || 'No venue') : 'No event';
        
        tomorrowDiv.onclick = () => {
          if(tomorrowTour){
            // Save current before switching
            if(selectedTourDateId && selectedTourDateId !== tomorrowTour.id){
              saveCurrentDateData();
            }
            selectTourDate(tomorrowTour);
            gig.date = tomorrowStr;
            renderDateHeader();
            renderTourPreviews(tomorrowTour);
          }
        };
      }
      
      // Mark form inputs as dirty on change and update map with delay
      let mapLoadTimer = null;
      let autoSaveTimer = null;
      [tourVenueInput, tourAddressInput, tourLoadInInput, tourShowTimeInput, tourBandInput].forEach(input => {
        if(input){
          input.addEventListener('input', () => {
            currentDateDirty = true;
            
            // Auto-save after 1 second of inactivity
            clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
              if(selectedTourDateId && typeof saveTourDateData === 'function'){
                saveTourDateData();
              }
            }, 1000);
            
            // Update map when address changes with 500ms delay
            if(input === tourAddressInput && input.value.trim()){
              clearTimeout(mapLoadTimer);
              mapLoadTimer = setTimeout(() => {
                loadMap(input.value);
              }, 500);
            }
          });
        }
      });
      
      // Map loading function using OpenStreetMap for better search results
      function loadMap(address){
        const mapContainer = document.getElementById('tourMapPlaceholder');
        if(!mapContainer || !address) return;
        
        // Show loading state
        mapContainer.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#64748b;font-size:12px">Loading map...</div>';
        
        // Check if viewing today's gig
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        const now = new Date();
        const isToday = tourDate && tourDate.date === now.toISOString().split('T')[0];
        
        // Use OpenStreetMap Nominatim to search for address (includes AirBnB, rehearsal spaces, hideouts)
        const encodedAddress = encodeURIComponent(address);
        
        // Fetch coordinates from Nominatim (OpenStreetMap)
        fetch(`https://nominatim.openstreetmap.org/search?q=${encodedAddress}&format=json&limit=1&addressdetails=1`)
          .then(res => res.json())
          .then(data => {
            if(data && data.length > 0){
              const location = data[0];
              const lat = location.lat;
              const lon = location.lon;
              
              // If today, use Google Maps with traffic layer, otherwise OpenStreetMap
              if(isToday){
                mapContainer.innerHTML = `<iframe 
                  width="100%" 
                  height="100%" 
                  style="border:0;border-radius:4px" 
                  loading="lazy" 
                  src="https://www.google.com/maps/embed/v1/place?key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&q=${encodedAddress}&zoom=14&maptype=roadmap"
                ></iframe>
                <div style="position:absolute;top:4px;right:4px;background:#dc2626;color:white;padding:2px 6px;border-radius:3px;font-size:9px;font-weight:600;pointer-events:none">LIVE TRAFFIC</div>`;
              } else {
                // Embed OpenStreetMap with marker
                mapContainer.innerHTML = `<iframe 
                  width="100%" 
                  height="100%" 
                  style="border:0;border-radius:4px" 
                  loading="lazy" 
                  src="https://www.openstreetmap.org/export/embed.html?bbox=${parseFloat(lon)-0.01},${parseFloat(lat)-0.01},${parseFloat(lon)+0.01},${parseFloat(lat)+0.01}&layer=mapnik&marker=${lat},${lon}"
                ></iframe>`;
              }
            } else {
              // Fallback to text search if no coordinates found
              mapContainer.innerHTML = `<iframe 
                width="100%" 
                height="100%" 
                style="border:0;border-radius:4px" 
                loading="lazy" 
                src="https://www.google.com/maps/embed/v1/place?key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&q=${encodedAddress}"
              ></iframe>`;
            }
          })
          .catch(err => {
            console.error('Map loading error:', err);
            // Fallback to Google Maps on error
            mapContainer.innerHTML = `<iframe 
              width="100%" 
              height="100%" 
              style="border:0;border-radius:4px" 
              loading="lazy" 
              src="https://www.google.com/maps/embed/v1/place?key=AIzaSyBFw0Qbyq9zTFTd-tUY6dZWTgaQzuU17R8&q=${encodedAddress}"
            ></iframe>`;
          });
      }
      
      // Save current tour date data (make globally accessible)
      window.saveTourDateData = function(){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        tourDate.venue = tourVenueInput?.value || '';
        tourDate.address = tourAddressInput?.value || '';
        tourDate.loadIn = tourLoadInInput?.value || '';
        tourDate.showTime = tourShowTimeInput?.value || '';
        tourDate.band = tourBandInput?.value || '';
        tourDate.setlistType = tourSetlistSelect?.value || 'current';
        tourDate.stagePlotType = tourStagePlotSelect?.value || 'current';
        tourDate.gearSummary = gearSummary;
        tourDate.techNotes = techNotes;
        
        // Sync times to itinerary
        syncTimesToItinerary(tourDate);
        
        // Also update gig object to maintain consistency (including band!)
        gig.venue = tourDate.venue;
        gig.address = tourDate.address;
        gig.band = tourDate.band;
        
        // Sync band name to sheet header if visible
        const sheetBandEl = document.querySelector('.header .band');
        if(sheetBandEl && gig.band) {
          sheetBandEl.textContent = gig.band;
        }
        
        // Update Act display in header
        if(typeof updateActDisplay === 'function') updateActDisplay();
        
        saveAll();
      };
      
      // Reload calendar data (map, stage, setlist) when tab is opened (make globally accessible)
      window.reloadCalendarData = function(){
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(!tourDate) return;
        
        // Reload map from venue address
        const addressToUse = tourDate.address || gig.address || '';
        if(addressToUse && addressToUse.trim()){
          loadMap(addressToUse);
        }
        
        // Refresh stage and setlist previews (force reload from global data)
        renderTourPreviews(tourDate);
      };
      
      // Track setlist modifications
      const originalAddToSet = window.addToSet;
      if(originalAddToSet){
        window.addToSet = function(){
          currentDateDirty = true;
          return originalAddToSet.apply(this, arguments);
        };
      }
      
      // Render itinerary as 24-hour timeline (5am to 5am next day) with 15-minute slots
      function renderItinerary(tourDate){
        if(!tourItineraryTimeline) return;
        tourItineraryTimeline.innerHTML = '';
        
        // Create 24-hour grid (5am to 5am next day = 96 slots √ó 15min = 24h)
        const gridContainer = document.createElement('div');
        gridContainer.style.cssText = 'display:grid;grid-template-columns:50px 1fr;gap:0;position:relative';
        
        // 5am to 5am next day (24 hours)
        const startHour = 5;
        const endHour = 29; // 5am next day = hour 29
        
        // Generate time slots for 24-hour window (5am to 5am)
        for(let h = startHour; h < endHour; h++){
          for(let m = 0; m < 60; m += 15){
            const displayHour = h >= 24 ? h - 24 : h;
            const timeStr = `${String(displayHour).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
            const slotIdx = (h - startHour) * 4 + m / 15;
            
            // Time label (every hour)
            const labelEl = document.createElement('div');
            labelEl.style.cssText = `
              grid-column:1;
              grid-row:${slotIdx + 1};
              font-size:10px;
              color:${m === 0 ? '#374151' : '#9ca3af'};
              font-weight:${m === 0 ? '600' : '400'};
              padding:2px 4px;
              text-align:right;
              border-right:1px solid #e5e7eb;
              background:${m === 0 ? '#f9fafb' : 'transparent'};
            `;
            labelEl.textContent = m === 0 ? timeStr : '';
            
            // Check if this is the current time slot (for highlighting)
            const now = new Date();
            const isToday = tourDate && tourDate.date === now.toISOString().split('T')[0];
            const currentHourNow = now.getHours();
            const currentMinNow = now.getMinutes();
            const isCurrentSlot = isToday && h === currentHourNow && m <= currentMinNow && (m + 15) > currentMinNow;
            
            // Time slot (drop zone)
            const slotEl = document.createElement('div');
            slotEl.className = 'timeline-slot';
            slotEl.dataset.time = timeStr;
            slotEl.style.cssText = `
              grid-column:2;
              grid-row:${slotIdx + 1};
              min-height:20px;
              border-bottom:1px solid ${m === 0 ? '#d1d5db' : '#f3f4f6'};
              background:${isCurrentSlot ? '#fef3c7' : 'white'};
              position:relative;
              cursor:pointer;
              ${isCurrentSlot ? 'box-shadow: inset 0 0 0 2px #fbbf24;' : ''}
            `;
            
            // Drop handlers for activity chips
            slotEl.addEventListener('dragover', (e) => {
              e.preventDefault();
              slotEl.style.background = '#eff6ff';
            });
            slotEl.addEventListener('dragleave', () => {
              slotEl.style.background = 'white';
            });
            slotEl.addEventListener('drop', (e) => {
              e.preventDefault();
              slotEl.style.background = 'white';
              
              const activity = e.dataTransfer.getData('activity');
              const duration = parseInt(e.dataTransfer.getData('duration')) || 30; // Default 30 minutes
              const color = e.dataTransfer.getData('color') || '#3b82f6';
              const draggedIdx = e.dataTransfer.getData('itemIndex');
              const jsonData = e.dataTransfer.getData('application/json');
              
              if(activity){
                // Activity chip dropped - add to itinerary at this time (30 min default)
                const newTime = timeStr;
                let title = activity.charAt(0).toUpperCase() + activity.slice(1);
                
                if(!tourDate.itinerary) tourDate.itinerary = [];
                tourDate.itinerary.push({
                  time: newTime,
                  title: title,
                  activity: activity,
                  duration: 30, // 30 minutes default
                  chipData: { color: color },
                  notes: ''
                });
                
                saveAll();
                renderItinerary(tourDate);
                renderDateHeader();
              } else if(jsonData){
                // Place chip dropped (hotel, restaurant, etc.) - 30 min default
                try {
                  const chipData = JSON.parse(jsonData);
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: chipData.name,
                    duration: 30, // 30 minutes default
                    notes: '',
                    chipData: chipData
                  });
                  
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                } catch(err) {
                  console.error('Error parsing place chip data:', err);
                }
              } else if(draggedIdx !== ''){
                // Existing item dragged to new time
                const idx = parseInt(draggedIdx);
                if(tourDate.itinerary[idx]){
                  tourDate.itinerary[idx].time = timeStr;
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                }
              }
            });
            
            // Click/tap empty slot to add note/item directly (inline editing)
            function openSlotEditor(){
              // Create inline input for quick note entry
              const input = document.createElement('input');
              input.type = 'text';
              input.placeholder = 'Type note or event...';
              input.style.cssText = 'width:100%;padding:8px;border:2px solid #3b82f6;border-radius:4px;font-size:16px;box-sizing:border-box;touch-action:manipulation';
              
              slotEl.innerHTML = '';
              slotEl.appendChild(input);
              input.focus();
              
              const saveNote = () => {
                const text = input.value.trim();
                if(text){
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: text,
                    duration: 30,
                    notes: ''
                  });
                  saveAll();
                }
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveNote);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveNote();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            slotEl.addEventListener('click', openSlotEditor);
            
            // Touch tap support for slots
            let slotTapTime = 0;
            slotEl.addEventListener('touchend', (e) => {
              // Only trigger if it wasn't a drag
              if(!e.target.closest('.touch-drop-target') && (Date.now() - slotTapTime) < 300){
                e.preventDefault();
                openSlotEditor();
              }
            });
            slotEl.addEventListener('touchstart', () => {
              slotTapTime = Date.now();
            }, {passive: true});
            
            gridContainer.appendChild(labelEl);
            gridContainer.appendChild(slotEl);
          }
        }
        
        // Overlay itinerary items on timeline
        if(tourDate.itinerary && tourDate.itinerary.length > 0){
          tourDate.itinerary.forEach((item, idx) => {
            const itemTime = item.time || '00:00';
            let [h, m] = itemTime.split(':').map(Number);
            
            // Adjust for 5am start (if hour < 5, it's next day)
            if(h < 5) h += 24;
            
            // Only show items within the 24-hour window (5am to 5am)
            if(h < startHour || h >= endHour) return;
            
            const slotIdx = (h - startHour) * 4 + Math.floor(m / 15);
            const duration = item.duration || 30;
            const numSlots = Math.ceil(duration / 15);
            
            const borderColor = item.chipData?.color || '#3b82f6';
            
            const itemEl = document.createElement('div');
            itemEl.className = 'itinerary-item';
            itemEl.dataset.idx = idx;
            itemEl.draggable = true;
            itemEl.style.cssText = `
              grid-column:2;
              grid-row:${slotIdx + 1} / span ${numSlots};
              border:2px solid ${borderColor};
              border-radius:6px;
              padding:6px;
              background:linear-gradient(to bottom, ${borderColor}15, ${borderColor}05);
              margin:2px;
              cursor:move;
              position:relative;
              z-index:10;
              box-shadow:0 1px 3px rgba(0,0,0,0.1);
              transition:all 0.2s;
              touch-action:none;
            `;
            
            // Drag handlers for moving items (mouse)
            itemEl.addEventListener('dragstart', (e) => {
              e.dataTransfer.setData('itemIndex', idx.toString());
              e.dataTransfer.effectAllowed = 'move';
              itemEl.style.opacity = '0.5';
            });
            
            itemEl.addEventListener('dragend', (e) => {
              itemEl.style.opacity = '1';
            });
            
            // Touch drag support for moving itinerary items
            let itemTouchDrag = false;
            let itemTouchClone = null;
            const itemIdx = idx;
            
            itemEl.addEventListener('touchstart', (e) => {
              // Don't interfere with delete button or resize handles
              if(e.target.closest('.itinerary-delete') || e.target.closest('.resize-handle-top') || e.target.closest('.resize-handle-bottom')) return;
              
              const touch = e.touches[0];
              itemTouchDrag = 'pending';
              
              setTimeout(() => {
                if(itemTouchDrag === 'pending'){
                  itemTouchDrag = true;
                  itemEl.style.opacity = '0.3';
                  
                  // Create visual clone
                  itemTouchClone = document.createElement('div');
                  itemTouchClone.style.cssText = `
                    position:fixed;
                    z-index:99999;
                    pointer-events:none;
                    opacity:0.9;
                    padding:8px 12px;
                    background:${borderColor}30;
                    border:2px solid ${borderColor};
                    border-radius:6px;
                    font-size:11px;
                    font-weight:600;
                    color:#111827;
                    box-shadow:0 8px 24px rgba(0,0,0,0.3);
                    left:${touch.clientX - 40}px;
                    top:${touch.clientY - 15}px;
                  `;
                  itemTouchClone.textContent = item.title;
                  document.body.appendChild(itemTouchClone);
                }
              }, 200);
            }, {passive: true});
            
            itemEl.addEventListener('touchmove', (e) => {
              if(itemTouchDrag !== true) return;
              e.preventDefault();
              const touch = e.touches[0];
              
              if(itemTouchClone){
                itemTouchClone.style.left = (touch.clientX - 40) + 'px';
                itemTouchClone.style.top = (touch.clientY - 15) + 'px';
              }
              
              // Highlight drop targets
              document.querySelectorAll('.timeline-slot').forEach(slot => {
                const rect = slot.getBoundingClientRect();
                if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                   touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                  slot.classList.add('touch-drop-target');
                } else {
                  slot.classList.remove('touch-drop-target');
                }
              });
            }, {passive: false});
            
            itemEl.addEventListener('touchend', (e) => {
              const wasDragging = itemTouchDrag === true;
              const touch = e.changedTouches[0];
              
              // Cleanup
              if(itemTouchClone){
                itemTouchClone.remove();
                itemTouchClone = null;
              }
              itemEl.style.opacity = '1';
              document.querySelectorAll('.timeline-slot').forEach(slot => {
                slot.classList.remove('touch-drop-target');
              });
              
              if(wasDragging){
                // Find drop target
                let dropSlot = null;
                document.querySelectorAll('.timeline-slot').forEach(slot => {
                  const rect = slot.getBoundingClientRect();
                  if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                     touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                    dropSlot = slot;
                  }
                });
                
                if(dropSlot && tourDate.itinerary[itemIdx]){
                  const newTime = dropSlot.dataset.time;
                  tourDate.itinerary[itemIdx].time = newTime;
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                }
              }
              
              itemTouchDrag = false;
            });
            
            // Resize handles
            const topHandle = document.createElement('div');
            topHandle.className = 'resize-handle-top';
            topHandle.style.cssText = 'position:absolute;top:0;left:0;right:0;height:6px;cursor:ns-resize;background:rgba(0,0,0,0.1);opacity:0;transition:opacity 0.2s';
            
            const bottomHandle = document.createElement('div');
            bottomHandle.className = 'resize-handle-bottom';
            bottomHandle.style.cssText = 'position:absolute;bottom:0;left:0;right:0;height:6px;cursor:ns-resize;background:rgba(0,0,0,0.1);opacity:0;transition:opacity 0.2s';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'item-content';
            contentDiv.style.cssText = 'height:100%;overflow:hidden;padding:2px';
            contentDiv.innerHTML = `
              <div style="display:flex;align-items:center;gap:4px;margin-bottom:2px">
                <div class="item-title" style="font-weight:600;font-size:11px;color:#111827;flex:1">${itemTime} - ${item.title}</div>
                <button class="itinerary-delete" style="padding:2px 6px;font-size:10px;background:#ef4444;color:white;border:none;border-radius:3px;cursor:pointer">√ó</button>
              </div>
              ${item.chipData?.address ? `<div style="font-size:10px;color:#64748b">${item.chipData.address}</div>` : ''}
              <div class="item-notes" style="font-size:10px;color:#64748b;margin-top:2px;min-height:14px;cursor:text">${item.notes || ''}</div>
            `;
            
            itemEl.appendChild(topHandle);
            itemEl.appendChild(contentDiv);
            itemEl.appendChild(bottomHandle);
            
            // Show resize handles on hover/touch
            function showHandles(){
              itemEl.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
              itemEl.style.zIndex = '20';
              topHandle.style.opacity = '1';
              bottomHandle.style.opacity = '1';
            }
            function hideHandles(){
              itemEl.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
              itemEl.style.zIndex = '10';
              topHandle.style.opacity = '0';
              bottomHandle.style.opacity = '0';
            }
            itemEl.addEventListener('mouseenter', showHandles);
            itemEl.addEventListener('mouseleave', hideHandles);
            // Touch: show handles on touch, hide after 3 seconds or on touchend outside
            itemEl.addEventListener('touchstart', (e) => {
              if(!e.target.closest('.resize-handle-top') && !e.target.closest('.resize-handle-bottom')){
                showHandles();
                setTimeout(hideHandles, 3000);
              }
            }, {passive: true});
            
            // Resize from top handle
            let resizing = false;
            topHandle.addEventListener('mousedown', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const startY = e.clientY;
              const startDuration = item.duration || 30;
              const startTime = item.time;
              const [startH, startM] = startTime.split(':').map(Number);
              
              const onMouseMove = (e2) => {
                if(!resizing) return;
                const deltaY = e2.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20); // ~20px per slot
                const deltaMinutes = deltaSlots * 15;
                
                // When dragging top DOWN (positive deltaY): start time moves forward, duration decreases
                // When dragging top UP (negative deltaY): start time moves backward, duration increases
                const newStartMinutes = (startH * 60 + startM) + deltaMinutes;
                const newDuration = Math.max(15, startDuration - deltaMinutes);
                const newH = Math.floor(newStartMinutes / 60);
                const newM = newStartMinutes % 60;
                
                item.time = `${String(newH).padStart(2,'0')}:${String(Math.max(0, newM)).padStart(2,'0')}`;
                item.duration = newDuration;
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onMouseUp = () => {
                resizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
              };
              
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            });
            
            // Touch support for top handle
            topHandle.addEventListener('touchstart', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const touch = e.touches[0];
              const startY = touch.clientY;
              const startDuration = item.duration || 30;
              const startTime = item.time;
              const [startH, startM] = startTime.split(':').map(Number);
              
              const onTouchMove = (e2) => {
                if(!resizing) return;
                const t = e2.touches[0]; if(!t) return;
                const deltaY = t.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20);
                const deltaMinutes = deltaSlots * 15;
                const newStartMinutes = (startH * 60 + startM) + deltaMinutes;
                const newDuration = Math.max(15, startDuration - deltaMinutes);
                const newH = Math.floor(newStartMinutes / 60);
                const newM = newStartMinutes % 60;
                item.time = `${String(newH).padStart(2,'0')}:${String(Math.max(0, newM)).padStart(2,'0')}`;
                item.duration = newDuration;
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onTouchEnd = () => {
                resizing = false;
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
              };
              
              document.addEventListener('touchmove', onTouchMove, {passive:false});
              document.addEventListener('touchend', onTouchEnd);
            }, {passive:false});
            
            // Resize from bottom handle
            bottomHandle.addEventListener('mousedown', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const startY = e.clientY;
              const startDuration = item.duration || 30;
              
              const onMouseMove = (e2) => {
                if(!resizing) return;
                const deltaY = e2.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20); // ~20px per slot
                const deltaMinutes = deltaSlots * 15;
                
                item.duration = Math.max(15, startDuration + deltaMinutes);
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onMouseUp = () => {
                resizing = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
              };
              
              document.addEventListener('mousemove', onMouseMove);
              document.addEventListener('mouseup', onMouseUp);
            });
            
            // Touch support for bottom handle
            bottomHandle.addEventListener('touchstart', (e) => {
              e.stopPropagation();
              e.preventDefault();
              resizing = true;
              const touch = e.touches[0];
              const startY = touch.clientY;
              const startDuration = item.duration || 30;
              
              const onTouchMove = (e2) => {
                if(!resizing) return;
                const t = e2.touches[0]; if(!t) return;
                const deltaY = t.clientY - startY;
                const deltaSlots = Math.round(deltaY / 20);
                const deltaMinutes = deltaSlots * 15;
                item.duration = Math.max(15, startDuration + deltaMinutes);
                saveAll();
                renderItinerary(tourDate);
              };
              
              const onTouchEnd = () => {
                resizing = false;
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
              };
              
              document.addEventListener('touchmove', onTouchMove, {passive:false});
              document.addEventListener('touchend', onTouchEnd);
            }, {passive:false});
            
            // Double-click/double-tap title to edit
            const titleEl = contentDiv.querySelector('.item-title');
            let titleLastTap = 0;
            
            function editTitle(){
              const currentText = item.title;
              titleEl.innerHTML = `<input type="text" value="${currentText}" style="width:100%;padding:4px;border:1px solid #3b82f6;border-radius:3px;font-size:14px;font-weight:600;touch-action:manipulation" />`;
              const input = titleEl.querySelector('input');
              input.focus();
              input.select();
              
              const saveEdit = () => {
                item.title = input.value.trim() || currentText;
                saveAll();
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveEdit);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveEdit();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            titleEl.addEventListener('dblclick', (e) => {
              e.stopPropagation();
              editTitle();
            });
            
            titleEl.addEventListener('touchend', (e) => {
              const now = Date.now();
              if(now - titleLastTap < 400){
                e.preventDefault();
                e.stopPropagation();
                editTitle();
              }
              titleLastTap = now;
            });
            
            // Double-click/double-tap notes area to edit
            const notesEl = contentDiv.querySelector('.item-notes');
            let notesLastTap = 0;
            
            function editNotes(){
              const currentNotes = item.notes || '';
              notesEl.innerHTML = `<input type="text" placeholder="Add notes..." value="${currentNotes}" style="width:100%;padding:4px;border:1px solid #3b82f6;border-radius:3px;font-size:14px;box-sizing:border-box;touch-action:manipulation" />`;
              const input = notesEl.querySelector('input');
              input.focus();
              input.select();
              
              const saveNotes = () => {
                item.notes = input.value.trim();
                saveAll();
                renderItinerary(tourDate);
              };
              
              input.addEventListener('blur', saveNotes);
              input.addEventListener('keydown', (e) => {
                if(e.key === 'Enter') saveNotes();
                if(e.key === 'Escape') renderItinerary(tourDate);
              });
            }
            
            notesEl.addEventListener('dblclick', (e) => {
              e.stopPropagation();
              editNotes();
            });
            
            notesEl.addEventListener('touchend', (e) => {
              const now = Date.now();
              if(now - notesLastTap < 400){
                e.preventDefault();
                e.stopPropagation();
                editNotes();
              }
              notesLastTap = now;
            });
            
            // Delete handler (click + touch)
            const deleteBtn = contentDiv.querySelector('.itinerary-delete');
            function handleDelete(e){
              e.stopPropagation();
              e.preventDefault();
              if(confirm('Delete this itinerary item?')){
                tourDate.itinerary.splice(idx, 1);
                saveAll();
                renderItinerary(tourDate);
                renderDateHeader();
              }
            }
            deleteBtn.addEventListener('click', handleDelete);
            deleteBtn.addEventListener('touchend', handleDelete);
            
            gridContainer.appendChild(itemEl);
          });
        }
        
        tourItineraryTimeline.appendChild(gridContainer);
      }
      
      // Show itinerary item details modal
      function showItineraryDetails(tourDate, idx){
        const item = tourDate.itinerary[idx];
        if(!item) return;
        
        const modal = document.createElement('div');
        modal.className = 'modal open';
        modal.innerHTML = `
          <div class="modalbox" style="max-width:500px;width:90%">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
              <h3 style="margin:0">${item.title || 'Itinerary Item'}</h3>
              <button class="close-modal" style="border:none;background:none;font-size:24px;cursor:pointer;color:#64748b">√ó</button>
            </div>
            
            <div style="display:flex;flex-direction:column;gap:12px">
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Time (30-min increments)</label>
                <input type="text" value="${item.time||''}" class="modal-time" placeholder="e.g., 2:30pm, 14:30, 230" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px" />
                <button class="btn modal-time-helper" style="margin-top:4px;padding:4px 8px;font-size:11px">Change Time</button>
              </div>
              
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Title</label>
                <input type="text" value="${item.title||''}" class="modal-title" placeholder="Event title" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px" />
              </div>
              
              ${item.chipData ? `
                <div style="padding:12px;background:#f9fafb;border-radius:6px;border-left:3px solid ${item.chipData.color || '#3b82f6'}">
                  <div style="font-weight:600;margin-bottom:4px">${item.chipData.name}</div>
                  <div style="font-size:12px;color:#64748b">${item.chipData.address || ''}</div>
                  ${item.chipData.phone ? `<div style="font-size:12px;color:#0ea5e9;margin-top:4px">üìû ${item.chipData.phone}</div>` : ''}
                  ${item.chipData.website ? `<a href="${item.chipData.website}" target="_blank" style="font-size:12px;color:#3b82f6;margin-top:4px;display:inline-block">üåê Website</a>` : ''}
                </div>
              ` : ''}
              
              <div>
                <label style="font-size:12px;font-weight:600;color:#64748b;display:block;margin-bottom:4px">Notes</label>
                <textarea class="modal-notes" placeholder="Additional notes, directions, contact info..." style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:4px;min-height:80px;resize:vertical">${item.notes||''}</textarea>
              </div>
              
              <div style="display:flex;gap:8px;margin-top:8px">
                <button class="btn primary save-modal" style="flex:1">Save Changes</button>
                <button class="btn cancel-modal" style="flex:1">Cancel</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
        
        // Close handlers
        modal.querySelector('.close-modal').addEventListener('click', () => modal.remove());
        modal.querySelector('.cancel-modal').addEventListener('click', () => modal.remove());
        modal.addEventListener('click', (e) => {
          if(e.target === modal) modal.remove();
        });
        
        // Time helper button
        modal.querySelector('.modal-time-helper').addEventListener('click', (e) => {
          e.preventDefault();
          const currentTime = modal.querySelector('.modal-time').value;
          const newTime = promptForTime(currentTime);
          if(newTime){
            modal.querySelector('.modal-time').value = newTime;
          }
        });
        
        // Save handler
        modal.querySelector('.save-modal').addEventListener('click', () => {
          item.time = modal.querySelector('.modal-time').value;
          item.title = modal.querySelector('.modal-title').value;
          item.notes = modal.querySelector('.modal-notes').value;
          saveAll();
          renderItinerary(tourDate);
          renderDateHeader();
          modal.remove();
        });
      }
      
      // Timeline drop handlers are now in renderItinerary() function
      // Each time slot handles its own drops without prompting for time
      
      // View mode change
      if(tourViewModeSelect){
        tourViewModeSelect.addEventListener('change', () => {
          tourViewMode = tourViewModeSelect.value;
          renderTimeline();
        });
      }
      
      // Navigation
      if(tourTodayBtn){
        tourTodayBtn.addEventListener('click', () => {
          tourViewDate = new Date();
          renderTimeline();
        });
      }
      
      // Yesterday/Tomorrow button handlers with long-press for week jumps
      const tourYesterdayBtn = document.getElementById('tourYesterdayBtn');
      const tourTomorrowBtn = document.getElementById('tourTomorrowBtn');
      
      let longPressTimer = null;
      let isLongPress = false;
      
      if(tourYesterdayBtn){
        tourYesterdayBtn.addEventListener('mousedown', () => {
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Jump back one week
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() - 7);
              const weekAgoStr = currentDate.toISOString().split('T')[0];
              const weekAgoTour = tourDates.find(td => td.date === weekAgoStr);
              if(weekAgoTour){
                selectTourDate(weekAgoTour);
                gig.date = weekAgoStr;
                selectedTourDateId = weekAgoTour.id;
                loadDateData(weekAgoTour);
                renderDateHeader();
                saveAll();
              }
            }
          }, 600);
        });
        
        tourYesterdayBtn.addEventListener('mouseup', () => {
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Normal click: go to yesterday
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() - 1);
              const yesterdayStr = currentDate.toISOString().split('T')[0];
              const yesterdayTour = tourDates.find(td => td.date === yesterdayStr);
              if(yesterdayTour){
                selectTourDate(yesterdayTour);
                gig.date = yesterdayStr;
                selectedTourDateId = yesterdayTour.id;
                loadDateData(yesterdayTour);
                renderDateHeader();
                saveAll();
              }
            }
          }
        });
        
        tourYesterdayBtn.addEventListener('mouseleave', () => {
          clearTimeout(longPressTimer);
        });
        
        // Touch support
        tourYesterdayBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() - 7);
              const weekAgoStr = currentDate.toISOString().split('T')[0];
              const weekAgoTour = tourDates.find(td => td.date === weekAgoStr);
              if(weekAgoTour){
                selectTourDate(weekAgoTour);
                gig.date = weekAgoStr;
                selectedTourDateId = weekAgoTour.id;
                loadDateData(weekAgoTour);
                renderDateHeader();
                saveAll();
              }
            }
          }, 600);
        });
        
        tourYesterdayBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() - 1);
              const yesterdayStr = currentDate.toISOString().split('T')[0];
              const yesterdayTour = tourDates.find(td => td.date === yesterdayStr);
              if(yesterdayTour){
                selectTourDate(yesterdayTour);
                gig.date = yesterdayStr;
                selectedTourDateId = yesterdayTour.id;
                loadDateData(yesterdayTour);
                renderDateHeader();
                saveAll();
              }
            }
          }
        });
      }
      
      if(tourTomorrowBtn){
        tourTomorrowBtn.addEventListener('mousedown', () => {
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Jump forward one week
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() + 7);
              const weekAheadStr = currentDate.toISOString().split('T')[0];
              const weekAheadTour = tourDates.find(td => td.date === weekAheadStr);
              if(weekAheadTour){
                selectTourDate(weekAheadTour);
                gig.date = weekAheadStr;
                selectedTourDateId = weekAheadTour.id;
                loadDateData(weekAheadTour);
                renderDateHeader();
                saveAll();
              }
            }
          }, 600);
        });
        
        tourTomorrowBtn.addEventListener('mouseup', () => {
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            // Normal click: go to tomorrow
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() + 1);
              const tomorrowStr = currentDate.toISOString().split('T')[0];
              const tomorrowTour = tourDates.find(td => td.date === tomorrowStr);
              if(tomorrowTour){
                selectTourDate(tomorrowTour);
                gig.date = tomorrowStr;
                selectedTourDateId = tomorrowTour.id;
                loadDateData(tomorrowTour);
                renderDateHeader();
                saveAll();
              }
            }
          }
        });
        
        tourTomorrowBtn.addEventListener('mouseleave', () => {
          clearTimeout(longPressTimer);
        });
        
        // Touch support
        tourTomorrowBtn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          isLongPress = false;
          longPressTimer = setTimeout(() => {
            isLongPress = true;
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() + 7);
              const weekAheadStr = currentDate.toISOString().split('T')[0];
              const weekAheadTour = tourDates.find(td => td.date === weekAheadStr);
              if(weekAheadTour){
                selectTourDate(weekAheadTour);
                gig.date = weekAheadStr;
                selectedTourDateId = weekAheadTour.id;
                loadDateData(weekAheadTour);
                renderDateHeader();
                saveAll();
              }
            }
          }, 600);
        });
        
        tourTomorrowBtn.addEventListener('touchend', (e) => {
          e.preventDefault();
          clearTimeout(longPressTimer);
          if(!isLongPress){
            // Save current date data before navigating
            if(typeof saveTourDateData === 'function') saveTourDateData();
            
            const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
            if(currentTourDate){
              const currentDate = new Date(currentTourDate.date + 'T12:00:00');
              currentDate.setDate(currentDate.getDate() + 1);
              const tomorrowStr = currentDate.toISOString().split('T')[0];
              const tomorrowTour = tourDates.find(td => td.date === tomorrowStr);
              if(tomorrowTour){
                selectTourDate(tomorrowTour);
                gig.date = tomorrowStr;
                selectedTourDateId = tomorrowTour.id;
                loadDateData(tomorrowTour);
                renderDateHeader();
                saveAll();
              }
            }
          }
        });
      }
      
      if(tourPrevBtn){
        tourPrevBtn.addEventListener('click', () => {
          if(tourViewMode === 'week'){
            tourViewDate.setDate(tourViewDate.getDate() - 7);
          } else if(tourViewMode === 'month'){
            tourViewDate.setMonth(tourViewDate.getMonth() - 1);
          } else if(tourViewMode === 'year'){
            tourViewDate.setFullYear(tourViewDate.getFullYear() - 1);
          }
          renderTimeline();
        });
      }
      
      if(tourNextBtn){
        tourNextBtn.addEventListener('click', () => {
          if(tourViewMode === 'week'){
            tourViewDate.setDate(tourViewDate.getDate() + 7);
          } else if(tourViewMode === 'month'){
            tourViewDate.setMonth(tourViewDate.getMonth() + 1);
          } else if(tourViewMode === 'year'){
            tourViewDate.setFullYear(tourViewDate.getFullYear() + 1);
          }
          renderTimeline();
        });
      }
      
      // Add new date
      if(tourAddDateBtn){
        tourAddDateBtn.addEventListener('click', () => {
          const newDate = {
            id: generateId(),
            date: new Date().toISOString().split('T')[0],
            venue: '',
            address: '',
            loadIn: '',
            showTime: '',
            band: gig.band || '',
            setlistType: 'current',
            stagePlotType: 'current',
            itinerary: [],
            interests: []
          };
          tourDates.push(newDate);
          selectTourDate(newDate);
          saveAll();
          renderTimeline();
          renderDateHeader();
        });
      }
      
      // Save date changes
      if(tourSaveDateBtn){
        tourSaveDateBtn.addEventListener('click', () => {
          saveTourDateData();
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(!tourDate) return;
          
          tourDate.date = tourDateInput?.value || tourDate.date;
          tourDate.venue = tourVenueInput?.value || '';
          tourDate.address = tourAddressInput?.value || '';
          tourDate.loadIn = tourLoadInInput?.value || '';
          tourDate.showTime = tourShowTimeInput?.value || '';
          tourDate.band = tourBandInput?.value || '';
          tourDate.setlistType = tourSetlistSelect?.value || 'current';
          tourDate.stagePlotType = tourStagePlotSelect?.value || 'current';
          
          saveAll();
          renderTimeline();
          renderDateHeader();
          alert('Date saved!');
        });
      }
      
      // Delete date
      if(tourDeleteDateBtn){
        tourDeleteDateBtn.addEventListener('click', () => {
          if(!confirm('Delete this tour date and all its details?')) return;
          const idx = tourDates.findIndex(td => td.id === selectedTourDateId);
          if(idx !== -1){
            tourDates.splice(idx, 1);
            selectedTourDateId = null;
            selectTourDate(null);
            saveAll();
            renderTimeline();
            renderDateHeader();
          }
        });
      }
      
      // Lock Calendar checkbox
      const tourLockCalendar = document.getElementById('tourLockCalendar');
      if(tourLockCalendar){
        tourLockCalendar.addEventListener('change', () => {
          const isLocked = tourLockCalendar.checked;
          // Disable all form inputs when locked
          [tourDateInput, tourVenueInput, tourAddressInput, tourLoadInInput, tourShowTimeInput, tourBandInput, tourSetlistSelect, tourStagePlotSelect].forEach(input => {
            if(input) input.disabled = isLocked;
          });
          if(tourSaveDateBtn) tourSaveDateBtn.disabled = isLocked;
          if(tourDeleteDateBtn) tourDeleteDateBtn.disabled = isLocked;
          if(tourAddDateBtn) tourAddDateBtn.disabled = isLocked;
          if(tourAddItineraryItem) tourAddItineraryItem.disabled = isLocked;
        });
      }
      
      // Clear Calendar button
      const tourClearCalendar = document.getElementById('tourClearCalendar');
      if(tourClearCalendar){
        tourClearCalendar.addEventListener('click', () => {
          if(!confirm('Clear ALL tour dates from calendar?\n\nThis will delete all tour dates and their data. You should save a .BAND file first!\n\nProceed?')) return;
          
          // Offer to save first
          if(confirm('Would you like to save a .BAND file before clearing?')){
            // Trigger save profile
            const saveProfileBtn = document.getElementById('saveProfile');
            if(saveProfileBtn) saveProfileBtn.click();
            
            // Wait a moment for save dialog
            setTimeout(() => {
              if(confirm('Ready to clear calendar now?')){
                tourDates = [];
                selectedTourDateId = null;
                selectTourDate(null);
                saveAll();
                renderTimeline();
                renderDateHeader();
                alert('Calendar cleared!');
              }
            }, 500);
          } else {
            // Clear without saving
            tourDates = [];
            selectedTourDateId = null;
            selectTourDate(null);
            saveAll();
            renderTimeline();
            renderDateHeader();
            alert('Calendar cleared!');
          }
        });
      }
      
      // Add itinerary item
      if(tourAddItineraryBtn){
        tourAddItineraryBtn.addEventListener('click', () => {
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(!tourDate) return;
          
          if(!tourDate.itinerary) tourDate.itinerary = [];
          tourDate.itinerary.push({
            time: '',
            title: '',
            notes: ''
          });
          
          saveAll();
          renderItinerary(tourDate);
          renderDateHeader();
        });
      }
      
      // Custom search button handler
      if (tourCustomSearchBtn) {
        tourCustomSearchBtn.addEventListener('click', () => {
          const searchTerm = tourCustomSearchInput?.value?.trim();
          if (!searchTerm) {
            alert('Please enter a search term');
            return;
          }
          
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
      }
      
      // Allow Enter key in custom search
      if (tourCustomSearchInput) {
        tourCustomSearchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            tourCustomSearchBtn?.click();
          }
        });
      }
      
      // ========================================================================
      // SEARCH POPUP & DRAGGABLE CHIPS SYSTEM
      // ========================================================================
      
      const searchResults = document.getElementById('tourSearchResults');
      const interestsDropZone = document.getElementById('tourInterestsDropZone');
      const interestsPlaceholder = document.getElementById('tourInterestsPlaceholder');
      const clearInterestsBtn = document.getElementById('tourClearInterests');
      
      // Chip factory: creates draggable chips with full business info
      function createInterestChip(data) {
        const { name, address, phone, url, rating, type, color, distance } = data;
        
        const chip = document.createElement('div');
        chip.className = 'tour-interest-chip';
        chip.draggable = true;
        chip.style.borderLeftColor = color || '#0ea5e9';
        chip.style.borderLeftWidth = '4px';
        chip.style.borderLeftStyle = 'solid';
        
        const ratingStars = rating ? '‚≠ê'.repeat(Math.round(rating)) : '';
        
        // Format distance display
        let distanceText = '';
        if (distance !== null && distance !== undefined) {
          if (distance < 1) {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#dcfce7;color:#166534;border-radius:3px;font-weight:600">${Math.round(distance * 1000)}m away</span>`;
          } else if (distance < 5) {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#fef9c3;color:#854d0e;border-radius:3px;font-weight:600">${distance.toFixed(1)}km away</span>`;
          } else {
            distanceText = `<span style="font-size:10px;padding:2px 4px;background:#fed7aa;color:#9a3412;border-radius:3px;font-weight:600">${Math.round(distance)}km away</span>`;
          }
        }
        
        chip.innerHTML = `
          <div style="display:flex;flex-direction:column;gap:4px;flex:1;min-width:0">
            <div style="display:flex;align-items:center;gap:6px">
              <div style="font-weight:600;font-size:14px;color:#111827;flex:1">${name}</div>
              ${distanceText}
            </div>
            ${address ? `<div style="font-size:11px;color:#64748b;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${address}</div>` : ''}
            ${phone ? `<div style="font-size:11px;color:#0ea5e9;font-weight:500">üìû ${phone}</div>` : ''}
            ${ratingStars ? `<div style="font-size:11px">${ratingStars} ${rating}</div>` : ''}
          </div>
          <button class="chip-remove" title="Remove">√ó</button>
        `;
        
        // Store data on element
        chip.dataset.chipData = JSON.stringify(data);
        chip.style.touchAction = 'none';
        
        // Drag handlers (mouse/desktop)
        chip.addEventListener('dragstart', (e) => {
          chip.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'copy';
          e.dataTransfer.setData('application/json', chip.dataset.chipData);
          e.dataTransfer.setData('text/plain', name); // Fallback
        });
        
        chip.addEventListener('dragend', () => {
          chip.classList.remove('dragging');
        });
        
        // Touch drag support for place chips
        let touchDragActive = false;
        let touchClone = null;
        let touchStartTime = 0;
        
        chip.addEventListener('touchstart', (e) => {
          // Don't interfere with remove button
          if(e.target.closest('.chip-remove')) return;
          
          touchStartTime = Date.now();
          const touch = e.touches[0];
          
          // Short delay before starting drag to differentiate from tap
          setTimeout(() => {
            if(touchDragActive === 'pending'){
              touchDragActive = true;
              chip.classList.add('dragging');
              
              // Create visual clone
              touchClone = document.createElement('div');
              touchClone.className = 'tour-interest-chip touch-dragging';
              touchClone.style.cssText = `
                position:fixed;
                z-index:99999;
                pointer-events:none;
                opacity:0.9;
                transform:scale(1.05);
                box-shadow:0 8px 24px rgba(0,0,0,0.3);
                padding:8px 12px;
                background:white;
                border-radius:8px;
                border-left:4px solid ${color || '#0ea5e9'};
                max-width:200px;
                left:${touch.clientX - 50}px;
                top:${touch.clientY - 20}px;
              `;
              touchClone.innerHTML = `<div style="font-weight:600;font-size:12px">${name}</div>`;
              document.body.appendChild(touchClone);
              
              chip.style.opacity = '0.3';
            }
          }, 150);
          
          touchDragActive = 'pending';
        }, {passive: true});
        
        chip.addEventListener('touchmove', (e) => {
          if(touchDragActive !== true) return;
          e.preventDefault();
          const touch = e.touches[0];
          
          if(touchClone){
            touchClone.style.left = (touch.clientX - 50) + 'px';
            touchClone.style.top = (touch.clientY - 20) + 'px';
          }
          
          // Highlight timeline drop targets
          document.querySelectorAll('.timeline-slot').forEach(slot => {
            const rect = slot.getBoundingClientRect();
            if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
               touch.clientY >= rect.top && touch.clientY <= rect.bottom){
              slot.classList.add('touch-drop-target');
            } else {
              slot.classList.remove('touch-drop-target');
            }
          });
          
          // Also highlight interests drop zone
          const interestsZone = document.getElementById('tourInterestsDropZone');
          if(interestsZone){
            const rect = interestsZone.getBoundingClientRect();
            if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
               touch.clientY >= rect.top && touch.clientY <= rect.bottom){
              interestsZone.style.background = '#eff6ff';
              interestsZone.style.borderColor = '#3b82f6';
            } else {
              interestsZone.style.background = '';
              interestsZone.style.borderColor = '';
            }
          }
        }, {passive: false});
        
        chip.addEventListener('touchend', (e) => {
          const wasDragging = touchDragActive === true;
          const touch = e.changedTouches[0];
          
          // Cleanup
          if(touchClone){
            touchClone.remove();
            touchClone = null;
          }
          chip.classList.remove('dragging');
          chip.style.opacity = '1';
          document.querySelectorAll('.timeline-slot').forEach(slot => {
            slot.classList.remove('touch-drop-target');
          });
          const interestsZone = document.getElementById('tourInterestsDropZone');
          if(interestsZone){
            interestsZone.style.background = '';
            interestsZone.style.borderColor = '';
          }
          
          if(wasDragging){
            // Find drop target - timeline slot
            let dropSlot = null;
            document.querySelectorAll('.timeline-slot').forEach(slot => {
              const rect = slot.getBoundingClientRect();
              if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                 touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                dropSlot = slot;
              }
            });
            
            if(dropSlot){
              // Add to itinerary
              const timeStr = dropSlot.dataset.time;
              const tourDate = tourDates.find(td => td.id === selectedTourDateId);
              if(tourDate && timeStr){
                try {
                  const chipData = JSON.parse(chip.dataset.chipData);
                  if(!tourDate.itinerary) tourDate.itinerary = [];
                  tourDate.itinerary.push({
                    time: timeStr,
                    title: chipData.name,
                    duration: 30,
                    notes: '',
                    chipData: chipData
                  });
                  saveAll();
                  renderItinerary(tourDate);
                  renderDateHeader();
                } catch(err) {
                  console.error('Error adding chip to itinerary:', err);
                }
              }
            } else {
              // Check interests drop zone
              if(interestsZone){
                const rect = interestsZone.getBoundingClientRect();
                if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                   touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                  // Add to interests
                  try {
                    const chipData = JSON.parse(chip.dataset.chipData);
                    const newChip = createInterestChip(chipData);
                    interestsZone.appendChild(newChip);
                    saveInterests();
                    updateInterestsPlaceholder();
                  } catch(err) {
                    console.error('Error adding to interests:', err);
                  }
                }
              }
            }
          } else if(touchDragActive === 'pending' && (Date.now() - touchStartTime) < 300){
            // Was a tap, not a drag - open URL
            if(!e.target.closest('.chip-remove')){
              try {
                const chipData = JSON.parse(chip.dataset.chipData);
                const targetUrl = chipData.website || chipData.url;
                if (targetUrl && targetUrl !== '#' && targetUrl.startsWith('http')) {
                  window.open(targetUrl, '_blank');
                }
              } catch (err) {
                console.error('Error opening chip URL:', err);
              }
            }
          }
          
          touchDragActive = false;
        });
        
        // Click to open URL or remove (mouse)
        chip.addEventListener('click', (e) => {
          if (e.target.closest('.chip-remove')) {
            chip.remove();
            const parentIsDropZone = chip.closest('#tourInterestsDropZone');
            if (parentIsDropZone) {
              saveInterests();
              updateInterestsPlaceholder();
            }
          } else if (!chip.classList.contains('dragging')) {
            // Open website - prefer real website over map URL
            try {
              const chipData = JSON.parse(chip.dataset.chipData);
              const targetUrl = chipData.website || chipData.url;
              console.log('Chip click - website:', chipData.website, 'url:', chipData.url, 'opening:', targetUrl);
              if (targetUrl && targetUrl !== '#' && targetUrl.startsWith('http')) {
                window.open(targetUrl, '_blank');
              }
            } catch (e) {
              console.error('Error opening chip URL:', e);
            }
          }
        });
        
        return chip;
      }
      
      // Load search results inline (no popup)
      function loadSearchInline(searchTerm, addressToUse) {
        const searchResults = document.getElementById('tourSearchResults');
        if (!searchResults) return;
        
        searchResults.innerHTML = '<div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">üîç Searching for ' + searchTerm + '...</div>';
        
        // Fetch real business data from OpenStreetMap
        fetchRealBusinessData(searchTerm, addressToUse).then(results => {
          searchResults.innerHTML = '';
          
          if (results.length === 0) {
            searchResults.innerHTML = '<div style="width:100%;text-align:center;color:#64748b;padding:20px;font-size:13px">No results found for "' + searchTerm + '"</div>';
            return;
          }
          
          results.forEach(result => {
            const chip = createInterestChip(result);
            searchResults.appendChild(chip);
          });
        }).catch(error => {
          console.error('Search error:', error);
          const errorMsg = error.message.includes('Rate limit') 
            ? '‚è±Ô∏è Rate limit reached. Please wait 10 seconds and try again.'
            : 'Error loading results. Please try again.';
          searchResults.innerHTML = `<div style="width:100%;text-align:center;color:#dc2626;padding:20px;font-size:13px">${errorMsg}</div>`;
        });
      }
      
      // Fetch REAL business data using Overpass Turbo (OpenStreetMap)
      async function fetchRealBusinessData(searchTerm, address) {
        const colorMap = {
          'hotels': '#9333ea',
          'music stores': '#dc2626',
          'rehearsal studios': '#ea580c',
          'bars': '#ca8a04',
          'restaurants': '#16a34a',
          'cafes': '#0891b2',
          'gas stations': '#2563eb',
          'print shops': '#7c3aed',
          'guitar repair': '#db2777',
          'pharmacies': '#059669'
        };
        
        const color = colorMap[searchTerm.toLowerCase()] || '#0ea5e9';
        
        // Show loading state
        const mapEmbed = document.getElementById('tourMapEmbed');
        if (mapEmbed) {
          mapEmbed.innerHTML = `
            <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#f3f4f6;border-radius:6px">
              <div style="text-align:center;color:#64748b">
                <div class="spinner" style="width:24px;height:24px;border:3px solid #e5e7eb;border-top-color:#667eea;border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 12px"></div>
                <div style="font-size:13px">Searching REAL ${searchTerm} near ${address}...</div>
              </div>
            </div>
            <style>
              @keyframes spin {
                to { transform: rotate(360deg); }
              }
            </style>
          `;
        }
        
        try {
          // Geocode the address first
          const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`;
          const geoResponse = await fetch(geocodeUrl, {
            headers: { 'User-Agent': 'FASTFAST-Setlist-App' }
          });
          const geoData = await geoResponse.json();
          
          if (!geoData || geoData.length === 0) {
            throw new Error('Location not found');
          }
          
          const lat = parseFloat(geoData[0].lat);
          const lon = parseFloat(geoData[0].lon);
          const country = geoData[0].address?.country_code?.toUpperCase() || '';
          
          console.log(`Location: ${lat}, ${lon} in ${country}`);
          
          // Embed OpenStreetMap instead of Bing for better rendering
          const osmMapUrl = `https://www.openstreetmap.org/export/embed.html?bbox=${lon-0.05},${lat-0.05},${lon+0.05},${lat+0.05}&layer=mapnik&marker=${lat},${lon}`;
          
          if (mapEmbed) {
            mapEmbed.innerHTML = `
              <iframe 
                width="100%" 
                height="100%" 
                frameborder="0" 
                scrolling="no" 
                marginheight="0" 
                marginwidth="0" 
                src="${osmMapUrl}" 
                style="border:none;border-radius:6px">
              </iframe>
            `;
          }
          
          // Search query templates for OSM tags with progressive radius
          const osmQueries = {
            'hotels': '(node["tourism"="hotel"](around:{radius},{lat},{lon});way["tourism"="hotel"](around:{radius},{lat},{lon});node["tourism"="motel"](around:{radius},{lat},{lon});way["tourism"="motel"](around:{radius},{lat},{lon});node["tourism"="hostel"](around:{radius},{lat},{lon});way["tourism"="hostel"](around:{radius},{lat},{lon});)',
            'music stores': '(node["shop"="music"](around:{radius},{lat},{lon});way["shop"="music"](around:{radius},{lat},{lon});node["shop"="musical_instrument"](around:{radius},{lat},{lon});way["shop"="musical_instrument"](around:{radius},{lat},{lon});)',
            'rehearsal studios': '(node["amenity"="studio"](around:{radius},{lat},{lon});way["amenity"="studio"](around:{radius},{lat},{lon});node["amenity"="music_venue"]["rehearsal"="yes"](around:{radius},{lat},{lon});way["amenity"="music_venue"]["rehearsal"="yes"](around:{radius},{lat},{lon});node[~"name"~"[Rr]ehearsal|[Pp]ractice|[Ss]tudio|[Jj]am [Ss]pace|[Ll]ockup|[Mm]usic [Rr]oom",i](around:{radius},{lat},{lon});way[~"name"~"[Rr]ehearsal|[Pp]ractice|[Ss]tudio|[Jj]am [Ss]pace|[Ll]ockup|[Mm]usic [Rr]oom",i](around:{radius},{lat},{lon});)',
            'bars': '(node["amenity"="bar"](around:{radius},{lat},{lon});way["amenity"="bar"](around:{radius},{lat},{lon});node["amenity"="pub"](around:{radius},{lat},{lon});way["amenity"="pub"](around:{radius},{lat},{lon});)',
            'restaurants': '(node["amenity"="restaurant"](around:{radius},{lat},{lon});way["amenity"="restaurant"](around:{radius},{lat},{lon});node["amenity"="fast_food"](around:{radius},{lat},{lon});way["amenity"="fast_food"](around:{radius},{lat},{lon});)',
            'cafes': '(node["amenity"="cafe"](around:{radius},{lat},{lon});way["amenity"="cafe"](around:{radius},{lat},{lon});node["shop"="coffee"](around:{radius},{lat},{lon});)',
            'gas stations': '(node["amenity"="fuel"](around:{radius},{lat},{lon});way["amenity"="fuel"](around:{radius},{lat},{lon});)',
            'print shops': '(node["shop"="copyshop"](around:{radius},{lat},{lon});way["shop"="copyshop"](around:{radius},{lat},{lon});node["shop"="printer"](around:{radius},{lat},{lon});node["shop"="print"](around:{radius},{lat},{lon});)',
            'guitar repair': '(node["craft"="musical_instrument"](around:{radius},{lat},{lon});way["craft"="musical_instrument"](around:{radius},{lat},{lon});node["shop"="music"]["service"="repair"](around:{radius},{lat},{lon});)',
            'pharmacies': '(node["amenity"="pharmacy"](around:{radius},{lat},{lon});way["amenity"="pharmacy"](around:{radius},{lat},{lon});)'
          };
          
          const queryTemplate = osmQueries[searchTerm.toLowerCase()] || `(node[~"name"~"${searchTerm}",i](around:{radius},{lat},{lon});way[~"name"~"${searchTerm}",i](around:{radius},{lat},{lon});)`;
          
          // Single smart search with 10km radius (balance between coverage and API limits)
          const searchRadius = 10000; // 10km
          const osmQuery = queryTemplate.replace(/{radius}/g, searchRadius).replace(/{lat}/g, lat).replace(/{lon}/g, lon);
          const overpassQuery = `[out:json][timeout:30];${osmQuery};out body 50;`;
          const overpassUrl = 'https://overpass-api.de/api/interpreter';
          
          console.log(`Searching within ${searchRadius/1000}km radius...`);
          
          // Add delay to avoid rate limiting (wait 1 second between searches)
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          const response = await fetch(overpassUrl, {
            method: 'POST',
            body: overpassQuery,
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
          });
          
          if (!response.ok) {
            if (response.status === 429) {
              throw new Error('Rate limit reached. Please wait a moment and try again.');
            }
            throw new Error(`Overpass API error: ${response.status}`);
          }
          
          const data = await response.json();
          console.log(`Found ${data.elements.length} results within ${searchRadius/1000}km`);
          
          // Store elements with their search radius
          const allBusinesses = data.elements.map(el => {
            el._searchRadius = searchRadius;
            return el;
          });
          
          // Calculate distance helper function
          function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
          }
          
          // Convert OSM data to business chips, filtering by country
          const businesses = allBusinesses
            .filter(element => {
              if (!element.tags || !element.tags.name) return false;
              
              // Filter by country if available
              const elemCountry = element.tags['addr:country']?.toUpperCase();
              if (country && elemCountry && elemCountry !== country) {
                console.log(`Filtering out ${element.tags.name} - wrong country: ${elemCountry} != ${country}`);
                return false;
              }
              
              return true;
            })
            .map(element => {
              const tags = element.tags;
              const name = tags.name;
              
              // Build address
              const parts = [];
              if (tags['addr:housenumber']) parts.push(tags['addr:housenumber']);
              if (tags['addr:street']) parts.push(tags['addr:street']);
              if (tags['addr:city']) parts.push(tags['addr:city']);
              const addressLine = parts.length > 0 ? parts.join(' ') : 'Address unavailable';
              
              // Get contact info
              const phone = tags.phone || tags['contact:phone'] || tags['contact:mobile'] || '';
              const website = tags.website || tags['contact:website'] || '';
              
              // Build map URL
              const elLat = element.lat || (element.center && element.center.lat);
              const elLon = element.lon || (element.center && element.center.lon);
              const mapUrl = elLat && elLon 
                ? `https://www.openstreetmap.org/?mlat=${elLat}&mlon=${elLon}#map=19/${elLat}/${elLon}`
                : '#';
              
              // Calculate actual distance from venue
              const distance = elLat && elLon ? calculateDistance(lat, lon, elLat, elLon) : null;
              
              return {
                name: name,
                address: addressLine,
                phone: phone,
                url: mapUrl,
                website: website,
                rating: null,
                type: searchTerm,
                color: color,
                lat: elLat,
                lon: elLon,
                distance: distance
              };
            });
          
          console.log(`Processed ${businesses.length} businesses with names`);
          
          if (businesses.length === 0) {
            // Return empty array instead of throwing error - let UI handle gracefully
            return [];
          }
          
          // Update map to zoom to first result if available
          if (businesses.length > 0 && businesses[0].lat && businesses[0].lon && mapEmbed) {
            const topLat = businesses[0].lat;
            const topLon = businesses[0].lon;
            const zoomedMapUrl = `https://www.openstreetmap.org/export/embed.html?bbox=${topLon-0.01},${topLat-0.01},${topLon+0.01},${topLat+0.01}&layer=mapnik&marker=${topLat},${topLon}`;
            
            mapEmbed.innerHTML = `
              <iframe 
                width="100%" 
                height="100%" 
                frameborder="0" 
                scrolling="no" 
                marginheight="0" 
                marginwidth="0" 
                src="${zoomedMapUrl}" 
                style="border:none;border-radius:6px">
              </iframe>
            `;
          }
          
          return businesses;
          
        } catch (error) {
          console.error('Error fetching REAL business data:', error);
          throw error; // Re-throw to show error to user
        }
      }
      
      // Generate realistic mock search results with business details
      function generateMockResults(searchTerm, address) {
        const colorMap = {
          'hotels': '#9333ea',
          'music stores': '#dc2626',
          'rehearsal studios': '#ea580c',
          'bars': '#ca8a04',
          'restaurants': '#16a34a',
          'cafes': '#0891b2',
          'gas stations': '#2563eb',
          'print shops': '#7c3aed',
          'guitar repair': '#db2777',
          'pharmacies': '#059669'
        };
        
        const businessNames = {
          'hotels': ['Comfort Inn', 'Holiday Express', 'Hampton Inn', 'Best Western', 'Marriott', 'Hilton Garden', 'La Quinta', 'Courtyard'],
          'music stores': ['Guitar Center', 'Sam Ash', 'Long & McQuade', 'Music & Arts', 'Sweetwater', 'Local Music Shop', 'The Music Store', 'Sound House'],
          'rehearsal studios': ['Studio One Rehearsal', 'Band Practice Space', 'The Jam Room', 'Sound Studio', 'Rehearsal Factory', 'Music Lab', 'Practice HQ'],
          'bars': ['Irish Pub', 'Sports Bar & Grill', 'Craft Beer Hall', 'The Tavern', 'Downtown Bar', 'Ale House', 'Brewery Taproom'],
          'restaurants': ['Italian Bistro', 'Steakhouse', 'Sushi Bar', 'Mexican Cantina', 'Pizza Kitchen', 'Asian Fusion', 'BBQ Joint'],
          'cafes': ['Starbucks', 'Local Coffee Co.', 'Espresso Bar', 'The Daily Grind', 'Bean & Brew', 'Coffee House', 'Artisan Caf√©'],
          'gas stations': ['Shell', 'Chevron', 'BP', 'Exxon', 'Mobil', '7-Eleven', 'Circle K'],
          'print shops': ['FedEx Office', 'Staples', 'Office Depot', 'UPS Store', 'Kinko\'s', 'Local Print Shop'],
          'guitar repair': ['Guitar Tech Shop', 'Luthier Workshop', 'String & Fret', 'Guitar Hospital', 'Repair Station'],
          'pharmacies': ['Walgreens', 'CVS', 'Rite Aid', 'Local Pharmacy', 'HealthMart']
        };
        
        const streetSuffixes = ['Street', 'Avenue', 'Boulevard', 'Drive', 'Lane', 'Road', 'Way'];
        const streetNames = ['Main', 'Oak', 'Maple', 'Cedar', 'Pine', 'Washington', 'Lincoln', 'Jefferson', 'Madison', 'Park'];
        
        const color = colorMap[searchTerm.toLowerCase()] || '#0ea5e9';
        const names = businessNames[searchTerm.toLowerCase()] || ['Local Business'];
        
        // Generate realistic results
        const results = [];
        const count = Math.floor(Math.random() * 6) + 5; // 5-10 results
        
        for (let i = 0; i < count; i++) {
          const name = names[Math.floor(Math.random() * names.length)] + (names.length > 1 ? ` #${i + 1}` : ` ${i + 1}`);
          const streetNum = Math.floor(Math.random() * 9000) + 100;
          const street = streetNames[Math.floor(Math.random() * streetNames.length)];
          const suffix = streetSuffixes[Math.floor(Math.random() * streetSuffixes.length)];
          const addressLine = `${streetNum} ${street} ${suffix}`;
          
          // Generate phone number
          const areaCode = Math.floor(Math.random() * 900) + 100;
          const prefix = Math.floor(Math.random() * 900) + 100;
          const lineNum = Math.floor(Math.random() * 9000) + 1000;
          const phone = `(${areaCode}) ${prefix}-${lineNum}`;
          
          // Random rating
          const rating = (Math.random() * 2 + 3).toFixed(1); // 3.0 - 5.0
          
          const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(name + ' ' + addressLine + ' ' + address)}`;
          
          results.push({
            name: name,
            address: addressLine,
            phone: phone,
            url: searchUrl,
            rating: parseFloat(rating),
            type: searchTerm,
            color: color
          });
        }
        
        return results;
      }
      
      // Drop zone handlers
      if (interestsDropZone) {
        interestsDropZone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'copy';
          interestsDropZone.classList.add('drag-over');
        });
        
        interestsDropZone.addEventListener('dragleave', () => {
          interestsDropZone.classList.remove('drag-over');
        });
        
        interestsDropZone.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          interestsDropZone.classList.remove('drag-over');
          
          try {
            // Try to get JSON data first
            let data = null;
            const jsonData = e.dataTransfer.getData('application/json');
            if (jsonData) {
              data = JSON.parse(jsonData);
            } else {
              // Fallback to text/plain
              const textData = e.dataTransfer.getData('text/plain');
              if (textData) {
                try {
                  data = JSON.parse(textData);
                } catch (e) {
                  console.log('Could not parse text data as JSON');
                  return;
                }
              }
            }
            
            if (data && data.name) {
              // Check for duplicates
              const existing = Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip'));
              const isDuplicate = existing.some(chip => {
                try {
                  const chipData = JSON.parse(chip.dataset.chipData);
                  return chipData.name === data.name && chipData.address === data.address;
                } catch (e) {
                  return false;
                }
              });
              
              if (!isDuplicate) {
                const chip = createInterestChip(data);
                if (interestsPlaceholder) interestsPlaceholder.style.display = 'none';
                interestsDropZone.appendChild(chip);
                saveInterests();
                updateInterestsPlaceholder();
              }
            }
          } catch (err) {
            console.error('Drop error:', err);
          }
        });
      }
      
      // Save interests to tour date
      function saveInterests() {
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if (!tourDate) return;
        
        const chips = Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip'));
        tourDate.interests = chips.map(chip => {
          try {
            return JSON.parse(chip.dataset.chipData);
          } catch (e) {
            return null;
          }
        }).filter(x => x !== null);
        
        saveAll();
      }
      
      // Load interests for selected tour date
      function loadInterests() {
        if (!interestsDropZone) return;
        
        // Clear existing chips (except placeholder)
        Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip')).forEach(chip => chip.remove());
        
        const tourDate = tourDates.find(td => td.id === selectedTourDateId);
        if (!tourDate || !tourDate.interests || tourDate.interests.length === 0) {
          updateInterestsPlaceholder();
          return;
        }
        
        tourDate.interests.forEach(interestData => {
          const chip = createInterestChip(interestData);
          interestsDropZone.appendChild(chip);
        });
        
        updateInterestsPlaceholder();
      }
      
      // Update placeholder visibility
      function updateInterestsPlaceholder() {
        if (!interestsPlaceholder) return;
        const hasChips = interestsDropZone.querySelectorAll('.tour-interest-chip').length > 0;
        interestsPlaceholder.style.display = hasChips ? 'none' : '';
      }
      
      // Clear all interests
      if (clearInterestsBtn) {
        clearInterestsBtn.addEventListener('click', () => {
          if (!confirm('Clear all saved places for this date?')) return;
          
          Array.from(interestsDropZone.querySelectorAll('.tour-interest-chip')).forEach(chip => chip.remove());
          saveInterests();
          updateInterestsPlaceholder();
        });
      }
      
      // Custom search buttons storage
      let customSearchButtons = [];
      try {
        const stored = localStorage.getItem(STORE_KEY);
        if(stored){
          const data = JSON.parse(stored);
          customSearchButtons = Array.isArray(data.customSearchButtons) ? data.customSearchButtons : [];
        }
      } catch(e) {
        customSearchButtons = [];
      }
      
      // Ensure it's always an array before rendering
      if(!Array.isArray(customSearchButtons)) customSearchButtons = [];
      
      // Render custom search buttons
      function renderCustomSearchButtons() {
        const container = document.getElementById('customSearchButtons');
        if(!container) return;
        
        container.innerHTML = '';
        if(!Array.isArray(customSearchButtons)) customSearchButtons = [];
        customSearchButtons.forEach((term, idx) => {
          const btn = document.createElement('button');
          btn.className = 'btn';
          btn.style.cssText = 'padding:3px 6px;font-size:9px;position:relative;padding-right:18px';
          btn.textContent = term;
          btn.dataset.search = term;
          
          // Remove button
          const removeBtn = document.createElement('span');
          removeBtn.textContent = '√ó';
          removeBtn.style.cssText = 'position:absolute;right:4px;top:50%;transform:translateY(-50%);cursor:pointer;font-weight:bold;color:#ef4444';
          removeBtn.onclick = (e) => {
            e.stopPropagation();
            if(confirm(`Remove "${term}" button?`)){
              customSearchButtons.splice(idx, 1);
              saveAll();
              renderCustomSearchButtons();
            }
          };
          
          btn.appendChild(removeBtn);
          container.appendChild(btn);
          
          // Add click handler
          btn.addEventListener('click', () => {
            const tourDate = tourDates.find(td => td.id === selectedTourDateId);
            let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
            
            if (!addressToUse) {
              alert('Please enter a venue address in the Tour date details above');
              return;
            }
            
            loadSearchInline(term, addressToUse);
          });
        });
      }
      
      // Add custom search button
      const tourAddCustomBtn = document.getElementById('tourAddCustomBtn');
      if(tourAddCustomBtn){
        tourAddCustomBtn.addEventListener('click', () => {
          const term = prompt('Enter search term (e.g., "Laundromat", "Bike Shops", etc.):');
          if(term && term.trim()){
            customSearchButtons.push(term.trim());
            saveAll();
            renderCustomSearchButtons();
          }
        });
      }
      
      // Custom search from input field
      const tourSearchBtn = document.getElementById('tourSearchBtn');
      const tourSearchInput = document.getElementById('tourSearchLocation');
      if(tourSearchBtn && tourSearchInput){
        tourSearchBtn.addEventListener('click', () => {
          const searchTerm = tourSearchInput.value.trim();
          if(!searchTerm){
            alert('Please enter a search term');
            return;
          }
          
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
        
        // Enter key to search
        tourSearchInput.addEventListener('keydown', (e) => {
          if(e.key === 'Enter'){
            tourSearchBtn.click();
          }
        });
      }
      
      // Quick service search buttons
      document.querySelectorAll('[data-search]').forEach(btn => {
        btn.addEventListener('click', () => {
          const searchTerm = btn.dataset.search;
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          
          // Get address from: 1) current form input, 2) tour date, 3) main gig
          let addressToUse = (tourAddressInput && tourAddressInput.value) || (tourDate && tourDate.address) || gig.address || gig.venue || '';
          
          if (!addressToUse) {
            alert('Please enter a venue address in the Tour date details above');
            return;
          }
          
          loadSearchInline(searchTerm, addressToUse);
        });
      });
      
      // Initialize custom buttons
      renderCustomSearchButtons();
      

      
      // Update selectTourDate to load interests
      const originalSelectTourDate = selectTourDate;
      selectTourDate = function(tourDate) {
        originalSelectTourDate(tourDate);
        loadInterests();
      };
      
      // Auto-sync: when gig.date changes, switch to matching tour date
      let lastGigDate = gig.date || '';
      function checkGigDateChange(){
        const currentGigDate = gig.date || '';
        if(currentGigDate && currentGigDate !== lastGigDate){
          lastGigDate = currentGigDate;
          console.log(`Gig date changed to ${currentGigDate}, checking for matching tour date...`);
          
          // Find or create matching tour date
          let matchingTourDate = tourDates.find(td => td.date === currentGigDate);
          
          if(!matchingTourDate){
            // Create new tour date for this gig date
            console.log(`Creating new tour date for ${currentGigDate}`);
            matchingTourDate = {
              id: generateId(),
              date: currentGigDate,
              venue: gig.venue || '',
              address: gig.address || '',
              loadIn: '',
              showTime: '',
              band: gig.band || '',
              setlistType: 'current',
              stagePlotType: 'current',
              itinerary: [],
              interests: []
            };
            tourDates.push(matchingTourDate);
            saveAll();
          }
          
          // Switch to this tour date
          console.log(`Switching to tour date: ${matchingTourDate.id}`);
          selectTourDate(matchingTourDate);
          renderTimeline();
        }
      }
      
      // Check for gig date changes periodically
      setInterval(checkGigDateChange, 2000);
      
      // Initialize
      renderTimeline();
      renderDateHeader(); // Render global date strip
      checkGigDateChange(); // Initial check
      
      // Load first tour date or today on startup
      if(tourDates && tourDates.length > 0){
        // Find first upcoming or current tour date
        const today = new Date();
        today.setHours(0,0,0,0);
        const upcomingDate = tourDates.find(td => {
          const d = new Date(td.date);
          d.setHours(0,0,0,0);
          return d >= today;
        });
        const firstDate = upcomingDate || tourDates[0];
        if(firstDate){
          gig.date = firstDate.date;
          selectedTourDateId = firstDate.id;
          loadDateData(firstDate);
          selectTourDate(firstDate);
          renderDateHeader();
        }
      }
      
      // Show Calendar tab on load
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      const calTab = document.querySelector('.tab[data-tab="tour"]');
      if(calTab) calTab.classList.add('active');
      ['db','set','adv','tour','live'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      const tourEl = document.getElementById('tour');
      if(tourEl) tourEl.style.display='block';
      
      // Activity chip drag handlers - with touch support
      let touchDragClone = null;
      let touchDragData = null;
      let touchStartTarget = null;
      
      function initActivityChips(){
        const chips = document.querySelectorAll('.activity-chip');
        chips.forEach(chip => {
          // Mouse/desktop drag
          chip.addEventListener('dragstart', (e) => {
            const activity = chip.dataset.activity;
            const duration = chip.dataset.duration;
            const color = chip.dataset.color;
            
            e.dataTransfer.setData('activity', activity);
            e.dataTransfer.setData('duration', duration);
            e.dataTransfer.setData('color', color);
            e.dataTransfer.effectAllowed = 'copy';
            
            chip.style.opacity = '0.5';
          });
          
          chip.addEventListener('dragend', (e) => {
            chip.style.opacity = '1';
          });
          
          // Touch drag - custom implementation since HTML5 drag doesn't work on touch
          chip.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartTarget = chip;
            
            // Store drag data
            touchDragData = {
              activity: chip.dataset.activity,
              duration: chip.dataset.duration,
              color: chip.dataset.color
            };
            
            // Create clone for visual feedback
            touchDragClone = chip.cloneNode(true);
            touchDragClone.classList.add('touch-dragging');
            touchDragClone.style.left = (touch.clientX - 40) + 'px';
            touchDragClone.style.top = (touch.clientY - 15) + 'px';
            document.body.appendChild(touchDragClone);
            
            chip.style.opacity = '0.3';
          }, {passive: false});
          
          chip.addEventListener('touchmove', (e) => {
            if(!touchDragClone) return;
            e.preventDefault();
            const touch = e.touches[0];
            
            // Move clone
            touchDragClone.style.left = (touch.clientX - 40) + 'px';
            touchDragClone.style.top = (touch.clientY - 15) + 'px';
            
            // Highlight drop targets
            document.querySelectorAll('.timeline-slot').forEach(slot => {
              const rect = slot.getBoundingClientRect();
              if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                 touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                slot.classList.add('touch-drop-target');
              } else {
                slot.classList.remove('touch-drop-target');
              }
            });
          }, {passive: false});
          
          chip.addEventListener('touchend', (e) => {
            if(!touchDragClone || !touchDragData) {
              cleanupTouchDrag();
              return;
            }
            
            const touch = e.changedTouches[0];
            
            // Find drop target
            let dropTarget = null;
            document.querySelectorAll('.timeline-slot').forEach(slot => {
              const rect = slot.getBoundingClientRect();
              if(touch.clientX >= rect.left && touch.clientX <= rect.right &&
                 touch.clientY >= rect.top && touch.clientY <= rect.bottom){
                dropTarget = slot;
              }
              slot.classList.remove('touch-drop-target');
            });
            
            if(dropTarget && touchDragData.activity){
              // Add to itinerary
              const timeStr = dropTarget.dataset.time;
              const tourDate = tourDates.find(td => td.id === selectedTourDateId);
              if(tourDate && timeStr){
                let title = touchDragData.activity.charAt(0).toUpperCase() + touchDragData.activity.slice(1);
                if(!tourDate.itinerary) tourDate.itinerary = [];
                tourDate.itinerary.push({
                  time: timeStr,
                  title: title,
                  activity: touchDragData.activity,
                  duration: 30,
                  chipData: { color: touchDragData.color },
                  notes: ''
                });
                saveAll();
                renderItinerary(tourDate);
                renderDateHeader();
              }
            }
            
            cleanupTouchDrag();
          });
        });
      }
      
      function cleanupTouchDrag(){
        if(touchDragClone){
          touchDragClone.remove();
          touchDragClone = null;
        }
        if(touchStartTarget){
          touchStartTarget.style.opacity = '1';
          touchStartTarget = null;
        }
        touchDragData = null;
        document.querySelectorAll('.timeline-slot').forEach(slot => {
          slot.classList.remove('touch-drop-target');
        });
      }
      
      // Initialize chip drag handlers
      initActivityChips();
      
      // Drag-to-assign handlers for setlist and stage plot
      function initDragAssignHandles(){
        const setlistHandle = document.getElementById('setlistDragHandle');
        const stageHandle = document.getElementById('stageDragHandle');
        
        // Remove old listeners by cloning
        if(setlistHandle){
          const newSetlistHandle = setlistHandle.cloneNode(true);
          setlistHandle.parentNode.replaceChild(newSetlistHandle, setlistHandle);
          
          newSetlistHandle.draggable = true;
          
          // Use capture phase to block events before they reach other handlers
          newSetlistHandle.addEventListener('mousedown', (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, {capture: true});
          newSetlistHandle.addEventListener('touchstart', (e) => { e.stopPropagation(); e.stopImmediatePropagation(); }, {capture: true});
          
          newSetlistHandle.addEventListener('dragstart', (e) => {
            e.stopPropagation();
            e.dataTransfer.setData('text/plain', 'setlist');
            e.dataTransfer.setData('assignType', 'setlist');
            e.dataTransfer.effectAllowed = 'copy';
            newSetlistHandle.style.cursor = 'grabbing';
            console.log('‚úì Drag started: setlist');
          });
          
          newSetlistHandle.addEventListener('dragend', (e) => {
            newSetlistHandle.style.cursor = 'grab';
          });
        }
        
        // Stage plot drag handle
        if(stageHandle){
          const newStageHandle = stageHandle.cloneNode(true);
          stageHandle.parentNode.replaceChild(newStageHandle, stageHandle);
          
          newStageHandle.draggable = true;
          
          // Stop propagation to prevent stage plot interactions, but DON'T preventDefault for drag to work
          newStageHandle.addEventListener('mousedown', (e) => { 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('touchstart', (e) => { 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('click', (e) => { 
            e.preventDefault(); 
            e.stopPropagation(); 
            e.stopImmediatePropagation(); 
          }, {capture: true});
          
          newStageHandle.addEventListener('dragstart', (e) => {
            e.stopPropagation();
            e.dataTransfer.setData('text/plain', 'stagePlot');
            e.dataTransfer.setData('assignType', 'stagePlot');
            e.dataTransfer.effectAllowed = 'copy';
            newStageHandle.style.cursor = 'grabbing';
            console.log('‚úì Drag started: stagePlot');
          });
          
          newStageHandle.addEventListener('dragend', (e) => {
            newStageHandle.style.cursor = 'grab';
          });
        }
      }
      
      // Initialize drag-assign handles
      initDragAssignHandles();
      
      // Make globally accessible
      window.initDragAssignHandles = initDragAssignHandles;
      
    })();

    function buildSheet(target='sheet'){
      const isInline = (target!=='sheet');
      const sheet = document.getElementById(target);
      if(!sheet) return;
      
      // Apply paper format
      const format = pageLayout.format || 'letter';
      if(format === 'a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
      
      // Calculate required page count FIRST before building anything
      const songsPerPage = pageLayout.songsPerPage || 25;
      const songCount = setlist.filter(x => x.title).length;
      const breakCount = setlist.filter(x => x.type === 'break' || x.type === 'encore').length;
      const totalItems = songCount + breakCount;
      
      let pageCount = pageLayout.pageCount || 1;
      // Auto-generate pages based on total items (both preview and print)
      if(totalItems > songsPerPage){
        const requiredPages = Math.ceil(totalItems / songsPerPage);
        pageCount = Math.max(pageCount, requiredPages);
      }
      const multiPage = pageCount > 1;
      
      // Clear and setup sheet structure
      sheet.innerHTML = '';
      if(multiPage){
        sheet.classList.add('multipage');
        for(let p=0; p<pageCount; p++){
          const page = document.createElement('div');
          page.className = 'sheet-page';
          page.dataset.pageIndex = p;
          const pageHdr = document.createElement('div');
          pageHdr.className = 'hdr';
          pageHdr.id = (isInline ? 'hdrInline' : 'hdr') + (p>0 ? '_'+p : '');
          const pageSongs = document.createElement('div');
          pageSongs.className = 'songs';
          pageSongs.id = (isInline ? 'songsInline' : 'songs') + (p>0 ? '_'+p : '');
          page.appendChild(pageHdr);
          page.appendChild(pageSongs);
          sheet.appendChild(page);
        }
      } else {
        sheet.classList.remove('multipage');
        const hdrEl = document.createElement('div');
        hdrEl.className = 'hdr';
        hdrEl.id = isInline ? 'hdrInline' : 'hdr';
        const songsEl = document.createElement('div');
        songsEl.className = 'songs';
        songsEl.id = isInline ? 'songsInline' : 'songs';
        sheet.appendChild(hdrEl);
        sheet.appendChild(songsEl);
      }
      
      const hdr = document.getElementById(isInline? 'hdrInline' : 'hdr');
      const songs = document.getElementById(isInline? 'songsInline' : 'songs');
      if(!hdr || !songs) return;
      
      // Get current band from Act selector (authoritative source)
      const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || '') : (gig.band || '');
      
      // Header - directly editable
      hdr.innerHTML='';
      const b = el('div','band',currentBandName.trim()||'Enter Band Name');
      b.contentEditable = 'true';
      b.setAttribute('data-placeholder', 'Enter Band Name');
      b.addEventListener('blur', ()=>{
        gig.band = b.textContent.trim();
        // Sync to calendar band input
        const calBandInput = document.getElementById('tourBand');
        if(calBandInput) calBandInput.value = gig.band;
        // Also update current tour date's band
        const currentTourDate = tourDates.find(td => td.id === selectedTourDateId);
        if(currentTourDate) currentTourDate.band = gig.band;
        // Update Act display in header
        if(typeof updateActDisplay === 'function') updateActDisplay();
        saveAll();
      });
      b.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          b.blur();
        }
      });
      
      const v = el('div','venue',gig.venue||'Enter Venue');
      v.contentEditable = 'true';
      v.setAttribute('data-placeholder', 'Enter Venue');
      v.addEventListener('blur', ()=>{
        gig.venue = v.textContent.trim();
        saveAll();
      });
      v.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          v.blur();
        }
      });
      
      const sub = el('div','sub', gig.address||'Enter Address');
      sub.contentEditable = 'true';
      sub.setAttribute('data-placeholder', 'Enter Address');
      sub.addEventListener('blur', ()=>{
        gig.address = sub.textContent.trim();
        saveAll();
      });
      sub.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          sub.blur();
        }
      });
      
      const n = el('div','notes', gig.notes||'Enter Notes');
      n.contentEditable = 'true';
      n.setAttribute('data-placeholder', 'Enter Notes');
      n.addEventListener('blur', ()=>{
        gig.notes = n.textContent.trim();
        saveAll();
      });
      n.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter') {
          e.preventDefault();
          n.blur();
        }
      });
      
      hdr.appendChild(b);
      hdr.appendChild(v);
      
      // Add date display if exists
      if(gig.date){
        // Parse YYYY-MM-DD as local date (not UTC) to avoid timezone shift
        const [y, m, d] = gig.date.split('-').map(Number);
        const localDate = new Date(y, m - 1, d);
        const dateEl = el('div','sub', localDate.toLocaleDateString('en-US', {weekday:'long', year:'numeric', month:'long', day:'numeric'}));
        dateEl.style.fontWeight = '700';
        dateEl.style.color = '#111';
        hdr.appendChild(dateEl);
      }
      
      hdr.appendChild(sub);
      hdr.appendChild(n);

      // Apply font selection
      const fontMap={
        'default':'Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif',
        'helvetica':'Helvetica, Arial, sans-serif',
        'georgia':'Georgia, Times, serif',
        'roboto-condensed':'"Roboto Condensed", Roboto, Arial, sans-serif',
        'courier':'"Courier New", Courier, monospace'
      };
      sheet.style.fontFamily = fontMap[gig.font||'default']||fontMap.default;

      // Songs
      songs.innerHTML='';
      // dynamic font scaling to fit one page
      // Start with base sizes and try to fit, shrink if overflow
  const base = { title:14, lineGap:3 };

      const lines=[];
      let sinceBreak=0;
      let songCounter=0;
      setlist.forEach((it, idx)=>{
        if(it.type==='break'){
          const br=el('div','break',`${it.title} ‚Äî ${it.length}m`);
          if(sinceBreak>=15) br.classList.add('pagebreak');
          lines.push(br); sinceBreak=0; return;
        }
        if(it.type==='encore'){ const label=(it.title||'Encore'); const enc=el('div','break',label.toUpperCase()); if(sinceBreak>=15) enc.classList.add('pagebreak'); lines.push(enc); sinceBreak=0; return; }
        if(it.type==='blankrow'){ const blank=el('div','line'); blank.style.height='1.5em'; blank.innerHTML='&nbsp;'; lines.push(blank); return; }
        if(it.type==='separator'){ const sep=el('div','separator'); sep.style.borderBottom='2px solid #333'; sep.style.margin='4px 0'; sep.style.height='0'; lines.push(sep); return; }
        const row=el('div','line');
        row.append(el('div','no', String(++songCounter)));
        
        // Build display: Number, Title, Artist, Key, Capo, BPM, Notes, Lyrics, Time
        const title=el('div','title', shorten(it.title));
        const displayParts = [];
        
        // Artist (if checkbox checked)
        if(setlistColumns.artist && it.artist){
          displayParts.push(it.artist);
        }
        
        // Only show these if checkboxes are checked
        if(setlistColumns.key && it.key){
          displayParts.push(it.key);
        }
        if(setlistColumns.capo && Number.isInteger(it.capo) && it.capo>0){
          displayParts.push('Capo '+it.capo);
        }
        if(setlistColumns.bpm && it.bpm){
          displayParts.push(it.bpm+' BPM');
        }
        if(setlistColumns.notes && it.notes){
          displayParts.push(it.notes);
        }
        if(setlistColumns.lyrics && it.lyrics){
          const firstLine = findFirstLyricLine(it.lyrics);
          if(firstLine){
            displayParts.push(firstLine.length>40 ? firstLine.substring(0,40)+'...' : firstLine);
          }
        }
        // Custom columns from setlistColumns
        if(gig.customColumns && it.customFields){
          gig.customColumns.forEach(cc=>{
            if(setlistColumns[cc.key] && it.customFields[cc.key]){
              displayParts.push(it.customFields[cc.key]);
            }
          });
        }
        
        if(displayParts.length > 0){
          const detailSpan = el('span','notePrint',' ‚Äì ' + displayParts.join(' ‚Äì '));
          title.appendChild(detailSpan);
        }
        
        row.append(title);
        // Right side no longer shows key/capo/bpm - empty for now
        row.append(el('div','key', ''));
        row.append(el('div','time', `${it.length}m`));
        lines.push(row); sinceBreak++;
      });

      // Multi-page layout: fill each page completely before moving to next
      if(multiPage && pageCount > 1){
        // Distribute songs sequentially - fill page 1 completely, then page 2, etc.
        let currentLineIdx = 0;
        let lastPageWithContent = null;
        const pagesToRemove = [];
        
        for(let p=0; p<pageCount; p++){
          const pageHdr = sheet.querySelector(`.sheet-page[data-page-index="${p}"] .hdr`);
          const pageSongs = sheet.querySelector(`.sheet-page[data-page-index="${p}"] .songs`);
          if(!pageHdr || !pageSongs) continue;
          
          // Clone header to each page
          if(p === 0){
            pageHdr.innerHTML = hdr.innerHTML;
          } else {
            // Minimal header for continuation pages
            const contBand = gig.logo ? (function(){ const d=el('div','logo'); const img=document.createElement('img'); img.src=gig.logo; img.alt='Band Logo'; d.appendChild(img); return d; })() : el('div','band',(gig.band||'').trim()||'BAND NAME');
            pageHdr.appendChild(contBand);
            const contLabel = el('div','sub','(continued)');
            pageHdr.appendChild(contLabel);
          }
          
          // Add lines to this page up to songsPerPage threshold
          const pageLines = [];
          const maxForPage = pageLayout.songsPerPage || 25;
          while(currentLineIdx < lines.length && pageLines.length < maxForPage){
            const line = lines[currentLineIdx];
            line.dataset.setlistIndex = currentLineIdx;
            pageLines.push(line);
            currentLineIdx++;
          }
          if(pageLines.length > 0){
            pageSongs.append(...pageLines);
            lastPageWithContent = pageSongs;
          } else {
            // Mark empty page for removal
            pagesToRemove.push(p);
          }
        }
        
        // Remove any blank pages from the DOM
        pagesToRemove.forEach(pageIdx => {
          const emptyPage = sheet.querySelector(`.sheet-page[data-page-index="${pageIdx}"]`);
          if(emptyPage) emptyPage.remove();
        });
        
        // Add total time to the last page that actually received content BEFORE fitting
        if(lastPageWithContent){
          const totalMin = setlist.reduce((acc,it)=> acc + ((it.type==='song'||it.type==='break') ? (parseFloat(it.length)||0) : 0), 0);
          const totalEl = document.createElement('div');
          totalEl.className = 'total-time';
          totalEl.textContent = `Total: ${totalMin.toFixed(0)}m`;
          totalEl.style.textAlign='right'; totalEl.style.marginTop='4px'; totalEl.style.fontWeight='600'; totalEl.style.fontSize='9pt';
          lastPageWithContent.appendChild(totalEl);
        }
        
        // Fit each page to available space AFTER adding total time (skip removed pages)
        for(let p=0; p<pageCount; p++){
          if(pagesToRemove.includes(p)) continue;
          const pageSongs = sheet.querySelector(`.sheet-page[data-page-index="${p}"] .songs`);
          if(pageSongs) fitToPage(pageSongs);
        }
      } else {
        // Single page: append all songs and fit
        // Add data-setlist-index to track position
        lines.forEach((line, idx) => {
          line.dataset.setlistIndex = idx;
        });
        songs.append(...lines);
        
        // Add total time inside songs container before fitting
        const totalMin = setlist.reduce((acc,it)=> acc + ((it.type==='song'||it.type==='break') ? (parseFloat(it.length)||0) : 0), 0);
        let totalEl = songs.querySelector('.total-time');
        if(!totalEl){ 
          totalEl=document.createElement('div'); 
          totalEl.className='total-time'; 
        }
        totalEl.textContent = `Total: ${totalMin.toFixed(0)}m`;
        totalEl.style.textAlign='right'; totalEl.style.marginTop='4px'; totalEl.style.fontWeight='600'; totalEl.style.fontSize='9pt';
        songs.appendChild(totalEl);
        
        fitToPage();
      }

      function fitToPage(songsContainer){
        // Allow passing in a specific songs container, or use the global one
        const songs = songsContainer || document.querySelector('#sheetInline .songs');
        if(!songs) return;
        // Get the actual container (sheet or sheet-page)
        const container = songs.closest('.sheet-page') || songs.closest('.sheet') || sheet;
        
        // Remove any transform scaling - fit naturally
        songs.style.transform = 'none';
        songs.style.width = '100%';
        
        // Ensure songs stretch vertically
        songs.style.height = '100%';
        
        // Start with larger font, maximize text size - start at 15pt for better use of space
        let tSize=15;
        for(let i=0;i<30;i++){
          songs.style.setProperty('--t', tSize);
          Array.from(songs.querySelectorAll('.title')).forEach(d=> d.style.fontSize = tSize+'pt');
          const minor = Math.max(7, tSize-4);
          Array.from(songs.querySelectorAll('.key,.time,.no')).forEach(d=> d.style.fontSize = minor+'pt');
          if(container.scrollHeight<=container.clientHeight) return; // fits
          tSize -= 0.2; if(tSize<6.5) break; // lower bound
        }
  // If still overflowing, reduce subnotes
  let sSize=7;
        for(let i=0;i<8 && container.scrollHeight>container.clientHeight;i++){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=> d.style.fontSize = sSize+'pt');
          sSize -= 0.3; if(sSize<5) break;
        }
        // Reduce vertical gaps/padding progressively
        const gapSteps=['1.5px','1px','0.5px'];
        for(const g of gapSteps){
          if(container.scrollHeight<=container.clientHeight) break;
          songs.style.gap=g;
          Array.from(songs.querySelectorAll('.line')).forEach(d=> d.style.padding = '0.5px 0');
        }
        // Shrink break banners
        if(container.scrollHeight>container.clientHeight){
          let bSize=10;
          for(let i=0;i<6 && container.scrollHeight>container.clientHeight;i++){
            bSize-=0.5; if(bSize<6) break;
            Array.from(songs.querySelectorAll('.break')).forEach(d=>{ d.style.fontSize=bSize+'pt'; d.style.padding='2px 4px'; });
          }
        }
        // If still overflowing, elide subnotes text more aggressively
        if(sheet.scrollHeight>sheet.clientHeight){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=>{
            if(d.textContent.length>25) d.textContent=d.textContent.slice(0,22)+'‚Ä¶';
          });
        }
        // Shrink total time footer
        if(sheet.scrollHeight>sheet.clientHeight && totalEl){
          totalEl.style.fontSize='7pt';
          totalEl.style.marginTop='0px';
          totalEl.style.paddingTop='1px';
        }
        // Last resort: shrink everything more for setlists <=35 songs
        if(sheet.scrollHeight>sheet.clientHeight && setlist.filter(x=>x.type==='song').length<=35){
          Array.from(songs.querySelectorAll('.title')).forEach(d=>{
            const currentSize=parseFloat(d.style.fontSize)||10;
            if(currentSize>5.5) d.style.fontSize = Math.max(5.5, currentSize-1.2)+'pt';
          });
          Array.from(songs.querySelectorAll('.key,.time,.no')).forEach(d=>{
            const currentSize=parseFloat(d.style.fontSize)||8;
            if(currentSize>4.5) d.style.fontSize = Math.max(4.5, currentSize-0.8)+'pt';
          });
          Array.from(songs.querySelectorAll('.break')).forEach(d=>{
            d.style.fontSize='6pt';
            d.style.padding='1px 2px';
          });
        }
      }
      
      // Attach drag/touch interactions for inline preview
      if(isInline && setlist.length > 0){
        attachPreviewInteractions();
      }
    }
    // Embedded song pool chips (Originals vs Covers) for direct drag into preview
    function renderSongPool(){
      const pO=document.getElementById('poolOriginals');
      const pC=document.getElementById('poolCovers');
      const pB=document.getElementById('poolBreaks');
      const covHdr=document.getElementById('poolCoversHdr');
      const brHdr=document.getElementById('poolBreaksHdr');
      const typeSel=document.getElementById('poolType');
      const sortSel=document.getElementById('poolSort');
      const moodSel=document.getElementById('poolMood');
      const searchInput=document.getElementById('poolSearch');
      if(!pO || !pC) return;
      
      // Allow dropping items from set back into the pool to remove them
      // Only add listeners once per element to prevent duplicate event handlers
      [pO,pC,pB].forEach(el=>{ 
        if(!el) return;
        if(!el.dataset.dropListenerAdded){
          el.dataset.dropListenerAdded = 'true';
          el.addEventListener('dragover',e=> e.preventDefault());
          el.addEventListener('drop',e=>{ 
            e.preventDefault();
            e.stopPropagation(); // Prevent event bubbling to parent handlers
            const idxRaw=e.dataTransfer.getData('text/x-set-index');
            if(idxRaw){
              const idx=parseInt(idxRaw,10);
              if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
                setlist.splice(idx,1); // Remove only the one item
                rebuildPreview();
                saveAll();
              }
            }
          });
        }
      });
      
      pO.innerHTML=''; pC.innerHTML=''; if(pB) pB.innerHTML='';
      if(!db.length){ pO.textContent='No songs.'; pC.textContent=''; return; }
      const usedIds=new Set(setlist.filter(x=>x.type==='song').map(x=>x.id));
      const typeVal=(typeSel && typeSel.value) || 'all';
      const sortVal=(sortSel && sortSel.value) || 'alpha';
      const moodVal=(moodSel && moodSel.value) || 'all';
      const searchTerm=(searchInput && searchInput.value) || '';

      const songMood=(s)=> s.isUpbeat? 'upbeat' : s.isHappy? 'happy' : s.isEnergetic? 'energetic' : s.isMellow? 'mellow' : s.isSad? 'sad' : ((s.customMoods||[])[0] || 'none');
      const moodRank={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:5}; getAllMoods().forEach((m,i)=>{ if(!(m in moodRank)) moodRank[m]=6+i; });
      const moodMatch=(s)=> moodVal==='all' || songMood(s)===moodVal;
      const searchMatch=(s)=>{
        if(!searchTerm) return true;
        try{
          const regex = new RegExp(searchTerm, 'i');
          return regex.test(s.title||'') || regex.test(s.artist||'') || regex.test(s.composer||'') || regex.test(s.lyrics||'');
        }catch(e){
          const term=searchTerm.toLowerCase();
          return (s.title||'').toLowerCase().includes(term) || (s.artist||'').toLowerCase().includes(term) || (s.composer||'').toLowerCase().includes(term) || (s.lyrics||'').toLowerCase().includes(term);
        }
      };
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (moodRank[songMood(a)] - moodRank[songMood(b)]) || a.title.localeCompare(b.title);
      const applySort=(arr,isCover)=>{
        if(sortVal==='band') return (isCover? arr.sort(byBand) : arr.sort(byAlpha));
        if(sortVal==='mood') return arr.sort(byMood);
        return arr.sort(byAlpha);
      };

      let originals=db.filter(s=>!s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      let covers=db.filter(s=>s.isCover && !usedIds.has(s.id) && moodMatch(s) && searchMatch(s));
      originals=applySort(originals,false);
      covers=applySort(covers,true);

      // Toggle visibility based on type filter
      const showOriginals = typeVal==='all' || typeVal==='originals';
      const showCovers    = typeVal==='all' || typeVal==='covers';
      pO.style.display = showOriginals? 'flex':'none';
      if(covHdr) covHdr.style.display = showCovers? '' : 'none';
      pC.style.display = showCovers? 'flex':'none';
      if(brHdr) brHdr.style.display=''; if(pB) pB.style.display='flex'; // always show break section

      const hueFromStr=(str)=>{ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h%360; };
      const makeChip=(s)=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.setAttribute('draggable','true'); chip.style.cursor='grab'; chip.dataset.id=s.id;
        const moodClass = s.isUpbeat ? 'mood-upbeat'
          : s.isHappy ? 'mood-happy'
          : s.isEnergetic ? 'mood-energetic'
          : s.isMellow ? 'mood-mellow'
          : s.isSad ? 'mood-sad'
          : ((s.customMoods||[]).length ? 'mood-custom' : '');
        if(moodClass) chip.classList.add(moodClass);
        // Custom mood color (use first custom mood)
        if(!s.isUpbeat && !s.isHappy && !s.isEnergetic && !s.isMellow && !s.isSad && (s.customMoods||[]).length){
          const key=(s.customMoods||[])[0]; const h=hueFromStr(key);
          chip.style.backgroundColor = `hsl(${h} 90% 95%)`;
          chip.style.borderColor = `hsl(${h} 60% 80%)`;
          chip.style.color = '#0f172a';
        }
        const showArtist = s.isCover && s.artist && s.artist!=='Original';
        chip.textContent = showArtist ? `${s.artist} - ${s.title}` : s.title;
        chip.title=`${s.artist} ‚Ä¢ ${s.length}m${s.key? ' ‚Ä¢ '+s.key:''}`;
        chip.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/plain', String(s.id)); });
        chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; activePoolTouch={kind:'song', id:s.id, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
        chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
        return chip;
      };
      if(showOriginals){
        if(!originals.length) pO.textContent = 'No songs.'; else originals.forEach(s=> pO.appendChild(makeChip(s)));
      }
      if(showCovers){
        if(!covers.length) pC.textContent = showOriginals? '' : 'No songs.'; else covers.forEach(s=> pC.appendChild(makeChip(s)));
      }
      if(pB){
        const len = parseFloat((document.getElementById('gBreakLen') && document.getElementById('gBreakLen').value) || gig.breakLen || 15);
        const makeEventChip=(label, kind, hint='')=>{
          const chip=document.createElement('div'); chip.className='pill'; chip.style.cursor='grab'; chip.setAttribute('draggable','true'); chip.textContent= hint? `${label} (${hint})` : label;
          chip.addEventListener('dragstart',e=>{ if(kind==='break'){ e.dataTransfer.setData('text/x-break', String(len)); } else { e.dataTransfer.setData('text/x-event', JSON.stringify({kind})); } });
          chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; const payload=(kind==='break')? {kind:'break', length:len} : {kind:'event', event:{kind}}; activePoolTouch={...payload, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); ev.stopPropagation(); }, {passive:false});
          chip.addEventListener('touchend',ev=>{ chip.classList.remove('drag-touch'); });
          return chip;
        };
        pB.appendChild(makeEventChip(`Break (${len}m)`, 'break'));
        pB.appendChild(makeEventChip('SOUNDCHECK', 'soundcheck'));
        pB.appendChild(makeEventChip('ENCORE', 'encore'));
        pB.appendChild(makeEventChip('INTERMISSION', 'intermission'));
        pB.appendChild(makeEventChip('ANNOUNCEMENT', 'announcement'));
        pB.appendChild(makeEventChip('BLANK ROW', 'blankrow'));
        pB.appendChild(makeEventChip('SEPARATOR LINE', 'separator'));
        pB.appendChild(makeEventChip('CUSTOM‚Ä¶', 'custom'));
      }
    }
    // renderEncore removed - element #encoreList does not exist
    
    // New drop handling directly on preview songs area
    const previewSongs=document.getElementById('songsInline');
    function rebuildPreview(){ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll(); try{ pushAppHistory('rebuildPreview'); }catch(_){ } initDragAssignHandles(); }
    function attachPreviewInteractions(){
      const sheet=document.getElementById('sheetInline');
      if(!sheet) return;
      
      // Get all song containers (either single songs div or multiple across pages)
      const allSongsContainers = sheet.querySelectorAll('.songs');
      
      // Mark all lines and breaks draggable across all pages
      allSongsContainers.forEach(songsContainer => {
        songsContainer.querySelectorAll('.line, .break').forEach((row)=>{
          const setlistIdx = parseInt(row.dataset.setlistIndex, 10);
          if(!Number.isInteger(setlistIdx)) return;
          
          // Only allow dragging when grabbing text elements, not whitespace
          let dragTargets;
          if(row.classList.contains('break')){
            // Breaks have text directly in the element
            dragTargets = [row];
            row.setAttribute('draggable','true');
            row.style.cursor = 'grab';
          } else {
            // Lines have .title, .no, .time sub-elements
            dragTargets = [row.querySelector('.title'), row.querySelector('.no'), row.querySelector('.time')].filter(Boolean);
            dragTargets.forEach(target => {
              target.setAttribute('draggable','true');
              target.style.cursor = 'grab';
            });
          }
          
          row.addEventListener('dragstart',e=>{ 
            // Only allow drag if started from a text element
            const isDragTarget = dragTargets.some(t => t.contains(e.target));
            if(!isDragTarget) {
              e.preventDefault();
              return;
            }
            // Check if setlist is locked
            if(isSetlistLocked()) {
              e.preventDefault();
              return;
            }
            e.dataTransfer.setData('text/x-set-index', String(setlistIdx));
            row.classList.add('dragging');
          });
          row.addEventListener('dragend',()=> row.classList.remove('dragging'));
          
          // Add dragover handlers to show blue line indicator
          row.addEventListener('dragover', e => {
            if(isSetlistLocked()) return;
            e.preventDefault();
            const rect = row.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            
            // Remove all indicators first (check all pages if multi-page)
            const allRows = sheet.querySelectorAll('.sheet-page .line, .sheet-page .break, .songs > .line, .songs > .break');
            allRows.forEach(r => {
              r.classList.remove('drop-before', 'drop-after');
            });
            
            // Add indicator based on cursor position
            if(e.clientY < midpoint) {
              row.classList.add('drop-before');
            } else {
              row.classList.add('drop-after');
            }
          });
          
          row.addEventListener('dragleave', () => {
            row.classList.remove('drop-before', 'drop-after');
          });
          
          // Double-click to edit notes (only songs)
          if(row.classList.contains('line')){
            const titleDiv=row.querySelector('.title');
            if(titleDiv){ titleDiv.addEventListener('dblclick',()=>{
              if(isSetlistLocked()) return;
              const entry=setlist[setlistIdx]; if(!entry || entry.type!=='song') return; const val=prompt('Notes for '+entry.title, entry.notes||''); if(val!=null){ entry.notes=val.trim(); rebuildPreview(); }
            }); }
          }
          
          // Touch drag - use same dragTargets from above
          dragTargets.forEach(target => {
            target.style.touchAction='none';
            target.addEventListener('touchstart',ev=>{
              if(isSetlistLocked()){ ev.preventDefault(); return; }
              const t=ev.touches[0]; if(!t) return; 
              window._activeSetTouch={ 
                idx:setlistIdx, 
                startX:t.clientX, 
                startY:t.clientY, 
                x:t.clientX, 
                y:t.clientY, 
                removed:false, 
                reorderTarget:setlistIdx 
              }; 
              row.classList.add('drag-touch'); 
              ev.preventDefault();
            }, {passive:false});
          });
          
          row.addEventListener('touchmove',ev=>{
            if(isSetlistLocked()) return;
            const act=window._activeSetTouch; if(!act) return; 
            for(const t of ev.touches){ 
              if(t.identifier!=null){ 
                act.x=t.clientX; 
                act.y=t.clientY; 
                break; 
              } 
            }
            
            // Determine potential reorder target across all pages
            const sheetRect=sheet.getBoundingClientRect();
            if(act.x>=sheetRect.left && act.x<=sheetRect.right && act.y>=sheetRect.top && act.y<=sheetRect.bottom){
              const allRows=[...sheet.querySelectorAll('.line, .break')];
              let targetIndex=allRows.length; 
              for(let k=0;k<allRows.length;k++){ 
                const r=allRows[k].getBoundingClientRect(); 
                if(act.y < (r.top + r.height/2)){ 
                  const targetSetlistIdx = parseInt(allRows[k].dataset.setlistIndex, 10);
                  targetIndex = Number.isInteger(targetSetlistIdx) ? targetSetlistIdx : k;
                  break; 
                } else if(k===allRows.length-1 && act.y >= (r.top + r.height/2)){ 
                  const lastSetlistIdx = parseInt(allRows[k].dataset.setlistIndex, 10);
                  targetIndex = Number.isInteger(lastSetlistIdx) ? lastSetlistIdx + 1 : allRows.length;
                  break; 
                } 
              }
              act.reorderTarget=targetIndex;
              const showBefore=targetIndex<setlist.length;
              allRows.forEach((rEl)=>{ 
                const rIdx = parseInt(rEl.dataset.setlistIndex, 10);
                rEl.classList.toggle('drop-before', showBefore && rIdx===targetIndex); 
                rEl.classList.toggle('drop-after', !showBefore && rIdx===setlist.length-1); 
              });
            } else {
              // outside: clear indicators
              [...sheet.querySelectorAll('.line, .break')].forEach(rEl=> rEl.classList.remove('drop-before','drop-after'));
            }
            ev.preventDefault();
          }, {passive:false});
          
          row.addEventListener('touchend',()=> row.classList.remove('drag-touch'));
        });
      });
    }
    // Setup drop handlers on all preview song containers (works with single or multi-page)
    (function setupPreviewDropHandlers(){
      const sheet=document.getElementById('sheetInline');
      if(!sheet) return;
      
      // Get all song containers
      const allSongsContainers = sheet.querySelectorAll('.songs');
      
      allSongsContainers.forEach(songsContainer => {
        songsContainer.addEventListener('dragover',e=> {
          if(isSetlistLocked()) return;
          e.preventDefault();
          
          // Show blue line indicator when dragging from pool
          const allRows=[...sheet.querySelectorAll('.line, .break')];
          if(allRows.length === 0) return;
          
          // Check if dragging from pool (not internal reorder)
          const isInternalDrag = e.dataTransfer.types.includes('text/x-set-index');
          if(isInternalDrag) return; // Internal drag handlers manage their own indicators
          
          // Find closest row based on Y coordinate
          let closestRow = null;
          let minDistance = Infinity;
          let insertBefore = true;
          
          for(const row of allRows) {
            const rect = row.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const distance = Math.abs(e.clientY - midpoint);
            
            if(distance < minDistance) {
              minDistance = distance;
              closestRow = row;
              insertBefore = e.clientY < midpoint;
            }
          }
          
          // Clear all indicators first
          allRows.forEach(r => {
            r.classList.remove('drop-before', 'drop-after');
          });
          
          // Set indicator on closest row
          if(closestRow) {
            if(insertBefore) {
              closestRow.classList.add('drop-before');
            } else {
              closestRow.classList.add('drop-after');
            }
          }
        });
        
        songsContainer.addEventListener('drop',e=>{
          e.preventDefault(); e.stopPropagation(); 
          
          // Check if setlist is locked
          if(isSetlistLocked()) return;
          
          // Clear all drop indicators
          const allRows=[...sheet.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
          
          const br=e.dataTransfer.getData('text/x-break');
          const getInsertIndex=(clientY)=>{ 
            if(allRows.length===0) return 0; 
            for(let i=0;i<allRows.length;i++){ 
              const r=allRows[i].getBoundingClientRect(); 
              if(clientY < (r.top + r.height/2)){
                const idx = parseInt(allRows[i].dataset.setlistIndex, 10);
                return Number.isInteger(idx) ? idx : i;
              }
            }
            const lastIdx = parseInt(allRows[allRows.length-1].dataset.setlistIndex, 10);
            return Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
          };
          const insertAt=getInsertIndex(e.clientY);
          
          if(br){ 
            const lenInput=document.getElementById('gBreakLen'); 
            const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; 
            setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); 
            rebuildPreview(); 
            return; 
          }
          
          const evJson=e.dataTransfer.getData('text/x-event');
          if(evJson){
            try{
              const payload=JSON.parse(evJson);
              const kind=payload.kind;
              if(kind==='encore'){
                const count=setlist.filter(x=>x.type==='encore').length;
                const title = count>=1? `Encore ${count+1}` : 'Encore';
                setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
              }
              if(kind==='blankrow'){
                setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
              }
              if(kind==='separator'){
                setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
              }
              if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
                let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
                if(kind==='custom'){
                  const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
                }
                const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
                const defDur = (kind==='announcement')? '5' : '30';
                const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
                setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
                rebuildPreview(); return;
              }
            }catch(_){ /* ignore malformed */ }
          }
          
          const idRaw=e.dataTransfer.getData('text/plain'); 
          const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
          
          if(fromIdxRaw){ // reorder existing
            const fromIdx=parseInt(fromIdxRaw,10); 
            if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ 
              const item=setlist.splice(fromIdx,1)[0]; 
              const adj= fromIdx<insertAt? insertAt-1 : insertAt; 
              setlist.splice(adj,0,item); 
              rebuildPreview(); 
            }
            return;
          }
          
          if(!idRaw) return; 
          if(idRaw==='__break__') return; 
          const id=parseInt(idRaw,10); 
          const song=db.find(s=>s.id===id); 
          if(!song) return; 
          if(setlist.some(x=>x.id===song.id)) return; 
          setlist.splice(insertAt,0,{...song,type:'song',notes:''}); 
          rebuildPreview();
        });
      });
    })();

    // Global touchend listener for removing rows by dragging them out of sheet
    window.addEventListener('touchend',()=>{
      const act=window._activeSetTouch; 
      if(!act) return; 
      const sheet=document.getElementById('sheetInline'); 
      if(!sheet){ 
        window._activeSetTouch=null; 
        return; 
      }
      const rect=sheet.getBoundingClientRect(); 
      const outside = act.x < rect.left-30 || act.x > rect.right+30 || act.y < rect.top-30 || act.y > rect.bottom+30;
      
      if(outside){ 
        // Remove only the dragged item
        const idx=act.idx; 
        if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ 
          setlist.splice(idx,1); 
          currentDateDirty = true;
          rebuildPreview(); 
          saveAll(); 
        } 
      } else {
        // inside: perform reorder if target different
        const from=act.idx; 
        const to=act.reorderTarget; 
        if(Number.isInteger(from) && Number.isInteger(to) && from!==to && from>=0 && to>=0 && from<setlist.length && to<=setlist.length){ 
          const item=setlist.splice(from,1)[0]; 
          const adj = (from<to) ? to-1 : to; 
          setlist.splice(adj,0,item); 
          rebuildPreview(); 
          saveAll(); 
        }
      }
      window._activeSetTouch=null;
    }, {passive:true});
    // Allow dropping anywhere on the sheet area (including whitespace and between pages)
    const sheetInline=document.getElementById('sheetInline');
    if(sheetInline){
      sheetInline.addEventListener('dragover',e=> {
        e.preventDefault();
        
        // Show blue line indicator when dragging from pool
        const allRows=[...sheetInline.querySelectorAll('.line, .break')];
        if(allRows.length === 0) return;
        
        // Check if dragging from pool (not internal reorder)
        const isInternalDrag = e.dataTransfer.types.includes('text/x-set-index');
        if(isInternalDrag) return; // Internal drag handlers manage their own indicators
        
        // Find closest row based on Y coordinate
        let closestRow = null;
        let minDistance = Infinity;
        let insertBefore = true;
        
        for(const row of allRows) {
          const rect = row.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const distance = Math.abs(e.clientY - midpoint);
          
          if(distance < minDistance) {
            minDistance = distance;
            closestRow = row;
            insertBefore = e.clientY < midpoint;
          }
        }
        
        // Clear all indicators first
        allRows.forEach(r => {
          r.classList.remove('drop-before', 'drop-after');
        });
        
        // Set indicator on closest row
        if(closestRow) {
          if(insertBefore) {
            closestRow.classList.add('drop-before');
          } else {
            closestRow.classList.add('drop-after');
          }
        }
      });
      
      // Clear indicators when drag leaves the sheet
      sheetInline.addEventListener('dragleave',e=> {
        // Only clear if actually leaving the sheet container
        const rect = sheetInline.getBoundingClientRect();
        if(e.clientX < rect.left || e.clientX > rect.right || 
           e.clientY < rect.top || e.clientY > rect.bottom) {
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
        }
      });
      
      // Add dragover and drop handlers to individual pages for better hit detection
      sheetInline.querySelectorAll('.sheet-page').forEach((page, pageIdx) => {
        page.addEventListener('dragover',e=> e.preventDefault());
        page.addEventListener('drop',e=>{
          // Only handle if dropped on page background (not on a song)
          if(e.target.closest('.line, .break')) return;
          
          e.preventDefault();
          e.stopPropagation();
          
          // Clear all drop indicators
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
          let insertAt = 0;
          
          // Find the last song on this page
          const pageRows = [...page.querySelectorAll('.line, .break')];
          if(pageRows.length > 0){
            const lastRowOnPage = pageRows[pageRows.length - 1];
            const lastIdx = parseInt(lastRowOnPage.dataset.setlistIndex, 10);
            insertAt = Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
          } else {
            // Empty page - check if it's page 1 or later
            const firstRowOfNextPage = allRows.find(r => {
              const pageEl = r.closest('.sheet-page');
              const pIdx = pageEl ? parseInt(pageEl.dataset.pageIndex, 10) : -1;
              return pIdx > pageIdx;
            });
            if(firstRowOfNextPage){
              const firstIdx = parseInt(firstRowOfNextPage.dataset.setlistIndex, 10);
              insertAt = Number.isInteger(firstIdx) ? firstIdx : allRows.length;
            } else {
              insertAt = allRows.length;
            }
          }
          
          // Handle different drop types
          const br=e.dataTransfer.getData('text/x-break');
          if(br){ 
            const lenInput=document.getElementById('gBreakLen'); 
            const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; 
            setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); 
            rebuildPreview(); 
            return; 
          }
          
          const evJson=e.dataTransfer.getData('text/x-event');
          if(evJson){
            try{
              const payload=JSON.parse(evJson);
              const kind=payload.kind;
              if(kind==='encore'){
                const count=setlist.filter(x=>x.type==='encore').length;
                const title = count>=1? `Encore ${count+1}` : 'Encore';
                setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
              }
              if(kind==='blankrow'){
                setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
              }
              if(kind==='separator'){
                setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
              }
              if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
                let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
                if(kind==='custom'){
                  const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
                }
                const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
                const defDur = (kind==='announcement')? '5' : '30';
                const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
                setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
                rebuildPreview(); return;
              }
            }catch(_){ /* ignore malformed */ }
          }
          
          const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
          if(fromIdxRaw){
            const fromIdx=parseInt(fromIdxRaw,10); 
            if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ 
              const item=setlist.splice(fromIdx,1)[0]; 
              const adj= fromIdx<insertAt? insertAt-1 : insertAt; 
              setlist.splice(adj,0,item); 
              rebuildPreview(); 
            }
            return;
          }
          
          const idRaw=e.dataTransfer.getData('text/plain'); 
          if(!idRaw || idRaw==='__break__') return;
          const id=parseInt(idRaw,10); 
          const song=db.find(s=>s.id===id); 
          if(!song) return; 
          if(setlist.some(x=>x.id===song.id)) return; 
          setlist.splice(insertAt,0,{...song,type:'song',notes:''}); 
          rebuildPreview();
        });
      });
      
      sheetInline.addEventListener('drop',e=>{
        e.preventDefault();
        
        // Clear all drop indicators
        const allRows=[...sheetInline.querySelectorAll('.line, .break')];
        allRows.forEach(r => r.classList.remove('drop-before', 'drop-after'));
        
        // If drop hit a page or songs container directly, those handlers processed it
        // This handles drops in any remaining whitespace
        const getInsertIndex=(clientY)=>{ 
          if(allRows.length===0) return 0; 
          for(let i=0;i<allRows.length;i++){ 
            const r=allRows[i].getBoundingClientRect(); 
            if(clientY < (r.top + r.height/2)){
              const idx = parseInt(allRows[i].dataset.setlistIndex, 10);
              return Number.isInteger(idx) ? idx : i;
            }
          }
          const lastIdx = parseInt(allRows[allRows.length-1].dataset.setlistIndex, 10);
          return Number.isInteger(lastIdx) ? lastIdx + 1 : allRows.length;
        };
        const insertAt=getInsertIndex(e.clientY);
        const br=e.dataTransfer.getData('text/x-break');
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            if(kind==='blankrow'){
              setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview(); return;
            }
            if(kind==='separator'){
              setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview(); return;
            }
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= (fromIdx<insertAt) ? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); } return; }
        const idRaw=e.dataTransfer.getData('text/plain'); if(!idRaw || idRaw==='__break__') return; const id=parseInt(idRaw,10); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    }
    // Pool open/close and drop-to-remove
    const openPoolBtn=document.getElementById('openPool');
    const closePoolBtn=document.getElementById('closePool');
    const poolFly=document.getElementById('songPoolFlyout');
    const poolCol=document.getElementById('poolCol');
    function positionPool(){
      if(!poolFly) return;
      const setCard=document.getElementById('set'); if(!setCard) return;
      const rect=setCard.getBoundingClientRect();
      const left=Math.min(window.innerWidth - poolFly.offsetWidth - 12, rect.right + 12);
      const top=Math.max(12, rect.top);
      poolFly.style.left=left+"px"; poolFly.style.top=top+"px";
      poolFly.style.right=""; // ensure left-based positioning
      poolFly.style.height = Math.min(window.innerHeight - top - 20, 720) + 'px';
    }
    // Removed openPool button usage (embedded pool); keep flyout logic if still present elsewhere
    if(closePoolBtn && poolFly){ closePoolBtn.addEventListener('click',()=> poolFly.classList.remove('open')); }
    window.addEventListener('scroll',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); }, {passive:true});
    window.addEventListener('resize',()=>{ 
      if(poolFly && poolFly.classList.contains('open')) positionPool(); 
      // Recalculate date box widths on resize
      if(typeof renderDateHeader === 'function') renderDateHeader();
    });
    if(poolFly && !poolFly.dataset.dropListenerAdded){
      poolFly.dataset.dropListenerAdded = 'true';
      poolFly.addEventListener('dragover',e=> e.preventDefault());
      poolFly.addEventListener('drop',e=>{ 
        e.preventDefault();
        e.stopPropagation(); // Prevent event bubbling
        const idxRaw=e.dataTransfer.getData('text/x-set-index');
        if(idxRaw){
          const idx=parseInt(idxRaw,10);
          if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
            setlist.splice(idx,1); // remove ONLY dragged item
            // If encore header now orphaned (no songs after it) remove header only
            const encIdx=setlist.findIndex(x=>x.type==='encore');
            if(encIdx>-1){
              const anyAfter=setlist.slice(encIdx+1).some(x=>x.type==='song');
              if(!anyAfter){ setlist.splice(encIdx,1); }
            }
            rebuildPreview();
            saveAll();
          }
        }
      });
    }
    // Also allow dropping onto the embedded pool column to remove from set
    if(poolCol && !poolCol.dataset.dropListenerAdded){
      poolCol.dataset.dropListenerAdded = 'true';
      poolCol.addEventListener('dragover',e=> e.preventDefault());
      poolCol.addEventListener('drop',e=>{ 
        e.preventDefault();
        e.stopPropagation(); // Prevent event bubbling
        const idxRaw=e.dataTransfer.getData('text/x-set-index');
        if(idxRaw){
          const idx=parseInt(idxRaw,10);
          if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){
            setlist.splice(idx,1); // Remove only the one item
            rebuildPreview();
            saveAll();
          }
        }
      });
    }
    // Initial pool render (kept ready; open with button)
    // Hook pool controls if present
    const poolType=document.getElementById('poolType');
    const poolSort=document.getElementById('poolSort');
    const poolMood=document.getElementById('poolMood');
    const poolSearch=document.getElementById('poolSearch');
    if(poolType) poolType.addEventListener('change', renderSongPool);
    if(poolSort) poolSort.addEventListener('change', renderSongPool);
    if(poolMood) poolMood.addEventListener('change', renderSongPool);
    if(poolSearch) poolSearch.addEventListener('input', renderSongPool);
    renderSongPool();

    // Hook DB controls
    (function(){
      const sSel=document.getElementById('dbSort');
      const searchInput=document.getElementById('dbSearch');
      const addBtn=document.getElementById('addMoodBtn');
      if(sSel) sSel.addEventListener('change', renderDB);
      if(searchInput) searchInput.addEventListener('input', renderDB);
      // Hook all filter checkboxes
      ['filterCovers','filterOriginals','filterHasLyrics','filterKaraoke','filterHasAudio','filterHasURL','filterInSet','filterUpbeat','filterHappy','filterEnergetic','filterMellow','filterSad'].forEach(id=>{
        const el=document.getElementById(id);
        if(el) el.addEventListener('change', renderDB);
      });
      if(addBtn) addBtn.addEventListener('click', ()=>{
        const name = prompt('New mood name (max 16 chars).'); if(name==null) return; const n=name.trim(); if(!n){ return; }
        const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
        const all=getAllMoods(); if(all.length>=12){ alert('Max 12 moods reached.'); return; }
        if(DEFAULT_MOODS.includes(key) || (gig.customMoods||[]).includes(key)){ alert('Mood already exists.'); return; }
        gig.customMoods = gig.customMoods || []; gig.customMoods.push(key);
        saveAll();
        renderAddMoodsUI();
        // Add custom mood filter checkbox
        const filterContainer=document.getElementById('customMoodFilters');
        if(filterContainer){
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        }
        renderDB(); renderSongPool();
      });
      // Hydrate custom mood filter checkboxes
      const filterContainer=document.getElementById('customMoodFilters');
      if(filterContainer && gig.customMoods){
        gig.customMoods.forEach(key=>{
          const lbl=document.createElement('label');
          lbl.style.cssText='display:inline-flex;align-items:center;gap:4px';
          const chk=document.createElement('input');
          chk.type='checkbox';
          chk.id='filter-'+key;
          chk.addEventListener('change', renderDB);
          lbl.appendChild(chk);
          lbl.appendChild(document.createTextNode(moodLabel(key)));
          filterContainer.appendChild(lbl);
        });
      }
    })();
      // Simplified touch drag for preview-only interface (song/break/event chips)
      let activePoolTouch=null;
      window.addEventListener('touchmove',ev=>{ 
        if(!activePoolTouch) return; 
        const t=ev.touches[0]; 
        if(!t) return; 
        activePoolTouch.x=t.clientX; 
        activePoolTouch.y=t.clientY; 
        // Show visual drop indicator
        const sheetInline=document.getElementById('sheetInline');
        if(sheetInline){
          // Query all rows across all pages
          const rows=[...sheetInline.querySelectorAll('.line, .break')];
          const sheetRect=sheetInline.getBoundingClientRect();
          const inDropZone = (activePoolTouch.x>=sheetRect.left && activePoolTouch.x<=sheetRect.right && activePoolTouch.y>=sheetRect.top && activePoolTouch.y<=sheetRect.bottom);
          
          if(inDropZone && rows.length>0){
            // Find closest row based on Y coordinate (works across all pages)
            let closestRow = null;
            let minDistance = Infinity;
            let insertBefore = true;
            
            for(const row of rows) {
              const rect = row.getBoundingClientRect();
              const midpoint = rect.top + rect.height / 2;
              const distance = Math.abs(activePoolTouch.y - midpoint);
              
              if(distance < minDistance) {
                minDistance = distance;
                closestRow = row;
                insertBefore = activePoolTouch.y < midpoint;
              }
            }
            
            // Clear all indicators first
            rows.forEach(r => {
              r.classList.remove('drop-before', 'drop-after');
            });
            
            // Set indicator on closest row
            if(closestRow) {
              if(insertBefore) {
                closestRow.classList.add('drop-before');
              } else {
                closestRow.classList.add('drop-after');
              }
            }
          } else if(inDropZone && rows.length===0){
            // Empty setlist - highlight sheet itself
            sheetInline.style.boxShadow='inset 0 0 0 3px #60a5fa';
          } else {
            rows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
            sheetInline.style.boxShadow='';
          }
        }
        ev.preventDefault(); 
      }, {passive:false});
      window.addEventListener('touchend',ev=>{
        if(!activePoolTouch) return; 
        const x=activePoolTouch.x, y=activePoolTouch.y; 
        const sheetInline=document.getElementById('sheetInline');
        
        // Clear drop indicators
        if(sheetInline){ 
          const allRows=[...sheetInline.querySelectorAll('.line, .break')];
          allRows.forEach(r=>{ r.classList.remove('drop-before','drop-after'); });
          sheetInline.style.boxShadow='';
        }
        
        // Check if dropped on sheet (expand boundaries for easier mobile drops)
        if(sheetInline){ 
          const rect=sheetInline.getBoundingClientRect(); 
          const margin=50; 
          if(x>=rect.left-margin && x<=rect.right+margin && y>=rect.top-margin && y<=rect.bottom+margin){
            // Query all rows across all pages
            const rows=[...sheetInline.querySelectorAll('.line, .break')];
            
            // Calculate insert position based on Y coordinate across all pages
            const getInsertIndex=(clientY)=>{ 
              if(rows.length===0) return 0; 
              for(let i=0;i<rows.length;i++){ 
                const r=rows[i].getBoundingClientRect(); 
                if(clientY < (r.top + r.height/2)){
                  const idx = parseInt(rows[i].dataset.setlistIndex, 10);
                  return Number.isInteger(idx) ? idx : i;
                }
              }
              const lastIdx = parseInt(rows[rows.length-1].dataset.setlistIndex, 10);
              return Number.isInteger(lastIdx) ? lastIdx + 1 : rows.length;
            };
            const insertAt=getInsertIndex(y);
          if(activePoolTouch.kind==='song'){ const song=db.find(s=>s.id===activePoolTouch.id); if(song && !setlist.some(sl=>sl.id===song.id)){ setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview(); } }
          else if(activePoolTouch.kind==='break'){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); }
          else if(activePoolTouch.kind==='event'){
            const kind = activePoolTouch.event && activePoolTouch.event.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length; const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview();
            }else if(kind==='blankrow'){
              setlist.splice(insertAt,0,{type:'blankrow'}); rebuildPreview();
            }else if(kind==='separator'){
              setlist.splice(insertAt,0,{type:'separator'}); rebuildPreview();
            }else if(kind){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview();
            }
          }
          }
        }
        activePoolTouch=null;
      });
      // Touch reorder legacy removed ‚Äì interactions handled via standard drag & drop in preview.

  // Tech / Stage: Tech Rider table generation synced to setlist (populates inline or fullscreen as available)
    // buildTechTable removed - element #techBody does not exist, only buildTechTableFull is used

    function buildTechTableFull(){
      const body=document.getElementById('techBodyFull'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    // Stage Plot: simple B&W draggable glyphs
    const TOOLBOX=[
  {key:'mic', label:'Vocal Mic', svg:'M0 0 h16 v48 h-16z M8 48 a8 8 0 1 0 0.01 0'},
  {key:'monitor', label:'Monitor', svg:'M0 44 l36 -18 v18 l-36 18z'},
  {key:'guitar', label:'Electric Guitar', svg:'M0 0 h16 v32 h-16z M16 10 l30 -8 l3 10 l-30 8z'},
  {key:'bassamp', label:'Bass Amp', svg:'M0 0 h34 v44 h-34z'},
  {key:'keyboard', label:'Keyboard', svg:'M0 0 h60 v16 h-60z M3 2 v12 M8 2 v12 M13 2 v12 M18 2 v12 M23 2 v12 M28 2 v12 M33 2 v12 M38 2 v12 M43 2 v12 M48 2 v12 M53 2 v12 M58 2 v12'},
  {key:'drums', label:'Drums', svg:'M15 20 a14 10 0 1 0 0.01 0 M42 20 a14 10 0 1 0 0.01 0 M28 34 a10 7 0 1 0 0.01 0'},
  {key:'di', label:'DI Box', svg:'M0 0 h40 v18 h-40z'},
      {key:'gtramp', label:'Guitar Amp', svg:'M0 0 h34 v44 h-34z'},
      {key:'label', label:'Custom Label', custom:'label'},
      {key:'rect', label:'Rectangle', custom:'rect'},
    ];

    // Image-based toolbox items (replace emojis)
    // Files must exist alongside index.html
    const ICON_ITEMS=[
      {key:'kick', label:'Kick', src:'Kick.png'},
      {key:'snare', label:'Snare', src:'Snare.png'},
      {key:'hihat', label:'Hat', src:'Hihat.png'},
      {key:'tom', label:'Tom', src:'Tom.png'},
      {key:'floor', label:'Floor Tom', src:'Floor.png'},
      {key:'overhead', label:'Instrument Mic', src:'Overhead.png'},
      {key:'crash', label:'Crash', src:'Crash.png'},
      {key:'cymbal1', label:'Crash 2', src:'Cymbal_1.png'},
      {key:'cymbal2', label:'Crash 3', src:'Cymbal_2.png'},
      // Gap then guitars
      {key:'bass', label:'Bass Guitar', src:'Bass.png'},
      {key:'bassamp', label:'Bass Amp', src:'Bassamp.png'},
      {key:'electric', label:'Electric Guitar', src:'Electric.png'},
      {key:'combo', label:'Gtr Combo', src:'Combo.png'},
      {key:'stack', label:'Gtr Stack', src:'Stack.png'},
      // Gap then vocal/stereo/DI
      {key:'vocal', label:'Vocal Mic', src:'Vocal%20Mic.png'},
      {key:'stereoPair', label:'Stereo Pair', src:'Stereo%20Pair.png'},
      {key:'di', label:'DI', src:'DI.png'},
      // Gap then sampler/laptop/power
      {key:'sampler', label:'Sampler', src:'Sampler.png'},
      {key:'laptop', label:'Laptop', src:'Laptop.png'},
      {key:'power', label:'Power', src:'Power.png'},
      // Gap then other instruments
      {key:'acoustic', label:'Acoustic', src:'Acoustic.png'},
      {key:'violin', label:'Violin', src:'Violin.png'},
      {key:'banjo', label:'Banjo', src:'Banjo.png'},
      {key:'clarinet', label:'Clarinet', src:'Clarinet.png'},
      {key:'bongoes', label:'Bongoes', src:'Bongoes.png'},
      {key:'congas', label:'Congas', src:'Congas.png'},
      {key:'deck', label:'Deck', src:'Deck.png'},
      {key:'keys', label:'Keys', src:'keys.png'},
      {key:'sax', label:'Sax', src:'sax.png'},
      {key:'fxpedal', label:'FX Pedal', src:'FXpedal.png'},
      {key:'fxboard', label:'FX Board', src:'FXboard.png'},
      // Gap then props
      {key:'tipjar', label:'Tip Jar', src:'Tipjar.png'},
      {key:'table', label:'Table', src:'Table.png'},
      {key:'stool', label:'Stool', src:'Stool.png'},
      {key:'fan', label:'Fan', src:'Fan.png'},
      // Gap then monitors
      {key:'monitor', label:'Monitor', src:'Monitor.png'},
    ];
    // Sequence with explicit gaps using special token '__gap__'
    const TOOL_ORDER=[
      'kick','snare','hihat','tom','floor','overhead','crash','cymbal1','cymbal2','__gap__',
      'bass','bassamp','electric','combo','stack','__gap__',
      'vocal','stereoPair','di','__gap__',
      'sampler','laptop','power','__gap__',
      'acoustic','violin','banjo','clarinet','bongoes','congas','deck','keys','sax','fxpedal','fxboard','__gap__',
      'tipjar','table','stool','fan','__gap__',
      'monitor'
    ];

    // Type mapping for routing logic
    const TYPE_MAP={
      acoustic:'acoustic', banjo:'acoustic', violin:'acoustic',
      electric:'electric', combo:'amp', stack:'amp', bassamp:'amp', bass:'electric',
      vocal:'mic', overhead:'mic', stereoPair:'mic', hihat:'drum', hihat2:'drum', kick:'drum', snare:'drum', tom:'drum', floor:'drum',
      crash:'cymbal', cymbal1:'cymbal', cymbal2:'cymbal', bongoes:'drum', congas:'drum',
      deck:'deck', sampler:'sampler', laptop:'sampler',
      keys:'keys', sax:'sax', fxpedal:'fx', fxboard:'fx',
      di:'di',
      monitor:'monitor',
      power:'utility', fan:'utility', table:'utility', stool:'utility', tipjar:'utility'
    };

    // Allowed routing targets by source type (routeTo). 'channel' is represented by selecting a channel directly, not via routeTo.
    const ROUTE_TARGETS={
      drum:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','monitor'], // can connect to everything except utility
      cymbal:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','monitor'],
      mic:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'], // mics can NOT connect to other mics
      di:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // can connect to everything except utility
      fx:['di','channel','sampler','fx','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // FX intermediates can connect between any items
      amp:['mic','di','channel','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'], // amps can connect to mics
      acoustic:['di','mic','channel','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      electric:['fx','amp','di','channel','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      deck:['fx','di','channel','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      sampler:['fx','di','channel','sampler','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      keys:['sampler','di','mic','channel','fx','amp','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      sax:['mic','channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor'],
      monitor:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'],
      other:['channel','di','fx','amp','sampler','acoustic','electric','deck','keys','sax','drum','cymbal','monitor','mic'], // custom can connect to anything
    };

    // Effective per-node targets (adds key-specific rules, e.g., bass amp can go direct to channel)
    function effectiveTargets(node){
      const base=(ROUTE_TARGETS[node.dataset.type||'other']||[]).slice();
      const key=node.dataset.key||'';
      if((node.dataset.type||'')==='amp'){
        if(key==='bassamp'){ // bass amps can feed DI or mic or direct channel (via built-in DI out)
          if(!base.includes('di')) base.push('di');
          if(!base.includes('mic')) base.push('mic');
          if(!base.includes('channel')) base.push('channel');
        } else { // guitar amps must only go to mics
          return ['mic'];
        }
      }
      return base;
    }

    // Items considered processors (appear prioritized at top of legend)
    const PRIORITY_TYPES=new Set(['di','fx','amp','sampler']);

    function buildTools(){
      ['stageTools','stageToolsFull'].forEach(cid=>{
        const tools=document.getElementById(cid);
        if(!tools) return;
        tools.innerHTML='';
        const byKey=new Map(ICON_ITEMS.map(i=>[i.key,i]));
        // Show All button if any hidden
        const hidden=(gig.hiddenIcons||[]);
        const actions=document.createElement('div'); actions.className='toolbox-actions';
        if(hidden.length){
          const showAllBtn=document.createElement('button'); showAllBtn.className='tool'; showAllBtn.textContent='Show All Icons';
          showAllBtn.addEventListener('click',()=>{ gig.hiddenIcons=[]; saveAll(); buildTools(); });
          actions.appendChild(showAllBtn);
        }
        if(cid==='stageToolsFull') tools.appendChild(actions);
        TOOL_ORDER.forEach(k=>{
          if(k==='__gap__'){ const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='8px'; gap.style.borderTop='1px solid #e5e7eb'; gap.style.margin='4px 0'; tools.appendChild(gap); return; }
          const t=byKey.get(k); if(!t) return;
          if((gig.hiddenIcons||[]).includes(k)) return; // skip hidden
          const b=document.createElement('button');
          b.className='tool';
          b.innerHTML=`<img src="${t.src}" alt="${t.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${t.label}`;
          // Don't use HTML5 draggable - we use custom mouse/touch handlers instead to avoid duplicates
          b.dataset.key = t.key;
          b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:t.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
          // Long press (~1s) to hide icon: only when cursor/finger stays put
          let lpTimer=null; let startPos=null; const cancel=()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } startPos=null; };
          const arm=(sx,sy)=>{ cancel(); startPos={x:sx,y:sy}; lpTimer=setTimeout(()=>{
            if(!startPos) return; // was cancelled by movement or release
            if(!confirm('Hide this tool from the toolbox?')) return;
            if((gig.hiddenIcons||[]).indexOf(t.key)===-1){ gig.hiddenIcons.push(t.key); saveAll(); buildTools(); }
          },1000); };
          b.addEventListener('mousedown',e=>{ if(e.button!==0) return; arm(e.clientX,e.clientY); });
          b.addEventListener('mousemove',e=>{ if(!lpTimer||!startPos) return; const dx=Math.abs(e.clientX-startPos.x), dy=Math.abs(e.clientY-startPos.y); if(dx>2||dy>2) cancel(); });
          b.addEventListener('mouseup',cancel);
          b.addEventListener('mouseleave',cancel);
          b.addEventListener('touchstart',e=>{ const tTouch=e.touches[0]; if(!tTouch) return; arm(tTouch.clientX,tTouch.clientY); }, {passive:true});
          b.addEventListener('touchmove',e=>{ if(!lpTimer||!startPos) return; const tTouch=e.touches[0]; if(!tTouch) return; const dx=Math.abs(tTouch.clientX-startPos.x), dy=Math.abs(tTouch.clientY-startPos.y); if(dx>4||dy>4) cancel(); }, {passive:true});
          b.addEventListener('touchend',cancel);
          b.addEventListener('touchcancel',cancel);
          tools.appendChild(b);
        });
        // Custom images always at bottom of full toolbox
        if(cid==='stageToolsFull'){
          if((gig.customImages||[]).length){
            const gap=document.createElement('div'); gap.style.flexBasis='100%'; gap.style.height='10px'; gap.style.borderTop='2px dashed #d1d5db'; gap.style.margin='6px 0'; tools.appendChild(gap);
          }
          (gig.customImages||[]).forEach(imgObj=>{
            const wrap=document.createElement('div'); wrap.style.position='relative';
            const b=document.createElement('button'); b.className='tool'; b.style.paddingRight='26px';
            b.innerHTML=`<img src="${imgObj.data}" alt="${imgObj.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${imgObj.label}`;
            // Don't use HTML5 draggable - we use custom mouse/touch handlers instead
            b.dataset.key=imgObj.key;
            b.style.touchAction='none';
            b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:imgObj.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
            const del=document.createElement('button'); del.textContent='√ó'; del.title='Remove'; del.style.position='absolute'; del.style.top='2px'; del.style.right='2px'; del.style.width='20px'; del.style.height='20px'; del.style.lineHeight='16px'; del.style.padding='0'; del.style.fontSize='14px'; del.style.background='#374151'; del.style.color='#fff'; del.style.border='none'; del.style.borderRadius='4px'; del.style.cursor='pointer';
            del.addEventListener('click',()=>{ if(!confirm('Delete custom icon?')) return; gig.customImages = (gig.customImages||[]).filter(ci=>ci.key!==imgObj.key); saveAll(); buildTools(); rebuildCustomImages(); });
            wrap.appendChild(b); wrap.appendChild(del); tools.appendChild(wrap);
          });
        }
      });
    }
    buildTools();

    let _suppressBgClick=false;
    // Ensure arrow marker exists in SVG for arrow drawing
    function ensureStageMarkers(svg){ if(!svg) return; let defs=svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
      if(!svg.querySelector('marker#arrowHead')){
        const m=document.createElementNS('http://www.w3.org/2000/svg','marker'); m.setAttribute('id','arrowHead'); m.setAttribute('markerWidth','8'); m.setAttribute('markerHeight','8'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto');
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d','M0,0 L8,3 L0,6 Z'); p.setAttribute('fill','#000'); m.appendChild(p); defs.appendChild(m);
      }
    }

    function refreshStageHeader(){
      // Get current band from Act selector (authoritative source)
      const currentBandName = currentBandPresetId ? (bandPresets.find(bp => bp.id === currentBandPresetId)?.name || gig.band || 'Band') : (gig.band || 'Band');
      const text=`${currentBandName.trim()} ‚Ä¢ ${(gig.date||'Date')}`;
      const elT=document.getElementById('stageTitle'); if(elT) elT.textContent=text;
      const elTF=document.getElementById('stageTitleFull'); if(elTF) elTF.textContent=text;
      
      // Update the header bar above stage canvas
      const headerDate = document.getElementById('stageHeaderDate');
      const headerBand = document.getElementById('stageHeaderBand');
      const headerVenue = document.getElementById('stageHeaderVenue');
      
      if(headerDate){
        if(selectedTourDateId){
          const td = tourDates.find(t => t.id === selectedTourDateId);
          if(td && td.date){
            const d = new Date(td.date + 'T12:00:00');
            headerDate.textContent = d.toLocaleDateString('en-US', {weekday:'long', month:'short', day:'numeric', year:'numeric'});
          } else {
            headerDate.textContent = gig.date || 'No date selected';
          }
        } else {
          headerDate.textContent = gig.date || 'No date selected';
        }
      }
      if(headerBand) headerBand.textContent = gig.band || 'Band';
      if(headerVenue) headerVenue.textContent = gig.venue || 'Venue';
    }
    
    // Lock state for setlist and stage plot
    window.setlistLocked = false;
    window.stageLocked = false;
    
    function isSetlistLocked(){
      return window.setlistLocked || (document.getElementById('setlistLockCheckbox') && document.getElementById('setlistLockCheckbox').checked);
    }
    
    function isStageLocked(){
      return window.stageLocked || (document.getElementById('stageLockCheckbox') && document.getElementById('stageLockCheckbox').checked);
    }

    // Note: small stage removed; glyphs are added via fullscreen only

    let _nextStageId=1;
    function addGlyphFull(key, at){
      const iconSpec=ICON_ITEMS.find(x=>x.key===key);
      const customSpec=(gig.customImages||[]).find(ci=>ci.key===key);
      const svg=document.getElementById('stageSvgFull');
      const g=document.createElementNS('http://www.w3.org/2000/svg','g');
      const x = (at && typeof at.x==='number') ? at.x : 100, y = (at && typeof at.y==='number') ? at.y : 120;
      // Compute initial scale so the visible icon is ~100px wide on screen
      const vbw = (svg && svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) ? svg.viewBox.baseVal.width : 1500;
      const pxPerUnit = svg ? (svg.getBoundingClientRect().width / vbw) : (1000/1500);
      const targetPx = (key==='tom' ? 50 : 100); const baseUnits = 60; // image width set below; toms default to 50% size
      let initScale = targetPx / (baseUnits * Math.max(0.01, pxPerUnit));
      initScale = Math.max(0.3, Math.min(5, initScale));
      g.dataset.x=String(x); g.dataset.y=String(y); g.dataset.scale=String(initScale);
      g.dataset.key=key; g.dataset.channel=g.dataset.channel||'';
      g.dataset.id=String(_nextStageId++);
      const type=TYPE_MAP[key]||'other';
      g.dataset.type=type;
      g.dataset.showLabel='0'; // default hidden
      g.setAttribute('data-draggable','1');
      // Auto-assign next channel for common sources (drums, mics)
      const autoTypes=new Set(['drum','mic']);
      const canChannel=(ROUTE_TARGETS[type]||[]).includes('channel');
      if(autoTypes.has(type) && canChannel){
        const existing=getStageGroups();
        const assigned=existing.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
        const next=(assigned.length? Math.max(...assigned):0)+1;
        g.dataset.channel=String(next);
      }
      if(customSpec){
        const img=document.createElementNS('http://www.w3.org/2000/svg','image');
        img.setAttribute('href', customSpec.data);
        img.setAttributeNS('http://www.w3.org/1999/xlink','href', customSpec.data);
        img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=customSpec.label; label.style.display='none'; g.appendChild(label);
        // Removed intrinsic autoscale override; initial scale already targets ~100px visual size.
      } else if(iconSpec){
        // Place icon image centered; no background rectangle (transparent icons expected)
  const img=document.createElementNS('http://www.w3.org/2000/svg','image');
  // set both href and xlink:href for compatibility
  img.setAttribute('href', iconSpec.src);
  img.setAttributeNS('http://www.w3.org/1999/xlink','href', iconSpec.src);
  img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=iconSpec.label;
        label.style.display='none';
        g.appendChild(label);
      }else{
        const spec=TOOLBOX.find(x=>x.key===key); if(!spec) return;
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', toPath(spec.svg));
        path.setAttribute('fill','none');
        path.setAttribute('stroke','#000');
        path.setAttribute('stroke-width','2');
        g.appendChild(path);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','58'); label.setAttribute('font-size','14'); label.setAttribute('data-role','label'); label.textContent=spec.label;
        label.style.display='none';
        g.appendChild(label);
      }
      applyTransform(g);
      svg.appendChild(g);
      enableSvgDrag(g);
      selectNode(g); // immediately select newly added item for quick edits
      // focus name field so user can rename right away (skip on mobile to avoid keyboard popup)
      const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
      if(!isMobile){
        const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); if(nameInp.select) nameInp.select(); }
      }
      refreshStageLegend(); saveAll(); snapshotStage();
      return g;
    }

    function toPath(simple){
      // simple mini-language passthrough for small glyphs (already path commands)
      return simple;
    }

    // Helper: connect source->target if allowed, otherwise try reverse
    function connectEitherDirection(source, target){
      if(!source || !target || source===target) return false;
      
      // Determine connection priority based on type hierarchy: instruments ‚Üí amps ‚Üí mics ‚Üí channels
      const getConnectionPriority=(node)=>{
        const type=node.dataset.type||'other';
        if(type==='acoustic' || type==='electric' || type==='keys' || type==='sax' || type==='deck' || type==='drum' || type==='cymbal') return 0; // instruments
        if(type==='amp') return 1; // amps
        if(type==='mic') return 2; // mics
        if(type==='di') return 1.5; // DI
        if(type==='fx') return 1.7; // FX
        if(type==='sampler') return 0.5; // samplers
        return 3; // others/endpoints
      };
      
      const sPriority=getConnectionPriority(source);
      const tPriority=getConnectionPriority(target);
      const sAllowed=effectiveTargets(source);
      const tAllowed=effectiveTargets(target);
      const sCanTarget=sAllowed.includes(target.dataset.type||'other');
      const tCanTarget=tAllowed.includes(source.dataset.type||'other');
      
      // If both directions are valid, choose based on priority (lower priority ‚Üí higher priority)
      if(sCanTarget && tCanTarget){
        if(sPriority < tPriority){ 
          // source has lower priority (e.g., amp) and target has higher priority (e.g., mic)
          source.dataset.routeTo=target.dataset.id; 
          return true; 
        } else { 
          // target has lower priority, so target routes to source
          target.dataset.routeTo=source.dataset.id; 
          return true; 
        }
      }
      
      // Only one direction is valid
      if(sCanTarget){ source.dataset.routeTo=target.dataset.id; return true; }
      if(tCanTarget){ target.dataset.routeTo=source.dataset.id; return true; }
      return false;
    }
    // Helper: find chain endpoint (following valid routeTo)
    function resolveEndpoint(start){
      const svg=start && start.closest && start.closest('svg'); if(!svg) return start;
      const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      let cur=start; const seen=new Set();
      while(cur && !seen.has(cur)){
        seen.add(cur);
        const nid=cur.dataset.routeTo||''; if(!nid) break;
        const nxt=nodes.find(n=> n.dataset.id===nid); if(!nxt) break;
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(nxt.dataset.type||'other')===-1) break;
        cur=nxt;
      }
      return cur||start;
    }
    function nameOf(node){ const t=findText(node); return (t && t.textContent) || (node.dataset.key||'Item'); }
    function maybePromptChannel(endNode){
      try{
        if(!endNode) return;
        const targets=effectiveTargets(endNode);
        if(!targets.includes('channel')) return;
        if(endNode.dataset.channel && String(endNode.dataset.channel).trim()!=='') return;
        const label=nameOf(endNode);
        const ans=prompt('Assign channel for '+label+'? (number)','');
        if(ans==null) return; const v=parseInt(String(ans).trim(),10);
        if(Number.isFinite(v) && v>=1){ endNode.dataset.channel=String(v); saveAll(); refreshStageLegend(); }
      }catch(_){ /* ignore prompt issues */ }
    }
    function autoConnectOnPoint(sourceNode, clientX, clientY){
      if(!sourceNode) return false;
      const prevPE=sourceNode.style.pointerEvents;
      sourceNode.style.pointerEvents='none';
      const el=document.elementFromPoint(clientX, clientY);
      sourceNode.style.pointerEvents=prevPE;
      const target= el && el.closest && el.closest('g[data-draggable]');
      if(!target || target===sourceNode) return false;
      const did=connectEitherDirection(sourceNode, target);
      if(did){ const end=resolveEndpoint(sourceNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); const svg=sourceNode.closest('svg'); if(svg) refreshCables(svg); return true; }
      return false;
    }
    function enableSvgDrag(node){
      function isBottomLayer(node){
        const k=node.dataset.key||'';
        return k==='kick' || k==='gtramp' || k==='bassamp' || k==='stack' || k==='combo';
      }
      function bringToFront(node){
        if(isBottomLayer(node)) return;
        const parent=node.parentNode; if(!parent) return;
        parent.appendChild(node);
      }
      // initialize dataset from existing transform if missing
      initDatasetFromTransform(node);
      let start=null; let orig=null;
      // Long-press cable drag state
      let lpTimer=null; let lpActive=false; let lpLine=null; let lpSource=null; let lpTouchId=null;
        node.addEventListener('mousedown',e=>{ if(e.button===2){ return; } if(isStageLocked()){ e.preventDefault(); return; } bringToFront(node); start={x:e.clientX,y:e.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); e.preventDefault(); selectNode(node); });
      function move(e){ if(!start || isStageLocked()) return; var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(e.clientX-start.x)/zoom, dy=(e.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); }
        function up(e){ start=null; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); if(e && typeof e.clientX==='number' && !isStageLocked()){ autoConnectOnPoint(node, e.clientX, e.clientY); } saveAll(); snapshotStage(); }
      // rename on double click (desktop only - avoid on mobile to prevent keyboard popup after drag)
      node.addEventListener('dblclick',()=>{
        if(isStageLocked()) return;
        const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
        if(isMobile) return; // skip on mobile/tablet
        const txt=findText(node); if(!txt) return; const nv=prompt('Rename item:', txt.textContent||''); if(nv!=null){ txt.textContent=nv; syncInspectorFrom(node); saveAll(); }
      });
      // Touch drag + long-press cable gesture OR disconnect gesture
      let touchId=null;
      node.addEventListener('touchstart',e=>{
        if(isStageLocked()){ e.preventDefault(); return; }
        if(touchId!=null) return; const t=e.touches[0]; if(!t) return; touchId=t.identifier; lpTouchId=touchId; start={x:t.clientX,y:t.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; selectNode(node); e.preventDefault();
        lpTimer=setTimeout(()=>{
          if(isStageLocked()) return;
          if(lpTouchId===touchId){ 
            // Check if item has any connections - if so, disconnect; otherwise start cable drag
            const hasConnection = node.dataset.routeTo || Array.from(node.closest('svg').querySelectorAll('g[data-draggable]')).some(g => g.dataset.routeTo === node.dataset.id);
            if(hasConnection){
              // Disconnect: clear this node's routeTo and any incoming connections
              if(node.dataset.routeTo){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); }
              const svg=node.closest('svg'); if(svg){
                Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(g=>{ if(g.dataset.routeTo===node.dataset.id){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); } });
              }
              saveAll(); refreshStageLegend(); if(svg) refreshCables(svg);
              lpActive=false; lpTimer=null;
            } else {
              // No connection, start cable drag
              const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=start.x; pt.y=start.y; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine=document.createElementNS('http://www.w3.org/2000/svg','line'); lpLine.setAttribute('x1',p.x); lpLine.setAttribute('y1',p.y); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); lpLine.setAttribute('stroke','#000'); lpLine.setAttribute('stroke-width','2'); lpLine.setAttribute('stroke-dasharray','6,4'); lpLine.setAttribute('data-temp','cable'); svg.appendChild(lpLine); lpActive=true; lpSource=node; }
            }
          }
        },300);
      }, {passive:false});
      node.addEventListener('touchmove',e=>{
        if(isStageLocked()) return;
        if(touchId==null) return; for(const t of e.touches){ if(t.identifier===touchId){
            // cancel long-press if user moves significantly before it triggers
            if(!lpActive && lpTimer){ const dx=Math.abs(t.clientX-start.x), dy=Math.abs(t.clientY-start.y); if(dx>8 || dy>8){ clearTimeout(lpTimer); lpTimer=null; }
            }
            if(lpActive && lpLine){ const svg=node.closest('svg'); if(svg){ const pt=svg.createSVGPoint(); pt.x=t.clientX; pt.y=t.clientY; const p=pt.matrixTransform(svg.getScreenCTM().inverse()); lpLine.setAttribute('x2',p.x); lpLine.setAttribute('y2',p.y); } e.preventDefault(); break; }
            var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(t.clientX-start.x)/zoom, dy=(t.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } queueSave(); e.preventDefault(); break; } }
      }, {passive:false});
      node.addEventListener('touchend',e=>{
        if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; }
        if(lpActive){ // finalize cable connection
          if(lpLine){ lpLine.remove(); }
          const touch=e.changedTouches && e.changedTouches[0]; if(touch){ const targetEl=document.elementFromPoint(touch.clientX,touch.clientY); const tgt= targetEl && targetEl.closest && targetEl.closest('g[data-draggable]'); if(tgt && tgt!==lpSource){ const sAllowed=effectiveTargets(lpSource); const tAllowed=effectiveTargets(tgt); if(sAllowed.includes(tgt.dataset.type||'other')){ lpSource.dataset.routeTo=tgt.dataset.id; } else if(tAllowed.includes(lpSource.dataset.type||'other')){ tgt.dataset.routeTo=lpSource.dataset.id; } 
            // Easter egg: Fan connected to vocal mic
            if((lpSource.dataset.key==='fan' && tgt.dataset.key==='vocal') || (tgt.dataset.key==='fan' && lpSource.dataset.key==='vocal')){
              const fanNode = lpSource.dataset.key==='fan' ? lpSource : tgt;
              const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
            }
            saveAll(); refreshStageLegend(); } }
          lpActive=false; lpLine=null; lpSource=null; lpTouchId=null;
        }
        // Auto-connect on drop if released over another component
        const ct=(e.changedTouches && e.changedTouches[0])||null; if(ct){ autoConnectOnPoint(node, ct.clientX, ct.clientY); }
        if(touchId==null) return; let still=false; for(const t of e.touches){ if(t.identifier===touchId){ still=true; break; } } if(!still){ touchId=null; saveAll(); snapshotStage(); }
      });
      node.addEventListener('touchcancel',()=>{ if(lpTimer){ clearTimeout(lpTimer); lpTimer=null; } if(lpLine){ lpLine.remove(); lpLine=null; } lpActive=false; lpSource=null; lpTouchId=null; if(touchId!=null){ touchId=null; saveAll(); }});
      
      // Multi-touch pinch to scale and rotate
      let initialPinchDist = null;
      let initialPinchAngle = null;
      let initialScale = null;
      let initialRotation = null;
      let isPinching = false;
      
      node.addEventListener('touchstart', (e) => {
        if(e.touches.length === 2) {
          isPinching = true;
          touchId = null; // Cancel single-touch drag
          if(lpTimer) { clearTimeout(lpTimer); lpTimer = null; }
          if(lpLine) { lpLine.remove(); lpLine = null; }
          lpActive = false;
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchAngle = Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX) * (180 / Math.PI);
          initialScale = parseFloat(node.dataset.scale || '1');
          initialRotation = parseFloat(node.dataset.rotation || '0');
          e.preventDefault();
        }
      }, {passive: false});
      
      node.addEventListener('touchmove', (e) => {
        if(isPinching && e.touches.length === 2) {
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          const currentAngle = Math.atan2(touch2.clientY - touch1.clientY, touch2.clientX - touch1.clientX) * (180 / Math.PI);
          
          // Scale
          const scaleChange = currentDist / initialPinchDist;
          const newScale = Math.max(0.2, Math.min(5, initialScale * scaleChange));
          node.dataset.scale = String(newScale);
          
          // Rotate
          let angleDiff = currentAngle - initialPinchAngle;
          const newRotation = initialRotation + angleDiff;
          node.dataset.rotation = String(newRotation);
          
          applyTransform(node);
          const svg = node.closest('svg');
          if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
          queueSave();
          e.preventDefault();
        }
      }, {passive: false});
      
      node.addEventListener('touchend', (e) => {
        if(e.touches.length < 2) {
          if(isPinching) {
            saveAll();
            snapshotStage();
          }
          isPinching = false;
          initialPinchDist = null;
          initialPinchAngle = null;
        }
      });
      
      // Mousewheel: scale on wheel, rotate on Ctrl+wheel
      node.addEventListener('wheel', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const delta = -e.deltaY * 0.001; // Normalize scroll amount
        
        if(e.ctrlKey || e.metaKey) {
          // Rotate with Ctrl/Cmd + wheel
          const currentRotation = parseFloat(node.dataset.rotation || '0');
          const newRotation = currentRotation + (delta * 15); // 15 degrees per scroll unit
          node.dataset.rotation = String(newRotation);
        } else {
          // Scale with wheel
          const currentScale = parseFloat(node.dataset.scale || '1');
          const newScale = Math.max(0.2, Math.min(5, currentScale + delta));
          node.dataset.scale = String(newScale);
        }
        
        applyTransform(node);
        const svg = node.closest('svg');
        if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
        queueSave();
        saveAll();
      }, {passive: false});
      
      // Enable label dragging (independent of parent item)
      enableLabelDrag(node);
    }
    
    function enableLabelDrag(node){
      const lbl=findText(node);
      if(!lbl) return;
      
      let labelStart=null;
      let labelOrig=null;
      const maxOffset=150; // Maximum distance from parent
      
      const clampOffset=(val)=> Math.max(-maxOffset, Math.min(maxOffset, val));
      
      // Mouse drag for label
      lbl.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        if(node.dataset.showLabel!=='1') return; // Only drag if label is shown
        e.stopPropagation(); // Prevent parent drag
        labelStart={x:e.clientX, y:e.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
        document.addEventListener('mousemove',labelMove);
        document.addEventListener('mouseup',labelUp);
        lbl.style.cursor='grabbing';
      });
      
      const labelMove=(e)=>{
        if(!labelStart) return;
        const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
        const dx=(e.clientX-labelStart.x)/zoom;
        const dy=(e.clientY-labelStart.y)/zoom;
        node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
        node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
        applyLabelTransform(node);
        queueSave();
      };
      
      const labelUp=()=>{
        labelStart=null;
        document.removeEventListener('mousemove',labelMove);
        document.removeEventListener('mouseup',labelUp);
        lbl.style.cursor='grab';
        saveAll();
      };
      
      // Touch drag for label
      let labelTouchId=null;
      lbl.addEventListener('touchstart',e=>{
        if(node.dataset.showLabel!=='1') return;
        const t=e.touches[0];
        if(!t || labelTouchId!=null) return;
        e.stopPropagation(); // Prevent parent drag
        labelTouchId=t.identifier;
        labelStart={x:t.clientX, y:t.clientY};
        labelOrig={x:parseFloat(node.dataset.labelOffsetX||'0'), y:parseFloat(node.dataset.labelOffsetY||'0')};
      }, {passive:false});
      
      lbl.addEventListener('touchmove',e=>{
        if(labelTouchId==null) return;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){
            const zoom=parseFloat(document.getElementById('stageZoom')?.value||'1');
            const dx=(t.clientX-labelStart.x)/zoom;
            const dy=(t.clientY-labelStart.y)/zoom;
            node.dataset.labelOffsetX=String(clampOffset((labelOrig.x||0)+dx));
            node.dataset.labelOffsetY=String(clampOffset((labelOrig.y||0)+dy));
            applyLabelTransform(node);
            queueSave();
            e.preventDefault();
            break;
          }
        }
      }, {passive:false});
      
      lbl.addEventListener('touchend',e=>{
        if(labelTouchId==null) return;
        let still=false;
        for(const t of e.touches){
          if(t.identifier===labelTouchId){ still=true; break; }
        }
        if(!still){
          labelTouchId=null;
          saveAll();
        }
      });
      
      // Multi-touch pinch to scale label (for custom labels and arrows)
      let lblInitialPinchDist = null;
      let lblInitialScale = null;
      let lblIsPinching = false;
      
      lbl.addEventListener('touchstart', (e) => {
        if(e.touches.length === 2 && node.dataset.showLabel === '1') {
          lblIsPinching = true;
          labelTouchId = null; // Cancel single-touch drag
          
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          lblInitialPinchDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          
          const k = node.dataset.key || '';
          if(k === 'arrow' || k === 'label') {
            const currentFontSize = parseFloat(lbl.getAttribute('font-size') || '16');
            lblInitialScale = currentFontSize;
          } else {
            lblInitialScale = parseFloat(node.dataset.scale || '1');
          }
          
          e.stopPropagation();
          e.preventDefault();
        }
      }, {passive: false});
      
      lbl.addEventListener('touchmove', (e) => {
        if(lblIsPinching && e.touches.length === 2) {
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDist = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          
          const scaleChange = currentDist / lblInitialPinchDist;
          const k = node.dataset.key || '';
          
          if(k === 'arrow' || k === 'label') {
            const newFontSize = Math.max(8, Math.min(72, lblInitialScale * scaleChange));
            lbl.setAttribute('font-size', String(Math.round(newFontSize)));
          } else {
            const newScale = Math.max(0.2, Math.min(5, lblInitialScale * scaleChange));
            node.dataset.scale = String(newScale);
            applyTransform(node);
          }
          
          const svg = node.closest('svg');
          if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
          queueSave();
          e.stopPropagation();
          e.preventDefault();
        }
      }, {passive: false});
      
      lbl.addEventListener('touchend', (e) => {
        if(e.touches.length < 2) {
          if(lblIsPinching) {
            saveAll();
            snapshotStage();
          }
          lblIsPinching = false;
          lblInitialPinchDist = null;
        }
      });
      
      // Mousewheel: scale label on wheel
      lbl.addEventListener('wheel', (e) => {
        if(node.dataset.showLabel !== '1') return;
        e.preventDefault();
        e.stopPropagation();
        
        const delta = -e.deltaY * 0.001;
        const k = node.dataset.key || '';
        
        if(k === 'arrow' || k === 'label') {
          const currentFontSize = parseFloat(lbl.getAttribute('font-size') || '16');
          const newFontSize = Math.max(8, Math.min(72, currentFontSize + (delta * 20)));
          lbl.setAttribute('font-size', String(Math.round(newFontSize)));
        } else {
          const currentScale = parseFloat(node.dataset.scale || '1');
          const newScale = Math.max(0.2, Math.min(5, currentScale + delta));
          node.dataset.scale = String(newScale);
          applyTransform(node);
        }
        
        const svg = node.closest('svg');
        if(svg && svg.id === 'stageSvgFull') { refreshCables(svg); }
        queueSave();
        saveAll();
      }, {passive: false});
      
      // Set cursor style when label is draggable
      if(node.dataset.showLabel==='1'){
        lbl.style.cursor='grab';
      }
    }

    // Right-click cable drag connection gesture
    (function setupCableDrag(){
      const svg=document.getElementById('stageSvgFull'); if(!svg) return;
      let cableDrag=null; // {source, x1,y1, line}
      function clientToSvg(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      svg.addEventListener('contextmenu',e=>{ if(e.target.closest('svg#stageSvgFull')){ e.preventDefault(); }});
      let disconnectTimer=null;
      svg.addEventListener('mousedown',e=>{
        if(e.button!==2) return; // only right-click
        const g=e.target.closest && e.target.closest('g[data-draggable]');
        if(!g) return; e.preventDefault();
        // Start disconnect timer - if held for 500ms without movement, disconnect
        const startX=e.clientX, startY=e.clientY;
        disconnectTimer=setTimeout(()=>{
          // Disconnect this item from all connections
          if(g.dataset.routeTo){ delete g.dataset.routeTo; g.removeAttribute('data-route-to'); }
          Array.from(svg.querySelectorAll('g[data-draggable]')).forEach(node=>{ if(node.dataset.routeTo===g.dataset.id){ delete node.dataset.routeTo; node.removeAttribute('data-route-to'); } });
          saveAll(); refreshStageLegend(); refreshCables(svg);
          disconnectTimer=null;
        },500);
        const p=clientToSvg(e.clientX,e.clientY);
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p.x); line.setAttribute('y1', p.y); line.setAttribute('x2', p.x); line.setAttribute('y2', p.y);
        line.setAttribute('stroke','#000'); line.setAttribute('stroke-width','2'); line.setAttribute('stroke-dasharray','6,4'); line.setAttribute('data-temp','cable');
        svg.appendChild(line);
        cableDrag={source:g, x1:p.x, y1:p.y, line:line, startX:startX, startY:startY};
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });
      function onMove(e){ if(!cableDrag) return; 
        // Cancel disconnect timer if mouse moved significantly
        if(disconnectTimer && cableDrag.startX!=null){
          const dx=Math.abs(e.clientX-cableDrag.startX), dy=Math.abs(e.clientY-cableDrag.startY);
          if(dx>8 || dy>8){ clearTimeout(disconnectTimer); disconnectTimer=null; }
        }
        const p=clientToSvg(e.clientX,e.clientY); cableDrag.line.setAttribute('x2',p.x); cableDrag.line.setAttribute('y2',p.y); }
      function onUp(e){ if(disconnectTimer){ clearTimeout(disconnectTimer); disconnectTimer=null; } if(!cableDrag) return; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp);
        const line=cableDrag.line; const source=cableDrag.source; line.remove();
        // determine drop target
        const el=document.elementFromPoint(e.clientX,e.clientY);
        const target= el && el.closest && el.closest('g[data-draggable]');
        if(target && target!==source){
          const sAllowed=effectiveTargets(source); const tAllowed=effectiveTargets(target);
          if(sAllowed.includes(target.dataset.type||'other')){ source.dataset.routeTo=target.dataset.id; }
          else if(tAllowed.includes(source.dataset.type||'other')){ target.dataset.routeTo=source.dataset.id; }
          // Easter egg: Fan connected to vocal mic
          if((source.dataset.key==='fan' && target.dataset.key==='vocal') || (target.dataset.key==='fan' && source.dataset.key==='vocal')){
            const fanNode = source.dataset.key==='fan' ? source : target;
            const txt=findText(fanNode); if(txt){ txt.textContent="I'm the bad guy"; }
          }
          saveAll(); refreshStageLegend();
        }
        cableDrag=null;
      }
    })();

    function initDatasetFromTransform(node){
      if(node.dataset.x && node.dataset.y) return;
      const m=node.transform.baseVal.consolidate();
      const t=m? m.matrix : {e:0,f:0,a:1,d:1};
      node.dataset.x=String(t.e||0);
      node.dataset.y=String(t.f||0);
      // scale approx from matrix a/d
      const s=(t.a&&t.d)? Math.max(1e-3, Math.sqrt(Math.abs(t.a*t.d))) : 1;
      node.dataset.scale=String(s);
      applyTransform(node);
    }

    function applyTransform(node){
      const x=parseFloat(node.dataset.x||'0');
      const y=parseFloat(node.dataset.y||'0');
      const s=parseFloat(node.dataset.scale||'1');
      const r=parseFloat(node.dataset.rotation||'0');
      node.setAttribute('transform',`translate(${x},${y}) scale(${s}) rotate(${r})`);
    }

  function findText(node){ return node.querySelector('text[data-role="label"]') || node.querySelector('text'); }
  
  // Apply label offset transform (labels can be dragged independently)
  function applyLabelTransform(node){
    const lbl=findText(node);
    if(!lbl) return;
    const offsetX=parseFloat(node.dataset.labelOffsetX||'0');
    const offsetY=parseFloat(node.dataset.labelOffsetY||'0');
    lbl.setAttribute('x',String(offsetX));
    lbl.setAttribute('y',String(offsetY));
    const size=parseInt(node.dataset.labelSize||'16',10);
    lbl.setAttribute('font-size',String(size));
  }

    // selection + inspector (selectedNode declared at top level before openStageModal)
    function selectNode(g){
      // Remove any existing selection highlight across both SVGs
      document.querySelectorAll('#stageSvgFull g[data-draggable].selected, #stageSvg g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      selectedNode=g||null;
      const nameInp=document.getElementById('selName');
      const sizeInp=document.getElementById('selSize');
      const showLabelChk=document.getElementById('selShowLabel');
      const inspector=document.getElementById('stageInspector');
      const delBtn=document.getElementById('delSel');
      const dupBtn=document.getElementById('dupSel');
      const rotInp=document.getElementById('selRotation');
      const rotVal=document.getElementById('selRotationValue');
      const labelSizeInp=document.getElementById('selLabelSize');
      const labelSizeControls=document.getElementById('labelSizeControls');
      const selLabel=document.getElementById('selLabel');
      
      // Always keep inspector visible
      if(inspector) inspector.style.display='flex';
      
      if(!g){
        // Show placeholder state
        if(selLabel) selLabel.textContent='Selected: (none)';
        if(nameInp){ nameInp.value=''; nameInp.placeholder='Click an item to select'; nameInp.disabled=true; }
        if(sizeInp){ sizeInp.value='1'; sizeInp.disabled=true; }
        if(rotInp){ rotInp.value='0'; rotInp.disabled=true; }
        if(rotVal) rotVal.textContent='0¬∞';
        if(showLabelChk){ showLabelChk.checked=false; showLabelChk.disabled=true; }
        if(labelSizeControls) labelSizeControls.style.display='none';
        if(delBtn) delBtn.disabled=true;
        if(dupBtn) dupBtn.disabled=true;
        return;
      }
      
      // Enable controls for selected item
      if(selLabel) selLabel.textContent='Selected:';
      if(nameInp){ nameInp.disabled=false; nameInp.placeholder='Label (double‚Äëclick item to rename)'; }
      if(sizeInp) sizeInp.disabled=false;
      if(rotInp) rotInp.disabled=false;
      if(showLabelChk) showLabelChk.disabled=false;
      if(delBtn) delBtn.disabled=false;
      if(dupBtn) dupBtn.disabled=false;
      
      g.classList.add('selected');
      const lbl=g.querySelector('[data-role="label"]');
      if(nameInp)nameInp.value=(lbl?lbl.textContent:'')||g.dataset.key||'';
      if(sizeInp)sizeInp.value=g.dataset.scale||'1';
      if(showLabelChk)showLabelChk.checked=(g.dataset.showLabel==='1');
      if(labelSizeControls)labelSizeControls.style.display=(g.dataset.showLabel==='1')?'flex':'none';
      if(labelSizeInp&&lbl)labelSizeInp.value=lbl.getAttribute('font-size')||'16';
      if(rotInp)rotInp.value=g.dataset.rotation||'0';
      if(rotVal)rotVal.textContent=(g.dataset.rotation||'0')+'¬∞';
      
      // Build and show signal chain display
      buildConnectionChain(g, inspector);
      if(delBtn){
        delBtn.onclick=()=>{
          if(!selectedNode)return;
          const confirmed=confirm('Delete this item?');
          if(confirmed){selectedNode.remove();selectNode(null);refreshStageLegend();refreshCables(selectedNode.closest('svg'));saveAll();}
        };
      }
      if(dupBtn){
        dupBtn.onclick=()=>{
          if(!selectedNode)return;
          const svg=selectedNode.closest('svg');
          const clone=selectedNode.cloneNode(true);
          const x=parseFloat(clone.dataset.x||'0');
          const y=parseFloat(clone.dataset.y||'0');
          clone.dataset.x=String(x+30);
          clone.dataset.y=String(y+30);
          applyTransform(clone);
          svg.appendChild(clone);
          enableSvgDrag(clone);
          selectNode(clone);
          refreshStageLegend();
          refreshCables(svg);
          saveAll();
        };
      }
      if(nameInp){
        nameInp.oninput=()=>{
          if(!selectedNode)return;
          const val=nameInp.value;
          const lbl=selectedNode.querySelector('[data-role="label"]');
          if(lbl)lbl.textContent=val;
          refreshStageLegend();
          saveAll();
        };
      }
      if(sizeInp){
        sizeInp.oninput=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.scale=sizeInp.value;
          applyTransform(selectedNode);
          const svg=selectedNode.closest('svg');
          refreshCables(svg);
          saveAll();
        };
      }
      if(showLabelChk){
        showLabelChk.onchange=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.showLabel=showLabelChk.checked?'1':'0';
          updateLabelVisibility(selectedNode);
          if(labelSizeControls)labelSizeControls.style.display=showLabelChk.checked?'flex':'none';
          saveAll();
        };
      }
      if(labelSizeInp){
        labelSizeInp.oninput=()=>{
          if(!selectedNode)return;
          const lbl=selectedNode.querySelector('[data-role="label"]');
          if(lbl){
            selectedNode.dataset.labelSize=labelSizeInp.value;
            updateLabelSize(selectedNode);
            saveAll();
          }
        };
      }
      if(rotInp){
        rotInp.oninput=()=>{
          if(!selectedNode)return;
          selectedNode.dataset.rotation=rotInp.value;
          applyTransform(selectedNode);
          if(rotVal)rotVal.textContent=rotInp.value+'¬∞';
          const svg=selectedNode.closest('svg');
          refreshCables(svg);
          saveAll();
        };
      }
    }
    
    function bindSelection(svg){
        svg.addEventListener('click',ev=>{
          // Skip if preset modal is open
          const presetModal = document.getElementById('presetModal');
          if(presetModal && presetModal.style.display === 'flex') return;
          
          const g=ev.target.closest && ev.target.closest('g[data-draggable]');
          if(g){ selectNode(g); refreshStageLegend(); ev.stopPropagation(); return; }
          // click on whitespace creates a text label at click position
          const bg=ev.target.closest && ev.target.closest('.stage-bg');
          if(bg){
            if(_suppressBgClick){ _suppressBgClick=false; ev.stopPropagation(); return; }
            const pt=svg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=svg.getScreenCTM().inverse(); const p=pt.matrixTransform(ctm);
            // Ask first; cancel or empty -> deselect only (don't create label)
            let entered=prompt('Text label (leave empty to deselect):',''); 
            if(entered==null || entered.trim()==='') { selectNode(null); refreshStageLegend(); return; }
            entered=String(entered).trim();
            const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(p.x)); gN.dataset.y=String(Math.round(p.y)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
            const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
            applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
            const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); }
            ev.stopPropagation();
            return;
          }
          // Only deselect if clicking on truly empty space (not on any element)
          if(ev.target === svg || ev.target.tagName === 'svg'){
            selectNode(null); refreshStageLegend();
          }
        });
    }
  function ensureSelectionBindings(){ const svg=document.getElementById('stageSvgFull'); if(svg && !svg._boundSel){ bindSelection(svg); svg._boundSel=true; } }
    
    // selectNode function already defined above with selectedNode declaration
    
    function buildConnectionChain(selectedItem, inspector){
      const svg=selectedItem.closest('svg');
      if(!svg) return;
      const allNodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
      const nameInp=document.getElementById('selName');
      const selLabel=document.getElementById('selLabel');
      
      // Build the complete chain by finding the true start
      const chain=[];
      const visited=new Set();
      
      // Helper: determine type priority for proper chain ordering
      const typePriority=(node)=>{
        const type=node.dataset.type||'other';
        if(type==='acoustic' || type==='electric' || type==='keys' || type==='sax' || type==='deck' || type==='drum' || type==='cymbal') return 0; // instruments/sources
        if(type==='amp') return 1; // amps
        if(type==='mic') return 2; // mics
        if(type==='di') return 1.5; // DI boxes
        if(type==='fx') return 1.7; // FX
        if(type==='sampler') return 0.5; // samplers
        return 3; // others/channel endpoints
      };
      
      // Find the absolute start of the chain by walking backwards from selected item
      const findChainStart=(item)=>{
        const candidates=[];
        const seen=new Set();
        
        // Recursively find all items that route to this item
        const walkBack=(target)=>{
          if(seen.has(target.dataset.id)) return;
          seen.add(target.dataset.id);
          const incoming=allNodes.filter(n=> n.dataset.routeTo===target.dataset.id);
          if(incoming.length===0){
            candidates.push(target); // This is a potential start
          } else {
            incoming.forEach(src=> walkBack(src));
          }
        };
        
        walkBack(item);
        
        // Sort candidates by priority to get the true start (instrument before amp before mic)
        candidates.sort((a,b)=> typePriority(a) - typePriority(b));
        return candidates.length>0 ? candidates[0] : item;
      };
      
      const chainStart = findChainStart(selectedItem);
      
      // Walk forward from the true start to build the COMPLETE chain (don't stop at intermediate items with channels)
      let current=chainStart;
      const maxIterations=50; // safety limit
      let iterations=0;
      while(current && !visited.has(current) && iterations<maxIterations){
        iterations++;
        visited.add(current);
        chain.push(current);
        const nextId=current.dataset.routeTo;
        if(!nextId) break;
        const next=allNodes.find(n=> n.dataset.id===nextId);
        if(!next) break;
        // validate connection is allowed
        const allowed=effectiveTargets(current);
        if(!allowed.includes(next.dataset.type||'other')) break;
        current=next;
      }
      
      // Ensure selected item is in the chain
      if(!chain.includes(selectedItem)){
        chain.push(selectedItem);
      }
      
      // Always use chain display for consistency (even for single items)
      // Hide standard name input
      if(nameInp) nameInp.style.display='none';
      if(selLabel) selLabel.style.display='none';
      
      // Remove any existing chain displays to prevent duplicates
      inspector.querySelectorAll('.connection-chain').forEach(el => el.remove());
      
      // Create chain display (single row, no wrap) - ALWAYS shown for consistency
      const chainDiv=document.createElement('div');
      chainDiv.className='connection-chain';
      chainDiv.style.cssText='display:flex;align-items:center;gap:6px;flex-wrap:nowrap;padding:6px 8px;background:#f3f4f6;border-radius:6px;overflow-x:auto;width:100%';
      
      chain.forEach((node,idx)=>{
        const isSelected = node===selectedItem;
        const isLast = idx===chain.length-1;
        
        // Item name field - fixed width for consistency
        const itemInput=document.createElement('input');
        itemInput.type='text';
        itemInput.value=findText(node)?.textContent || node.dataset.key||'Item';
        itemInput.style.cssText=`padding:4px 8px;border:2px solid ${isSelected?'#374151':'#d1d5db'};border-radius:4px;font-size:13px;font-weight:${isSelected?'700':'400'};background:${isSelected?'#e5e7eb':'#fff'};width:120px;flex-shrink:0`;
        itemInput.title='Name: '+itemInput.value;
        itemInput.addEventListener('change',()=>{
          const t=findText(node);
          if(t){ 
            t.textContent=itemInput.value; 
            saveAll(); 
            refreshStageLegend();
            if(node===selectedItem) syncInspectorFrom(node);
          }
        });
        chainDiv.appendChild(itemInput);
        
        // Arrow between items (only if there's actually a connection)
        if(!isLast){
          const arrow=document.createElement('span');
          arrow.textContent='‚Üí';
          arrow.style.cssText='color:#6b7280;font-size:14px;font-weight:bold;flex-shrink:0';
          chainDiv.appendChild(arrow);
        }
      });
      
      // Find which item in the chain can/should have the channel
      // Check all items in chain (backwards) to find one with channel capability
      let channelNode=null;
      
      // First check if any item already has a channel assigned
      for(let i=chain.length-1; i>=0; i--){
        const node=chain[i];
        if(node.dataset.channel && node.dataset.channel!==''){
          channelNode=node;
          break;
        }
      }
      
      // If no channel assigned, check if any item CAN have a channel (prefer last item)
      if(!channelNode){
        for(let i=chain.length-1; i>=0; i--){
          const node=chain[i];
          const targets=effectiveTargets(node);
          if(targets.includes('channel')){
            channelNode=node;
            break;
          }
        }
      }
      
      // ALWAYS add channel field if any item can have one (for consistent formatting)
      if(channelNode){
        const isStereo=(channelNode.dataset.key||'')==='stereoPair';
        const chInput=document.createElement('input');
        chInput.type='number';
        chInput.min='1';
        chInput.max=isStereo?'63':'64';
        chInput.placeholder='Ch';
        chInput.value=channelNode.dataset.channel||'';
        chInput.style.cssText='padding:4px 8px;border:2px solid #10b981;border-radius:4px;font-size:13px;font-weight:700;background:#d1fae5;width:70px;flex-shrink:0';
        chInput.title='Channel number (assigned to '+((findText(channelNode)?.textContent)||'this item')+')';
        
        chInput.addEventListener('change',()=>{
          const newCh=parseInt(chInput.value,10);
          if(!Number.isFinite(newCh) || newCh<1){
            delete channelNode.dataset.channel;
            channelNode.removeAttribute('data-channel');
          } else {
            // Check if channel is taken
            const taken=allNodes.find(n=> n!==channelNode && occupiesChannelHelper(n,newCh));
            if(taken){
              const takenName=findText(taken)?.textContent||'another item';
              if(!confirm(`Channel ${newCh} is used by ${takenName}. Reassign anyway? (This will disconnect ${takenName})`)){
                chInput.value=channelNode.dataset.channel||'';
                return;
              }
              delete taken.dataset.channel;
              taken.removeAttribute('data-channel');
            }
            channelNode.dataset.channel=String(newCh);
          }
          saveAll();
          refreshStageLegend();
          const stageSvg=channelNode.closest('svg');
          if(stageSvg) refreshCables(stageSvg);
        });
        
        chainDiv.appendChild(chInput);
      }
      
      // Insert chain display before the standard name input
      inspector.insertBefore(chainDiv, inspector.firstChild);
    }
    
    function occupiesChannelHelper(node,ch){
      if(!ch) return false;
      const a=parseInt(node.dataset.channel||'0',10);
      if(!a) return false;
      const isStereo=(node.dataset.key||'')==='stereoPair';
      if(isStereo){ return ch===a || ch===a+1; }
      return ch===a;
    }
    function syncInspectorFrom(g){ if(!g) return; const nameInp=document.getElementById('selName'); const sizeInp=document.getElementById('selSize'); const rotInp=document.getElementById('selRotation'); const rotVal=document.getElementById('selRotationValue'); if(nameInp){ const txt=findText(g); nameInp.value=txt? (txt.textContent||'') : ''; } if(sizeInp){ sizeInp.value=g.dataset.scale||'1'; } if(rotInp){ const r=parseFloat(g.dataset.rotation||'0'); rotInp.value=String(Math.round(r)%360); if(rotVal) rotVal.textContent=Math.round(r)%360+'¬∞'; } }
  document.getElementById('selName').addEventListener('change',()=>{ if(!selectedNode) return; const t=findText(selectedNode); if(t){ t.textContent=document.getElementById('selName').value; saveAll(); }});
  document.getElementById('selName').addEventListener('change',()=> refreshStageLegend());
  document.getElementById('selSize').addEventListener('input',()=>{ if(!selectedNode) return; const v=parseFloat(document.getElementById('selSize').value); const k=selectedNode.dataset.key||''; if(k==='arrow' || k==='label'){ const lbl=findText(selectedNode); if(lbl){ const base = (k==='arrow')?14:16; const fs=Math.max(8, Math.round(base*v)); lbl.setAttribute('font-size', String(fs)); } } else { selectedNode.dataset.scale=String(v); applyTransform(selectedNode); } saveAll(); });
  document.getElementById('selSize').addEventListener('change',()=>{ if(isStageLocked()) return; saveAll(); snapshotStage(); });
  document.getElementById('selRotation').addEventListener('input',()=>{ if(!selectedNode || isStageLocked()) return; const v=parseFloat(document.getElementById('selRotation').value); selectedNode.dataset.rotation=String(v); applyTransform(selectedNode); const svg=selectedNode.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } const rotVal=document.getElementById('selRotationValue'); if(rotVal) rotVal.textContent=Math.round(v)+'¬∞'; queueSave(); saveAll(); });
  document.getElementById('selRotation').addEventListener('change',()=>{ if(isStageLocked()) return; saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=>{ if(!selectedNode || isStageLocked()) return; selectedNode.remove(); selectedNode=null; document.getElementById('selName').value=''; saveAll(); snapshotStage(); });
  document.getElementById('delSel').addEventListener('click',()=> refreshStageLegend());
  // Show label toggle
  const showLabelChk=document.getElementById('selShowLabel');
  const labelSizeControls=document.getElementById('labelSizeControls');
  const labelSizeSlider=document.getElementById('selLabelSize');
  if(showLabelChk){
    showLabelChk.addEventListener('change',()=>{
      if(!selectedNode) return; 
      selectedNode.dataset.showLabel= showLabelChk.checked ? '1':'0'; 
      const lbl=findText(selectedNode); 
      if(lbl){ 
        lbl.style.display= showLabelChk.checked ? 'block':'none'; 
        // Initialize label offset if not set
        if(!selectedNode.dataset.labelOffsetX) selectedNode.dataset.labelOffsetX='0';
        if(!selectedNode.dataset.labelOffsetY) selectedNode.dataset.labelOffsetY='0';
        if(!selectedNode.dataset.labelSize) selectedNode.dataset.labelSize='16';
        applyLabelTransform(selectedNode);
      }
      // Show/hide label size controls
      if(labelSizeControls){ labelSizeControls.style.display= showLabelChk.checked ? 'flex':'none'; }
      if(labelSizeSlider && showLabelChk.checked){ labelSizeSlider.value=selectedNode.dataset.labelSize||'16'; }
      saveAll(); refreshStageLegend();
    });
  }
  // Label size slider
  if(labelSizeSlider){
    labelSizeSlider.addEventListener('input',()=>{
      if(!selectedNode) return;
      const size=parseInt(labelSizeSlider.value,10);
      selectedNode.dataset.labelSize=String(size);
      const lbl=findText(selectedNode);
      if(lbl){ lbl.setAttribute('font-size',String(size)); }
      saveAll();
    });
  }
  // Duplicate button
  const dupBtn=document.getElementById('dupSel');
  if(dupBtn){ dupBtn.addEventListener('click',()=>{
    if(!selectedNode) return;
    const clone=selectedNode.cloneNode(true);
    const svg=selectedNode.closest('svg');
    initDatasetFromTransform(clone);
    clone.dataset.x=String(parseFloat(clone.dataset.x||'0')+40);
    clone.dataset.y=String(parseFloat(clone.dataset.y||'0')+40);
    applyTransform(clone);
    svg.appendChild(clone);
    enableSvgDrag(clone);
    selectNode(clone);
    refreshStageLegend(); saveAll();
  }); }
  // Global touch-based toolbox drag handling
  let activeToolTouch=null;
  window.addEventListener('touchmove',e=>{
    if(!activeToolTouch) return; const t=e.touches[0]; if(!t) return; activeToolTouch.x=t.clientX; activeToolTouch.y=t.clientY; }, {passive:true});
  window.addEventListener('touchend',e=>{
    if(!activeToolTouch) return; const stage=document.getElementById('stageSvgFull'); if(stage){ const rect=stage.getBoundingClientRect(); const x=activeToolTouch.x, y=activeToolTouch.y; if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){ // inside stage
        // detect target BEFORE adding new node
        const el=document.elementFromPoint(x, y);
        const dropTarget= el && el.closest && el.closest('g[data-draggable]');
        // convert to SVG coords
        const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
        const newNode=addGlyphFull(activeToolTouch.key, {x:Math.round(svgP.x), y:Math.round(svgP.y)});
        if(newNode) selectNode(newNode);
        if(dropTarget && newNode){
          if(connectEitherDirection(newNode, dropTarget)){
            const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
            refreshCables(stage);
          }
        }
        try{ snapshotStage(); }catch(_){ }
      } }
    activeToolTouch=null;
  });
  // Mouse / touchpad fallback drag (for environments where HTML5 drag doesn't fire)
  let activeToolMouse=null; // {key,startX,startY,started,ghost}
  document.addEventListener('mousedown',e=>{
    // Skip if preset modal is open
    const presetModal = document.getElementById('presetModal');
    if(presetModal && presetModal.style.display === 'flex') return;
    
    const btn=e.target.closest && e.target.closest('button.tool');
    if(!btn) return; if(e.button!==0) return;
    // We stored key explicitly on custom images; for standard tools key derivation from dragstart handler's closure is harder; embed data-key at build time for reliability
    const explicit=btn.dataset.key; if(!explicit) return; 
    activeToolMouse={key:explicit,startX:e.clientX,startY:e.clientY,started:false,ghost:null};
  });
  // Mouse drag: start after small movement threshold, update ghost position
  document.addEventListener('mousemove',e=>{
    if(!activeToolMouse) return; 
    if(activeToolMouse.started){ 
      // Already started - just update ghost position
      if(activeToolMouse.ghost){ activeToolMouse.ghost.style.left=(e.clientX+12)+'px'; activeToolMouse.ghost.style.top=(e.clientY+12)+'px'; } 
      return; 
    }
    // Not started yet - check if moved enough from start position
    const dx=Math.abs(e.clientX - activeToolMouse.startX), dy=Math.abs(e.clientY - activeToolMouse.startY); 
    if(dx+dy>6){
      activeToolMouse.started=true;
      const ghost=document.createElement('div'); ghost.style.position='fixed'; ghost.style.left=(e.clientX+12)+'px'; ghost.style.top=(e.clientY+12)+'px'; ghost.style.pointerEvents='none'; ghost.style.zIndex='99999'; ghost.style.padding='4px 6px'; ghost.style.background='rgba(31,41,55,0.85)'; ghost.style.color='#fff'; ghost.style.fontSize='11px'; ghost.style.borderRadius='4px'; ghost.style.boxShadow='0 2px 6px rgba(0,0,0,0.4)'; ghost.textContent='Place '+activeToolMouse.key; document.body.appendChild(ghost); activeToolMouse.ghost=ghost;
    }
  });
  document.addEventListener('mouseup',e=>{
    if(!activeToolMouse) return; const data=activeToolMouse; activeToolMouse=null; if(data.ghost){ data.ghost.remove(); }
    // Skip if preset modal is open
    const presetModal = document.getElementById('presetModal');
    if(presetModal && presetModal.style.display === 'flex') return;
    
    if(!data.started) return; const stage=document.getElementById('stageSvgFull'); if(!stage) return; const rect=stage.getBoundingClientRect(); const x=e.clientX, y=e.clientY; if(x<rect.left||x>rect.right||y<rect.top||y>rect.bottom) return;
    // detect target before adding
    const el=document.elementFromPoint(x,y); const dropTarget= el && el.closest && el.closest('g[data-draggable]');
    const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
    const newNode=addGlyphFull(data.key,{x:Math.round(svgP.x), y:Math.round(svgP.y)}); if(newNode) selectNode(newNode);
    if(dropTarget && newNode){ if(connectEitherDirection(newNode, dropTarget)){ const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end); refreshCables(stage); } }
    saveAll(); try{ snapshotStage(); }catch(_){ }
  });
  function getStageGroups(){ const full=document.getElementById('stageSvgFull'); if(!full) return []; return Array.from(full.querySelectorAll('g[data-draggable]')); }
  // Draw curvy dotted cables between connected items (routeTo chains)
  function refreshCables(svg){ if(!svg) return; const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
    // ensure a dedicated layer
    let layer=svg.querySelector('g[data-layer="cables"]'); if(layer){ layer.remove(); }
    layer=document.createElementNS('http://www.w3.org/2000/svg','g'); layer.setAttribute('data-layer','cables'); layer.setAttribute('pointer-events','none'); svg.appendChild(layer);
    const byId=new Map(nodes.map(n=> [n.dataset.id, n]));
    function centerOf(n){ return {x:parseFloat(n.dataset.x||'0')||0, y:parseFloat(n.dataset.y||'0')||0}; }
    function nodeRadius(n){ const s=Math.max(0.3, parseFloat(n.dataset.scale||'1')||1); const k=n.dataset.key||''; const base=(k==='label'||k==='arrow')? 20 : 30; return base*s; }
    function sampleQuad(a,c,b,t){ const x=(1-t)*(1-t)*a.x + 2*(1-t)*t*c.x + t*t*b.x; const y=(1-t)*(1-t)*a.y + 2*(1-t)*t*c.y + t*t*b.y; return {x,y}; }
    function pickControl(a,b,initial, obstacles){ let c={x:initial.x,y:initial.y}; const clamp=(v,min,max)=> Math.max(min, Math.min(max,v)); const vb=svg.viewBox && svg.viewBox.baseVal; const bx={x:0,y:0,w:(vb?vb.width:1500),h:(vb?vb.height:900)};
      for(let it=0; it<3; it++){
        // sample along curve, compute repulsion from obstacles
        let rx=0, ry=0; const steps=10; for(let i=1;i<steps;i++){ const t=i/steps; const p=sampleQuad(a,c,b,t); obstacles.forEach(o=>{
            const dx=p.x-o.x, dy=p.y-o.y; const d=Math.hypot(dx,dy); const th=o.r+40; if(d<th && d>1e-3){ const f=(th-d)/th; rx += (dx/d)*f; ry += (dy/d)*f; }
        }); }
        // apply small push
        const push=30; c.x = clamp(c.x + rx*push, bx.x+4, bx.x+bx.w-4); c.y = clamp(c.y + ry*push, bx.y+4, bx.y+bx.h-4);
      }
      return c;
    }
    // build obstacle list (centers + radii)
    const obstacles = nodes.map(n=>{ const c=centerOf(n); return {x:c.x,y:c.y,r:nodeRadius(n)}; });
    nodes.forEach(src=>{
      const to=src.dataset.routeTo; if(!to) return; const dst=byId.get(to); if(!dst) return;
      // make sure the connection is allowed; use effectiveTargets if available
      try{ if(typeof effectiveTargets==='function'){ const ok=effectiveTargets(src).includes(dst.dataset.type||'other'); if(!ok) return; } }catch(_){ /* ignore */ }
      
      // Check if this is a mic-amp connection (either direction)
      const srcType=src.dataset.type||'other';
      const dstType=dst.dataset.type||'other';
      const isMicAmpConnection = (srcType==='amp' && dstType==='mic') || (srcType==='mic' && dstType==='amp');
      
      const a=centerOf(src), b=centerOf(dst); const dx=b.x-a.x, dy=b.y-a.y; const len=Math.hypot(dx,dy)||1; const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const nx=-dy/len, ny=dx/len; const baseK=30; const init={x:mx+nx*baseK, y:my+ny*baseK};
      
      if(isMicAmpConnection){
        // Draw straight arrow for mic-amp connection (no curve)
        const d=`M ${a.x} ${a.y} L ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','2'); 
        p.setAttribute('marker-end','url(#arrowhead)');
        layer.appendChild(p);
        
        // Ensure arrowhead marker exists
        let defs=svg.querySelector('defs');
        if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
        if(!defs.querySelector('#arrowhead')){
          const marker=document.createElementNS('http://www.w3.org/2000/svg','marker');
          marker.setAttribute('id','arrowhead');
          marker.setAttribute('markerWidth','10');
          marker.setAttribute('markerHeight','10');
          marker.setAttribute('refX','9');
          marker.setAttribute('refY','3');
          marker.setAttribute('orient','auto');
          const triangle=document.createElementNS('http://www.w3.org/2000/svg','polygon');
          triangle.setAttribute('points','0 0, 10 3, 0 6');
          triangle.setAttribute('fill','#111');
          marker.appendChild(triangle);
          defs.appendChild(marker);
        }
      } else {
        // Draw normal curved dotted cable
        const c=pickControl(a,b,init, obstacles);
        const d=`M ${a.x} ${a.y} Q ${c.x} ${c.y} ${b.x} ${b.y}`;
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); 
        p.setAttribute('d', d); 
        p.setAttribute('fill','none'); 
        p.setAttribute('stroke','#111'); 
        p.setAttribute('stroke-width','1.5'); 
        p.setAttribute('stroke-dasharray','4 3'); 
        layer.appendChild(p);
      }
    });
  }
  function refreshStageLegend(){
    const host=document.getElementById('stageLegend'); if(!host) return;
    const rows=getStageGroups();
    host.innerHTML='';
    // sort with priority processors first
    rows.sort((a,b)=>{
      const ta=a.dataset.type||'other', tb=b.dataset.type||'other';
      const pa=PRIORITY_TYPES.has(ta), pb=PRIORITY_TYPES.has(tb);
      if(pa&&!pb) return -1; if(pb&&!pa) return 1; return parseInt(a.dataset.id||'0')-parseInt(b.dataset.id||'0');
    });

    // helpers for channels and chains
    function isStereo(node){ return (node.dataset.key||'')==='stereoPair'; }
    function occupiesChannel(node, ch){ if(!ch) return false; const a=parseInt(node.dataset.channel||'0',10); if(!a) return false; if(isStereo(node)){ return ch===a || ch===a+1; } return ch===a; }
    function channelTaken(ch, except){ return rows.find(r=> r!==except && occupiesChannel(r, ch)); }
    function nextFreeChannel(start, dir, stereo){ let c=start; const upper=stereo?63:64; const lower=1; while(true){ if(c<lower || c>upper) return null; const occupied = channelTaken(c, null) || (stereo && channelTaken(c+1, null)); if(!occupied) return c; c += dir; }
    }
    // helper to build chain string
    function buildChain(from){
      const seen=new Set();
      const parts=[];
      let cur=from;
      while(cur){
        if(seen.has(cur)) { parts.push('[loop]'); break; }
        seen.add(cur);
        const t=findText(cur); const base=(t && t.textContent)||cur.dataset.key||'Item';
        parts.push(base);
        const nextId=cur.dataset.routeTo || '';
        if(!nextId) break;
        const next=rows.find(r=> r.dataset.id===nextId);
        if(!next) break;
        // validate that next type is an allowed target from current type
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(next.dataset.type||'other')===-1){ break; }
        cur=next;
      }
      const last=cur||from;
      if(last.dataset.channel){
        if(isStereo(last)){
          const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1));
        }else{
          parts.push('Ch '+last.dataset.channel);
        }
      }
      return parts.join(' - ');
    }

      // Build incoming map to identify roots (start of chains)
      const incoming=new Set(); rows.forEach(r=>{ const to=r.dataset.routeTo; if(to) incoming.add(to); });
      // Filter: hide annotations; compact view = only root items OR items that expose a channel directly
      const displayRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const targets=ROUTE_TARGETS[tp]||[];
        const exposesChannel=targets.includes('channel');
        const isRoot=!incoming.has(r.dataset.id);
        return isRoot || exposesChannel; // keep if chain start or endpoint with channel
      });
      // Identify unconnected items (no routeTo, no channel, not routed to by anyone, not utility annotations)
      const unconnectedRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        const hasChannel = r.dataset.channel;
        const hasRouteTo = r.dataset.routeTo;
        const isRoutedTo = incoming.has(r.dataset.id);
        return !hasChannel && !hasRouteTo && !isRoutedTo;
      });
    // Precompute candidates map for routing dropdown population
    const byType={}; displayRows.forEach(r=>{ const t=r.dataset.type||'other'; (byType[t]||(byType[t]=[])).push(r); });

    // determine dynamic channel range (still consider all rows for occupancy logic)
    const assignedChannels=rows.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
    const maxChan=assignedChannels.length? Math.max(...assignedChannels):0;
      displayRows.forEach((g,i)=>{
      const item=document.createElement('div'); item.className='row';
      const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
      const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
      const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);

      const type=g.dataset.type||'other';
  const targets=effectiveTargets(g);
      // Routing (routeTo or channel) cell
      const routeCell=document.createElement('div');
      let chInput=null;
      // Channel editing is applied to the chain endpoint, not necessarily the current row
      const resolveEnd=(start)=>{ let s=new Set(); let cur=start; while(cur && !s.has(cur)){ s.add(cur); const nid=cur.dataset.routeTo||''; if(!nid) break; const nxt=rows.find(r=> r.dataset.id===nid); if(!nxt) break; const allowed=effectiveTargets(cur); if(allowed.indexOf(nxt.dataset.type||'other')===-1) break; cur=nxt; } return cur||start; };
      const endNode=resolveEnd(g);
      const endTargets=effectiveTargets(endNode);
      if(endTargets.includes('channel')){
        const stereo=isStereo(endNode);
        chInput=document.createElement('input'); chInput.type='number'; chInput.min='1'; chInput.max= stereo ? '63' : '64'; chInput.step='1'; chInput.placeholder='Ch'; chInput.style.width='56px'; chInput.value=endNode.dataset.channel||''; chInput.title='Right-click drag between items to auto-chain';
        let prevVal = endNode.dataset.channel||'';
        const applyChannel=(ch)=>{ if(!ch){ endNode.dataset.channel=''; delete endNode.dataset.channel2; saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } return; }
          // block if taken
          if(channelTaken(ch, endNode) || (stereo && channelTaken(ch+1, endNode))){ chInput.value = prevVal; return; }
          endNode.dataset.channel=String(ch); if(stereo){ endNode.dataset.channel2=String(ch+1); } else { delete endNode.dataset.channel2; }
          prevVal=String(ch); saveAll(); refreshStageLegend(); try{ snapshotStage(); }catch(_){ } };
        const onChanChange=()=>{ const v=parseInt(chInput.value||'0',10); if(!isFinite(v) || v<1){ applyChannel(null); }
          else { const val=Math.min(stereo?63:64, v); if(channelTaken(val, endNode) || (stereo && channelTaken(val+1, endNode))){ chInput.value=prevVal; return; } applyChannel(val); } };
        chInput.addEventListener('focus',()=>{ prevVal = chInput.value; });
        chInput.addEventListener('change', onChanChange);
        chInput.addEventListener('blur', onChanChange);
        chInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ onChanChange(); }
          if(e.key==='ArrowUp' || e.key==='ArrowDown'){ e.preventDefault(); const dir = e.key==='ArrowUp' ? 1 : -1; const cur=parseInt(chInput.value|| (prevVal||'0'),10) || 0; const start = Math.max(1, cur + dir); const nf = nextFreeChannel(start, dir, stereo); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } }
        });
        chInput.addEventListener('input', ()=>{ const cur=parseInt(chInput.value||'0',10)||0; const pv=parseInt(prevVal||'0',10)||0; const stereoNow=stereo; if(cur===pv+1 || cur===pv-1){ const dir = (cur>pv)?1:-1; const nf = nextFreeChannel(cur, dir, stereoNow); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } } });
        routeCell.appendChild(chInput);
      }
      // RouteTo select for processors / sources that can feed other processors
      if(targets.filter(t=> t!=='channel').length){
        const rtSel=document.createElement('select'); rtSel.className='routeSel'; rtSel.appendChild(new Option('‚Üí none',''));
        const elig=[]; targets.forEach(tt=>{ if(tt==='channel') return; const groups=byType[tt]; if(groups){ groups.forEach(gr=>{ if(gr!==g) elig.push(gr); }); } });
        elig.forEach(gr=>{ const name=findText(gr); const label=(name && name.textContent)||gr.dataset.key||('Item '+gr.dataset.id); rtSel.appendChild(new Option(label, gr.dataset.id)); });
        // sanitize existing route if invalid
        if(g.dataset.routeTo){ const curNext=rows.find(r=> r.dataset.id===g.dataset.routeTo); const allowed=effectiveTargets(g); if(!curNext || allowed.indexOf(curNext.dataset.type||'other')===-1){ g.dataset.routeTo=''; } }
        rtSel.value=g.dataset.routeTo||'';
        rtSel.addEventListener('change',()=>{ const dest=rows.find(r=> r.dataset.id===rtSel.value); const allowed=effectiveTargets(g); if(dest && allowed.indexOf(dest.dataset.type||'other')!==-1){ g.dataset.routeTo=rtSel.value; } else { g.dataset.routeTo=''; } saveAll(); refreshStageLegend(); });
        routeCell.appendChild(rtSel);
      }
      item.appendChild(routeCell);

      // Chain cell
  const chainCell=document.createElement('div'); chainCell.className='chain'; chainCell.style.textAlign='left'; chainCell.textContent=buildChain(g); item.appendChild(chainCell);

      host.appendChild(item);
    });
    // Add unconnected items section if any exist
    if(unconnectedRows.length>0){
      const divider=document.createElement('div'); divider.style.cssText='border-top:2px solid #d1d5db;margin:12px 0 8px 0;padding-top:8px;font-weight:600;color:#64748b;font-size:12px';
      divider.textContent='Unconnected Items (acoustic/props):';
      host.appendChild(divider);
      unconnectedRows.forEach((g,i)=>{
        const item=document.createElement('div'); item.className='row'; item.style.opacity='0.7';
        const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
        const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
        const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);
        const noteCell=document.createElement('div'); noteCell.style.cssText='font-size:11px;color:#64748b;font-style:italic'; noteCell.textContent='(no signal path)'; item.appendChild(noteCell);
        host.appendChild(item);
      });
    }
    // After legend rebuild, refresh visual cables on both editor and stored SVGs
    const svgFull=document.getElementById('stageSvgFull'); if(svgFull) refreshCables(svgFull);
    const svgSmall=document.getElementById('stageSvg'); if(svgSmall) refreshCables(svgSmall);
  }
  /* Filter system removed: icons now assumed to have proper transparency baked in. */

    // Print Tech Rider + Stage
  // Print Tech button opens chooser modal
  document.getElementById('printTech').addEventListener('click',()=>{
    openPrintChooser('tech');
  });
  document.getElementById('closeTech').addEventListener('click',()=> document.getElementById('modalTech').classList.remove('open'));

    // Stage selection state (must be declared before openStageModal)
    let selectedNode = null;

    // Fullscreen stage editor open/close (now inline, used for Stage Plot view)
    function openStageModal(){
      // ensure header reflects current gig
      try{
        refreshStageHeader();
        // ensure toolbox is populated
        try{ buildTools(); }catch(_){ /* ignore */ }
        
        // Re-attach drag handlers to ensure they work
        attachStageDragHandlers();
        
        // Initialize drag-assign handles
        initDragAssignHandles();
        
        // FIRST: Load stage from tourDate if available
        if(selectedTourDateId){
          const tourDate = tourDates.find(td => td.id === selectedTourDateId);
          if(tourDate && tourDate.stage && tourDate.stage.length > 0){
            const container = document.getElementById('stageStore');
            if(container){
              container.innerHTML = tourDate.stage;
              const svg = container.querySelector('svg');
              if(svg){
                svg.id = 'stageSvg';
                svg.classList.add('bw');
                try{ refreshCables(svg); }catch(e){}
              }
            }
          }
        }
        
        // seed full editor from stored svg
        const store=document.getElementById('stageSvg');
        const full=document.getElementById('stageSvgFull');
        // enforce stage outline
        if(full && !full.classList.contains('bw')) full.classList.add('bw');
        const bg=full && full.querySelector('rect.stage-bg');
        if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        // initialize resize handles (corner-only interaction) and apply stored size
        (function initStageResize(){
          const frame=document.getElementById('stageFrame'); if(!frame||!full) return;
          // default size if not previously set
          const prevW=parseInt(full.style.width||'0',10); const prevH=parseInt(full.style.height||'0',10);
            if(prevW>0 && prevH>0){ frame.style.width=prevW+'px'; frame.style.height=prevH+'px'; }
            else { frame.style.width='1000px'; frame.style.height='600px'; full.style.width='1000px'; full.style.height='600px'; }
          const handles=frame.querySelectorAll('.stage-handle');
          handles.forEach(h=>{
            h.addEventListener('mousedown',e=>{
              if(e.button!==0) return; e.preventDefault();
              const startX=e.clientX, startY=e.clientY; const startW=frame.offsetWidth, startH=frame.offsetHeight; const pos=h.dataset.handle;
              function move(ev){
                let dx=ev.clientX-startX, dy=ev.clientY-startY; let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                newW=Math.max(600,newW); newH=Math.max(360,newH);
                frame.style.width=newW+'px'; frame.style.height=newH+'px'; full.style.width=newW+'px'; full.style.height=newH+'px';
              }
              function up(){ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); saveAll(); }
              document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
            });
            // Touch support for handles
            h.addEventListener('touchstart',e=>{
              e.preventDefault(); const t=e.touches[0]; if(!t) return;
              const startX=t.clientX, startY=t.clientY; const startW=frame.offsetWidth, startH=frame.offsetHeight; const pos=h.dataset.handle;
              function touchMove(ev){
                const tt=ev.touches[0]; if(!tt) return;
                let dx=tt.clientX-startX, dy=tt.clientY-startY; let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                newW=Math.max(600,newW); newH=Math.max(360,newH);
                frame.style.width=newW+'px'; frame.style.height=newH+'px'; full.style.width=newW+'px'; full.style.height=newH+'px';
                ev.preventDefault();
              }
              function touchEnd(){ document.removeEventListener('touchmove',touchMove); document.removeEventListener('touchend',touchEnd); saveAll(); }
              document.addEventListener('touchmove',touchMove,{passive:false}); document.addEventListener('touchend',touchEnd);
            },{passive:false});
          });
        })();
        if(!full){ throw new Error('Stage SVG not found'); }
        // reset children (keep first two nodes: bg rect and title)
        while(full.childNodes.length>2) full.removeChild(full.lastChild);
        if(store){
          Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
          var tnode=store.querySelector('#stageTitle'); var ttl=document.getElementById('stageTitleFull'); if(ttl){ ttl.textContent=(tnode && tnode.textContent) || ttl.textContent; }
        }
  // Ensure arrow markers are available
    ensureStageMarkers(full);
  // Filter defs removed (icons expected to be clean PNGs without white fill)
        // Migration: remove legacy background rects behind emojis/images
        Array.from(full.querySelectorAll('g[data-draggable]')).forEach(gr=>{
          // assign ids/types to legacy nodes
          if(!gr.dataset.id){ gr.dataset.id=String(_nextStageId++); }
          if(!gr.dataset.type){ const k=gr.dataset.key||''; gr.dataset.type=TYPE_MAP[k]||'other'; }
          if(!('showLabel' in gr.dataset)) gr.dataset.showLabel = (gr.dataset.key==='label' || gr.dataset.key==='arrow') ? '1':'0';
          const hasImg = !!gr.querySelector('image');
          const hadEmoji = !!gr.querySelector('text[data-role="emoji"]');
          if(hasImg || hadEmoji){ Array.from(gr.querySelectorAll('rect[data-bg]')).forEach(r=> r.remove()); }
          // Remove any legacy filter attributes
          Array.from(gr.querySelectorAll('image[filter]')).forEach(im=> im.removeAttribute('filter'));
        });
  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=>{
    enableSvgDrag(g);
    applyLabelTransform(g); // Apply saved label offsets and size
  });
  refreshCables(full);
  bindSelection(full);
  const modal=document.getElementById('stageModal');
  if(!modal){ throw new Error('Stage modal not found'); }
  modal.classList.add('open');
  refreshStageLegend();
  selectNode(null);
  }catch(err){
    if(window && window.alert){ alert('Could not open Stage Plot editor. See console for details.'); }
    if(console && console.error) console.error(err);
  }
}

// closeStageModal function
function closeStageModal(){
  const full=document.getElementById('stageSvgFull');
  let small=document.getElementById('stageSvg');
  if(full){
    if(!small){
      const store=document.getElementById('stageStore');
      if(store){ small=full.cloneNode(true); small.id='stageSvg'; small.classList.add('bw'); store.appendChild(small); }
    }
    if(small){
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
      Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
      Array.from(small.querySelectorAll('g[data-draggable]')).forEach(gr=>{ const lbl=findText(gr); if(lbl){ lbl.style.display = gr.dataset.showLabel==='1' ? 'block':'none'; } });
      ensureStageMarkers(small); refreshCables(small);
      const fullTitle=document.getElementById('stageTitleFull');
      let smallTitle=document.getElementById('stageTitle');
      if(!smallTitle && small){ smallTitle=small.querySelector('#stageTitle'); }
      if(fullTitle){
        if(smallTitle){ smallTitle.textContent=fullTitle.textContent; }
        else {
          const t=document.createElementNS('http://www.w3.org/2000/svg','text');
          t.setAttribute('id','stageTitle'); t.setAttribute('x','500'); t.setAttribute('y','36'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','22'); t.setAttribute('font-weight','bold'); t.textContent=fullTitle.textContent; small.appendChild(t);
        }
      }
      const bg=small.querySelector('rect.stage-bg'); if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
    }
  }
  
  // Save stage to current tour date immediately (use small/stored SVG which was just synced)
  // SAFETY: Only save if we have actual stage content - never overwrite existing data with blank
  if(selectedTourDateId){
    const tourDate = tourDates.find(td => td.id === selectedTourDateId);
    if(tourDate && small){
      // Get the synced small SVG (stageSvg) not the editor (stageSvgFull)
      const hasItems = small.querySelectorAll('g[data-draggable]').length > 0;
      const stageHTML = small.outerHTML;
      // Only save if we have items OR if there was no previous stage data
      if(hasItems || !tourDate.stage){
        tourDate.stage = stageHTML;
      }
      tourDate.gearSummary = gearSummary;
      tourDate.techNotes = techNotes;
    }
  }
  
  saveAll();
  
  // Update Calendar tab preview after closing stage editor
  if(selectedTourDateId){
    const tourDate = tourDates.find(td => td.id === selectedTourDateId);
    if(tourDate && typeof renderTourPreviews === 'function'){
      setTimeout(() => renderTourPreviews(tourDate), 100);
    }
  }
  
  document.getElementById('stageModal').classList.remove('open');
}

    // Unified toggle: Stage Plot <-> Lighting & FX
    function toggleStageAndNotes(){
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      const btn=document.getElementById('stageToggle');
      if(!stageModal || !notesModal || !btn) return;

      const showingStage = stageModal.classList.contains('open');

      if(showingStage){
        // currently Stage Plot -> switch to Lighting / FX view
        closeStageModal();
        buildTechTableFull();
        const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary||'';
        notesModal.classList.add('open');
        btn.textContent = 'Stage Plot';
        saveAll(); // persist after switching away
      } else {
        // currently Lighting / FX (or neither) -> switch to Stage Plot view
        notesModal.classList.remove('open');
        openStageModal();
        btn.textContent = 'Lighting / FX';
        saveAll(); // persist after opening stage
      }
    }
    window.toggleStageAndNotes = toggleStageAndNotes;
    window.openStageModal = openStageModal; // legacy safety
    // final safety: delegate click in case listeners were missed
    document.addEventListener('click',ev=>{
      const trg=ev.target && ev.target.closest ? ev.target.closest('#openStage') : null;
      if(trg){ ev.preventDefault(); openStageModal(); }
    });
    document.getElementById('closeStage').addEventListener('click',closeStageModal);
    // Clear full stage editor
    const clearStageBtn=document.getElementById('clearStage');
    if(clearStageBtn){ clearStageBtn.addEventListener('click',()=>{
      if(isStageLocked()){ alert('Stage plot is locked. Uncheck the lock to make changes.'); return; }
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      // preserve background rect and title only
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll(); snapshotStage();
    }); }
    
    // New Stage button
    const newStageBtn=document.getElementById('newStageBtn');
    if(newStageBtn){ newStageBtn.addEventListener('click',()=>{
      if(isStageLocked()){ alert('Stage plot is locked. Uncheck the lock to make changes.'); return; }
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      const hasItems = full.childNodes.length > 2;
      if(!hasItems){
        alert('Stage is already empty!');
        return;
      }
      const save = confirm('Save current stage plot as a preset before starting fresh?\n\nOK = Save as preset\nCancel = Just clear (lose current plot)');
      if(save){
        const name = prompt('Name this stage preset:', 'Stage ' + new Date().toLocaleDateString());
        if(name && name.trim()){
          const container = document.getElementById('stageStore');
          if(container && container.querySelector('svg')){
            const stageSvgCopy = container.querySelector('svg').cloneNode(true);
            stagePresets.push({
              name: name.trim(),
              svg: stageSvgCopy.outerHTML,
              date: new Date().toISOString()
            });
            saveAll();
            if(typeof renderPresetList === 'function') renderPresetList();
            alert('Stage plot saved as preset: ' + name.trim());
          }
        }
      }
      // Clear stage (preserve background and title)
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll();
      snapshotStage();
    }); }

    // Keyboard shortcuts in stage editor: Ctrl+D duplicate (undo/redo handled globally)
    document.addEventListener('keydown',e=>{
      const modal=document.getElementById('stageModal');
      if(!modal || !modal.classList.contains('open')) return;
      if(e.target && (e.target.tagName==='INPUT' || e.target.tagName==='TEXTAREA' || e.target.isContentEditable)) return;
      if(e.ctrlKey && !e.shiftKey && (e.key==='d' || e.key==='D')){
        e.preventDefault();
        const dupBtn=document.getElementById('dupSel');
        if(dupBtn) dupBtn.click();
      }
    });

    // Lighting notes now controlled via unified toggle; keep close button local only
  const closeNotesBtn=document.getElementById('closeNotes');
  if(closeNotesBtn){ closeNotesBtn.addEventListener('click',()=> document.getElementById('notesModal').classList.remove('open')); }

    // Stage Preset Management (stagePresets is global, persists across all dates)
    
    function loadStagePreset(preset){
      if(!preset || !preset.stage) return;
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      const parent = svg.parentNode;
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = preset.stage;
      const newSvg = tempDiv.querySelector('svg');
      if(!newSvg) return;
      newSvg.id = 'stageSvgFull';
      parent.replaceChild(newSvg, svg);
      if(preset.gearSummary !== undefined){
        gearSummary = preset.gearSummary;
        const gearEl = document.getElementById('gear');
        if(gearEl) gearEl.value = gearSummary;
      }
      saveAll();
      rebuildStageInteractions();
      alert(`Preset "${preset.name}" loaded!`);
    }
    
    function rebuildStageInteractions(){
      const svg = document.getElementById('stageSvgFull');
      if(!svg) return;
      svg.querySelectorAll('g[data-draggable]').forEach(enableSvgDrag);
      refreshStageLegend();
      refreshCables(svg);
    }
    
    // Show preset modal - created dynamically to avoid event issues
    function showPresetModal(){
      // Remove any existing modal
      const existing = document.getElementById('presetModal');
      if(existing) existing.remove();
      
      // Create modal overlay
      const modal = document.createElement('div');
      modal.id = 'presetModal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.6);z-index:99999;display:flex;align-items:center;justify-content:center';
      
      // Create modal content
      const content = document.createElement('div');
      content.style.cssText = 'background:#fff;border-radius:10px;padding:24px;max-width:700px;width:90%;max-height:80vh;overflow-y:auto;box-shadow:0 8px 32px rgba(0,0,0,0.3)';
      
      // Header
      const header = document.createElement('h3');
      header.textContent = 'Stage Plot Presets';
      header.style.cssText = 'margin:0 0 16px 0;font-size:20px;color:#1e293b';
      content.appendChild(header);
      
      // Save button
      const saveBtn = document.createElement('button');
      saveBtn.textContent = 'üíæ Save Current';
      saveBtn.className = 'btn';
      saveBtn.style.cssText = 'background:#065f46;color:#fff;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;width:100%;margin-bottom:16px;font-size:14px';
      saveBtn.onclick = function(e) {
        e.stopPropagation();
        const svg = document.getElementById('stageSvgFull');
        if(!svg) { alert('No stage plot to save'); return; }
        const defaultName = (gig.band || 'Band') + '_StagePlot';
        const name = prompt('Preset name:', defaultName);
        if(!name || !name.trim()) return;
        const preset = {
          name: name.trim(),
          date: new Date().toISOString(),
          stage: svg.outerHTML,
          gearSummary: gearSummary || ''
        };
        stagePresets.push(preset);
        saveAll();
        showPresetModal(); // Refresh
        alert('Preset "' + preset.name + '" saved!');
      };
      content.appendChild(saveBtn);
      
      // Preset list container
      const listContainer = document.createElement('div');
      listContainer.style.cssText = 'margin-bottom:16px';
      
      if(!stagePresets || stagePresets.length === 0){
        listContainer.innerHTML = '<div style="color:#6b7280;font-size:14px;padding:20px;text-align:center;border:2px dashed #d1d5db;border-radius:8px">No presets saved yet</div>';
      } else {
        listContainer.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill, minmax(180px, 1fr));gap:12px;margin-bottom:16px';
        
        stagePresets.forEach((preset, idx) => {
          const card = document.createElement('div');
          card.style.cssText = 'border:2px solid #e5e7eb;border-radius:8px;background:#fff;overflow:hidden;cursor:pointer';
          
          // Thumbnail
          const thumb = document.createElement('div');
          thumb.style.cssText = 'width:100%;height:100px;background:#f8fafc;display:flex;align-items:center;justify-content:center;overflow:hidden;border-bottom:1px solid #e5e7eb';
          if(preset.stage){
            const temp = document.createElement('div');
            temp.innerHTML = preset.stage;
            const svg = temp.querySelector('svg');
            if(svg){
              svg.removeAttribute('id');
              svg.style.cssText = 'width:100%;height:100%;pointer-events:none';
              thumb.appendChild(svg);
            }
          } else {
            thumb.textContent = 'No preview';
          }
          card.appendChild(thumb);
          
          // Info bar
          const info = document.createElement('div');
          info.style.cssText = 'padding:8px;display:flex;align-items:center;justify-content:space-between;gap:6px;background:#f9fafb';
          
          const name = document.createElement('span');
          name.textContent = preset.name;
          name.style.cssText = 'font-size:11px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1';
          info.appendChild(name);
          
          const delBtn = document.createElement('button');
          delBtn.textContent = 'üóëÔ∏è';
          delBtn.style.cssText = 'background:#ef4444;color:#fff;border:none;padding:4px 8px;border-radius:4px;cursor:pointer;font-size:12px';
          delBtn.onclick = function(e) {
            e.stopPropagation();
            if(confirm('Delete "' + preset.name + '"?')){
              stagePresets.splice(idx, 1);
              saveAll();
              showPresetModal(); // Refresh
            }
          };
          info.appendChild(delBtn);
          
          card.appendChild(info);
          
          // Card click to load
          card.onclick = function(e) {
            e.stopPropagation();
            if(confirm('Load "' + preset.name + '"? This will replace your current stage plot.')){
              loadStagePreset(preset);
              modal.remove();
            }
          };
          
          card.onmouseenter = function(){ card.style.borderColor = '#0ea5e9'; };
          card.onmouseleave = function(){ card.style.borderColor = '#e5e7eb'; };
          
          listContainer.appendChild(card);
        });
      }
      content.appendChild(listContainer);
      
      // Close button
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'btn secondary';
      closeBtn.style.cssText = 'background:#6b7280;color:#fff;border:none;padding:10px 24px;border-radius:6px;cursor:pointer;float:right';
      closeBtn.onclick = function(e) {
        e.stopPropagation();
        modal.remove();
      };
      content.appendChild(closeBtn);
      
      // Clear float
      const clearDiv = document.createElement('div');
      clearDiv.style.clear = 'both';
      content.appendChild(clearDiv);
      
      modal.appendChild(content);
      
      // Click outside to close
      modal.onclick = function(e) {
        if(e.target === modal) modal.remove();
      };
      
      // Stop all events from reaching stage behind
      content.onclick = function(e) { e.stopPropagation(); };
      content.onmousedown = function(e) { e.stopPropagation(); };
      content.ontouchstart = function(e) { e.stopPropagation(); };
      
      document.body.appendChild(modal);
    }
    
    // Make showPresetModal globally accessible
    window.showPresetModal = showPresetModal;
    
    const presetBtn = document.getElementById('stagePresetBtnTop');
    if(presetBtn){
      presetBtn.addEventListener('click', ()=>{
        // Open stage plot first if not already open
        const stageModal = document.getElementById('stageModal');
        if(stageModal && !stageModal.classList.contains('open')){
          openStageModal();
        }
        showPresetModal();
      });
    }

    // Drag from toolbox into full SVG at drop position
    let currentDragSource = null;
    let dragHandlersAttached = false;
    
    function attachStageDragHandlers(){
      const fullSvg=document.getElementById('stageSvgFull');
      if(!fullSvg) return;
      
      // Remove old listeners if reattaching
      if(dragHandlersAttached){
        fullSvg.removeEventListener('dragover', stageDragOver);
        fullSvg.removeEventListener('drop', stageDrop);
      }
      
      fullSvg.addEventListener('dragover', stageDragOver);
      fullSvg.addEventListener('drop', stageDrop);
      dragHandlersAttached = true;
    }
    
    function stageDragOver(ev){
      if(isStageLocked()) return;
      ev.preventDefault();
    }
    
    function stageDrop(ev){
      ev.preventDefault();
      if(isStageLocked()) return;
      const fullSvg=document.getElementById('stageSvgFull');
      if(!fullSvg) return;
      
      const key=ev.dataTransfer.getData('text/plain');
      if(!key) return;
      
      // detect target under cursor BEFORE adding new glyph
      const el=document.elementFromPoint(ev.clientX, ev.clientY);
      const dropTarget= el && el.closest && el.closest('g[data-draggable]');
      const pt=fullSvg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=fullSvg.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
      const newNode=addGlyphFull(key,{x:Math.round(svgP.x), y:Math.round(svgP.y)});
      if(newNode) selectNode(newNode);
      if(dropTarget && newNode){
        if(connectEitherDirection(newNode, dropTarget)){
          const end=resolveEndpoint(newNode); saveAll(); refreshStageLegend(); maybePromptChannel(end);
          refreshCables(fullSvg);
        }
      }
    }
    
    // Attach handlers on page load
    attachStageDragHandlers();
    
    // Track drag source for duplicate prevention
    document.addEventListener('dragstart', (ev)=>{
      const toolBtn = ev.target.closest('.tool');
      if(toolBtn){
        currentDragSource = toolBtn;
      }
    });
    document.addEventListener('dragend', ()=>{
      currentDragSource = null;
    });

    // Arrow drawing: drag anywhere in SVG (hold Shift to draw over items)
    (function(){
      let drawing=null; // {x0,y0, preview}
      const svg=document.getElementById('stageSvgFull');
      if(!svg) return; // Exit if stage editor not available
      ensureStageMarkers(svg);
      function svgPointFromClient(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      function startDraw(x,y){ drawing={x0:x,y0:y, preview:document.createElementNS('http://www.w3.org/2000/svg','line')}; const ln=drawing.preview; ln.setAttribute('x1',String(x)); ln.setAttribute('y1',String(y)); ln.setAttribute('x2',String(x)); ln.setAttribute('y2',String(y)); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-dasharray','4,3'); ln.setAttribute('stroke-width','2'); ln.setAttribute('pointer-events','none'); svg.appendChild(ln); }
      function updateDraw(x,y){ if(!drawing) return; drawing.preview.setAttribute('x2',String(x)); drawing.preview.setAttribute('y2',String(y)); }
      function finishDraw(x1,y1){ if(!drawing){ return; } const {x0,y0, preview}=drawing; svg.removeChild(preview); drawing=null; const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy); if(dist<6){ // treat as click -> create label here
          // Ask first; cancel or empty -> abort (no stray labels)
          let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
          // Create label at point
          const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(x0)); gN.dataset.y=String(Math.round(y0)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
          const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
          applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
          const isMobile = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
          if(!isMobile){ const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); } }
          _suppressBgClick=true;
          return;
        }
        // Create arrow group anchored at origin (x0,y0) pointing to (x1,y1)
        const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.dataset.x=String(Math.round(x0)); g.dataset.y=String(Math.round(y0)); g.dataset.scale='1'; g.setAttribute('data-draggable','1'); g.dataset.key='arrow'; g.dataset.type='other'; g.dataset.showLabel='1';
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line'); ln.setAttribute('x1','0'); ln.setAttribute('y1','0'); ln.setAttribute('x2',String(Math.round(dx))); ln.setAttribute('y2',String(Math.round(dy))); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrowHead)'); g.appendChild(ln);
        // Ask for arrow label; cancel or empty -> abort entire arrow creation
        let enteredA=prompt('Arrow label:',''); if(enteredA==null) return; enteredA=String(enteredA).trim(); if(!enteredA) return;
  const t=document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('x', (Math.abs(dx)>Math.abs(dy) ? (dx<0?-8:8) : 0) );
  const yOff = (dy<0? 14 : -10);
  t.setAttribute('y', String(yOff));
  t.setAttribute('font-size','14'); t.setAttribute('text-anchor','start'); t.setAttribute('dominant-baseline','alphabetic'); t.setAttribute('data-role','label');
  t.textContent=enteredA; g.appendChild(t);
        applyTransform(g); svg.appendChild(g); enableSvgDrag(g); selectNode(g); refreshStageLegend(); saveAll();
        _suppressBgClick=true;
      }
      // Mouse support (capture to preempt item drag when Shift is held)
      svg.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        // ignore UI controls outside svg content AND drag handles
        if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions,.drag-assign-handle')) return;
        const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]'));
        if(overItem && !e.shiftKey) return; // allow drawing over items only with Shift
        const p=svgPointFromClient(e.clientX,e.clientY); startDraw(p.x,p.y); e.stopImmediatePropagation(); e.preventDefault();
      }, {capture:true});
      svg.addEventListener('mousemove',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); updateDraw(p.x,p.y); }, {capture:true});
      window.addEventListener('mouseup',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); finishDraw(p.x,p.y); }, {capture:true});
      // Touch support (capture); only allow drawing from whitespace background
      svg.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions,.drag-assign-handle')) return; const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]')); const onBg = !!(e.target.closest && e.target.closest('.stage-bg')); if(overItem || !onBg) return; const p=svgPointFromClient(t.clientX,t.clientY); startDraw(p.x,p.y); e.preventDefault(); e.stopImmediatePropagation(); }, {passive:false, capture:true});
      window.addEventListener('touchmove',e=>{ if(!drawing) return; const t=e.touches[0]; if(!t) return; const p=svgPointFromClient(t.clientX,t.clientY); updateDraw(p.x,p.y); }, {passive:true});
      window.addEventListener('touchend',e=>{ if(!drawing) return; const ct=(e.changedTouches && e.changedTouches[0])|| (e.touches && e.touches[0]); if(!ct) return; const p=svgPointFromClient(ct.clientX, ct.clientY); finishDraw(p.x,p.y); }, {passive:true});
    })();

    // Removed legacy custom tool buttons (label/rect/default layout). New upload image flow below.
    const uploadBtn=document.getElementById('uploadImageBtn');
    const uploadInput=document.getElementById('uploadImageInput');
    function rebuildCustomImages(){
      const host=document.getElementById('customImages'); if(!host) return; host.innerHTML='';
      (gig.customImages||[]).forEach(ci=>{
        const b=document.createElement('button'); b.className='tool'; b.dataset.key=ci.key; b.innerHTML=`<img src="${ci.data}" alt="${ci.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${ci.label}`; host.appendChild(b);
      });
    }
    if(uploadBtn && uploadInput){
      uploadBtn.addEventListener('click',()=> uploadInput.click());
      uploadInput.addEventListener('change',()=>{
        const file=uploadInput.files && uploadInput.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{
          const dataUrl=reader.result; const rawName=file.name.replace(/\.[^.]+$/,''); const label=prompt('Image label:', rawName)||rawName;
          const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl});
          saveAll(); rebuildCustomImages(); buildTools(); // add to toolbox drag list
        }; reader.readAsDataURL(file);
        uploadInput.value='';
      });
      // hydrate any existing
      rebuildCustomImages();
    }
    // New Icon drawing logic
    const newIconBtn=document.getElementById('newIconBtn');
    const iconModal=document.getElementById('iconMakerModal');
    const iconCanvas=document.getElementById('iconCanvas');
    const iconLineWidth=document.getElementById('iconLineWidth');
    const iconClear=document.getElementById('iconClear');
    const iconSave=document.getElementById('iconSave');
    const iconCancel=document.getElementById('iconCancel');
    let iconDrawing=false; let iconStrokes=[]; let currentStroke=null;
    function openIconModal(){ 
      if(iconModal){ 
        iconModal.style.display='flex'; 
        iconModal.classList.add('open'); 
        iconStrokes=[]; 
        redrawIcon();
      }
    }
    function closeIconModal(){ 
      if(iconModal){ 
        iconModal.classList.remove('open'); 
        iconModal.style.display='none';
        iconStrokes = [];
        if(iconCanvas){
          const ctx = iconCanvas.getContext('2d');
          ctx.clearRect(0, 0, iconCanvas.width, iconCanvas.height);
        }
      }
    }
    
    // Close modal when clicking backdrop
    if(iconModal){
      iconModal.addEventListener('click', (e) => {
        if(e.target === iconModal){
          closeIconModal();
        }
      });
    }
    function redrawIcon(){ if(!iconCanvas) return; const ctx=iconCanvas.getContext('2d'); ctx.clearRect(0,0,iconCanvas.width,iconCanvas.height); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle='#000'; iconStrokes.forEach(st=>{ ctx.lineWidth=st.w; ctx.beginPath(); st.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.stroke(); }); }
    function classifyStroke(pts){ 
      if(pts.length<8) return 'line';
      const first=pts[0], last=pts[pts.length-1];
      const minX=Math.min(...pts.map(p=>p.x)), maxX=Math.max(...pts.map(p=>p.x));
      const minY=Math.min(...pts.map(p=>p.y)), maxY=Math.max(...pts.map(p=>p.y));
      const w=maxX-minX, h=maxY-minY;
      const closeDist=Math.hypot(last.x-first.x,last.y-first.y);
      
      // Must be a closed shape
      if(closeDist > Math.max(30, 0.2*Math.max(w,h))) return 'line';
      if(pts.length<12) return 'line';
      
      // Look for concentrated direction changes (corners)
      // Group nearby angle changes together as one corner
      let cornerRegions = [];
      const minCornerAngle = Math.PI/4; // 45 degrees
      
      for(let i=5; i<pts.length-5; i++){
        const dx1 = pts[i].x - pts[i-5].x;
        const dy1 = pts[i].y - pts[i-5].y;
        const dx2 = pts[i+5].x - pts[i].x;
        const dy2 = pts[i+5].y - pts[i].y;
        
        const len1 = Math.hypot(dx1, dy1);
        const len2 = Math.hypot(dx2, dx2);
        if(len1 < 10 || len2 < 10) continue;
        
        const angle1 = Math.atan2(dy1, dx1);
        const angle2 = Math.atan2(dy2, dx2);
        let diff = Math.abs(angle2 - angle1);
        if(diff > Math.PI) diff = 2*Math.PI - diff;
        
        if(diff > minCornerAngle){
          // Check if this is near an existing corner region
          const nearExisting = cornerRegions.some(c => Math.abs(i - c) < 15);
          if(!nearExisting){
            cornerRegions.push(i);
          }
        }
      }
      
      // 3-5 distinct corner regions = rectangle
      if(cornerRegions.length >= 3 && cornerRegions.length <= 5){
        return 'rect';
      }
      
      // Smooth path with 0-2 corners = circle/ellipse
      if(cornerRegions.length <= 2){
        const aspect = w/h;
        if(aspect > 0.5 && aspect < 2.0){
          return 'ellipse';
        }
      }
      
      return 'line';
    }
    function normalizeStrokes(){ // replace rough shapes with ideal forms
      iconStrokes=iconStrokes.map(st=>{ const kind=classifyStroke(st.pts); if(kind==='line'){ return st; } const minX=Math.min(...st.pts.map(p=>p.x)), maxX=Math.max(...st.pts.map(p=>p.x)); const minY=Math.min(...st.pts.map(p=>p.y)), maxY=Math.max(...st.pts.map(p=>p.y)); if(kind==='rect'){ return {w:st.w, pts:[{x:minX,y:minY},{x:maxX,y:minY},{x:maxX,y:maxY},{x:minX,y:maxY},{x:minX,y:minY}]}; } if(kind==='ellipse'){ const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const rx=(maxX-minX)/2, ry=(maxY-minY)/2; const steps=40; const pts=[]; for(let i=0;i<=steps;i++){ const a=(i/steps)*Math.PI*2; pts.push({x:cx+rx*Math.cos(a), y:cy+ry*Math.sin(a)}); } return {w:st.w, pts}; } return st; }); }
    function iconPointerDown(x,y){ iconDrawing=true; currentStroke={w:parseInt(iconLineWidth.value)||4, pts:[{x,y}]}; iconStrokes.push(currentStroke); redrawIcon(); }
    function iconPointerMove(x,y){ if(!iconDrawing || !currentStroke) return; currentStroke.pts.push({x,y}); redrawIcon(); }
    function iconPointerUp(){ if(!iconDrawing) return; iconDrawing=false; currentStroke=null; normalizeStrokes(); redrawIcon(); }
    if(iconCanvas){
      iconCanvas.addEventListener('mousedown',e=>{ 
        e.preventDefault();
        e.stopPropagation();
        const r=iconCanvas.getBoundingClientRect(); 
        iconPointerDown(e.clientX-r.left,e.clientY-r.top);
      });
      window.addEventListener('mousemove',e=>{ 
        if(!iconDrawing) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerMove(e.clientX-r.left,e.clientY-r.top);
      });
      window.addEventListener('mouseup',()=> iconPointerUp());
      iconCanvas.addEventListener('touchstart',e=>{ 
        e.preventDefault();
        e.stopPropagation();
        const t=e.touches[0];
        if(!t) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerDown(t.clientX-r.left,t.clientY-r.top);
      }, {passive:false});
      iconCanvas.addEventListener('touchmove',e=>{ 
        e.preventDefault();
        const t=e.touches[0];
        if(!t) return;
        const r=iconCanvas.getBoundingClientRect();
        iconPointerMove(t.clientX-r.left,t.clientY-r.top);
      }, {passive:false});
      iconCanvas.addEventListener('touchend',e=>{ 
        e.preventDefault();
        iconPointerUp();
      });
    }
    if(newIconBtn) newIconBtn.addEventListener('click', openIconModal);
    if(iconCancel) iconCancel.addEventListener('click', closeIconModal);
    if(iconClear) iconClear.addEventListener('click',()=>{ iconStrokes=[]; redrawIcon(); });
    if(iconSave) iconSave.addEventListener('click',()=>{ if(!iconCanvas) return; normalizeStrokes(); redrawIcon(); const label=prompt('Icon label:','Custom')||'Custom'; const dataUrl=iconCanvas.toDataURL('image/png'); const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl}); saveAll(); rebuildCustomImages(); buildTools(); closeIconModal(); });
    // (Removed default layout auto-placement code)

    // Shuffle playlist (guard if legacy button exists)
    (function(){ const sh=document.getElementById('shuffleBtn'); if(!sh) return; sh.addEventListener('click',()=>{
      const songs=setlist.filter(x=>x.type==='song');
      const others=setlist.filter(x=>x.type!=='song');
      const shuffled=shuffle(songs);
      // keep others in their relative positions (insert breaks/encore by index mapping)
      let i=0; setlist=setlist.map(x=> x.type==='song' ? shuffled[i++] : x);
      buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll();
    }); })();

    // Gig info now edited directly on sheet header (no separate input fields)
    // Header flags removed - all header elements now always visible and directly editable
  // Logo and font selection UI removed - now edited directly on sheet
    // Gear summary persistence
  const gearEl2=document.getElementById('gear'); if(gearEl2){ gearEl2.addEventListener('input',()=>{ gearSummary=gearEl2.value; }); gearEl2.addEventListener('change',()=>{ gearSummary=gearEl2.value; saveAll(); }); }

    // Global print chooser wiring
    function openPrintChooser(pref){
      const dlg=document.getElementById('printChooser');
      // Close other modals so chooser is visible above everything and not printed with them
      ['stageModal','notesModal','modal','modalTech'].forEach(id=>{ const m=document.getElementById(id); if(m) m.classList.remove('open'); });
      const cSet=document.getElementById('pSet');
      const cStage=document.getElementById('pStage');
      const cTech=document.getElementById('pTech');
      // default: at least one checked
      const all=[cSet,cStage,cTech];
      all.forEach(c=> c.checked=false);
      if(pref==='set') cSet.checked=true; else if(pref==='stage') cStage.checked=true; else if(pref==='tech') cTech.checked=true; else cSet.checked=true;
      dlg.classList.add('open');
      validatePrintSelection();
    }
    function validatePrintSelection(){
      const btn=document.getElementById('doPrint');
      const any= document.getElementById('pSet').checked || document.getElementById('pStage').checked || document.getElementById('pTech').checked || document.getElementById('pLyrics').checked || document.getElementById('pItinerary').checked;
      btn.disabled = !any;
    }
    ['pSet','pStage','pTech','pLyrics','pItinerary'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('change',validatePrintSelection); }});
    
    // Lyrics checkbox handler - show song selector when checked
    const pLyricsCheckbox = document.getElementById('pLyrics');
    const lyricsSongSelector = document.getElementById('lyricsSongSelector');
    const lyricsSongList = document.getElementById('lyricsSongList');
    if(pLyricsCheckbox && lyricsSongSelector && lyricsSongList){
      pLyricsCheckbox.addEventListener('change', ()=>{
        if(pLyricsCheckbox.checked){
          // Populate song list with ALL songs from database that have lyrics
          lyricsSongList.innerHTML = '';
          const songsWithLyrics = db.filter(s => s.lyrics && s.lyrics.trim());
          if(songsWithLyrics.length === 0){
            lyricsSongList.innerHTML = '<div style="color:#9ca3af;font-size:12px">No songs with lyrics in database.</div>';
            lyricsSongSelector.style.display = 'block';
            return;
          }
          songsWithLyrics.forEach(s => {
            const label = document.createElement('label');
            label.style.cssText = 'display:flex;align-items:center;gap:6px;cursor:pointer';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.dataset.songId = s.id;
            checkbox.checked = false; // Default none selected
            label.appendChild(checkbox);
            const text = document.createElement('span');
            text.textContent = `${s.title} - ${s.artist || 'Original'}`;
            text.style.fontSize = '13px';
            label.appendChild(text);
            lyricsSongList.appendChild(label);
          });
          lyricsSongSelector.style.display = 'block';
        } else {
          lyricsSongSelector.style.display = 'none';
        }
      });
    }
    
    const openPrintFab=document.getElementById('openPrintOptions');
    if(openPrintFab){ openPrintFab.addEventListener('click',()=> openPrintChooser()); }
    const openPrintTop=document.getElementById('openPrintOptionsTop');
    if(openPrintTop){ openPrintTop.addEventListener('click',()=> openPrintChooser()); }
    document.getElementById('closePrintChooser').addEventListener('click',()=> document.getElementById('printChooser').classList.remove('open'));
  document.getElementById('printTechModal').addEventListener('click',()=> openPrintChooser('tech'));

    async function printSelected(){
      console.log('üñ®Ô∏è Starting print preparation...');
      
      const wantSet=document.getElementById('pSet').checked;
      const wantStage=document.getElementById('pStage').checked;
      const wantTech=document.getElementById('pTech').checked;
      const wantLyrics=document.getElementById('pLyrics').checked;
      const wantItinerary=document.getElementById('pItinerary').checked;
      
      // PRE-BUILD all content BEFORE printing to ensure SVGs are rendered
      try{ 
        console.log('Building setlist sheet...');
        buildSheet('sheetInline'); 
      }catch(e){ console.error('Failed to build sheet:', e); }
      
      try{ 
        console.log('Building tech header...');
        prepHdrTech(); 
      }catch(e){ console.error('Failed to build tech header:', e); }
      
      // If stage plot is needed, build it NOW and wait for images to load
      if(wantStage){
        try{
          console.log('Pre-building stage plot...');
          const stageOut = document.getElementById('stagePrint');
          if(stageOut){
            stageOut.innerHTML = '';
            stageOut.style.display = 'block';
            buildStageExport(stageOut);
            
            // Wait for all stage images to load
            const stageSvg = stageOut.querySelector('svg');
            if(stageSvg){
              console.log('Loading stage images...');
              await inlineStageImages(stageSvg);
              console.log('‚úÖ Stage images loaded');
            }
          }
        }catch(e){ console.error('Failed to pre-build stage:', e); }
      }
      
      // Build task queue
      const tasks=[];
      if(wantSet) tasks.push(()=> printSetOnce());
      if(wantStage) tasks.push(()=> printStageOnce());
      if(wantTech) tasks.push(()=> printTechOnlyOnce());
      if(wantLyrics) tasks.push(()=> printLyricsOnce());
      if(wantItinerary) tasks.push(()=> printItineraryOnce());
      
      // Close chooser before printing to prevent it from being captured by print
      document.getElementById('printChooser').classList.remove('open');
      
      console.log(`üñ®Ô∏è Executing ${tasks.length} print tasks...`);
      for(const t of tasks){ await t(); }
      console.log('‚úÖ All print tasks complete');
    }
    document.getElementById('doPrint').addEventListener('click',printSelected);

    // PDF/ZIP download removed: users can use native browser print dialog for PDF saving.

    function makePdfFromCanvas(canvas, paper){
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p', 'pt', paper||'letter');
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      let imgW = pageW;
      let imgH = canvas.height * (imgW / canvas.width);
      if(imgH > pageH){ imgH = pageH; imgW = canvas.width * (imgH / canvas.height); }
      const x = (pageW - imgW)/2, y=(pageH - imgH)/2;
      pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
      return pdf.output('blob');
    }

    function withOffscreen(el, fn){
      // Ensure element AND its hidden ancestors are visible for layout so html2canvas gets real size
      const stack=[]; let node=el;
      while(node && node.nodeType===1){
        stack.push({node, style:{display:node.style.display, visibility:node.style.visibility, position:node.style.position, left:node.style.left, top:node.style.top}});
        node.style.display='block';
        node.style.visibility='visible';
        node = node.parentElement;
      }
      // Position target far offscreen to avoid flicker
      el.style.position='fixed'; el.style.left='-10000px'; el.style.top='0';
      return Promise.resolve(fn()).finally(()=>{
        // Restore styles in reverse order
        for(let i=0;i<stack.length;i++){
          const {node, style}=stack[i];
          node.style.display=style.display;
          node.style.visibility=style.visibility;
          node.style.position=style.position;
          node.style.left=style.left;
          node.style.top=style.top;
        }
      });
    }
    async function createSetlistPdfBlob(){
      // Use inline sheet for export (already WYSIWYG)
      buildSheet('sheetInline');
      const el=document.getElementById('sheetInline');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for setlist (mobile or missing PDF libs).');
        // Build print sheet to match preview exactly
        buildSheet('sheet');
        document.getElementById('modal').classList.add('open'); await printPromise(); window.print(); document.getElementById('modal').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, (el.classList.contains('a4')? 'a4' : 'letter'));
      return blob;
    }
    // Helper: obtain current stage SVG (fullscreen editor if open, else stored miniature)
    function getStageSource(){
      let src=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      if(!src){ const store=document.getElementById('stageStore'); if(store){ src=store.querySelector('svg'); } }
      return src;
    }
    // Helper: build channel-ordered legend + cloned stage (with border) identical to printStageOnce
    function buildStageExport(into){
      const stageOut = into; stageOut.innerHTML='';
      const src=getStageSource();
      // Clear any selection highlight before export so no blue glow prints
      document.querySelectorAll('g[data-draggable].selected').forEach(el=> el.classList.remove('selected'));
      const legend=document.createElement('table'); legend.className='tech-table';
      const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Channel</th><th>Chain</th></tr>';
      const tbody=document.createElement('tbody');
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const isStereo=n=> (n.dataset.key||'')==='stereoPair';
        const typeOf=n=> n.dataset.type||'other';
        const findRoot=(end)=>{ let cur=end; const seen=new Set(); while(cur && !seen.has(cur)){ seen.add(cur); const prev=rows.find(r=> r.dataset.routeTo===cur.dataset.id && effectiveTargets(r).includes(typeOf(cur))); if(!prev) break; cur=prev; } return cur||end; };
        const buildChain=(from)=>{ const seen=new Set(); const parts=[]; let cur=from; while(cur){ if(seen.has(cur)) break; seen.add(cur); const t=cur.querySelector('text[data-role="label"]')||cur.querySelector('text'); const base=(t && t.textContent)||(cur.dataset.key||'Item'); parts.push(base); const nid=cur.dataset.routeTo||''; if(!nid) break; const next=rows.find(r=> r.dataset.id===nid); if(!next) break; const ok=effectiveTargets(cur).includes(typeOf(next)); if(!ok) break; cur=next; } const last=cur||from; if(last.dataset.channel){ if(isStereo(last)){ const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1)); } else { parts.push('Ch '+last.dataset.channel); } } return parts.join(' - '); };
        // Collect only endpoints that have an assigned channel (used channels only)
        const endpoints=rows.filter(r=> r.dataset.channel && r.dataset.channel!=='' && (parseInt(r.dataset.channel||'0',10)>0));
        const byCh = endpoints
          .map(n=> ({ node:n, ch: parseInt(n.dataset.channel||'0',10)||0 }))
          .filter(x=> x.ch>0)
          .sort((a,b)=> a.ch - b.ch);
        for(const {node:end, ch} of byCh){
          const tr=document.createElement('tr');
          const chCell=document.createElement('td');
          if(isStereo(end)) chCell.textContent = `${ch} & ${ch+1}`; else chCell.textContent=String(ch);
          const chainCell=document.createElement('td');
          const root=findRoot(end); chainCell.textContent = buildChain(root);
          tr.append(chCell, chainCell); tbody.appendChild(tr);
        }
      }
      legend.append(thead,tbody);
      // Add unconnected items section to print legend
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const typeOf=n=> n.dataset.type||'other';
        const UTILITY_TYPES=['label','arrow'];
        const unconnectedRows = rows.filter(g=>{
          const t=typeOf(g);
          if(UTILITY_TYPES.includes(t)) return false;
          const hasRouteTo = (g.dataset.routeTo||'').trim().length>0;
          const hasChannel = (g.dataset.channel||'').trim().length>0 && parseInt(g.dataset.channel||'0',10)>0;
          const routedTo = rows.some(r=> (r.dataset.routeTo===g.dataset.id) && effectiveTargets(r).includes(t));
          return !hasRouteTo && !hasChannel && !routedTo;
        });
        if(unconnectedRows.length>0){
          const dividerRow=document.createElement('tr');
          const dividerCell=document.createElement('td'); dividerCell.colSpan=2;
          dividerCell.style.cssText='border-top:2px solid #000;padding-top:8px;padding-bottom:4px;font-weight:600;font-size:11pt';
          dividerCell.textContent='Unconnected Items (acoustic/props): ';
          const itemNames = unconnectedRows.map(g=>{
            const tEl=g.querySelector('text[data-role="label"]')||g.querySelector('text');
            const key=g.dataset.key||'';
            const icon=ICON_ITEMS.find(x=>x.key===key);
            return (tEl && tEl.textContent) || (icon?icon.label:'Item');
          });
          const boldSpan=document.createElement('span');
          boldSpan.style.fontWeight='bold';
          boldSpan.textContent=itemNames.join(', ');
          dividerCell.appendChild(boldSpan);
          dividerRow.appendChild(dividerCell);
          tbody.appendChild(dividerRow);
        }
      }
      stageOut.appendChild(legend);
      if(src){
        const clone=src.cloneNode(true); 
        clone.removeAttribute('id'); 
        clone.setAttribute('preserveAspectRatio','xMidYMid meet');
        // Ensure viewBox is set properly for consistent scaling
        if(!clone.hasAttribute('viewBox')){
          const vb=src.viewBox && src.viewBox.baseVal;
          if(vb) clone.setAttribute('viewBox', `0 0 ${vb.width} ${vb.height}`);
          else clone.setAttribute('viewBox', '0 0 1500 900');
        }
        clone.style.width='100%'; 
        clone.style.height='auto'; 
        clone.style.maxHeight='6.5in';
        clone.style.maxWidth='100%';
        clone.style.display='block';
        try{ 
          const vb=clone.viewBox && clone.viewBox.baseVal; 
          if(vb){ 
            const br=document.createElementNS('http://www.w3.org/2000/svg','rect'); 
            br.setAttribute('x','1.5'); 
            br.setAttribute('y','1.5'); 
            br.setAttribute('width', String(vb.width-3)); 
            br.setAttribute('height', String(vb.height-3)); 
            br.setAttribute('fill','none'); 
            br.setAttribute('stroke','#000'); 
            br.setAttribute('stroke-width','3'); 
            br.setAttribute('pointer-events','none'); 
            br.setAttribute('data-print-border','1'); 
            clone.appendChild(br); 
          } 
        }catch(_){ }
        stageOut.appendChild(clone);
      }
      return stageOut;
    }
    async function inlineStageImages(svg){
      if(!svg) return;
      const images=Array.from(svg.querySelectorAll('image'));
      for(const im of images){
        const href=im.getAttribute('href')||im.getAttribute('xlink:href');
        if(!href || href.startsWith('data:')) continue;
        try{
          const resp=await fetch(href);
          if(!resp.ok) continue;
          const blob=await resp.blob();
          await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>{ im.setAttribute('href', fr.result); res(); }; fr.readAsDataURL(blob); });
        }catch(e){ /* ignore fetch failures (e.g. file:// restrictions) */ }
      }
    }
    async function createStagePdfBlob(){
      prepHdrTech(); const techOut=$('#techPrint'); techOut.innerHTML='';
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; buildStageExport(stageOut); // unified rendering identical to print
      // Keep legend with stage plot on same page for PDF
      const legend = stageOut.querySelector('table.tech-table');
      // Don't move legend, leave it in stageOut for single-page layout
      // Remove page breaks to fit everything on one page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      await inlineStageImages(stageOut.querySelector('svg'));
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for stage (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2, useCORS:true, allowTaint:true}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }
    async function createTechPdfBlob(){
      prepHdrTech(); const stageOut=$('#stagePrint'); stageOut.innerHTML=''; const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl);
      const el=document.getElementById('sheetTech');
      // On iOS/Android, html2canvas/jspdf are unreliable: prefer native print dialog
      if(isMobileLike() || typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('Using native print for tech sheet (mobile or missing PDF libs).');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }

    function printPromise(){ return new Promise(res=> setTimeout(res, 150)); }
    
    // Convert SVG to high-quality canvas for reliable printing across platforms
    async function svgToCanvas(svgElement, targetWidth, targetHeight) {
      return new Promise((resolve, reject) => {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // High DPI for crisp print output
          const scale = 2;
          canvas.width = targetWidth * scale;
          canvas.height = targetHeight * scale;
          canvas.style.width = targetWidth + 'px';
          canvas.style.height = targetHeight + 'px';
          ctx.scale(scale, scale);
          
          // Serialize SVG to data URL
          const svgData = new XMLSerializer().serializeToString(svgElement);
          const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          
          const img = new Image();
          img.onload = () => {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, targetWidth, targetHeight);
            ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
            URL.revokeObjectURL(url);
            resolve(canvas);
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error('Failed to load SVG'));
          };
          img.src = url;
        } catch (e) {
          reject(e);
        }
      });
    }
    
    // Platform-specific print preparation
    async function preparePrintContent(modalElement, contentElement) {
      const paperSize = getPreferredPaperSize();
      const isLetter = paperSize === 'letter';
      
      // Paper dimensions in pixels at 96 DPI (standard screen DPI)
      const paperWidth = isLetter ? 816 : 794;  // 8.5in or 210mm
      const paperHeight = isLetter ? 1056 : 1123; // 11in or 297mm
      
      // Convert any SVG elements to canvas for reliable printing
      const svgElements = contentElement.querySelectorAll('svg');
      for (const svg of svgElements) {
        if (isAndroid() || isIOS()) {
          // Mobile: Convert SVG to canvas for consistent rendering
          const rect = svg.getBoundingClientRect();
          const canvas = await svgToCanvas(svg, rect.width, rect.height);
          canvas.className = svg.className;
          svg.parentNode.replaceChild(canvas, svg);
        } else {
          // Desktop: Keep SVG but ensure proper sizing
          svg.style.maxWidth = '100%';
          svg.style.height = 'auto';
        }
      }
      
      return { paperWidth, paperHeight, paperSize };
    }
    
    async function printSetOnce(){ 
      console.log('üñ®Ô∏è SETLIST PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      // Build sheet to match preview exactly (not auto-pagination)
      buildSheet('sheet'); 
      const modal=document.getElementById('modal'); 
      const sheet=document.getElementById('sheet');
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      
      // Hide everything except modal content for all platforms
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      
      modal.classList.add('open'); 
      await printPromise();
      
      // Platform-specific handling
      if(sheet) {
        // Prepare content for printing (convert SVGs if needed)
        await preparePrintContent(modal, sheet);
        
        // Force layout recalculation
        sheet.style.display='none'; 
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering print dialog...');
      window.print(); 
      await printPromise();
      
      modal.classList.remove('open'); 
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      
      await printPromise();
      console.log('‚úÖ Setlist print complete');
    }
    function prepHdrTech(){
      const hdr=$('#hdrTech'); hdr.innerHTML='';
      const hf=(function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band&&!f.venue&&!f.sub&&!f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.append(el('div','band',(gig.band||'BAND')));
      if(hf.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
      if(hf.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' ‚Ä¢ '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
      if(hf.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
    }
    async function printStageOnce(){
      console.log('üñ®Ô∏è STAGE PLOT PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech();
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='none';
      const stageOut=$('#stagePrint');
      
      // Check if stage content was already built in printSelected()
      const hasPrebuiltStage = stageOut && stageOut.querySelector('svg');
      if(!hasPrebuiltStage){
        console.log('Stage not pre-built, building now...');
        stageOut.innerHTML='';
        buildStageExport(stageOut);
        // Force images to load before printing
        await inlineStageImages(stageOut.querySelector('svg'));
      } else {
        console.log('Using pre-built stage content');
      }
      
      stageOut.style.display='block';
      
      // Keep legend with stage plot on same page
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      stageOut.style.breakInside = 'avoid'; stageOut.style.pageBreakInside = 'avoid';
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      // Hide everything except the tech/stage modal content
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(setlistModal) setlistModal.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      
      const modal=document.getElementById('modalTech');
      modal.classList.add('open');
      await printPromise();
      
      // Platform-specific SVG handling
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        // Prepare content for printing (convert SVGs on mobile)
        await preparePrintContent(modal, stageOut);
        
        // Force layout recalculation
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering print dialog for stage plot...');
      window.print();
      await printPromise();
      modal.classList.remove('open');
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(setlistModal) setlistModal.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      
      await printPromise();
      console.log('‚úÖ Stage plot print complete');
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        // Re-render the current view by toggling stage/notes modals
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          // Stage was visible - reopen it
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          // Tech table was visible - rebuild it
          try{ buildTechTableFull(); }catch(_){}
        } else {
          // Neither was open, default to stage plot
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }
    async function printTechOnlyOnce(){ 
      console.log('üñ®Ô∏è TECH NOTES PRINT - OS:', isWindows() ? 'Windows' : isIOS() ? 'iOS' : isAndroid() ? 'Android' : 'Other');
      
      // Close any open stage/notes modals first to prevent them from being captured
      const stageModal=document.getElementById('stageModal');
      const notesModal=document.getElementById('notesModal');
      if(stageModal) stageModal.classList.remove('open');
      if(notesModal) notesModal.classList.remove('open');
      
      prepHdrTech(); 
      const stageOut=$('#stagePrint'); stageOut.innerHTML=''; stageOut.style.display='none'; 
      const techOut=$('#techPrint'); techOut.innerHTML=''; techOut.style.display='block';
      // Ensure no forced page break when printing tech-only
      techOut.style.breakBefore = 'auto'; techOut.style.pageBreakBefore = 'auto';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl); 
      
      // Hide all non-printable UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const printChooser=document.getElementById('printChooser');
      const setlistModal=document.getElementById('modal');
      
      // Hide everything except the tech modal content
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      if(printChooser) printChooser.style.display='none';
      if(setlistModal) setlistModal.style.display='none';
      if(stageModal) stageModal.style.display='none';
      if(notesModal) notesModal.style.display='none';
      
      const modal=document.getElementById('modalTech'); 
      modal.classList.add('open'); 
      await printPromise(); 
      
      // Force layout recalculation
      const sheet=document.getElementById('sheetTech');
      if(sheet){
        sheet.style.display='none';
        sheet.offsetHeight; // trigger reflow
        sheet.style.display='block';
      }
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering print dialog for tech notes...');
      window.print(); 
      await printPromise();
      modal.classList.remove('open'); 
      
      // Restore visibility
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      if(printChooser) printChooser.style.display='';
      if(setlistModal) setlistModal.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      
      await printPromise();
      console.log('‚úÖ Tech notes print complete');
      
      // Restore Tech/Stage tab view if user is on that tab
      const activeTab = document.querySelector('.tab.active');
      if(activeTab && activeTab.dataset.tab === 'adv'){
        const stageModal = document.getElementById('stageModal');
        const notesModal = document.getElementById('notesModal');
        if(stageModal && stageModal.classList.contains('open')){
          try{ openStageModal(); }catch(_){}
        } else if(notesModal && notesModal.classList.contains('open')){
          try{ buildTechTableFull(); }catch(_){}
        } else {
          try{ toggleStageAndNotes(); }catch(_){}
        }
      }
    }
    
    async function printLyricsOnce(){
      console.log('üñ®Ô∏è LYRICS PRINT');
      
      // Get selected song IDs from the lyrics selector
      const selectedSongIds = [];
      const lyricsSongList = document.getElementById('lyricsSongList');
      if(lyricsSongList){
        const checkboxes = lyricsSongList.querySelectorAll('input[type="checkbox"]:checked');
        checkboxes.forEach(cb => {
          if(cb.dataset.songId) selectedSongIds.push(cb.dataset.songId);
        });
      }
      
      if(selectedSongIds.length === 0){
        alert('No songs selected for lyrics printing.');
        return;
      }
      
      // Hide ALL UI elements that could interfere with print
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const modals=document.querySelectorAll('.modal');
      const stagePrint = document.getElementById('stagePrint');
      const techPrint = document.getElementById('techPrint');
      const modalTech = document.getElementById('modalTech');
      const stageModal = document.getElementById('stageModal');
      const notesModal = document.getElementById('notesModal');
      const modal = document.getElementById('modal');
      
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      modals.forEach(m => { m.style.display='none'; m.classList.remove('open'); });
      // Explicitly hide stage-related elements
      if(stagePrint) stagePrint.style.display='none';
      if(techPrint) techPrint.style.display='none';
      if(modalTech) { modalTech.style.display='none'; modalTech.classList.remove('open'); }
      if(stageModal) { stageModal.style.display='none'; stageModal.classList.remove('open'); }
      if(notesModal) { notesModal.style.display='none'; notesModal.classList.remove('open'); }
      if(modal) { modal.style.display='none'; modal.classList.remove('open'); }
      
      // Create a temporary print container
      const printContainer = document.createElement('div');
      printContainer.id = 'lyricsPrintContainer';
      printContainer.style.cssText = 'width:8.5in;padding:0.15in 0.4in;font-family:system-ui,-apple-system,sans-serif;background:white;margin:0 auto';
      
      // Get songs directly from database and print whatever text is in the lyrics field
      for(const id of selectedSongIds){
        const dbSong = db.find(ds => ds.id == id);
        if(!dbSong) continue;
        
        const songPage = document.createElement('div');
        songPage.style.cssText = 'page-break-after:always;page-break-inside:avoid;min-height:10in;max-height:10.5in';
        
        const title = document.createElement('h1');
        title.textContent = dbSong.title || 'Untitled';
        title.style.cssText = 'font-size:16px;font-weight:bold;margin:0 0 2px 0;color:#111';
        
        const artist = document.createElement('h2');
        artist.textContent = dbSong.artist || 'Original';
        artist.style.cssText = 'font-size:12px;font-weight:600;margin:0 0 8px 0;color:#666';
        
        const lyrics = document.createElement('div');
        // Remove excessive blank lines (more than 2 consecutive newlines become 2)
        const cleanedLyrics = (dbSong.lyrics || '(no lyrics)').replace(/\n\n\n+/g, '\n\n');
        lyrics.textContent = cleanedLyrics;
        lyrics.style.cssText = 'white-space:pre-wrap;font-family:system-ui,-apple-system,sans-serif;font-size:11px;line-height:1.35;margin:0;color:#111';
        
        songPage.appendChild(title);
        songPage.appendChild(artist);
        songPage.appendChild(lyrics);
        printContainer.appendChild(songPage);
      }
      
      document.body.appendChild(printContainer);
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering lyrics print dialog...');
      window.print();
      await printPromise();
      
      // Cleanup
      document.body.removeChild(printContainer);
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      modals.forEach(m => m.style.display='');
      // Restore stage-related elements (don't re-show them, just remove display:none)
      if(stagePrint) stagePrint.style.display='';
      if(techPrint) techPrint.style.display='';
      if(modalTech) modalTech.style.display='';
      if(stageModal) stageModal.style.display='';
      if(notesModal) notesModal.style.display='';
      if(modal) modal.style.display='';
      
      console.log('‚úÖ Lyrics print complete');
    }
    
    async function printItineraryOnce(){
      console.log('üñ®Ô∏è ITINERARY PRINT');
      
      // Get current tour date
      const tourDate = tourDates.find(td => td.id === selectedTourDateId);
      if(!tourDate){
        alert('No tour date selected for itinerary printing.');
        return;
      }
      
      if(!tourDate.itinerary || tourDate.itinerary.length === 0){
        alert('No itinerary items for this date.');
        return;
      }
      
      // Create a temporary print container
      const printContainer = document.createElement('div');
      printContainer.id = 'itineraryPrintContainer';
      printContainer.style.cssText = 'position:fixed;top:-10000px;left:-10000px;width:8.5in;padding:0.5in;font-family:system-ui,-apple-system,sans-serif;background:white';
      
      // Header
      const header = document.createElement('div');
      header.style.cssText = 'margin-bottom:24px;border-bottom:2px solid #111;padding-bottom:12px';
      
      const title = document.createElement('h1');
      title.textContent = 'Daily Itinerary';
      title.style.cssText = 'font-size:24px;font-weight:bold;margin:0 0 8px 0;color:#111';
      
      const dateInfo = document.createElement('div');
      const dateObj = new Date(tourDate.date + 'T00:00:00');
      dateInfo.textContent = `${dateObj.toLocaleDateString('en-US', {weekday:'long', year:'numeric', month:'long', day:'numeric'})} ‚Ä¢ ${tourDate.venue || 'No venue'}`;
      dateInfo.style.cssText = 'font-size:14px;color:#666;margin-bottom:4px';
      
      const addressInfo = document.createElement('div');
      addressInfo.textContent = tourDate.address || '';
      addressInfo.style.cssText = 'font-size:12px;color:#888';
      
      header.appendChild(title);
      header.appendChild(dateInfo);
      if(tourDate.address) header.appendChild(addressInfo);
      printContainer.appendChild(header);
      
      // Itinerary items
      const items = [...tourDate.itinerary].sort((a, b) => {
        const [aH, aM] = a.time.split(':').map(Number);
        const [bH, bM] = b.time.split(':').map(Number);
        return (aH * 60 + aM) - (bH * 60 + bM);
      });
      
      items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.style.cssText = 'margin-bottom:16px;padding:12px;border-left:4px solid #3b82f6;background:#f9fafb';
        
        const timeDiv = document.createElement('div');
        timeDiv.textContent = item.time;
        timeDiv.style.cssText = 'font-size:14px;font-weight:bold;color:#111;margin-bottom:4px';
        
        const titleDiv = document.createElement('div');
        titleDiv.textContent = item.title;
        titleDiv.style.cssText = 'font-size:16px;font-weight:600;color:#111;margin-bottom:4px';
        
        const durationDiv = document.createElement('div');
        durationDiv.textContent = `Duration: ${item.duration || 30} minutes`;
        durationDiv.style.cssText = 'font-size:12px;color:#666;margin-bottom:4px';
        
        itemDiv.appendChild(timeDiv);
        itemDiv.appendChild(titleDiv);
        itemDiv.appendChild(durationDiv);
        
        if(item.notes){
          const notesDiv = document.createElement('div');
          notesDiv.textContent = item.notes;
          notesDiv.style.cssText = 'font-size:12px;color:#666;margin-top:8px;font-style:italic';
          itemDiv.appendChild(notesDiv);
        }
        
        printContainer.appendChild(itemDiv);
      });
      
      document.body.appendChild(printContainer);
      
      // Hide all UI elements
      const wrap=document.querySelector('.wrap');
      const brandBar=document.querySelector('.brand-bar');
      const modals=document.querySelectorAll('.modal');
      
      if(wrap) wrap.style.display='none';
      if(brandBar) brandBar.style.display='none';
      modals.forEach(m => m.style.display='none');
      
      printContainer.style.position='static';
      printContainer.style.top='';
      printContainer.style.left='';
      
      await printPromise();
      console.log('üñ®Ô∏è Triggering itinerary print dialog...');
      window.print();
      await printPromise();
      
      // Cleanup
      document.body.removeChild(printContainer);
      if(wrap) wrap.style.display='';
      if(brandBar) brandBar.style.display='';
      modals.forEach(m => m.style.display='');
      
      console.log('‚úÖ Itinerary print complete');
    }

    // Share Database
    const shareBtn = document.getElementById('shareBtn');
    if(shareBtn){ 
      shareBtn.addEventListener('click', async ()=>{
        var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
        const stage = stageEl ? stageEl.outerHTML : '';
        const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
        const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
        const jsonStr = JSON.stringify(data,null,2);
        const blob=new Blob([jsonStr],{type:'application/json'});
        const filename = ((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band');
        
        // Try Web Share API first (mobile-friendly)
        if(navigator.share && navigator.canShare){
          try{
            const file = new File([blob], filename, {type:'application/json'});
            const shareData = {
              title: 'FASTFAST Setlist Database',
              text: `Sharing ${gig.band || 'band'} profile with ${db.length} songs`,
              files: [file]
            };
            if(navigator.canShare(shareData)){
              await navigator.share(shareData);
              console.log('‚úÖ Shared via Web Share API');
              return;
            }
          }catch(e){
            console.log('Web Share API failed, falling back to download/email', e);
          }
        }
        
        // Fallback: Download file + offer email option
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); 
        a.href=url; 
        a.download=filename; 
        a.click(); 
        URL.revokeObjectURL(url);
        
        // Offer email option
        setTimeout(()=>{
          if(confirm('File downloaded. Would you like to open your email client to share it?')){
            const subject = encodeURIComponent(`FASTFAST Setlist: ${gig.band || 'Band'} Profile`);
            const body = encodeURIComponent(`Hi,\n\nI'm sharing my FASTFAST Setlist database with you.\n\nDatabase contains ${db.length} songs.\n\nPlease download the attached .BAND file and load it in FASTFAST Setlist using the "Load Profile (.BAND)" button.\n\nCheers!`);
            window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');
          }
        }, 500);
      });
    }
    
    // Save/Load Profile (.BAND)
    const saveProfileBtn=document.getElementById('saveProfile');
    if(saveProfileBtn){ saveProfileBtn.addEventListener('click',()=>{
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      const stage = stageEl ? stageEl.outerHTML : '';
      const dbOut = db.map(s=>{ const {audioData, ...rest}=s||{}; return rest; });
      const data={version:3,type:'fastfast-band', db:dbOut, setlist, gig, gearSummary, techNotes, stage};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
    }); }
    const loadProfileBtn=document.getElementById('loadProfile'); const loadProfileFile=document.getElementById('loadProfileFile');
    if(loadProfileBtn && loadProfileFile){
      loadProfileBtn.addEventListener('click',()=> loadProfileFile.click());
      loadProfileFile.addEventListener('change',()=>{
        const f=loadProfileFile.files && loadProfileFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && Array.isArray(obj.db)){
              // merge db by title+artist (case-insensitive)
              const keyOf=s=> ((s.title||'').toLowerCase().trim()+'|'+((s.artist||'Original').toLowerCase().trim()));
              const existing=new Set(db.map(keyOf));
              obj.db.forEach(s=>{
                const { audioData, ...rest } = s||{}; // drop any embedded audio from import
                const item={...rest};
                if(!item.id) item.id=Date.now()+Math.random();
                if(!item.artist) item.artist='Original';
                if(!item.length) item.length=3.5;
                if(!existing.has(keyOf(item))){ db.push(item); existing.add(keyOf(item)); }
              });
              renderDB();
            }
            if(obj && obj.gig){
              // merge gig fields only if missing
              const fields=['band','date','venue','address','contact','notes','font','logo'];
              fields.forEach(k=>{ if(!gig[k] && obj.gig[k]) gig[k]=obj.gig[k]; });
              if(obj.gig.headerFlags){ gig.headerFlags=Object.assign({band:true,venue:true,sub:true,notes:true}, gig.headerFlags, obj.gig.headerFlags); }
              // hydrate UI
              if(gig.band) document.getElementById('gBand').value=gig.band;
              if(gig.date) document.getElementById('gDate').value=gig.date;
              if(gig.venue) document.getElementById('gVenue').value=gig.venue;
              if(gig.address) document.getElementById('gAddr').value=gig.address;
              if(gig.contact) document.getElementById('gContact').value=gig.contact;
              if(gig.notes) document.getElementById('gNotes').value=gig.notes;
              const gFontElTmp=document.getElementById('gFont'); if(gFontElTmp && gig.font) gFontElTmp.value=gig.font;
              // header flags checkboxes
              ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
              refreshLogoPreview();
            }
            // hydrate gear and stage if present
            if(obj && 'gearSummary' in obj){ gearSummary = obj.gearSummary || ''; const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary; }
            if(obj && obj.stage){
              const container=document.getElementById('stageStore');
              if(container){
                container.innerHTML=obj.stage;
                const svg=container.querySelector('svg');
                if(svg){
                  svg.id='stageSvg';
                  svg.classList.add('bw');
                  try{ refreshCables(svg); }catch(_){ }
                }
              }
              // Overwrite existing full editor (if open) with loaded stage BEFORE any autosave can race
              const full=document.getElementById('stageSvgFull');
              const stageModal=document.getElementById('stageModal');
              const store=document.getElementById('stageSvg');
              if(full && store){
                try{
                  while(full.childNodes.length>2) full.removeChild(full.lastChild);
                  Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
                  ensureStageMarkers(full);
                  refreshCables(full);
                  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
                  bindSelection(full);
                  if(typeof refreshStageLegend==='function') refreshStageLegend();
                  if(typeof selectNode==='function') selectNode(null);
                  // Reset undo history baseline
                  if(Array.isArray(stageHistory)){
                    stageHistory.length=0; stageHistory.push(full.outerHTML); stageHistoryIndex=stageHistory.length-1;
                  }
                }catch(_){ /* non-fatal */ }
              }
              // If Tech/Stage tab is active and modal not open, auto-open it now to show restored layout
              const advPanel=document.getElementById('adv');
              const tabActive = advPanel && advPanel.style.display!=='none';
              if(tabActive && stageModal && !stageModal.classList.contains('open')){
                try{ if(typeof openStageModal==='function') openStageModal(); }catch(_){ }
              }
            }
            // Restore setlist & tech notes if present (current set)
            if(obj && Array.isArray(obj.setlist)){
              setlist = obj.setlist;
              try{ buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); }catch(_){ }
            }
            if(obj && obj.techNotes && typeof obj.techNotes==='object'){
              techNotes = obj.techNotes;
            }
            saveAll();
          }catch(err){ alert('Failed to read .BAND file'); }
        };
        r.readAsText(f);
      });
    }

    // Zoom control for stage (applies to small canvas)
    // No inline zoom control anymore

    // Save .SET (export setlist only)
    const saveSetBtn=document.getElementById('saveSet'); if(saveSetBtn){ saveSetBtn.addEventListener('click',()=>{
      const data={version:1,type:'fastfast-set',setlist};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(gig.band? gig.band.replace(/\s+/g,'_')+'_' : '')+'setlist.set'; a.click(); URL.revokeObjectURL(a.href);
    }); }
    // Load .SET (import setlist only, keep current gig)
    const loadSetBtn=document.getElementById('loadSet'); const loadSetFile=document.getElementById('loadSetFile');
    if(loadSetBtn && loadSetFile){
      loadSetBtn.addEventListener('click',()=> loadSetFile.click());
      loadSetFile.addEventListener('change',()=>{
        const f=loadSetFile.files && loadSetFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && obj.setlist && Array.isArray(obj.setlist)){
              setlist=obj.setlist; buildSheet('sheetInline'); attachPreviewInteractions(); renderSongPool(); saveAll();
            }else{ alert('Invalid .SET file'); }
          }catch(err){ alert('Failed to read .SET file'); }
        };
        r.readAsText(f);
      });
    }
    // --- Import (OCR / Paste) ---
    (function setupImport(){
      const txt=document.getElementById('importText');
      const file=document.getElementById('importFile');
      const parseBtn=document.getElementById('importParseBtn');
      const commitBtn=document.getElementById('importCommitBtn');
      const statusEl=document.getElementById('importStatus');
      const previewEl=document.getElementById('importPreview');
      if(!txt || !file || !parseBtn || !commitBtn) return;
      let parsed=[];
      function sanitizeLine(line){ return line.replace(/\s+/g,' ').trim(); }
      function detectCapo(str){ const m=str.match(/capo\s*(\d{1,2})/i); if(m){ const v=parseInt(m[1],10); if(Number.isInteger(v) && v>=0 && v<=24) return v; } return 0; }
      function detectKey(str){ // first standalone musical key token
        const m=str.match(/\b([A-G](?:#|b)?m?)\b/); return m? m[1] : ''; }
      function parseSongLines(text){
        const out=[]; const lines=text.split(/\r?\n/);
        for(let raw of lines){ let line=sanitizeLine(raw); if(!line) continue; const capo=detectCapo(line); if(capo) line=line.replace(/capo\s*\d{1,2}/i,'').trim(); const key=detectKey(line); let title=line; // remove key if separated by dash/pipe/colon or at end
          if(key){ const sepPattern=new RegExp('[-|:]?\s*'+key+'\s*$','i'); title=title.replace(sepPattern,'').trim(); if(title.toLowerCase().startsWith(key.toLowerCase()+' ')) title=title.slice(key.length).trim(); }
          // Remove trailing parentheses or brackets containing key or capo info
          title=title.replace(/\((?:capo|key)[^)]*\)$/i,'').trim();
          if(title) out.push({title, key, capo, length:3.5, artist:'Original'}); }
        return out; }
      function dedupe(list){ const seen=new Set(); return list.filter(s=>{ const k=(s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); if(seen.has(k)) return false; seen.add(k); return true; }); }
      function renderPreview(){ if(!parsed.length){ previewEl.innerHTML='<em>No parsed songs.</em>'; commitBtn.disabled=true; return; }
        // Build editable table
        const tbl=document.createElement('table'); tbl.style.width='100%'; tbl.style.borderCollapse='collapse';
        const thead=document.createElement('thead'); thead.innerHTML='<tr style="background:#e2e8f0"><th style="text-align:left;padding:4px 6px">Title</th><th style="text-align:left;padding:4px 6px">Key</th><th style="text-align:left;padding:4px 6px">Capo</th><th style="text-align:left;padding:4px 6px">Len (m)</th><th style="text-align:left;padding:4px 6px">Remove</th></tr>';
        const tbody=document.createElement('tbody');
        parsed.forEach((s,i)=>{
          const tr=document.createElement('tr');
          const tdTitle=document.createElement('td'); const inpTitle=document.createElement('input'); inpTitle.type='text'; inpTitle.value=s.title; inpTitle.style.width='100%'; inpTitle.addEventListener('input',()=>{ s.title=inpTitle.value.trim(); }); tdTitle.style.padding='4px 6px'; tdTitle.appendChild(inpTitle);
          const tdKey=document.createElement('td'); const inpKey=document.createElement('input'); inpKey.type='text'; inpKey.value=s.key||''; inpKey.placeholder='Key'; inpKey.style.width='70px'; inpKey.addEventListener('input',()=>{ s.key=inpKey.value.trim(); }); tdKey.style.padding='4px 6px'; tdKey.appendChild(inpKey);
          const tdCapo=document.createElement('td'); const inpCapo=document.createElement('input'); inpCapo.type='number'; inpCapo.min='0'; inpCapo.max='24'; inpCapo.value=String(Number.isInteger(s.capo)? s.capo:0); inpCapo.style.width='56px'; inpCapo.addEventListener('change',()=>{ let v=parseInt(inpCapo.value,10); if(!Number.isInteger(v)||v<0) v=0; if(v>24) v=24; s.capo=v; inpCapo.value=String(v); }); tdCapo.style.padding='4px 6px'; tdCapo.appendChild(inpCapo);
          const tdLen=document.createElement('td'); const inpLen=document.createElement('input'); inpLen.type='number'; inpLen.min='0.5'; inpLen.step='0.5'; inpLen.value=String(s.length||3.5); inpLen.style.width='70px'; inpLen.addEventListener('change',()=>{ let v=parseFloat(inpLen.value); if(!isFinite(v)||v<=0) v=3.5; s.length=v; inpLen.value=String(v); }); tdLen.style.padding='4px 6px'; tdLen.appendChild(inpLen);
          const tdRemove=document.createElement('td'); tdRemove.style.padding='4px 6px'; const btnRem=document.createElement('button'); btnRem.type='button'; btnRem.textContent='√ó'; btnRem.className='btn danger'; btnRem.style.padding='2px 8px'; btnRem.style.fontSize='14px'; btnRem.addEventListener('click',()=>{ parsed.splice(i,1); renderPreview(); }); tdRemove.appendChild(btnRem);
          tr.append(tdTitle,tdKey,tdCapo,tdLen,tdRemove); tbody.appendChild(tr);
        });
        tbl.append(thead,tbody); previewEl.innerHTML=''; previewEl.appendChild(tbl); commitBtn.disabled=false;
      }
      function addParsedToDb(){ const existingKeyOf=s=> (s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); const existing=new Set(db.map(existingKeyOf)); let added=0; parsed.forEach(s=>{ if(!existing.has(existingKeyOf(s))){ s.id=Date.now()+Math.random(); db.push(s); existing.add(existingKeyOf(s)); added++; } }); renderDB(); renderSongPool(); saveAll(); statusEl.textContent=`Imported ${added} new song${added===1?'':'s'}.`; }
      parseBtn.addEventListener('click',()=>{ parsed=dedupe(parseSongLines(txt.value||'')); statusEl.textContent=`Parsed ${parsed.length} song line${parsed.length===1?'':'s'}.`; renderPreview(); });
      commitBtn.addEventListener('click', addParsedToDb);
      async function ensurePdfJs(){ if(window.pdfjsLib) return; statusEl.textContent='Loading PDF.js‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); if(window.pdfjsLib){ window.pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; } }
      async function ensureTesseract(){ if(window.Tesseract) return; statusEl.textContent='Loading Tesseract‚Ä¶'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); }
      
      // Folder checkbox handler
      const folderCb=document.getElementById('importFolder');
      if(folderCb){
        folderCb.addEventListener('change',()=>{
          file.webkitdirectory = folderCb.checked;
          file.multiple = true;
          file.value = '';
        });
      }
      
      // Load jsmediatags library for ID3 reading
      async function ensureMediaTags(){
        if(window.jsmediatags) return;
        statusEl.textContent='Loading metadata parser‚Ä¶';
        await new Promise((res,rej)=>{
          const sc=document.createElement('script');
          sc.src='https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js';
          sc.onload=res;
          sc.onerror=rej;
          document.head.appendChild(sc);
        });
      }
      
      // Extract metadata from audio/video files
      async function extractAudioMetadata(f){
        return new Promise(async (resolve)=>{
          // Try to read ID3 tags first (MP3, M4A, etc.)
          try{
            await ensureMediaTags();
            window.jsmediatags.read(f, {
              onSuccess: (tag)=>{
                const tags = tag.tags || {};
                let title = tags.title || '';
                let artist = tags.artist || '';
                let album = tags.album || '';
                let lyrics = tags.lyrics || tags.USLT || tags.unsynchronizedLyrics || '';
                
                // Clean up any non-English characters if they're garbled
                const cleanText = (str) => {
                  if(!str) return '';
                  // Remove or replace common garbled characters
                  return str.replace(/[\x00-\x1F\x7F-\x9F]/g, '').trim();
                };
                
                title = cleanText(title);
                artist = cleanText(artist);
                lyrics = cleanText(lyrics);
                
                // Fallback to filename if tags are empty or garbled
                if(!title || title.length < 2 || /[^\x20-\x7E\u00A0-\uFFFF]/.test(title)){
                  const fileName = f.name.replace(/\.[^.]+$/, '');
                  const patterns = [
                    /^\d+[._\s-]*(.+?)\s*[_-]\s*(.+)$/,
                    /^(.+?)\s*[_-]\s*(.+)$/
                  ];
                  for(const pattern of patterns){
                    const match = fileName.match(pattern);
                    if(match){
                      if(!artist || artist.length < 2) artist = match[1].trim();
                      title = match[2].trim();
                      break;
                    }
                  }
                  if(!title) title = fileName;
                }
                
                if(!artist || artist.length < 2) artist = 'Original';
                
                // Get duration using HTML5 Audio API
                const audio = new Audio();
                const url = URL.createObjectURL(f);
                audio.src = url;
                audio.addEventListener('loadedmetadata', ()=>{
                  const duration = audio.duration || 0;
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    album: album || '',
                    length: Math.round(duration / 60 * 10) / 10 || 3.5,
                    lyrics: lyrics || '',
                    key: '',
                    capo: 0,
                    bpm: 0
                  });
                });
                audio.addEventListener('error', ()=>{
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    album: album || '',
                    length: 3.5,
                    lyrics: lyrics || '',
                    key: '',
                    capo: 0,
                    bpm: 0
                  });
                });
              },
              onError: (error)=>{
                // Fallback to filename parsing if ID3 reading fails
                const fileName = f.name.replace(/\.[^.]+$/, '');
                let title = fileName;
                let artist = 'Original';
                const patterns = [
                  /^\d+[._\s-]*(.+?)\s*[_-]\s*(.+)$/,
                  /^(.+?)\s*[_-]\s*(.+)$/
                ];
                for(const pattern of patterns){
                  const match = fileName.match(pattern);
                  if(match){
                    artist = match[1].trim();
                    title = match[2].trim();
                    break;
                  }
                }
                
                // Get duration
                const audio = new Audio();
                const url = URL.createObjectURL(f);
                audio.src = url;
                audio.addEventListener('loadedmetadata', ()=>{
                  const duration = audio.duration || 0;
                  URL.revokeObjectURL(url);
                  resolve({
                    title,
                    artist,
                    length: Math.round(duration / 60 * 10) / 10 || 3.5,
                    lyrics: '',
                    key: '',
                    capo: 0,
                    bpm: 0
                  });
                });
                audio.addEventListener('error', ()=>{
                  URL.revokeObjectURL(url);
                  resolve(null);
                });
              }
            });
          }catch(err){
            console.error('Metadata extraction failed:', err);
            resolve(null);
          }
        });
      }
      
      // Parse CSV content
      function parseCSV(text){
        const lines = text.split(/\r?\n/).filter(l => l.trim());
        if(lines.length < 2) return [];
        const headers = lines[0].toLowerCase().split(/[,\t;]/).map(h => h.trim());
        const titleIdx = headers.findIndex(h => /title|song|name/.test(h));
        const artistIdx = headers.findIndex(h => /artist|band|by/.test(h));
        const keyIdx = headers.findIndex(h => /key/.test(h));
        const capoIdx = headers.findIndex(h => /capo/.test(h));
        const bpmIdx = headers.findIndex(h => /bpm|tempo/.test(h));
        const lengthIdx = headers.findIndex(h => /length|duration|time/.test(h));
        if(titleIdx === -1) return [];
        const songs = [];
        for(let i = 1; i < lines.length; i++){
          const cols = lines[i].split(/[,\t;]/).map(c => c.trim().replace(/^"|"$/g, ''));
          if(!cols[titleIdx]) continue;
          const song = {
            title: cols[titleIdx],
            artist: artistIdx >= 0 && cols[artistIdx] ? cols[artistIdx] : 'Original',
            key: keyIdx >= 0 && cols[keyIdx] ? cols[keyIdx] : '',
            capo: capoIdx >= 0 && cols[capoIdx] ? parseInt(cols[capoIdx]) || 0 : 0,
            bpm: bpmIdx >= 0 && cols[bpmIdx] ? parseInt(cols[bpmIdx]) || 0 : 0,
            length: lengthIdx >= 0 && cols[lengthIdx] ? parseFloat(cols[lengthIdx]) || 3.5 : 3.5
          };
          songs.push(song);
        }
        return songs;
      }
      
      // Parse spreadsheet (basic XLS/XLSX support)
      async function parseSpreadsheet(f){
        return new Promise((resolve)=>{
          const reader = new FileReader();
          reader.onload = (e)=>{
            try{
              const text = String(e.target.result || '');
              const songs = parseCSV(text);
              resolve(songs);
            }catch(err){
              resolve([]);
            }
          };
          reader.onerror = ()=> resolve([]);
          reader.readAsText(f);
        });
      }
      
      file.addEventListener('change', async()=>{
        previewEl.innerHTML=''; parsed=[]; commitBtn.disabled=true; statusEl.textContent='';
        const files = Array.from(file.files || []);
        if(!files.length) return;
        statusEl.textContent = `Processing ${files.length} file${files.length===1?'':'s'}...`;
        
        // First, group files by base name to match audio with lyrics
        const fileGroups = new Map(); // baseName -> {audio: file, lyrics: [files]}
        const standaloneFiles = []; // Files without a match
        
        for(const f of files){
          const baseName = f.name.replace(/\.(mp3|wav|flac|m4a|aac|ogg|wma|mp4|avi|mov|mkv|txt|pdf|jpg|jpeg|png|gif|bmp)$/i, '').toLowerCase();
          const ext = (f.name.match(/\.[^.]+$/)?.[0] || '').toLowerCase();
          const isAudio = /\.(mp3|wav|flac|m4a|aac|ogg|wma|mp4|avi|mov|mkv)$/i.test(f.name);
          const isLyrics = /\.(txt|pdf|jpg|jpeg|png|gif|bmp)$/i.test(f.name);
          
          if(!fileGroups.has(baseName)){
            fileGroups.set(baseName, {audio: null, lyrics: []});
          }
          const group = fileGroups.get(baseName);
          
          if(isAudio){
            group.audio = f;
          } else if(isLyrics){
            group.lyrics.push(f);
          } else {
            standaloneFiles.push(f);
          }
        }
        
        let allSongs = [];
        let processed = 0;
        
        // Process grouped files (audio + lyrics)
        for(const [baseName, group] of fileGroups){
          try{
            let songData = null;
            let lyricsText = '';
            
            // Extract audio metadata if present
            if(group.audio){
              songData = await extractAudioMetadata(group.audio);
              statusEl.textContent = `Processing ${processed+1}/${files.length}: ${group.audio.name}...`;
            }
            
            // Extract lyrics from companion files
            for(const lyricsFile of group.lyrics){
              statusEl.textContent = `Processing lyrics: ${lyricsFile.name}...`;
              const type = lyricsFile.type || '';
              const name = lyricsFile.name.toLowerCase();
              
              if(type.startsWith('text/') || name.endsWith('.txt')){
                const text = await new Promise((res)=>{
                  const r = new FileReader();
                  r.onload = e => res(String(e.target.result || ''));
                  r.onerror = () => res('');
                  r.readAsText(lyricsFile);
                });
                lyricsText += (lyricsText ? '\n\n' : '') + text;
              }
              else if(name.endsWith('.pdf')){
                await ensurePdfJs();
                const url = URL.createObjectURL(lyricsFile);
                const doc = await window.pdfjsLib.getDocument(url).promise;
                let pdfText = '';
                for(let p = 1; p <= doc.numPages; p++){
                  const page = await doc.getPage(p);
                  const txtC = await page.getTextContent();
                  pdfText += txtC.items.map(i => i.str).join(' ') + '\n';
                }
                URL.revokeObjectURL(url);
                lyricsText += (lyricsText ? '\n\n' : '') + pdfText;
              }
              else if(type.startsWith('image/')){
                await ensureTesseract();
                const { Tesseract } = window;
                const imgBitmap = await createImageBitmap(lyricsFile);
                const canvas = document.createElement('canvas');
                const scale = 2;
                canvas.width = imgBitmap.width * scale;
                canvas.height = imgBitmap.height * scale;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
                
                const result = await Tesseract.recognize(canvas, 'eng', {
                  logger: m => {
                    if(m.status === 'recognizing text'){
                      statusEl.textContent = `OCR lyrics: ${lyricsFile.name} ${Math.round(m.progress*100)}%`;
                    }
                  },
                  tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                  tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?\'-[]()#/\\|'
                });
                lyricsText += (lyricsText ? '\n\n' : '') + (result?.data?.text || '');
              }
              processed++;
            }
            
            // Merge lyrics into song data
            if(songData){
              songData.lyrics = lyricsText || songData.lyrics || '';
              allSongs.push(songData);
              if(group.audio) processed++;
            } else if(lyricsText){
              // Lyrics only, no audio - parse as song lines
              allSongs.push(...parseSongLines(lyricsText));
            }
          }catch(err){
            console.error(`Failed to process group ${baseName}:`, err);
          }
        }
        
        // Process standalone files (CSV, spreadsheet, standalone text)
        for(const f of standaloneFiles){
          const type = f.type || '';
          const name = (f.name || '').toLowerCase();
          try{
            if(type.startsWith('text/') || name.endsWith('.txt')){
              const text = await new Promise((res)=>{
                const r = new FileReader();
                r.onload = e => res(String(e.target.result || ''));
                r.onerror = () => res('');
                r.readAsText(f);
              });
              allSongs.push(...parseSongLines(text));
            }
            else if(name.endsWith('.csv') || type === 'text/csv'){
              const text = await new Promise((res)=>{
                const r = new FileReader();
                r.onload = e => res(String(e.target.result || ''));
                r.onerror = () => res('');
                r.readAsText(f);
              });
              allSongs.push(...parseCSV(text));
            }
            else if(name.match(/\.(xlsx?|ods)$/)){
              const songs = await parseSpreadsheet(f);
              allSongs.push(...songs);
            }
            else if(name.endsWith('.pdf') || type === 'application/pdf'){
              await ensurePdfJs();
              const url = URL.createObjectURL(f);
              const doc = await window.pdfjsLib.getDocument(url).promise;
              let full = '';
              for(let p = 1; p <= doc.numPages; p++){
                const page = await doc.getPage(p);
                const txtC = await page.getTextContent();
                full += txtC.items.map(i => i.str).join(' ') + '\n';
              }
              URL.revokeObjectURL(url);
              allSongs.push(...parseSongLines(full));
            }
            else if(type.startsWith('image/')){
              await ensureTesseract();
              const { Tesseract } = window;
              // Increase resolution for better handwriting recognition
              const imgBitmap = await createImageBitmap(f);
              const canvas = document.createElement('canvas');
              const scale = 2; // 2x resolution
              canvas.width = imgBitmap.width * scale;
              canvas.height = imgBitmap.height * scale;
              const ctx = canvas.getContext('2d');
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = 'high';
              ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
              
              const result = await Tesseract.recognize(canvas, 'eng', {
                logger: m => {
                  if(m.status === 'recognizing text'){
                    statusEl.textContent = `OCR ${processed+1}/${files.length}: ${Math.round(m.progress*100)}%`;
                  }
                },
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 .,;:!?\'-[]()#/\\|'
              });
              const text = result && result.data && result.data.text || '';
              allSongs.push(...parseSongLines(text));
            }
          }catch(err){
            console.error(`Failed to process ${f.name}:`, err);
          }
          processed++;
          statusEl.textContent = `Processed ${processed}/${files.length} files...`;
        }
        parsed = dedupe(allSongs);
        statusEl.textContent = `Parsed ${parsed.length} song${parsed.length===1?'':'s'} from ${files.length} file${files.length===1?'':'s'}.`;
        renderPreview();
      });
    })();
  </script>
  <!-- Lightweight libs for client PDF/ZIP export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- Bottom brand bar -->
  <div class="brand-bar">
    FASTFAST SETLIST and STAGE DESIGNER (c) 2025 All Rights Reserved
  </div>
</body>
</html>
