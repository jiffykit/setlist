<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    :root{
      --bg:#f5f7fb; --card:#ffffff; --muted:#4b5563; --accent:#2563eb; --accent2:#0ea5e9; --danger:#dc2626;
      --paperText:#111; --paperRule:#444;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-size:16px;font-family:Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif;background:#f3f4f6;color:#1f2937}
  .wrap{max-width:min(1600px,98vw);margin:0 auto;padding:24px}
    .hero{background:linear-gradient(135deg,#e0ecff 0%,#f0f7ff 60%,#e6fbff 100%);border:1px solid #dbeafe;border-radius:16px;padding:28px;text-align:center;color:#111;box-shadow:0 8px 24px rgba(0,0,0,.08)}
    .hero h1{margin:0 0 6px;font-size:32px}
  .tabs{display:flex;margin:16px 0;border-bottom:1px solid #e5e7eb}
  .tab{flex:1;padding:12px 16px;background:transparent;border:none;color:#374151;font-weight:700;cursor:pointer}
    .tab.active{color:#111;border-bottom:3px solid var(--accent)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .card{background:var(--card);border:1px solid #e5e7eb;border-radius:12px;padding:16px}
    .card h2{margin:0 0 12px;font-size:20px;color:#111}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    .row>.field{flex:1;min-width:220px}
    .field{margin:8px 0}
    label{display:block;margin-bottom:6px;font-size:13px;color:#374151;font-weight:600}
    input,select,textarea{width:100%;padding:12px 12px;border-radius:10px;border:1px solid #d1d5db;background:#ffffff;color:#111;font-size:15px}
    input[type="checkbox"]{width:auto}
    .checks{display:flex;flex-wrap:wrap;gap:12px}
    .btn{padding:11px 16px;border-radius:10px;border:1px solid #c7d2fe;color:white;background:linear-gradient(135deg,#2563eb,#0ea5e9);cursor:pointer;font-weight:800}
    .btn.secondary{background:linear-gradient(135deg,#f59e0b,#ef4444);border-color:#fcd34d}
    .btn.danger{background:linear-gradient(135deg,#ef4444,#b91c1c);border-color:#fecaca}
    .list{display:grid;gap:10px;margin-top:12px}
  .song{display:flex;gap:12px;align-items:center;justify-content:space-between;background:#ffffff;border:1px solid #e5e7eb;border-radius:10px;padding:12px}
    .song.dragging{opacity:.6}
    .song .meta{font-size:13px;color:#4b5563}
    .chip{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;background:#eef2ff;color:#374151;border:1px solid #c7d2fe;margin-right:6px}
  .handle{cursor:grab;color:#6b7280;font-size:18px;user-select:none;margin-right:6px}
  .handle:active{cursor:grabbing}

    /* Print preview (paper look) */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:24px;z-index:80}
    .modal.open{display:flex}
    .sheet{width:8.5in;max-width:100%;height:11in;background:white;color:var(--paperText);border-radius:8px;box-shadow:0 20px 60px rgba(0,0,0,.25);padding:0.65in;overflow:auto}
    .sheet.a4{width:210mm;height:297mm}
  .hdr{text-align:center;padding-bottom:8px;margin-bottom:8px}
    .hdr .band{font-size:26pt;font-weight:900;letter-spacing:.6px}
    .hdr .venue{font-size:22pt;font-weight:800;letter-spacing:.5px;margin-top:2px}
  .hdr .sub{font-size:10pt;color:#444;margin-top:4px}
  .hdr .notes{font-size:10pt;color:#333;margin-top:2px;font-style:italic}
  .hdr .logo{display:block}
  .hdr .logo img{max-height:56pt;max-width:100%;height:auto}
    .songs{display:flex;flex-direction:column;gap:2px}
  .line{display:grid;grid-template-columns:22px 1fr minmax(90px,120px) 40px;align-items:baseline;column-gap:8px;padding:1px 0}
  .line .no{font-weight:800;text-align:right;opacity:.85}
  .line .title{font-weight:900;letter-spacing:.1px}
  .line .title .notePrint{font-size:9pt;font-style:italic;font-weight:400;opacity:.75;margin-left:6px}
  .line .key{font-size:10pt;color:#374151;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .line .time{font-size:10pt;text-align:right;opacity:.9}
    .no{font-weight:800;font-size:12pt;min-width:26px;text-align:right;color:#333}
  .title{flex:1;font-size:17pt;font-weight:900;letter-spacing:0.2px}
    .time{min-width:42px;text-align:right;font-size:10pt;color:#444}
  .subnotes{font-size:9pt;color:#4b5563;font-style:italic;margin-top:-2px;margin-left:34px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .break{font-weight:900;text-transform:uppercase;font-size:14pt;color:#7b1fa2;text-align:center;border:2px dashed #7b1fa2;padding:6px 8px;border-radius:8px;background:#f7efff}

  .tools{display:flex;gap:10px;justify-content:center;align-items:center;margin-top:12px}
    .tools .paper{color:#374151}

  /* Floating Song Pool */
  .pool-flyout{position:fixed;top:76px;right:18px;width:320px;max-width:92vw;height:calc(100% - 100px);background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 12px 36px rgba(0,0,0,.18);display:none;flex-direction:column;z-index:65}
  .pool-flyout.open{display:flex}
  .pool-head{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #e5e7eb}
  .pool-body{padding:10px;overflow:auto;display:flex;flex-direction:column;gap:12px}
  .pool-sec h4{margin:0 0 6px 0;font-size:13px;color:#6b7280;text-transform:uppercase;letter-spacing:.6px}
  /* Base pill chip styling (used in Song Pool) */
  .pill{display:inline-flex;align-items:center;gap:6px;border:2px solid #d1d5db;border-radius:999px;padding:4px 10px;background:#fff;font-size:12px;color:#111827}
  .pool-sec .pill{cursor:grab}
  .pill.drag-touch{opacity:.55;outline:2px dashed #2563eb}
  .touch-target-highlight{box-shadow:inset 0 3px 0 #2563eb,inset 0 -3px 0 #2563eb}
  /* Mood pastel chips */
  .pill.mood-upbeat{background:#FECACA;border-color:#FCA5A5}
  .pill.mood-happy{background:#FEF9C3;border-color:#FDE68A}
  .pill.mood-energetic{background:#CFFAFE;border-color:#A5F3FC}
  .pill.mood-mellow{background:#FFEDD5;border-color:#FED7AA}
  .pill.mood-sad{background:#DBEAFE;border-color:#BFDBFE}
  /* Drop indicator on set rows */
  #setList .song.drop-before{box-shadow:inset 0 3px 0 0 #60a5fa}
  #setList .song.drop-after{box-shadow:inset 0 -3px 0 0 #60a5fa}

    @media print{
      body,*{background:transparent!important}
      .wrap{display:none}
      .modal{position:static;display:none;background:none;padding:0}
      .modal.open{display:block}
      .sheet{box-shadow:none;height:auto}
      .tools{display:none}
      /* Never print the Print Options dialog */
      #printChooser{display:none!important}
      .break.pagebreak{page-break-after:always}
      #songPoolFlyout{display:none!important}
    }

  /* Fullscreen Stage Editor */
  .stage-modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;z-index:60}
  .stage-modal.open{display:flex}
  .stage-editor{display:grid;grid-template-columns:280px 1fr;gap:12px;background:#fff;width:100%;height:100%}
  .stage-pane{padding:12px;overflow:auto;border-right:1px solid #e5e7eb}
  .stage-canvas{padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;overflow:auto}
  /* Preserve full-size stage canvas regardless of legend height */
  #stageSvgFull{width:100% !important;height:100% !important;aspect-ratio:1500/900;flex:0 0 auto}
  .stage-legend{width:100%;border:1px solid #e5e7eb;background:#f9fafb;border-radius:6px;padding:4px;display:flex;flex-direction:column;gap:2px;font-size:11px;line-height:1.1}
  .stage-legend .row{display:grid;grid-template-columns:60px 1fr 110px 160px;align-items:center;gap:6px;padding:1px 4px;}
  .stage-legend .row:nth-child(odd){background:#fff}
  .stage-legend img{width:16px;height:16px;object-fit:contain;display:block;margin:0 auto}
  .stage-legend .nm{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:11px}
  .stage-legend select,.stage-legend input[type=number]{font-size:11px;padding:0 2px;height:18px}
  .stage-legend .chain{font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .tool[draggable="true"]{user-select:none}
  .stage-actions{position:absolute;top:10px;right:10px;display:flex;gap:8px}
  /* Tech / Stage: tech rider & stage plot (B&W) */
  .advanced-grid{display:grid;grid-template-columns:320px 1fr;gap:16px;align-items:start}
  .tech-table{width:100%;border-collapse:collapse}
  .tech-table th,.tech-table td{border:1px solid #e5e7eb;padding:8px;font-size:14px}
  .stage-wrap{border:1px solid #e5e7eb;border-radius:8px;background:#fff;padding:10px}
  .stage-tools{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px}
  .tool{border:1px solid #d1d5db;border-radius:6px;background:#f9fafb;padding:6px 8px;font-size:13px;cursor:pointer}
  .stage{width:100%;height:90vh;min-height:640px;border:1px dashed #cbd5e1;background:#ffffff}
  .stage svg{width:100%;height:100%;background:white}
  /* B&W outlines for glyphs, keep background white */
  .bw .stage-bg{fill:#fff;stroke:#000;stroke-width:2}
  /* Allow colored emoji backgrounds: only force outline for rects without data-bg */
  .bw rect:not([data-bg]){fill:none;stroke:#000}
  .bw path,.bw circle,.bw ellipse,.bw line,.bw polyline,.bw polygon{fill:none;stroke:#000}
  .bw text{fill:#000;stroke:none}
  /* selection visual (editor only; not printed) */
  g[data-draggable].selected path,
  g[data-draggable].selected rect,
  g[data-draggable].selected circle,
  g[data-draggable].selected ellipse,
  g[data-draggable].selected line,
  g[data-draggable].selected polyline,
  g[data-draggable].selected polygon{stroke:#1d4ed8}
  g[data-draggable].selected text{text-decoration:underline}
  .stage-inspector{margin-top:8px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  /* Stage frame & resize handles */
  #stageFrame{outline:3px solid #000;pointer-events:none}
  #stageFrame .stage-handle{position:absolute;width:16px;height:16px;background:#000;border:2px solid #fff;border-radius:4px;z-index:85;pointer-events:auto;box-shadow:0 0 0 1px #000}
  #stageFrame .stage-handle.tl{top:-10px;left:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle.tr{top:-10px;right:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.bl{bottom:-10px;left:-10px;cursor:nesw-resize}
  #stageFrame .stage-handle.br{bottom:-10px;right:-10px;cursor:nwse-resize}
  #stageFrame .stage-handle:active{background:#1d4ed8}
  #stageSvgFull{pointer-events:auto}
  .stage-inspector .muted{color:#6b7280;font-size:13px}
  .gear-wrap{margin-top:8px}
  .gear-wrap textarea{width:100%;min-height:42px}
  /* Global print FAB */
  .print-fab{position:fixed;right:18px;bottom:18px;z-index:70;border-radius:999px;padding:12px 16px;box-shadow:0 6px 18px rgba(0,0,0,.2)}
  @media print{ .print-fab{display:none} }
  /* Touch optimizations */
  #stageSvgFull{ touch-action:none; }
  .stage-canvas{ -webkit-user-select:none; user-select:none; }
  /* Global sticky actions (top-left) */
  .global-actions{position:sticky;top:0;z-index:60;display:flex;gap:8px;flex-wrap:wrap;padding:8px 0 6px 0;margin:-6px 0 8px 0;background:linear-gradient(180deg, rgba(249,250,251,0.96), rgba(249,250,251,0));backdrop-filter:saturate(1.2) blur(2px)}
  @media print{ .global-actions{display:none} }
  /* Missing songs list */
  .missing{margin:8px 0 6px 0;display:flex;flex-wrap:wrap;gap:6px}
  .missing .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #d1d5db;border-radius:999px;padding:4px 8px;background:#fff;font-size:12px;color:#111827}
  .missing .pill .add{background:#1d4ed8;color:#fff;border:none;border-radius:999px;padding:2px 8px;cursor:pointer}
  .missing .pill .add:hover{background:#1e40af}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>Jiffykit: Setlist Creator v1.2</h1>
      <div>Build, arrange, and print a clean one-page setlist</div>
    </div>

    <!-- Global sticky actions: always available top-left -->
    <div class="global-actions">
      <button class="btn" id="saveProfile">Save Profile (.BAND)</button>
      <button class="btn" id="loadProfile">Load Profile (.BAND)</button>
      <input type="file" id="loadProfileFile" accept=".band,application/json" style="display:none" />
      <button class="btn" id="saveSet">Save .SET</button>
      <button class="btn" id="loadSet">Load .SET</button>
      <input type="file" id="loadSetFile" accept=".set,application/json" style="display:none" />
      <button class="btn" id="openPrintOptionsTop" title="Print…">Print…</button>
      <button class="btn secondary" id="helpBtn" title="Help / Tutorial">?</button>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="db">Song Database</button>
      <button class="tab" data-tab="set">Setlist</button>
  <button class="tab" data-tab="adv">Tech / Stage</button>
    </div>

    <div class="grid">
      <div class="card" id="db" style="grid-column:1 / -1; width:100%;">
        <h2>Add Song</h2>
        <div class="field"><label>Title</label><input id="t" placeholder="Song Title" /></div>
        <div class="row">
          <div class="field"><label>Artist (blank=Original)</label><input id="a" placeholder="Artist or leave blank" /></div>
          <div class="field"><label>Length (min)</label><input id="l" type="number" min="0.5" step="0.5" value="3.5" placeholder="3.5" /></div>
        </div>
        <div class="row">
          <div class="field" style="flex:2 1 320px"><label>Key / Notes</label><input id="k" placeholder="e.g., Am, G-C-D" /></div>
          <div class="field" style="max-width:120px"><label>Capo</label><input id="capo" type="number" min="0" max="24" value="0" /></div>
        </div>
        <div class="checks">
          <label class="chip"><input type="checkbox" id="c"> Cover</label>
          <label class="chip"><input type="checkbox" id="u"> Upbeat</label>
          <label class="chip"><input type="checkbox" id="h"> Happy</label>
          <label class="chip"><input type="checkbox" id="m"> Mellow</label>
          <label class="chip"><input type="checkbox" id="e"> Energetic</label>
          <label class="chip"><input type="checkbox" id="s"> Sad</label>
        </div>
        <div class="checks" id="addCustomMoods" style="margin-top:6px"></div>
          <div style="margin-top:10px"><button class="btn" id="add">Add Song</button></div>
          <div id="dbControls" style="margin:12px 0 8px;display:flex;flex-wrap:wrap;gap:10px;align-items:center">
            <label style="font-size:12px;color:#64748b">Type</label>
            <select id="dbType">
              <option value="all" selected>All</option>
              <option value="originals">Originals</option>
              <option value="covers">Covers</option>
            </select>
            <label style="font-size:12px;color:#64748b">Sort</label>
            <select id="dbSort">
              <option value="alpha" selected>Alphabetical</option>
              <option value="band">Band Name</option>
              <option value="mood">Mood Order</option>
              <option value="cover">Cover First</option>
              <option value="length">Length</option>
            </select>
            <label style="font-size:12px;color:#64748b">Mood</label>
            <select id="dbMood">
              <option value="all" selected>All</option>
              <option value="upbeat">Upbeat</option>
              <option value="happy">Happy</option>
              <option value="energetic">Energetic</option>
              <option value="mellow">Mellow</option>
              <option value="sad">Sad</option>
            </select>
            <button class="btn secondary" id="addMoodBtn" type="button">Add Mood</button>
          </div>
        <!-- Profile buttons moved to global-actions -->
        <div class="list" id="dbList" style="width:100%;"></div>
        <div style="margin-top:12px;display:flex;justify-content:flex-end">
          <button class="btn danger" id="clearDB">Clear Database</button>
        </div>
        <div class="import-block" id="importBlock" style="margin-top:22px;padding:14px;border:1px solid #e2e8f0;border-radius:8px;background:#f8fafc">
          <h3 style="margin:0 0 10px;font-size:18px">Import Songs (OCR / Paste)</h3>
          <textarea id="importText" rows="4" placeholder="Paste lines e.g.\nSong Title - Am (Capo 2)\nAnother Song G Capo 3\nThird Song - F#m" style="width:100%;resize:vertical;font-family:monospace"></textarea>
          <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;align-items:center">
            <input type="file" id="importFile" accept=".txt,.pdf,image/*" style="flex:1 1 240px" />
            <button class="btn" id="importParseBtn" type="button">Parse Text & Preview</button>
            <button class="btn secondary" id="importCommitBtn" type="button" disabled>Add Parsed Songs</button>
          </div>
          <div id="importStatus" style="margin-top:8px;font-size:12px;color:#64748b"></div>
          <div id="importPreview" style="margin-top:10px;font-size:13px;line-height:1.4"></div>
          <div style="margin-top:10px;font-size:11px;color:#94a3b8">Image/PDF OCR uses Tesseract.js & PDF.js in-browser; accuracy varies with scan quality. Keys & capo detected heuristically. Review before importing.</div>
        </div>
      </div>

      <!-- Combined Setlist + Generator Tab -->
      <div class="card" id="set" style="display:none">
        <h2>Setlist</h2>
        <h3 style="margin-top:0">Generator / Gig Info</h3>
        <div class="row">
          <div class="field"><label>Band Name</label><input id="gBand" placeholder="Band name"></div>
          <div class="field"><label>Date</label><input id="gDate" type="date"></div>
          <div class="field"><label>Venue</label><input id="gVenue" placeholder="Venue name"></div>
        </div>
        <div class="row">
          <div class="field"><label>Setlist Font</label>
            <select id="gFont">
              <option value="default">Default</option>
              <option value="helvetica">Helvetica/Arial</option>
              <option value="georgia">Georgia (serif)</option>
              <option value="roboto-condensed">Roboto Condensed</option>
              <option value="courier">Courier New (mono)</option>
            </select>
          </div>
          <div class="field"><label>Logo (overrides Band Name in print)</label>
            <input id="gLogo" type="file" accept="image/*" />
            <div style="margin-top:6px;display:flex;gap:8px;align-items:center">
              <img id="gLogoPrev" alt="logo preview" style="max-height:48px;display:none" />
              <button class="btn danger" id="gLogoClear" type="button">Remove Logo</button>
            </div>
          </div>
        </div>
        <div class="row">
          <div class="field"><label>Address</label><input id="gAddr" placeholder="123 Main St, City"></div>
          <div class="field"><label>Contact</label><input id="gContact" placeholder="Name / phone"></div>
        </div>
        <div class="field"><label>Notes (small, under header)</label><textarea id="gNotes" rows="2" placeholder="Load-in, request, etc"></textarea></div>

        <div class="row">
          <div class="field"><label>Set length (min)</label><input id="gLen" type="number" min="10" value="60" placeholder="60"></div>
          <div class="field"><label>Cover ratio</label>
            <select id="gCover">
              <option value="0">100% Originals</option>
              <option value="25">25% Covers</option>
              <option value="50" selected>50/50</option>
              <option value="75">75% Covers</option>
              <option value="90">90% Covers</option>
              <option value="100">100% Covers</option>
            </select>
          </div>
        </div>
        <div class="row">
          <div class="field"><label>Breaks</label>
            <select id="gBreaks">
              <option value="0">No breaks</option>
              <option value="1">1 break</option>
              <option value="2">2 breaks</option>
              <option value="3">3 breaks</option>
            </select>
          </div>
          <div class="field"><label>Break length (min)</label><input id="gBreakLen" type="number" min="5" value="15"></div>
        </div>
        <div class="row">
          <div class="field"><label><input type="checkbox" id="gEncore"> Include Encore</label></div>
          <div class="field"><label>Mood</label>
            <select id="gMood">
              <option value="mixed">Mixed</option>
              <option value="upbeat">Upbeat</option>
              <option value="happy">Happy</option>
              <option value="mellow">Mellow</option>
              <option value="energetic">Energetic</option>
              <option value="sad">Sad</option>
            </select>
          </div>
        </div>
        <div class="field" style="margin-top:4px">
          <label>Grouping Rules</label>
          <div class="checks" style="gap:6px">
            <label class="chip"><input type="checkbox" id="gKeepCovers"> Keep Covers Together</label>
            <label class="chip"><input type="checkbox" id="gKeepKeys"> Keep Keys Together</label>
            <label class="chip"><input type="checkbox" id="gKeepMoods"> Keep Moods Together</label>
          </div>
        </div>
          <div class="field" style="margin-top:4px">
            <label>Header print elements</label>
            <div class="checks" style="gap:6px">
              <label class="chip"><input type="checkbox" id="hdrBand" checked> Band/Logo</label>
              <label class="chip"><input type="checkbox" id="hdrVenue" checked> Venue</label>
              <label class="chip"><input type="checkbox" id="hdrSub" checked> Date / Address / Contact</label>
              <label class="chip"><input type="checkbox" id="hdrNotes" checked> Notes</label>
            </div>
          </div>
        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;justify-content:flex-start">
          <button class="btn" id="genBtn">Generate</button>
          <button class="btn danger" id="clearSet" type="button">Clear Setlist</button>
        </div>
        <div id="genStats" style="margin-top:10px;color:#a7b8e3;font-size:12px"></div>
        <div id="setlistLayout" style="display:flex;flex-wrap:nowrap;gap:24px;align-items:flex-start;margin-top:18px;width:100%">
          <div id="poolCol" style="flex:0 0 260px;display:flex;flex-direction:column;gap:12px;align-items:flex-start">
            <h3 style="margin:0">Song Pool</h3>
            <div id="poolControls" style="display:flex;flex-direction:column;gap:6px;width:100%">
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Type</label>
                <select id="poolType" style="flex:1 1 auto;min-width:120px">
                  <option value="all" selected>All</option>
                  <option value="originals">Originals</option>
                  <option value="covers">Covers</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Sort</label>
                <select id="poolSort" style="flex:1 1 auto;min-width:140px">
                  <option value="alpha" selected>Alphabetical</option>
                  <option value="band">Band Name</option>
                  <option value="mood">Mood Order</option>
                </select>
              </div>
              <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap">
                <label style="font-size:12px;color:#64748b">Mood</label>
                <select id="poolMood" style="flex:1 1 auto;min-width:140px">
                  <option value="all" selected>All</option>
                  <option value="upbeat">Upbeat</option>
                  <option value="happy">Happy</option>
                  <option value="energetic">Energetic</option>
                  <option value="mellow">Mellow</option>
                  <option value="sad">Sad</option>
                </select>
              </div>
            </div>
            <div id="poolOriginals" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolCoversHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Covers</h4>
            <div id="poolCovers" style="display:flex;flex-direction:column;gap:6px"></div>
            <h4 id="poolBreaksHdr" style="margin:12px 0 4px;font-size:13px;color:#64748b">Break</h4>
            <div id="poolBreaks" style="display:flex;flex-direction:column;gap:6px"></div>
          </div>
          <div id="previewCol" style="flex:1 1 auto;min-width:640px;max-width:1100px">
            <h3 style="margin:0 0 8px">Preview</h3>
            <div class="sheet" id="sheetInline">
              <div class="hdr" id="hdrInline"></div>
              <div class="songs" id="songsInline"></div>
            </div>
            <div style="margin-top:10px;font-size:12px;color:#64748b">Drag songs from the pool directly into the preview. Drag rows to reorder. Double‑click a title to add/edit notes. Drag a Break chip to insert a break.</div>
          </div>
        </div>
      </div>

      <div class="card" id="adv" style="display:none">
  <h2>Tech / Stage: Tech Rider & Stage Plot</h2>
        <div class="row" style="gap:8px">
          <button class="btn" id="openStage" onclick="openStageModal()">Stage Plot (Fullscreen)</button>
          <button class="btn" id="openNotes">Lighting Notes (Fullscreen)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Help / Tutorial Modal -->
  <div class="modal" id="helpModal" style="display:none">
    <div class="sheet" style="max-width:760px;height:auto">
      <h2>Jiffykit Setlist – Quick Tutorial</h2>
      <ol style="font-size:14px;line-height:1.5;margin-left:20px">
        <li><strong>Song Database</strong>: Add all your songs here. Mark moods & cover status to influence generation.</li>
        <li><strong>Generator</strong>: Enter gig details (band, venue, date, notes). Pick total length, break count, mood, and whether to include an encore, then click Generate.</li>
        <li><strong>Current Setlist</strong>: Drag songs to reorder with the handle (⋮⋮). Type notes inline and they appear immediately below titles in the preview. Use the “Missing” pills to quickly add songs from your database.</li>
  <li><strong>Tech / Stage</strong>: Fullscreen Stage Plot lets you drag icon images & labels; Lighting Notes table captures per-song FX cues. Assign mixer channels in the legend, duplicate to speed layout, and Clear to start over.</li>
        <li><strong>Printing</strong>: Use the Print… button for Setlist, Stage Plot, and Tech Notes—each prints separately. (Use your browser's Save as PDF in the print dialog.)</li>
        <li><strong>Profiles & Sets</strong>: Save Profile (.BAND) to archive your whole song DB + gig settings. Load Profile to merge. Save .SET to export just the current setlist arrangement.</li>
        <li><strong>Persistence</strong>: Everything auto-saves locally. Closing and reopening the browser restores your last session.</li>
  <li><strong>Stage Plot Tips</strong>: Drag from Toolbox, double‑click a label to rename, use the size slider, duplicate for symmetrical setups, Clear to wipe everything except background & title.</li>
      </ol>
      <div style="margin-top:16px;font-size:14px;background:#f1f5f9;padding:12px;border-radius:8px">
        This app is free. If it saves you time and you’d like to support development, you can donate:
        <p style="margin:10px 0"><a href="https://paypal.me/jamesmulvale" target="_blank" rel="noopener" class="btn" style="text-decoration:none">Donate via PayPal</a></p>
        Thank you and have a great show!
      </div>
      <div style="margin-top:18px;display:flex;gap:10px;justify-content:flex-end">
        <button class="btn" id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <!-- Floating Song Pool Flyout -->
  <div class="pool-flyout" id="songPoolFlyout">
    <div class="pool-head">
      <strong>Song Pool</strong>
      <button class="btn secondary" id="closePool" type="button">Close</button>
    </div>
    <div class="pool-body">
      <div class="pool-sec">
        <h4>Originals</h4>
        <div id="poolOriginals" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Covers</h4>
        <div id="poolCovers" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
      <div class="pool-sec">
        <h4>Breaks</h4>
        <div id="poolBreaks" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      </div>
    </div>
  </div>

  <!-- Global Print FAB removed; using top-row Print button for consistency -->

  <!-- Stage Fullscreen Modal -->
  <div class="stage-modal" id="stageModal">
    <div class="stage-editor">
      <div class="stage-pane">
  <h3>Toolbox <span style="font-weight:400;font-size:12px;color:#6b7280">(Drag and drop items)</span></h3>
        <div class="stage-tools" id="stageToolsFull"></div>
        <div style="margin-top:10px">
          <h4>Custom</h4>
          <button class="tool" id="uploadImageBtn">Upload Image</button>
          <input type="file" id="uploadImageInput" accept="image/*" style="display:none" />
          <button class="tool" id="newIconBtn">New Icon</button>
          <div id="customImages" style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px"></div>
        </div>
      </div>
      <div class="stage-canvas">
        <div id="stageFrame" style="position:relative;display:inline-block;">
          <svg id="stageSvgFull" class="bw" viewBox="0 0 1500 900" xmlns="http://www.w3.org/2000/svg" style="display:block;">
            <rect class="stage-bg" x="1" y="1" width="1498" height="898"/>
            <text x="750" y="50" text-anchor="middle" font-size="26" font-weight="bold" id="stageTitleFull">Band • Date</text>
          </svg>
          <div class="stage-handle tl" data-handle="tl"></div>
          <div class="stage-handle tr" data-handle="tr"></div>
          <div class="stage-handle bl" data-handle="bl"></div>
          <div class="stage-handle br" data-handle="br"></div>
        </div>
        <div class="stage-inspector" id="stageInspector">
          <span class="muted">Selected:</span>
          <input id="selName" placeholder="Label (double‑click item to rename)" style="min-width:220px" />
          <label class="muted" for="selSize">Size</label>
          <input id="selSize" type="range" min="0.3" max="5" step="0.05" value="1" style="width:160px" />
          
          <label class="muted" for="selShowLabel" style="display:flex;align-items:center;gap:4px"><input type="checkbox" id="selShowLabel" /> Show Label</label>
          <button class="btn danger" id="delSel">Delete</button>
          <button class="btn" id="dupSel" type="button">Duplicate</button>
        </div>
        <div id="stageLegend" class="stage-legend"></div>
        <div class="stage-actions">
          <button class="btn secondary" id="closeStage">Close</button>
          <button class="btn danger" id="clearStage">Clear</button>
        </div>
      </div>
    </div>
  </div>

  <!-- New Icon Drawing Modal -->
  <div class="modal" id="iconMakerModal" style="display:none">
    <div class="sheet" style="max-width:480px">
      <h3 style="margin-top:0">Create New Icon</h3>
      <canvas id="iconCanvas" width="400" height="400" style="border:1px solid #d1d5db;background:transparent;display:block;width:400px;height:400px;touch-action:none"></canvas>
      <div style="margin-top:8px;display:flex;gap:12px;flex-wrap:wrap;align-items:center">
        <label style="font-size:12px;color:#64748b">Line Width
          <input id="iconLineWidth" type="range" min="2" max="6" step="1" value="4" style="width:160px">
        </label>
        <button class="btn" id="iconClear">Clear</button>
        <button class="btn" id="iconSave">Save Icon</button>
        <button class="btn secondary" id="iconCancel">Cancel</button>
      </div>
      <div style="margin-top:6px;font-size:11px;color:#64748b">Draw with mouse or touch. Rough shapes will auto-normalize into lines, rectangles, or ellipses where recognized.</div>
    </div>
  </div>

  <!-- Lighting Notes Fullscreen Modal -->
  <div class="stage-modal" id="notesModal">
    <div class="stage-editor" style="grid-template-columns:1fr">
      <div class="stage-pane" style="border-right:none">
        <h3>Lighting Notes</h3>
        <table class="tech-table">
          <thead><tr><th>#</th><th>Song</th><th>Notes (e.g., Blue fade to orange, Delays in chorus)</th></tr></thead>
          <tbody id="techBodyFull"></tbody>
        </table>
        <div class="gear-wrap">
          <label>Gear list (printed under stage)</label>
          <textarea id="gear" placeholder="e.g., DI x3 • Guitar amp x2 • Vox x3 • Wireless x2"></textarea>
        </div>
        <div class="stage-actions">
          <button class="btn secondary" id="closeNotes">Close</button>
          <button class="btn" id="printTech">Print Tech Rider + Stage</button>
          <button class="btn" id="printTechOnly">Print Tech Only</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Print Modal -->
  <div class="modal" id="modal">
    <div class="sheet" id="sheet">
      <div class="hdr" id="hdr"></div>
      <div class="songs" id="songs"></div>
    </div>
    <div class="tools">
      <span class="paper">Paper:</span>
      <select id="paperSel">
        <option value="letter">Letter 8.5×11</option>
        <option value="a4">A4 210×297mm</option>
      </select>
  <button class="btn" id="printSheet">Print</button>
      <button class="btn secondary" id="closeModal">Close</button>
    </div>
  </div>

  <!-- Tech/Stage Print Modal -->
  <div class="modal" id="modalTech">
    <div class="sheet" id="sheetTech">
      <div class="hdr" id="hdrTech"></div>
      <div id="techPrint"></div>
      <div id="stagePrint"></div>
    </div>
    <div class="tools">
      <button class="btn" id="printTechModal">Print</button>
      <button class="btn secondary" id="closeTech">Close</button>
    </div>
  </div>

  <!-- Print Options Modal -->
  <div class="modal" id="printChooser">
    <div class="sheet" style="width:560px;height:auto;max-width:95vw">
      <div class="hdr"><div class="band">Print Options</div></div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <label class="chip"><input type="checkbox" id="pSet"> Setlist</label>
        <label class="chip"><input type="checkbox" id="pStage"> Stage Plot</label>
        <label class="chip"><input type="checkbox" id="pTech"> Lighting / Tech Notes</label>
        <div class="muted">Select one or more. Each prints separately.</div>
      </div>
      <div class="tools" style="justify-content:flex-end">
        <button class="btn" id="doPrint">Print Selected</button>
        <button class="btn secondary" id="closePrintChooser">Close</button>
      </div>
    </div>
  </div>

  <!-- Hidden storage for Stage SVG (used for save/print) -->
  <div id="stageStore" style="display:none">
    <svg id="stageSvg" class="bw" viewBox="0 0 1000 600" xmlns="http://www.w3.org/2000/svg">
      <rect class="stage-bg" x="1" y="1" width="998" height="598"/>
      <text x="500" y="36" text-anchor="middle" font-size="22" font-weight="bold" id="stageTitle">Band • Date</text>
    </svg>
  </div>

  <script>
    // Data
  const db = []; // {id,title,artist,length,key,isCover,isUpbeat,isHappy,isMellow,isEnergetic,isSad,customMoods?:string[]}
  let setlist = []; // array of {type:'song'|'break'|'encore', ...}
  let gig = { band:'', date:'', venue:'', address:'', contact:'', notes:'', breaks:0, breakLen:15, encore:false, font:'default', logo:'', headerFlags:{band:true,venue:true,sub:true,notes:true}, customMoods:[], customImages:[] };
  let gearSummary = '';
  // Tech notes persist independently of the current set (keyed by song id)
  let techNotes = {};
  const DEFAULT_MOODS = ['upbeat','happy','energetic','mellow','sad'];
  const moodLabel = (k)=> k.charAt(0).toUpperCase()+k.slice(1);
  const getAllMoods = ()=> [...DEFAULT_MOODS, ...((gig.customMoods||[]).filter(x=>!DEFAULT_MOODS.includes(x)))].slice(0,12);
  function renderAddMoodsUI(){
    const host=document.getElementById('addCustomMoods'); if(!host) return;
    host.innerHTML='';
    (gig.customMoods||[]).forEach(k=>{
      const lab=document.createElement('label'); lab.className='chip';
      const cb=document.createElement('input'); cb.type='checkbox'; cb.id='cm-'+k;
      lab.appendChild(cb); lab.appendChild(document.createTextNode(' '+moodLabel(k)));
      host.appendChild(lab);
    });
  }

  // Storage
  const STORE_KEY='fastfast-setlist-v1';
  function saveAll(){
    try{
      // Prefer full editor SVG if open; fallback to stored small one
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      const payload={db,setlist,gig,gearSummary,techNotes,stage:(stageEl? stageEl.outerHTML : '')};
      localStorage.setItem(STORE_KEY, JSON.stringify(payload));
    }catch(e){/* ignore */}
  }
  // Persist on navigation away
  window.addEventListener('beforeunload', saveAll);
    // Clear database
    const clearDBBtn=document.getElementById('clearDB');
    if(clearDBBtn){ clearDBBtn.addEventListener('click',()=>{
      if(!db.length) return;
      // Offer to save a .BAND backup first
      try{
        if(confirm('Download a .BAND backup before clearing the database? Click OK to Save, or Cancel to skip.')){
          var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
          const stage = stageEl ? stageEl.outerHTML : '';
          const data={version:2,type:'fastfast-band', db, gig, gearSummary, stage};
          const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
          const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
        }
      }catch(_){ /* ignore */ }
      if(!confirm('Clear entire song database now? This cannot be undone (unless you reload a .BAND profile).')) return;
      db.splice(0,db.length); renderDB(); saveAll();
    }); }
    // Clear setlist
    const clearSetBtn=document.getElementById('clearSet');
    if(clearSetBtn){ clearSetBtn.addEventListener('click',()=>{ if(!setlist.length) return; if(!confirm('Clear current setlist?')) return; setlist=[]; renderSet(); saveAll(); }); }
    // Help modal open/close
    const helpBtn=document.getElementById('helpBtn'); const helpModal=document.getElementById('helpModal'); const closeHelp=document.getElementById('closeHelp');
    if(helpBtn && helpModal){ helpBtn.addEventListener('click',()=>{ helpModal.style.display='block'; helpModal.classList.add('open'); }); }
    if(closeHelp){ closeHelp.addEventListener('click',()=>{ helpModal.classList.remove('open'); helpModal.style.display='none'; }); }
  function loadAll(){
    try{
      const raw=localStorage.getItem(STORE_KEY); if(!raw) return;
    const {db:dbIn,setlist:setIn,gig:gigIn,gearSummary:gearIn,techNotes:tnIn,stage}=JSON.parse(raw);
      if(Array.isArray(dbIn)) db.push(...dbIn);
      if(Array.isArray(setIn)) setlist=setIn;
      if(gigIn) gig=Object.assign(gig,gigIn);
      if(gearIn) { gearSummary = gearIn; }
  if(tnIn && typeof tnIn==='object') { techNotes = tnIn; }
  // header flag hydration
  if(!gig.headerFlags) gig.headerFlags={band:true,venue:true,sub:true,notes:true};
  ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
      // UI hydrate
      if(gig.band) document.getElementById('gBand').value=gig.band;
      if(gig.date) document.getElementById('gDate').value=gig.date;
      if(gig.venue) document.getElementById('gVenue').value=gig.venue;
      if(gig.address) document.getElementById('gAddr').value=gig.address;
      if(gig.contact) document.getElementById('gContact').value=gig.contact;
      if(gig.notes) document.getElementById('gNotes').value=gig.notes;
      const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value = gearSummary || '';
      renderDB(); renderSet();
      if(stage){ const container=document.getElementById('stageStore'); container.innerHTML=stage; const svg=container.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); }
      }
    }catch(e){/* ignore */}
  }

    // Helpers
    const $ = s=>document.querySelector(s);
    const el = (t,cls,txt)=>{const n=document.createElement(t); if(cls) n.className=cls; if(txt!=null) n.textContent=txt; return n;}
    const shuffle = a=>{const r=[...a]; for(let i=r.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[r[i],r[j]]=[r[j],r[i]];} return r}

    // Title shortening: trims, collapses, removes parentheticals, limits words, ensures width via characters
    function shorten(title, maxChars=48){
      if(!title) return '';
      // Keep original wording; only trim whitespace and optional parentheticals for clutter
      let t=title.replace(/\s+/g,' ').trim();
      t=t.replace(/\s*\([^\)]*\)\s*/g,' '); // remove (feat), (live), etc
      if(t.length>maxChars) t=t.slice(0,maxChars-1)+'…';
      return t;
    }

    function minutes(sum){ return `${sum.toFixed(1)}m`; }

    // Tabs
    document.querySelectorAll('.tab').forEach(btn=>btn.addEventListener('click',e=>{
      document.querySelectorAll('.tab').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      ['db','set','adv'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      document.getElementById(btn.dataset.tab).style.display='block';
      if(btn.dataset.tab==='adv'){ buildTechTable(); refreshStageHeader(); try{ buildTools(); }catch(_){} try{ openStageModal(); }catch(err){ console && console.error && console.error(err); }}
    }));

    // Prefill date today
    (function prefill(){
      const d=$('#gDate'); if(d && !d.value){ const t=new Date(); const iso=new Date(t.getTime()-t.getTimezoneOffset()*60000).toISOString().slice(0,10); d.value=iso; }
      loadAll();
      // Build initial inline preview
      try{ buildSheet('sheetInline'); }catch(_){ }
      try{ renderAddMoodsUI(); }catch(_){ }
    })();

    // Add song
    $('#add').addEventListener('click', ()=>{
      const title=$('#t').value.trim();
      const artist=$('#a').value.trim()||'Original';
      const lengthRaw=$('#l').value.trim();
      const length = lengthRaw? parseFloat(lengthRaw) : 3.5;
      const key=$('#k').value.trim();
      const capoRaw=$('#capo').value.trim();
      let capo = parseInt(capoRaw,10); if(!Number.isInteger(capo) || capo<0) capo=0; if(capo>24) capo=24;
      if(!title){ alert('Please enter a song title'); return; }
      if(!length||length<=0){ alert('Length invalid, using 3.5'); }
      const s={id:Date.now(),title,artist,length,key,capo,
        isCover:$('#c').checked,isUpbeat:$('#u').checked,isHappy:$('#h').checked,
        isMellow:$('#m').checked,isEnergetic:$('#e').checked,isSad:$('#s').checked, customMoods:[]};
      // Include custom moods from add section
      (gig.customMoods||[]).forEach(k=>{ const el=document.getElementById('cm-'+k); if(el && el.checked){ s.customMoods.push(k); } });
      db.push(s);
      $('#t').value=''; $('#a').value=''; $('#l').value='3.5'; $('#k').value=''; $('#capo').value='0';
      ['c','u','h','m','e','s'].forEach(id=>$('#'+id).checked=false);
      (gig.customMoods||[]).forEach(k=>{ const el=document.getElementById('cm-'+k); if(el) el.checked=false; });
  renderDB(); saveAll();
    });

    function renderDB(){
      const list=$('#dbList'); list.innerHTML='';
      if(!db.length){ list.textContent='No songs yet.'; return; }
      // Filters / sort
      const tSel=document.getElementById('dbType');
      const sSel=document.getElementById('dbSort');
      const mSel=document.getElementById('dbMood');
      const typeVal=(tSel&&tSel.value)||'all';
      const sortVal=(sSel&&sSel.value)||'alpha';
      const moodVal=(mSel&&mSel.value)||'all';
      const used=(arr)=>arr.filter(Boolean);
      const hasMood=(song, key)=>{
        if(DEFAULT_MOODS.includes(key)){
          return (key==='upbeat'&&song.isUpbeat) || (key==='happy'&&song.isHappy) || (key==='energetic'&&song.isEnergetic) || (key==='mellow'&&song.isMellow) || (key==='sad'&&song.isSad);
        }
        const cm = song.customMoods||[]; return cm.includes(key);
      };
      const songMood=(song)=>{
        if(song.isUpbeat) return 'upbeat'; if(song.isHappy) return 'happy'; if(song.isEnergetic) return 'energetic'; if(song.isMellow) return 'mellow'; if(song.isSad) return 'sad';
        const cm=(song.customMoods||[])[0]; return cm||'none';
      };
      const rankMap={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:99};
      getAllMoods().forEach((m,i)=>{ if(!(m in rankMap)) rankMap[m]=50+i; });
      let rows=db.filter(s=> typeVal==='all' ? true : (typeVal==='covers'? s.isCover : !s.isCover));
      if(moodVal!=='all') rows = rows.filter(s=> hasMood(s,moodVal));
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (rankMap[songMood(a)] - rankMap[songMood(b)]) || a.title.localeCompare(b.title);
      const byCover=(a,b)=> (b.isCover - a.isCover) || a.title.localeCompare(b.title);
      const byLength=(a,b)=> (a.length||0) - (b.length||0) || a.title.localeCompare(b.title);
      const sorter = sortVal==='band'? byBand : sortVal==='mood'? byMood : sortVal==='cover'? byCover : sortVal==='length'? byLength : byAlpha;
      rows.sort(sorter);
      rows.forEach(s=>{
        const row=document.createElement('div'); row.className='db-row'; row.style.display='flex'; row.style.gap='8px'; row.style.alignItems='center'; row.style.padding='6px 8px'; row.style.border='1px solid #e5e7eb'; row.style.borderRadius='6px'; row.style.margin='6px 0'; row.style.width='100%';
        const title=document.createElement('input'); title.value=s.title||''; title.placeholder='Title'; title.className='db-title'; title.style.flex='5 1 520px';
        title.addEventListener('change',()=>{ s.title=title.value.trim()||s.title; saveAll(); buildSheet('sheetInline'); renderSongPool(); });
        // Cover as simple checkbox
        const coverWrap=document.createElement('label'); coverWrap.style.display='inline-flex'; coverWrap.style.alignItems='center'; coverWrap.style.gap='6px'; coverWrap.style.minWidth='86px'; coverWrap.title='Is this a cover?';
        const coverChk=document.createElement('input'); coverChk.type='checkbox'; coverChk.checked=!!s.isCover; coverWrap.appendChild(coverChk); coverWrap.appendChild(document.createTextNode('Cover'));
        const artist=document.createElement('input'); artist.placeholder='Artist'; artist.value= (s.isCover? (s.artist||'') : ''); artist.className='db-artist'; artist.style.flex='3 1 260px'; artist.disabled = !s.isCover; artist.style.opacity = s.isCover? '1':'0.5';
        const syncCover=()=>{ const isC=!!coverChk.checked; s.isCover=isC; if(!isC){ s.artist='Original'; artist.value=''; artist.disabled=true; artist.style.opacity='0.5'; } else { artist.disabled=false; artist.style.opacity='1'; } saveAll(); renderSongPool(); };
        coverChk.addEventListener('change', syncCover);
        artist.addEventListener('change',()=>{ s.artist = coverChk.checked ? (artist.value.trim()||s.artist||'') : 'Original'; saveAll(); });
        const len=document.createElement('input'); len.type='number'; len.step='0.5'; len.min='0.5'; len.value=String(s.length||3.5); len.title='Length (min)'; len.style.width='70px';
        len.addEventListener('change',()=>{ const v=parseFloat(len.value); if(v>0) s.length=v; saveAll(); buildSheet('sheetInline'); });
        const key=document.createElement('input'); key.placeholder='Key'; key.value=s.key||''; key.style.width='90px';
        key.addEventListener('change',()=>{ s.key=key.value.trim(); saveAll(); buildSheet('sheetInline'); });
        const capo=document.createElement('input'); capo.type='number'; capo.min='0'; capo.max='24'; capo.value=String(Number.isInteger(s.capo)? s.capo : 0); capo.title='Capo fret (0-24)'; capo.style.width='60px';
        capo.addEventListener('change',()=>{ let v=parseInt(capo.value,10); if(!Number.isInteger(v) || v<0) v=0; if(v>24) v=24; s.capo=v; capo.value=String(v); saveAll(); buildSheet('sheetInline'); });
        // Mood checkboxes (defaults + custom)
        const moodsWrap=document.createElement('div'); moodsWrap.style.display='flex'; moodsWrap.style.flexWrap='wrap'; moodsWrap.style.gap='6px';
        const ensureCM=()=>{ if(!Array.isArray(s.customMoods)) s.customMoods=[]; };
        getAllMoods().forEach(m=>{
          const lab=document.createElement('label'); lab.className='chip'; const cb=document.createElement('input'); cb.type='checkbox';
          const isDefault=DEFAULT_MOODS.includes(m);
          let checked=false;
          if(isDefault){ checked = (m==='upbeat'&&s.isUpbeat) || (m==='happy'&&s.isHappy) || (m==='energetic'&&s.isEnergetic) || (m==='mellow'&&s.isMellow) || (m==='sad'&&s.isSad); }
          else { ensureCM(); checked=(s.customMoods||[]).includes(m); }
          cb.checked=checked;
          cb.addEventListener('change',()=>{
            if(isDefault){
              if(m==='upbeat') s.isUpbeat=cb.checked; else if(m==='happy') s.isHappy=cb.checked; else if(m==='energetic') s.isEnergetic=cb.checked; else if(m==='mellow') s.isMellow=cb.checked; else if(m==='sad') s.isSad=cb.checked;
            }else{
              ensureCM();
              const ix=(s.customMoods||[]).indexOf(m);
              if(cb.checked){ if(ix===-1) s.customMoods.push(m); }
              else { if(ix>-1) s.customMoods.splice(ix,1); }
            }
            saveAll(); renderSongPool();
          });
          lab.appendChild(cb); lab.appendChild(document.createTextNode(' '+moodLabel(m)));
          moodsWrap.appendChild(lab);
        });
        const del=document.createElement('button'); del.className='btn danger'; del.textContent='Delete'; del.style.marginLeft='auto'; del.addEventListener('click',()=>{ const i=db.findIndex(x=>x.id===s.id); if(i>-1){ db.splice(i,1); renderDB(); renderSongPool(); saveAll(); } });
        row.append(title,coverWrap,artist,len,key,capo,moodsWrap,del); list.appendChild(row);
      });
      try{ renderSongPool(); }catch(_){ }
    }

    // Generate fresh set each click (ignores current setlist)
    $('#genBtn').addEventListener('click', ()=>{
      const setLen = parseFloat($('#gLen').value || '60') || 60;
      const coverRatio=parseInt($('#gCover').value)||0;
      const breaks=parseInt($('#gBreaks').value)||0; // retained in gig but not auto-inserted
      const breakLen=parseFloat($('#gBreakLen').value)||15;
      const encore=$('#gEncore').checked;
      const mood=$('#gMood').value;

      var gFontElTmp=document.getElementById('gFont');
      gig={ band:$('#gBand').value, date:$('#gDate').value, venue:$('#gVenue').value, address:$('#gAddr').value, contact:$('#gContact').value, notes:$('#gNotes').value, breaks, breakLen, encore, font:((gFontElTmp&&gFontElTmp.value)||gig.font||'default'), logo:(gig.logo||'') };
      if(!db.length){ alert('Add some songs first.'); return; }

      // Filter pool by mood
      let pool=[...db];
      if(mood!=='mixed'){
        const keyMap={upbeat:'isUpbeat',happy:'isHappy',mellow:'isMellow',energetic:'isEnergetic',sad:'isSad'};
        pool=pool.filter(s=>s[keyMap[mood]]);
        if(!pool.length){ alert('No songs match this mood.'); return; }
      }

      const totalBreakTime = (breaks>0 ? (breaks * breakLen) : 0);
      const musicTime = Math.max(0, setLen - totalBreakTime);
      if(musicTime<=0){ alert('Set length must exceed total break time.'); return; }
      const covers=pool.filter(s=>s.isCover);
      const originals=pool.filter(s=>!s.isCover);
      let plan=[]; let total=0; const targetCover=(musicTime*coverRatio)/100;
      let coverSum=0, origSum=0;
      for(const s of shuffle(covers)){
        if(coverSum + s.length <= targetCover && total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); coverSum+=s.length; total+=s.length; }
      }
      for(const s of shuffle(originals)){
        if(total + s.length <= musicTime){ plan.push({...s,type:'song',notes:''}); origSum+=s.length; total+=s.length; }
      }
      plan=shuffle(plan);
      // Apply optional grouping rules
      const keepCovers = (document.getElementById('gKeepCovers') && document.getElementById('gKeepCovers').checked) || false;
      const keepKeys   = (document.getElementById('gKeepKeys') && document.getElementById('gKeepKeys').checked) || false;
      const keepMoods  = (document.getElementById('gKeepMoods') && document.getElementById('gKeepMoods').checked) || false;
      if(keepCovers || keepKeys || keepMoods){
        const songMoodOf=(s)=>{ if(s.isUpbeat) return 'upbeat'; if(s.isHappy) return 'happy'; if(s.isEnergetic) return 'energetic'; if(s.isMellow) return 'mellow'; if(s.isSad) return 'sad'; const cm=(s.customMoods||[])[0]; return cm||'none'; };
        const applyGrouping=(arr)=>{
          const songs=arr.filter(x=>x.type==='song');
          const others=arr.filter(x=>x.type!=='song');
          if(songs.length){
            songs.sort((a,b)=>{
              if(keepCovers){ const ca=(a.isCover?1:0), cb=(b.isCover?1:0); if(ca!==cb) return ca-cb; }
              if(keepKeys){ const ka=(a.key||''), kb=(b.key||''); if(ka!==kb) return ka.localeCompare(kb); }
              if(keepMoods){ const ma=songMoodOf(a), mb=songMoodOf(b); if(ma!==mb) return ma.localeCompare(mb); }
              return 0;
            });
          }
          // Rebuild segment by replacing song slots with sorted songs in order, preserving non-song positions
          let si=0; return arr.map(x=> x.type==='song' ? songs[si++] : x);
        };
        const encIdx=plan.findIndex(x=>x.type==='encore');
        if(encIdx>-1){
          const before=applyGrouping(plan.slice(0,encIdx));
          const after=applyGrouping(plan.slice(encIdx+1));
          const hdr=plan[encIdx];
          plan=[...before, hdr, ...after];
        }else{
          plan=applyGrouping(plan);
        }
      }
      if(encore){
        const usedIds=new Set(plan.filter(x=>x.type==='song').map(x=>x.id));
        const remaining=pool.filter(s=>!usedIds.has(s.id));
        let added=false;
        for(const s of shuffle(remaining)){
          if(total + s.length <= musicTime){ if(!added){ plan.push({type:'encore',title:'Encore'}); added=true; } plan.push({...s,type:'song',notes:''}); total+=s.length; if(total>=musicTime-0.01) break; }
        }
        if(added){ const h=plan.findIndex(x=>x.type==='encore'); if(h>-1 && !plan.slice(h+1).some(x=>x.type==='song')) plan=plan.filter((x,i)=> i!==h); }
      }
      // Trim overflow if any
      while(total>musicTime){ const last=plan.map((x,i)=>({x,i})).filter(y=>y.x.type==='song').map(y=>y.i).pop(); if(last==null) break; total-=plan[last].length; plan.splice(last,1); }

      // Automatic break insertion based on requested count (by cumulative music time)
      (function autoBreaks(){
        if(!breaks || breakLen<=0) return;
        const encoreIdx=plan.findIndex(x=>x.type==='encore');
        const songIndices=[]; let cum=0; const songLengths=[];
        plan.forEach((p,i)=>{ if(p.type==='song' && (encoreIdx===-1 || i<encoreIdx)){ cum += (p.length||0); songIndices.push(i); songLengths.push(cum); } });
        const totalSongLen=songLengths[songLengths.length-1]||0;
        if(totalSongLen < breakLen*0.75) return; // too short to bother
        let fracs=[];
        if(breaks===1) fracs=[0.5];
        else if(breaks===2) fracs=[0.5, 2/3];
        else if(breaks>=3) fracs=[0.25,0.5,0.75];
        const targets=fracs.map(f=> totalSongLen*f);
        const inserted=new Set();
        for(let tIdx=0; tIdx<targets.length; tIdx++){
          const tgt=targets[tIdx]; if(tgt<=0) continue;
          // Find first song index with cumulative >= target
          let songPos=-1;
          for(let j=0;j<songLengths.length;j++){ if(songLengths[j] >= tgt){ songPos=songIndices[j]; break; } }
          if(songPos===-1) continue;
          // Avoid duplicate insertion near previous breaks
          if(inserted.has(songPos)) continue;
          // Do not insert at very beginning
          if(songPos<=0) continue;
          // If previous element already a break, skip
          if(plan[songPos-1] && plan[songPos-1].type==='break') continue;
          plan.splice(songPos,0,{type:'break',title:'Break',length:breakLen});
          inserted.add(songPos);
          // Shift later songPositions automatically due to splice; recalc cumulative references minimal by adding length to later songLengths
          for(let k=0;k<songLengths.length;k++){ if(songIndices[k] >= songPos){ songIndices[k] += 1; } }
        }
      })();

      setlist=plan;
      const actualMusic = setlist.filter(x=>x.type==='song').reduce((a,b)=>a+(b.length||0),0);
      const breakCount=setlist.filter(x=>x.type==='break').length;
      $('#genStats').textContent=`Songs: ${setlist.filter(x=>x.type==='song').length} • Music: ${actualMusic.toFixed(1)}m (≤ target ${musicTime.toFixed(1)}m) • Covers ${coverSum.toFixed(1)}m / Originals ${origSum.toFixed(1)}m${breakCount? ' • Breaks '+breakCount+' × '+breakLen+'m':''}${encore? ' • Encore':''}`;
      rebuildPreview(); renderSongPool();
    });

    function renderSet(){
      const box=document.getElementById('setList');
      if(!box){ // preview-only layout (legacy set builder removed)
        buildSheet('sheetInline'); buildTechTable(); renderSongPool(); renderEncore(); return;
      }
      box.innerHTML='';
      if(!setlist.length){ box.textContent='No setlist yet.'; buildSheet('sheetInline'); buildTechTable(); renderSongPool(); renderEncore(); return; }
      let songNum=0;
      setlist.forEach((it,i)=>{
        const row=el('div','song');
        row.setAttribute('draggable', true);
        row.dataset.index=i;
        row.dataset.type=it.type;
        if(it.type==='break'){
          const container=el('div');
          container.append(el('span','handle','⋮⋮'));
          container.append(el('div','break',`${it.title} — ${it.length}m`));
          row.append(container);
        }else if(it.type==='encore'){
          const container=el('div');
          container.append(el('span','handle','⋮⋮'));
          container.append(el('div','break', (it.title||'ENCORE').toUpperCase() ));
          row.append(container);
        }else{
          const left=el('div');
          const top=el('div');
          top.append(el('span','handle','⋮⋮'));
          top.append(document.createTextNode(`${(++songNum)}. ${it.title}`));
          left.append(top);
          const metaKey = it.key ? (' • '+it.key) : '';
          const metaCapo = (Number.isInteger(it.capo) && it.capo>0) ? (' • Capo '+it.capo) : '';
          left.append(el('div','meta',`${it.artist} • ${it.length}m${metaKey}${metaCapo}`));
          const noteIn=el('input'); noteIn.placeholder='Add notes…'; noteIn.value=it.notes||'';
          // Update notes live while typing and refresh preview immediately
          noteIn.oninput=()=>{ it.notes=noteIn.value; saveAll(); buildSheet('sheetInline'); };
          noteIn.onchange=()=>{ it.notes=noteIn.value; saveAll(); buildSheet('sheetInline'); };
          noteIn.style.maxWidth='320px';
      const rm=el('button','btn danger','Remove'); rm.onclick=()=>{ setlist.splice(i,1); rebuildPreview(); saveAll(); };
          row.append(left,noteIn,rm);
        }
        box.append(row);
      });
      enableDrag();
      // Update inline preview
      buildSheet('sheetInline');
  buildTechTable(); // keep tech table in sync
  renderSongPool();
  renderEncore();
    }

    function enableDrag(){
      let dragIndex=null;
      const rows=[...document.querySelectorAll('#setList .song')];
      rows.forEach(r=>{
        r.addEventListener('dragstart',e=>{ if(r.getAttribute('draggable')==='true'){ dragIndex=parseInt(r.dataset.index,10); r.classList.add('dragging'); try{ e.dataTransfer.setData('text/x-set-index', String(dragIndex)); }catch(_){ } }});
        r.addEventListener('dragend',()=> r.classList.remove('dragging'));
        r.addEventListener('dragover',e=>{ e.preventDefault();
          // if dragging from pool, show above/below indicator
          const idRaw=e.dataTransfer.getData('text/plain');
          if(idRaw){ const rect=r.getBoundingClientRect(); const before=e.clientY < rect.top + rect.height/2; r.classList.toggle('drop-before', before); r.classList.toggle('drop-after', !before); }
        });
        r.addEventListener('dragleave',()=>{ r.classList.remove('drop-before','drop-after'); });
        r.addEventListener('drop',e=>{
          e.preventDefault();
          const to=parseInt(r.dataset.index,10);
          const fromSetIdxRaw=e.dataTransfer.getData('text/x-set-index');
          const incomingSongIdRaw=e.dataTransfer.getData('text/plain');
          // Reorder existing
          if(fromSetIdxRaw && Number.isInteger(dragIndex) && dragIndex!==to){
            const item=setlist.splice(dragIndex,1)[0];
            setlist.splice(to,0,item);
            renderSet(); saveAll();
            return;
          }
          // Insert new from pool at position (before/after based on cursor)
          if(incomingSongIdRaw){
            const id=parseInt(incomingSongIdRaw,10);
            const song=db.find(s=>s.id===id); if(!song) return;
            if(setlist.some(x=>x.id===song.id)) return;
            const rect=r.getBoundingClientRect(); const before=e.clientY < rect.top + rect.height/2;
            const insertAt = before ? to : to+1;
            // If dropping on ENCORE header, always insert after header
            if(r.dataset.type==='encore'){
              const idx=to+1; setlist.splice(idx,0,{...song,type:'song',notes:''});
            }else{
              setlist.splice(insertAt,0,{...song,type:'song',notes:''});
            }
            renderSet(); saveAll();
          }
        });
      });
    }
    

    // Preview (guarded if button exists)
    (function(){ const pb=document.getElementById('previewBtn'); if(pb){ pb.addEventListener('click', ()=>{ buildSheet('sheet'); document.getElementById('modal').classList.add('open'); }); } })();
  $('#closeModal').addEventListener('click', ()=> $('#modal').classList.remove('open'));
    $('#paperSel').addEventListener('change', ()=>{
      const sheet=$('#sheet');
      if($('#paperSel').value==='a4') sheet.classList.add('a4'); else sheet.classList.remove('a4');
    });
  // Setlist modal print opens print chooser for consistency
  document.getElementById('printSheet').addEventListener('click',()=> openPrintChooser('set'));

    function buildSheet(target='sheet'){
      const isInline = (target!=='sheet');
      const sheet = document.getElementById(target);
      const hdr = document.getElementById(isInline? 'hdrInline' : 'hdr');
      const songs = document.getElementById(isInline? 'songsInline' : 'songs');
      if(!sheet || !hdr || !songs) return;
      // Header
      hdr.innerHTML='';
      const b = gig.logo ? (function(){ const d=el('div','logo'); const img=document.createElement('img'); img.src=gig.logo; img.alt='Band Logo'; d.appendChild(img); return d; })() : el('div','band',(gig.band||'').trim()||'BAND NAME');
      const v=el('div','venue',gig.venue||'VENUE');
      const sub=el('div','sub', [gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' • '));
      const n=el('div','notes', gig.notes||'');
      // Effective header flags: if all off, show all
      const hf = (function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band && !f.venue && !f.sub && !f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.appendChild(b);
      if(hf.venue) hdr.appendChild(v);
      if(hf.sub && sub.textContent.trim()) hdr.appendChild(sub);
      if(hf.notes && gig.notes) hdr.appendChild(n);

      // Apply font selection
      const fontMap={
        'default':'Segoe UI,system-ui,-apple-system,Helvetica,Arial,sans-serif',
        'helvetica':'Helvetica, Arial, sans-serif',
        'georgia':'Georgia, Times, serif',
        'roboto-condensed':'"Roboto Condensed", Roboto, Arial, sans-serif',
        'courier':'"Courier New", Courier, monospace'
      };
      sheet.style.fontFamily = fontMap[gig.font||'default']||fontMap.default;

      // Songs
      songs.innerHTML='';
      // dynamic font scaling to fit one page
      // Start with base sizes and try to fit, shrink if overflow
  const base = { title:14, lineGap:3 };

      const lines=[];
      let sinceBreak=0;
      let songCounter=0;
      setlist.forEach((it, idx)=>{
        if(it.type==='break'){
          const br=el('div','break',`${it.title} — ${it.length}m`);
          if(sinceBreak>=15) br.classList.add('pagebreak');
          lines.push(br); sinceBreak=0; return;
        }
        if(it.type==='encore'){ const label=(it.title||'Encore'); const enc=el('div','break',label.toUpperCase()); if(sinceBreak>=15) enc.classList.add('pagebreak'); lines.push(enc); sinceBreak=0; return; }
        const row=el('div','line');
        row.append(el('div','no', String(++songCounter)));
        const title=el('div','title', shorten(it.title));
        if(it.notes){ const noteSpan=el('span','notePrint',' – '+it.notes); title.appendChild(noteSpan); }
        row.append(title);
        const keyBits=[]; if(it.key) keyBits.push(String(it.key)); if(Number.isInteger(it.capo) && it.capo>0) keyBits.push('Capo '+it.capo);
        const keyTxt = keyBits.join(' • ');
        row.append(el('div','key', keyTxt));
        row.append(el('div','time', `${it.length}m`));
        lines.push(row); sinceBreak++;
      });

      // Append, then check overflow; shrink title font until fits
      songs.append(...lines);
      fitToPage();

      // Add/update total time footer (includes songs + breaks)
      const totalMin = setlist.reduce((acc,it)=> acc + ((it.type==='song'||it.type==='break') ? (parseFloat(it.length)||0) : 0), 0);
      let totalEl = sheet.querySelector('.total-time');
      if(!totalEl){ totalEl=document.createElement('div'); totalEl.className='total-time'; sheet.appendChild(totalEl); }
      totalEl.textContent = `Total: ${totalMin.toFixed(0)}m`;
      totalEl.style.textAlign='right'; totalEl.style.marginTop='8px'; totalEl.style.fontWeight='600'; totalEl.style.fontSize='12pt';

      function fitToPage(){
        // fit within the target sheet element
        // Get available height inside sheet excluding padding already applied; rely on scrollHeight
  let tSize=16; // start slightly larger than base
        for(let i=0;i<12;i++){
          songs.style.setProperty('--t', tSize);
          Array.from(songs.querySelectorAll('.title')).forEach(d=> d.style.fontSize = tSize+'pt');
          const minor = Math.max(8, tSize-4);
          Array.from(songs.querySelectorAll('.key,.time,.no')).forEach(d=> d.style.fontSize = minor+'pt');
          if(sheet.scrollHeight<=sheet.clientHeight) return; // fits
          tSize -= 1; if(tSize<10) break; // lower bound
        }
  // If still overflowing, reduce subnotes
  let sSize=9;
        for(let i=0;i<6 && sheet.scrollHeight>sheet.clientHeight;i++){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=> d.style.fontSize = sSize+'pt');
          sSize -= 1; if(sSize<7) break;
        }
        // Reduce vertical gaps/padding progressively
        const gapSteps=['3px','2px','1px','0px'];
        for(const g of gapSteps){
          if(sheet.scrollHeight<=sheet.clientHeight) break;
          songs.style.gap=g;
          Array.from(songs.querySelectorAll('.line')).forEach(d=> d.style.padding = (g==='0px'?'0px 0':'1px 0'));
        }
        // Shrink break banners as last resort
        if(sheet.scrollHeight>sheet.clientHeight){
          let bSize=14;
          for(let i=0;i<4 && sheet.scrollHeight>sheet.clientHeight;i++){
            bSize-=1; if(bSize<10) break;
            Array.from(songs.querySelectorAll('.break')).forEach(d=>{ d.style.fontSize=bSize+'pt'; d.style.padding='4px 6px'; });
          }
        }
        // If still overflowing, elide subnotes text more aggressively
        if(sheet.scrollHeight>sheet.clientHeight){
          Array.from(songs.querySelectorAll('.subnotes')).forEach(d=>{
            if(d.textContent.length>40) d.textContent=d.textContent.slice(0,37)+'…';
          });
        }
      }
    }
    // Embedded song pool chips (Originals vs Covers) for direct drag into preview
    function renderSongPool(){
      const pO=document.getElementById('poolOriginals');
      const pC=document.getElementById('poolCovers');
      const pB=document.getElementById('poolBreaks');
      const covHdr=document.getElementById('poolCoversHdr');
      const brHdr=document.getElementById('poolBreaksHdr');
      const typeSel=document.getElementById('poolType');
      const sortSel=document.getElementById('poolSort');
      const moodSel=document.getElementById('poolMood');
      if(!pO || !pC) return;
      // Allow dropping items from set back into the pool to remove them
      [pO,pC,pB].forEach(el=>{ if(!el) return; el.addEventListener('dragover',e=> e.preventDefault()); el.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); rebuildPreview(); } } }); });
      pO.innerHTML=''; pC.innerHTML=''; if(pB) pB.innerHTML='';
      if(!db.length){ pO.textContent='No songs.'; pC.textContent=''; return; }
      const usedIds=new Set(setlist.filter(x=>x.type==='song').map(x=>x.id));
      const typeVal=(typeSel && typeSel.value) || 'all';
      const sortVal=(sortSel && sortSel.value) || 'alpha';
      const moodVal=(moodSel && moodSel.value) || 'all';

      const songMood=(s)=> s.isUpbeat? 'upbeat' : s.isHappy? 'happy' : s.isEnergetic? 'energetic' : s.isMellow? 'mellow' : s.isSad? 'sad' : ((s.customMoods||[])[0] || 'none');
      const moodRank={upbeat:0,happy:1,energetic:2,mellow:3,sad:4,none:5}; getAllMoods().forEach((m,i)=>{ if(!(m in moodRank)) moodRank[m]=6+i; });
      const moodMatch=(s)=> moodVal==='all' || songMood(s)===moodVal;
      const byAlpha=(a,b)=> a.title.localeCompare(b.title);
      const byBand=(a,b)=> (a.artist||'').localeCompare(b.artist||'') || a.title.localeCompare(b.title);
      const byMood=(a,b)=> (moodRank[songMood(a)] - moodRank[songMood(b)]) || a.title.localeCompare(b.title);
      const applySort=(arr,isCover)=>{
        if(sortVal==='band') return (isCover? arr.sort(byBand) : arr.sort(byAlpha));
        if(sortVal==='mood') return arr.sort(byMood);
        return arr.sort(byAlpha);
      };

      let originals=db.filter(s=>!s.isCover && !usedIds.has(s.id) && moodMatch(s));
      let covers=db.filter(s=>s.isCover && !usedIds.has(s.id) && moodMatch(s));
      originals=applySort(originals,false);
      covers=applySort(covers,true);

      // Toggle visibility based on type filter
      const showOriginals = typeVal==='all' || typeVal==='originals';
      const showCovers    = typeVal==='all' || typeVal==='covers';
      pO.style.display = showOriginals? 'flex':'none';
      if(covHdr) covHdr.style.display = showCovers? '' : 'none';
      pC.style.display = showCovers? 'flex':'none';
      if(brHdr) brHdr.style.display=''; if(pB) pB.style.display='flex'; // always show break section

      const hueFromStr=(str)=>{ let h=0; for(let i=0;i<str.length;i++){ h=(h*31 + str.charCodeAt(i))>>>0; } return h%360; };
      const makeChip=(s)=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.setAttribute('draggable','true'); chip.style.cursor='grab'; chip.dataset.id=s.id;
        const moodClass = s.isUpbeat ? 'mood-upbeat'
          : s.isHappy ? 'mood-happy'
          : s.isEnergetic ? 'mood-energetic'
          : s.isMellow ? 'mood-mellow'
          : s.isSad ? 'mood-sad'
          : ((s.customMoods||[]).length ? 'mood-custom' : '');
        if(moodClass) chip.classList.add(moodClass);
        // Custom mood color (use first custom mood)
        if(!s.isUpbeat && !s.isHappy && !s.isEnergetic && !s.isMellow && !s.isSad && (s.customMoods||[]).length){
          const key=(s.customMoods||[])[0]; const h=hueFromStr(key);
          chip.style.backgroundColor = `hsl(${h} 90% 95%)`;
          chip.style.borderColor = `hsl(${h} 60% 80%)`;
          chip.style.color = '#0f172a';
        }
        const showArtist = s.isCover && s.artist && s.artist!=='Original';
        chip.textContent = showArtist ? `${s.artist} - ${s.title}` : s.title;
        chip.title=`${s.artist} • ${s.length}m${s.key? ' • '+s.key:''}`;
        chip.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/plain', String(s.id)); });
        chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; activePoolTouch={kind:'song', id:s.id, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); }, {passive:false});
        chip.addEventListener('touchend',()=> chip.classList.remove('drag-touch'));
        return chip;
      };
      if(showOriginals){
        if(!originals.length) pO.textContent = 'No songs.'; else originals.forEach(s=> pO.appendChild(makeChip(s)));
      }
      if(showCovers){
        if(!covers.length) pC.textContent = showOriginals? '' : 'No songs.'; else covers.forEach(s=> pC.appendChild(makeChip(s)));
      }
      if(pB){
        const len = parseFloat((document.getElementById('gBreakLen') && document.getElementById('gBreakLen').value) || gig.breakLen || 15);
        const makeEventChip=(label, kind, hint='')=>{
          const chip=document.createElement('div'); chip.className='pill'; chip.style.cursor='grab'; chip.setAttribute('draggable','true'); chip.textContent= hint? `${label} (${hint})` : label;
          chip.addEventListener('dragstart',e=>{ if(kind==='break'){ e.dataTransfer.setData('text/x-break', String(len)); } else { e.dataTransfer.setData('text/x-event', JSON.stringify({kind})); } });
          chip.addEventListener('touchstart',ev=>{ const t=ev.touches[0]; if(!t) return; const payload=(kind==='break')? {kind:'break', length:len} : {kind:'event', event:{kind}}; activePoolTouch={...payload, startX:t.clientX, startY:t.clientY, x:t.clientX, y:t.clientY}; chip.classList.add('drag-touch'); ev.preventDefault(); }, {passive:false});
          chip.addEventListener('touchend',()=> chip.classList.remove('drag-touch'));
          return chip;
        };
        pB.appendChild(makeEventChip(`Break (${len}m)`, 'break'));
        pB.appendChild(makeEventChip('SOUNDCHECK', 'soundcheck'));
        pB.appendChild(makeEventChip('ENCORE', 'encore'));
        pB.appendChild(makeEventChip('INTERMISSION', 'intermission'));
        pB.appendChild(makeEventChip('ANNOUNCEMENT', 'announcement'));
        pB.appendChild(makeEventChip('CUSTOM…', 'custom'));
      }
    }
    function renderEncore(){
      const enc=document.getElementById('encoreList'); if(!enc) return; enc.innerHTML='';
      const idxHeader=setlist.findIndex(x=>x.type==='encore');
      if(idxHeader===-1){ enc.textContent='(none)'; return; }
      const encoreSongs=setlist.slice(idxHeader+1).filter(x=>x.type==='song');
      if(!encoreSongs.length){ enc.textContent='(none)'; return; }
      encoreSongs.forEach(s=>{
        const chip=document.createElement('div'); chip.className='pill'; chip.textContent=s.title; chip.title=`${s.artist} • ${s.length}m`; const rm=document.createElement('button'); rm.className='add'; rm.textContent='Remove'; rm.onclick=()=>{ // remove only this encore song
          const pos=setlist.findIndex(x=>x.id===s.id && x.type==='song'); if(pos>-1){
            setlist.splice(pos,1);
            // If encore header becomes orphaned (no songs after it), remove just that header
            if(idxHeader>-1){ const anyAfter=setlist.slice(idxHeader+1).some(x=>x.type==='song'); if(!anyAfter){ setlist.splice(idxHeader,1); } }
            rebuildPreview(); saveAll();
          }
        }; chip.appendChild(rm); enc.appendChild(chip);
      });
    }
    // New drop handling directly on preview songs area
    const previewSongs=document.getElementById('songsInline');
    function rebuildPreview(){ buildSheet('sheetInline'); attachPreviewInteractions(); saveAll(); }
    function attachPreviewInteractions(){
      if(!previewSongs) return;
      // Mark lines and breaks draggable
      previewSongs.querySelectorAll('.line, .break').forEach((row,i)=>{
        row.setAttribute('draggable','true');
        row.addEventListener('dragstart',e=>{ e.dataTransfer.setData('text/x-set-index', String(i)); });
        // Double-click to edit notes (only songs)
        if(row.classList.contains('line')){
          const titleDiv=row.querySelector('.title');
          if(titleDiv){ titleDiv.addEventListener('dblclick',()=>{
            const entry=setlist[i]; if(!entry || entry.type!=='song') return; const val=prompt('Notes for '+entry.title, entry.notes||''); if(val!=null){ entry.notes=val.trim(); rebuildPreview(); }
          }); }
        }
      });
    }
    if(previewSongs){
      previewSongs.addEventListener('dragover',e=> e.preventDefault());
      previewSongs.addEventListener('drop',e=>{
        e.preventDefault(); e.stopPropagation(); const br=e.dataTransfer.getData('text/x-break');
        const allRows=[...previewSongs.querySelectorAll('.line, .break')];
        const getInsertIndex=(clientY)=>{ for(let i=0;i<allRows.length;i++){ const r=allRows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return allRows.length; };
        const insertAt=getInsertIndex(e.clientY);
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const idRaw=e.dataTransfer.getData('text/plain'); const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ // reorder existing
          const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= fromIdx<insertAt? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); }
          return;
        }
        if(!idRaw) return; if(idRaw==='__break__') return; const id=parseInt(idRaw,10); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    }
    // Allow dropping anywhere on the page area (sheet background/whitespace), including when blank
    const sheetInline=document.getElementById('sheetInline');
    if(sheetInline){
      sheetInline.addEventListener('dragover',e=> e.preventDefault());
      sheetInline.addEventListener('drop',e=>{
        e.preventDefault();
        // If drop hit songs container, the other handler already handled; but duplicate logic is harmless
        const rowsCont=previewSongs;
        const allRows= rowsCont ? [...rowsCont.querySelectorAll('.line, .break')] : [];
        const getInsertIndex=(clientY)=>{ if(!allRows.length) return 0; for(let i=0;i<allRows.length;i++){ const r=allRows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return allRows.length; };
        const insertAt=getInsertIndex(e.clientY);
        const br=e.dataTransfer.getData('text/x-break');
        if(br){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); return; }
        const evJson=e.dataTransfer.getData('text/x-event');
        if(evJson){
          try{
            const payload=JSON.parse(evJson);
            const kind=payload.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length;
              const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview(); return;
            }
            const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
            if(kind==='soundcheck' || kind==='intermission' || kind==='announcement' || kind==='custom'){
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview(); return;
            }
          }catch(_){ /* ignore malformed */ }
        }
        const fromIdxRaw=e.dataTransfer.getData('text/x-set-index');
        if(fromIdxRaw){ const fromIdx=parseInt(fromIdxRaw,10); if(Number.isInteger(fromIdx) && fromIdx>=0 && fromIdx<setlist.length){ const item=setlist.splice(fromIdx,1)[0]; const adj= fromIdx<insertAt? insertAt-1 : insertAt; setlist.splice(adj,0,item); rebuildPreview(); } return; }
        const idRaw=e.dataTransfer.getData('text/plain'); if(!idRaw || idRaw==='__break__') return; const id=parseInt(idRaw,10); const song=db.find(s=>s.id===id); if(!song) return; if(setlist.some(x=>x.id===song.id)) return; setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview();
      });
    }
    // Pool open/close and drop-to-remove
    const openPoolBtn=document.getElementById('openPool');
    const closePoolBtn=document.getElementById('closePool');
    const poolFly=document.getElementById('songPoolFlyout');
    const poolCol=document.getElementById('poolCol');
    function positionPool(){
      if(!poolFly) return;
      const setCard=document.getElementById('set'); if(!setCard) return;
      const rect=setCard.getBoundingClientRect();
      const left=Math.min(window.innerWidth - poolFly.offsetWidth - 12, rect.right + 12);
      const top=Math.max(12, rect.top);
      poolFly.style.left=left+"px"; poolFly.style.top=top+"px";
      poolFly.style.right=""; // ensure left-based positioning
      poolFly.style.height = Math.min(window.innerHeight - top - 20, 720) + 'px';
    }
    // Removed openPool button usage (embedded pool); keep flyout logic if still present elsewhere
    if(closePoolBtn && poolFly){ closePoolBtn.addEventListener('click',()=> poolFly.classList.remove('open')); }
    window.addEventListener('scroll',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); }, {passive:true});
    window.addEventListener('resize',()=>{ if(poolFly && poolFly.classList.contains('open')) positionPool(); });
    if(poolFly){
      poolFly.addEventListener('dragover',e=> e.preventDefault());
      poolFly.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); // remove ONLY dragged item
        // If encore header now orphaned (no songs after it) remove header only
        const encIdx=setlist.findIndex(x=>x.type==='encore'); if(encIdx>-1){ const anyAfter=setlist.slice(encIdx+1).some(x=>x.type==='song'); if(!anyAfter){ setlist.splice(encIdx,1); } }
        rebuildPreview(); saveAll(); }
        }
      });
    }
    // Also allow dropping onto the embedded pool column to remove from set
    if(poolCol){
      poolCol.addEventListener('dragover',e=> e.preventDefault());
      poolCol.addEventListener('drop',e=>{ e.preventDefault(); const idxRaw=e.dataTransfer.getData('text/x-set-index'); if(idxRaw){ const idx=parseInt(idxRaw,10); if(Number.isInteger(idx) && idx>=0 && idx<setlist.length){ setlist.splice(idx,1); rebuildPreview(); } } });
    }
    // Initial pool render (kept ready; open with button)
    // Hook pool controls if present
    const poolType=document.getElementById('poolType');
    const poolSort=document.getElementById('poolSort');
    const poolMood=document.getElementById('poolMood');
    if(poolType) poolType.addEventListener('change', renderSongPool);
    if(poolSort) poolSort.addEventListener('change', renderSongPool);
    if(poolMood) poolMood.addEventListener('change', renderSongPool);
    renderSongPool();

    // Hook DB controls
    (function(){
      const tSel=document.getElementById('dbType');
      const sSel=document.getElementById('dbSort');
      const mSel=document.getElementById('dbMood');
      const addBtn=document.getElementById('addMoodBtn');
      if(tSel) tSel.addEventListener('change', renderDB);
      if(sSel) sSel.addEventListener('change', renderDB);
      if(mSel) mSel.addEventListener('change', renderDB);
      if(addBtn) addBtn.addEventListener('click', ()=>{
        const name = prompt('New mood name (max 16 chars).'); if(name==null) return; const n=name.trim(); if(!n){ return; }
        const key=n.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim().replace(/\s+/g,'-');
        const all=getAllMoods(); if(all.length>=12){ alert('Max 12 moods reached.'); return; }
        if(DEFAULT_MOODS.includes(key) || (gig.customMoods||[]).includes(key)){ alert('Mood already exists.'); return; }
        gig.customMoods = gig.customMoods || []; gig.customMoods.push(key);
        saveAll();
        // Rebuild DB mood filter select with custom
        if(mSel){
          const cur=mSel.value; mSel.innerHTML='<option value="all">All</option>' + getAllMoods().map(k=>`<option value="${k}">${moodLabel(k)}</option>`).join('');
          if([...mSel.options].some(o=>o.value===cur)) mSel.value=cur;
        }
        renderAddMoodsUI();
        renderDB(); renderSongPool();
      });
      // hydrate mood filter options with any custom moods
      if(mSel){
        const cur=mSel.value; mSel.innerHTML='<option value="all">All</option>' + getAllMoods().map(k=>`<option value="${k}">${moodLabel(k)}</option>`).join('');
        if([...mSel.options].some(o=>o.value===cur)) mSel.value=cur;
      }
    })();
      // Simplified touch drag for preview-only interface
      let activePoolTouch=null;
      window.addEventListener('touchmove',ev=>{ if(!activePoolTouch) return; const t=ev.touches[0]; if(!t) return; activePoolTouch.x=t.clientX; activePoolTouch.y=t.clientY; ev.preventDefault(); }, {passive:false});
      window.addEventListener('touchend',ev=>{
        if(!activePoolTouch) return; const x=activePoolTouch.x, y=activePoolTouch.y; const preview=document.getElementById('songsInline');
        if(preview){ const rect=preview.getBoundingClientRect(); if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){
          const rows=[...preview.querySelectorAll('.line, .break')];
          const getInsertIndex=(clientY)=>{ for(let i=0;i<rows.length;i++){ const r=rows[i].getBoundingClientRect(); if(clientY < (r.top + r.height/2)) return i; } return rows.length; };
          const insertAt=getInsertIndex(y);
          if(activePoolTouch.kind==='song'){ const song=db.find(s=>s.id===activePoolTouch.id); if(song && !setlist.some(sl=>sl.id===song.id)){ setlist.splice(insertAt,0,{...song,type:'song',notes:''}); rebuildPreview(); } }
          else if(activePoolTouch.kind==='break'){ const lenInput=document.getElementById('gBreakLen'); const len=parseFloat(lenInput && lenInput.value)||gig.breakLen||15; setlist.splice(insertAt,0,{type:'break',title:'Break',length:len}); rebuildPreview(); }
          else if(activePoolTouch.kind==='event'){
            const kind = activePoolTouch.event && activePoolTouch.event.kind;
            if(kind==='encore'){
              const count=setlist.filter(x=>x.type==='encore').length; const title = count>=1? `Encore ${count+1}` : 'Encore';
              setlist.splice(insertAt,0,{type:'encore',title}); rebuildPreview();
            }else if(kind){
              const ask=(q,def='')=>{ const v=prompt(q, def); if(v==null) return null; const t=v.trim(); return t; };
              let baseLabel = (kind==='soundcheck')? 'SOUNDCHECK' : (kind==='intermission')? 'INTERMISSION' : (kind==='announcement')? 'ANNOUNCEMENT' : '';
              if(kind==='custom'){
                const name=ask('Event name? (e.g., Raffle)'); if(name==null || !name){ return; } baseLabel = name.trim();
              }
              const time=ask('Time? (optional, e.g., 7:00pm)',''); if(time===null) return; const timePart = time? (' '+time) : '';
              const defDur = (kind==='announcement')? '5' : '30';
              const durStr=ask('Duration (minutes)?', defDur); if(durStr===null) return; const dur=parseFloat(durStr)||0;
              setlist.splice(insertAt,0,{type:'break',title: (baseLabel+timePart).trim(), length: Math.max(0, dur)});
              rebuildPreview();
            }
          }
        } }
        activePoolTouch=null;
      });
      // Touch reorder legacy removed – interactions handled via standard drag & drop in preview.

  // Tech / Stage: Tech Rider table generation synced to setlist (populates inline or fullscreen as available)
    function buildTechTable(){
      const body=$('#techBody'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    function buildTechTableFull(){
      const body=document.getElementById('techBodyFull'); if(!body) return; body.innerHTML='';
      const items=setlist.filter(x=>x.type==='song');
      items.forEach((s,idx)=>{
        const tr=document.createElement('tr');
        const td1=document.createElement('td'); td1.textContent=String(idx+1);
        const td2=document.createElement('td'); td2.textContent=s.title;
        const td3=document.createElement('td');
        const inp=document.createElement('input'); inp.style.width='100%'; inp.placeholder='Lighting/FX notes (e.g., Blue fade to orange, delays in chorus)';
        inp.value=techNotes[s.id]||''; inp.onchange=()=>{ techNotes[s.id]=inp.value; s.tech=inp.value; saveAll(); };
        td3.appendChild(inp);
        tr.append(td1,td2,td3); body.appendChild(tr);
      });
    }

    // Stage Plot: simple B&W draggable glyphs
    const TOOLBOX=[
  {key:'mic', label:'Vocal Mic', svg:'M0 0 h16 v48 h-16z M8 48 a8 8 0 1 0 0.01 0'},
  {key:'monitor', label:'Monitor', svg:'M0 44 l36 -18 v18 l-36 18z'},
  {key:'guitar', label:'Electric Guitar', svg:'M0 0 h16 v32 h-16z M16 10 l30 -8 l3 10 l-30 8z'},
  {key:'bassamp', label:'Bass Amp', svg:'M0 0 h34 v44 h-34z'},
  {key:'keyboard', label:'Keyboard', svg:'M0 0 h60 v16 h-60z M3 2 v12 M8 2 v12 M13 2 v12 M18 2 v12 M23 2 v12 M28 2 v12 M33 2 v12 M38 2 v12 M43 2 v12 M48 2 v12 M53 2 v12 M58 2 v12'},
  {key:'drums', label:'Drums', svg:'M15 20 a14 10 0 1 0 0.01 0 M42 20 a14 10 0 1 0 0.01 0 M28 34 a10 7 0 1 0 0.01 0'},
  {key:'di', label:'DI Box', svg:'M0 0 h40 v18 h-40z'},
      {key:'gtramp', label:'Guitar Amp', svg:'M0 0 h34 v44 h-34z'},
      {key:'label', label:'Custom Label', custom:'label'},
      {key:'rect', label:'Rectangle', custom:'rect'},
    ];

    // Image-based toolbox items (replace emojis)
    // Files must exist alongside index.html
    const ICON_ITEMS=[
      {key:'acoustic', label:'Acoustic', src:'Acoustic.png'},
      {key:'banjo', label:'Banjo', src:'Banjo.png'},
      {key:'bass', label:'Bass', src:'Bass.png'},
      {key:'bassamp', label:'Bass Amp', src:'Bassamp.png'},
      {key:'bongoes', label:'Bongoes', src:'Bongoes.png'},
      {key:'clarinet', label:'Clarinet', src:'Clarinet.png'},
      {key:'combo', label:'Gtr Combo', src:'Combo.png'},
      {key:'congas', label:'Congas', src:'Congas.png'},
      {key:'crash', label:'Crash', src:'Crash.png'},
      {key:'cymbal1', label:'Cymbal', src:'Cymbal_1.png'},
      {key:'cymbal2', label:'Cymbal', src:'Cymbal_2.png'},
      {key:'deck', label:'Deck', src:'Deck.png'},
      {key:'di', label:'DI', src:'DI.png'},
      {key:'electric', label:'Electric', src:'Electric.png'},
      {key:'fan', label:'Fan', src:'Fan.png'},
      {key:'hihat', label:'Hi-hat', src:'Hihat.png'},
      {key:'hihat2', label:'Hi-hat', src:'Hihat_2.png'},
      {key:'kick', label:'Kick', src:'Kick.png'},
      {key:'laptop', label:'Laptop', src:'Laptop.png'},
      {key:'monitor', label:'Monitor', src:'Monitor.png'},
  {key:'overhead', label:'Instrument Mic', src:'Overhead.png'},
      {key:'snare', label:'Snare', src:'Snare.png'},
      {key:'power', label:'Power', src:'Power.png'},
      {key:'sampler', label:'Sampler', src:'Sampler.png'},
      {key:'stack', label:'Amp Stack', src:'Stack.png'},
      {key:'tom', label:'Tom', src:'Tom.png'},
      {key:'floor', label:'Floor Tom', src:'Floor.png'},
      {key:'stereoPair', label:'Stereo Pair', src:'Stereo%20Pair.png'},
      {key:'stool', label:'Stool', src:'Stool.png'},
      {key:'table', label:'Table', src:'Table.png'},
      {key:'tipjar', label:'Tip Jar', src:'Tipjar.png'},
      {key:'violin', label:'Violin', src:'Violin.png'},
      {key:'vocal', label:'Vocal Mic', src:'Vocal%20Mic.png'},
    ];

    // Type mapping for routing logic
    const TYPE_MAP={
      acoustic:'acoustic', banjo:'acoustic', violin:'acoustic',
      electric:'electric', combo:'amp', stack:'amp', bassamp:'amp', bass:'electric',
      vocal:'mic', overhead:'mic', stereoPair:'mic', hihat:'drum', hihat2:'drum', kick:'drum', snare:'drum', tom:'drum', floor:'drum', crash:'drum', cymbal1:'drum', cymbal2:'drum', bongoes:'drum', congas:'drum',
      deck:'deck', sampler:'sampler', laptop:'sampler',
      di:'di',
      monitor:'monitor',
      power:'utility', fan:'utility', table:'utility', stool:'utility', tipjar:'utility'
    };

    // Allowed routing targets by source type (routeTo). 'channel' is represented by selecting a channel directly, not via routeTo.
    const ROUTE_TARGETS={
      drum:['mic','channel'], // drums can go to instrument/vocal/stereo mic or direct channel (kick/snare often direct)
      mic:['channel'], // mic feeds channel only (no DI after mic)
      di:['channel'],
      fx:['di','channel'],
      amp:['mic','di'], // amps -> mic or DI
      acoustic:['di','mic'], // must pass through mic or DI first (no direct channel)
      electric:['fx','amp','di','channel'],
      deck:['fx','di','channel'],
      sampler:['fx','di','channel'],
      // wind & hand percussion treated under acoustic/drum already; ensure explicit mapping if custom types emerge
    };

    // Effective per-node targets (adds key-specific rules, e.g., bass amp can go direct to channel)
    function effectiveTargets(node){
      const base=(ROUTE_TARGETS[node.dataset.type||'other']||[]).slice();
      const key=node.dataset.key||'';
      if((node.dataset.type||'')==='amp'){
        if(key==='bassamp'){ // bass amps can feed DI or mic or direct channel (via built-in DI out)
          if(!base.includes('di')) base.push('di');
          if(!base.includes('mic')) base.push('mic');
          if(!base.includes('channel')) base.push('channel');
        } else { // guitar amps must only go to mics
          return ['mic'];
        }
      }
      return base;
    }

    // Items considered processors (appear prioritized at top of legend)
    const PRIORITY_TYPES=new Set(['di','fx','amp','sampler']);

    function buildTools(){
      ['stageTools','stageToolsFull'].forEach(cid=>{
        const tools=document.getElementById(cid);
        if(tools){
          tools.innerHTML='';
          ICON_ITEMS.forEach(t=>{
            const b=document.createElement('button');
            b.className='tool';
            b.innerHTML=`<img src="${t.src}" alt="${t.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${t.label}`;
            b.setAttribute('draggable','true');
            b.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', t.key); });
            // Touch drag support: begin a simulated drag sequence
            b.addEventListener('touchstart',ev=>{
              const touch=ev.touches[0]; if(!touch) return;
              activeToolTouch={ key:t.key, x:touch.clientX, y:touch.clientY };
              ev.preventDefault();
            }, {passive:false});
            tools.appendChild(b);
          });
          // Append custom uploaded images (thumbnails) only to full toolbox
          if(cid==='stageToolsFull'){
            (gig.customImages||[]).forEach(imgObj=>{
              const wrap=document.createElement('div'); wrap.style.position='relative';
              const b=document.createElement('button'); b.className='tool'; b.style.paddingRight='26px';
              b.innerHTML=`<img src="${imgObj.data}" alt="${imgObj.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${imgObj.label}`;
              b.setAttribute('draggable','true'); b.dataset.key=imgObj.key;
              b.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', imgObj.key); });
              b.style.touchAction='none';
              b.addEventListener('touchstart',ev=>{ const touch=ev.touches[0]; if(!touch) return; activeToolTouch={ key:imgObj.key, x:touch.clientX, y:touch.clientY }; ev.preventDefault(); }, {passive:false});
              const del=document.createElement('button'); del.textContent='×'; del.title='Remove'; del.style.position='absolute'; del.style.top='2px'; del.style.right='2px'; del.style.width='20px'; del.style.height='20px'; del.style.lineHeight='16px'; del.style.padding='0'; del.style.fontSize='14px'; del.style.background='#dc2626'; del.style.color='#fff'; del.style.border='none'; del.style.borderRadius='4px'; del.style.cursor='pointer';
              del.addEventListener('click',()=>{ if(!confirm('Delete custom icon?')) return; gig.customImages = (gig.customImages||[]).filter(ci=>ci.key!==imgObj.key); saveAll(); buildTools(); rebuildCustomImages(); });
              wrap.appendChild(b); wrap.appendChild(del); tools.appendChild(wrap);
            });
          }
        }
      });
    }
    buildTools();

    let _suppressBgClick=false;
    // Ensure arrow marker exists in SVG for arrow drawing
    function ensureStageMarkers(svg){ if(!svg) return; let defs=svg.querySelector('defs'); if(!defs){ defs=document.createElementNS('http://www.w3.org/2000/svg','defs'); svg.insertBefore(defs, svg.firstChild); }
      if(!svg.querySelector('marker#arrowHead')){
        const m=document.createElementNS('http://www.w3.org/2000/svg','marker'); m.setAttribute('id','arrowHead'); m.setAttribute('markerWidth','8'); m.setAttribute('markerHeight','8'); m.setAttribute('refX','8'); m.setAttribute('refY','3'); m.setAttribute('orient','auto');
        const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d','M0,0 L8,3 L0,6 Z'); p.setAttribute('fill','#000'); m.appendChild(p); defs.appendChild(m);
      }
    }

    function refreshStageHeader(){
      const text=`${(gig.band||'Band').trim()} • ${(gig.date||'Date')}`;
      const elT=document.getElementById('stageTitle'); if(elT) elT.textContent=text;
      const elTF=document.getElementById('stageTitleFull'); if(elTF) elTF.textContent=text;
    }

    // Note: small stage removed; glyphs are added via fullscreen only

    let _nextStageId=1;
    function addGlyphFull(key, at){
      const iconSpec=ICON_ITEMS.find(x=>x.key===key);
      const customSpec=(gig.customImages||[]).find(ci=>ci.key===key);
      const svg=document.getElementById('stageSvgFull');
      const g=document.createElementNS('http://www.w3.org/2000/svg','g');
      const x = (at && typeof at.x==='number') ? at.x : 100, y = (at && typeof at.y==='number') ? at.y : 120;
      // Compute initial scale so the visible icon is ~100px wide on screen
      const vbw = (svg && svg.viewBox && svg.viewBox.baseVal && svg.viewBox.baseVal.width) ? svg.viewBox.baseVal.width : 1500;
      const pxPerUnit = svg ? (svg.getBoundingClientRect().width / vbw) : (1000/1500);
      const targetPx = 100; const baseUnits = 60; // image width set below
      let initScale = targetPx / (baseUnits * Math.max(0.01, pxPerUnit));
      initScale = Math.max(0.3, Math.min(5, initScale));
      g.dataset.x=String(x); g.dataset.y=String(y); g.dataset.scale=String(initScale);
      g.dataset.key=key; g.dataset.channel=g.dataset.channel||'';
      g.dataset.id=String(_nextStageId++);
      const type=TYPE_MAP[key]||'other';
      g.dataset.type=type;
      g.dataset.showLabel='0'; // default hidden
      g.setAttribute('data-draggable','1');
      // Auto-assign next channel for common sources (drums, mics)
      const autoTypes=new Set(['drum','mic']);
      const canChannel=(ROUTE_TARGETS[type]||[]).includes('channel');
      if(autoTypes.has(type) && canChannel){
        const existing=getStageGroups();
        const assigned=existing.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
        const next=(assigned.length? Math.max(...assigned):0)+1;
        g.dataset.channel=String(next);
      }
      if(customSpec){
        const img=document.createElementNS('http://www.w3.org/2000/svg','image');
        img.setAttribute('href', customSpec.data);
        img.setAttributeNS('http://www.w3.org/1999/xlink','href', customSpec.data);
        img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=customSpec.label; label.style.display='none'; g.appendChild(label);
        // Removed intrinsic autoscale override; initial scale already targets ~100px visual size.
      } else if(iconSpec){
        // Place icon image centered; no background rectangle (transparent icons expected)
  const img=document.createElementNS('http://www.w3.org/2000/svg','image');
  // set both href and xlink:href for compatibility
  img.setAttribute('href', iconSpec.src);
  img.setAttributeNS('http://www.w3.org/1999/xlink','href', iconSpec.src);
  img.setAttribute('x','-30'); img.setAttribute('y','-30'); img.setAttribute('width','60'); img.setAttribute('height','60');
        img.setAttribute('preserveAspectRatio','xMidYMid meet');
        g.appendChild(img);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','70'); label.setAttribute('font-size','16'); label.setAttribute('text-anchor','middle'); label.setAttribute('data-role','label'); label.textContent=iconSpec.label;
        label.style.display='none';
        g.appendChild(label);
      }else{
        const spec=TOOLBOX.find(x=>x.key===key); if(!spec) return;
        const path=document.createElementNS('http://www.w3.org/2000/svg','path');
        path.setAttribute('d', toPath(spec.svg));
        path.setAttribute('fill','none');
        path.setAttribute('stroke','#000');
        path.setAttribute('stroke-width','2');
        g.appendChild(path);
        const label=document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x','0'); label.setAttribute('y','58'); label.setAttribute('font-size','14'); label.setAttribute('data-role','label'); label.textContent=spec.label;
        label.style.display='none';
        g.appendChild(label);
      }
      applyTransform(g);
      svg.appendChild(g);
      enableSvgDrag(g);
      selectNode(g); // immediately select newly added item for quick edits
      // focus name field so user can rename right away
      const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); if(nameInp.select) nameInp.select(); }
      refreshStageLegend(); saveAll();
    }

    function toPath(simple){
      // simple mini-language passthrough for small glyphs (already path commands)
      return simple;
    }

    function enableSvgDrag(node){
      // initialize dataset from existing transform if missing
      initDatasetFromTransform(node);
      let start=null; let orig=null;
      node.addEventListener('mousedown',e=>{ if(e.button===2){ return; } start={x:e.clientX,y:e.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; document.addEventListener('mousemove',move); document.addEventListener('mouseup',up); e.preventDefault(); selectNode(node); });
  function move(e){ if(!start) return; var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(e.clientX-start.x)/zoom, dy=(e.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } }
      function up(){ start=null; document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); saveAll(); }
      // rename on double click
      node.addEventListener('dblclick',()=>{
        const txt=findText(node); if(!txt) return; const nv=prompt('Rename item:', txt.textContent||''); if(nv!=null){ txt.textContent=nv; syncInspectorFrom(node); saveAll(); }
      });
      // Touch drag
      let touchId=null;
      node.addEventListener('touchstart',e=>{
        if(touchId!=null) return; const t=e.touches[0]; if(!t) return; touchId=t.identifier; start={x:t.clientX,y:t.clientY}; orig={x:parseFloat(node.dataset.x||'0'), y:parseFloat(node.dataset.y||'0')}; selectNode(node); e.preventDefault();
      }, {passive:false});
      node.addEventListener('touchmove',e=>{
        if(touchId==null) return; for(const t of e.touches){ if(t.identifier===touchId){ var zEl=document.getElementById('stageZoom'); const zoom=parseFloat((zEl&&zEl.value)||'1'); const dx=(t.clientX-start.x)/zoom, dy=(t.clientY-start.y)/zoom; node.dataset.x=String((orig.x||0)+dx); node.dataset.y=String((orig.y||0)+dy); applyTransform(node); const svg=node.closest('svg'); if(svg && svg.id==='stageSvgFull'){ refreshCables(svg); } e.preventDefault(); break; } }
      }, {passive:false});
      node.addEventListener('touchend',e=>{
        if(touchId==null) return; let still=false; for(const t of e.touches){ if(t.identifier===touchId){ still=true; break; } } if(!still){ touchId=null; saveAll(); }
      });
      node.addEventListener('touchcancel',()=>{ if(touchId!=null){ touchId=null; saveAll(); }});
    }

    // Right-click cable drag connection gesture
    (function setupCableDrag(){
      const svg=document.getElementById('stageSvgFull'); if(!svg) return;
      let cableDrag=null; // {source, x1,y1, line}
      function clientToSvg(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      svg.addEventListener('contextmenu',e=>{ if(e.target.closest('svg#stageSvgFull')){ e.preventDefault(); }});
      svg.addEventListener('mousedown',e=>{
        if(e.button!==2) return; // only right-click
        const g=e.target.closest && e.target.closest('g[data-draggable]');
        if(!g) return; e.preventDefault();
        const p=clientToSvg(e.clientX,e.clientY);
        const line=document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', p.x); line.setAttribute('y1', p.y); line.setAttribute('x2', p.x); line.setAttribute('y2', p.y);
        line.setAttribute('stroke','#000'); line.setAttribute('stroke-width','2'); line.setAttribute('stroke-dasharray','6,4'); line.setAttribute('data-temp','cable');
        svg.appendChild(line);
        cableDrag={source:g, x1:p.x, y1:p.y, line:line};
        document.addEventListener('mousemove',onMove);
        document.addEventListener('mouseup',onUp);
      });
      function onMove(e){ if(!cableDrag) return; const p=clientToSvg(e.clientX,e.clientY); cableDrag.line.setAttribute('x2',p.x); cableDrag.line.setAttribute('y2',p.y); }
      function onUp(e){ if(!cableDrag) return; document.removeEventListener('mousemove',onMove); document.removeEventListener('mouseup',onUp);
        const line=cableDrag.line; const source=cableDrag.source; line.remove();
        // determine drop target
        const el=document.elementFromPoint(e.clientX,e.clientY);
        const target= el && el.closest && el.closest('g[data-draggable]');
        if(target && target!==source){
          const sAllowed=effectiveTargets(source); const tAllowed=effectiveTargets(target);
          if(sAllowed.includes(target.dataset.type||'other')){ source.dataset.routeTo=target.dataset.id; }
          else if(tAllowed.includes(source.dataset.type||'other')){ target.dataset.routeTo=source.dataset.id; }
          saveAll(); refreshStageLegend();
        }
        cableDrag=null;
      }
    })();

    function initDatasetFromTransform(node){
      if(node.dataset.x && node.dataset.y) return;
      const m=node.transform.baseVal.consolidate();
      const t=m? m.matrix : {e:0,f:0,a:1,d:1};
      node.dataset.x=String(t.e||0);
      node.dataset.y=String(t.f||0);
      // scale approx from matrix a/d
      const s=(t.a&&t.d)? Math.max(1e-3, Math.sqrt(Math.abs(t.a*t.d))) : 1;
      node.dataset.scale=String(s);
      applyTransform(node);
    }

    function applyTransform(node){
      const x=parseFloat(node.dataset.x||'0');
      const y=parseFloat(node.dataset.y||'0');
      const s=parseFloat(node.dataset.scale||'1');
      node.setAttribute('transform',`translate(${x},${y}) scale(${s})`);
    }

  function findText(node){ return node.querySelector('text[data-role="label"]') || node.querySelector('text'); }

    // selection + inspector
    let selectedNode=null;
    function bindSelection(svg){
        svg.addEventListener('click',ev=>{
          const g=ev.target.closest && ev.target.closest('g[data-draggable]');
          if(g){ selectNode(g); refreshStageLegend(); return; }
          // click on whitespace creates a text label at click position
          const bg=ev.target.closest && ev.target.closest('.stage-bg');
          if(bg){
            if(_suppressBgClick){ _suppressBgClick=false; ev.stopPropagation(); return; }
            const pt=svg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=svg.getScreenCTM().inverse(); const p=pt.matrixTransform(ctm);
            // Ask first; cancel or empty -> do nothing
            let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
            const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(p.x)); gN.dataset.y=String(Math.round(p.y)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
            const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
            applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll();
            const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); }
            ev.stopPropagation();
            return;
          }
          selectNode(null); refreshStageLegend();
        });
    }
  function ensureSelectionBindings(){ const svg=document.getElementById('stageSvgFull'); if(svg && !svg._boundSel){ bindSelection(svg); svg._boundSel=true; } }
    function selectNode(g){
      if(selectedNode) selectedNode.classList.remove('selected');
      selectedNode=g;
      const nameInp=document.getElementById('selName');
      const sizeInp=document.getElementById('selSize');
      
        const showLabelChk=document.getElementById('selShowLabel');
      if(!nameInp||!sizeInp) return;
      if(!g){ nameInp.value=''; sizeInp.value='1'; return; }
      g.classList.add('selected');
      initDatasetFromTransform(g);
      const txt=findText(g); nameInp.value=txt? (txt.textContent||'') : '';
      sizeInp.value=g.dataset.scale||'1';
        if(showLabelChk){ showLabelChk.checked = g.dataset.showLabel==='1'; }
      
    }
    function syncInspectorFrom(g){ if(!g) return; const nameInp=document.getElementById('selName'); const sizeInp=document.getElementById('selSize'); if(nameInp){ const txt=findText(g); nameInp.value=txt? (txt.textContent||'') : ''; } if(sizeInp){ sizeInp.value=g.dataset.scale||'1'; } }
  document.getElementById('selName').addEventListener('change',()=>{ if(!selectedNode) return; const t=findText(selectedNode); if(t){ t.textContent=document.getElementById('selName').value; saveAll(); }});
  document.getElementById('selName').addEventListener('change',()=> refreshStageLegend());
  document.getElementById('selSize').addEventListener('input',()=>{ if(!selectedNode) return; const v=parseFloat(document.getElementById('selSize').value); const k=selectedNode.dataset.key||''; if(k==='arrow' || k==='label'){ const lbl=findText(selectedNode); if(lbl){ const base = (k==='arrow')?14:16; const fs=Math.max(8, Math.round(base*v)); lbl.setAttribute('font-size', String(fs)); } } else { selectedNode.dataset.scale=String(v); applyTransform(selectedNode); } saveAll(); });
  document.getElementById('selSize').addEventListener('change',()=> saveAll());
  document.getElementById('delSel').addEventListener('click',()=>{ if(!selectedNode) return; selectedNode.remove(); selectedNode=null; document.getElementById('selName').value=''; saveAll(); });
  document.getElementById('delSel').addEventListener('click',()=> refreshStageLegend());
  // Show label toggle
  const showLabelChk=document.getElementById('selShowLabel');
  if(showLabelChk){
    showLabelChk.addEventListener('change',()=>{
      if(!selectedNode) return; selectedNode.dataset.showLabel= showLabelChk.checked ? '1':'0'; const lbl=findText(selectedNode); if(lbl){ lbl.style.display= showLabelChk.checked ? 'block':'none'; } saveAll(); refreshStageLegend();
    });
  }
  // Duplicate button
  const dupBtn=document.getElementById('dupSel');
  if(dupBtn){ dupBtn.addEventListener('click',()=>{
    if(!selectedNode) return;
    const clone=selectedNode.cloneNode(true);
    const svg=selectedNode.closest('svg');
    initDatasetFromTransform(clone);
    clone.dataset.x=String(parseFloat(clone.dataset.x||'0')+40);
    clone.dataset.y=String(parseFloat(clone.dataset.y||'0')+40);
    applyTransform(clone);
    svg.appendChild(clone);
    enableSvgDrag(clone);
    selectNode(clone);
    refreshStageLegend(); saveAll();
  }); }
  // Global touch-based toolbox drag handling
  let activeToolTouch=null;
  window.addEventListener('touchmove',e=>{
    if(!activeToolTouch) return; const t=e.touches[0]; if(!t) return; activeToolTouch.x=t.clientX; activeToolTouch.y=t.clientY; }, {passive:true});
  window.addEventListener('touchend',e=>{
    if(!activeToolTouch) return; const stage=document.getElementById('stageSvgFull'); if(stage){ const rect=stage.getBoundingClientRect(); const x=activeToolTouch.x, y=activeToolTouch.y; if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){ // inside stage
        // convert to SVG coords
        const pt=stage.createSVGPoint(); pt.x=x; pt.y=y; const ctm=stage.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
        addGlyphFull(activeToolTouch.key, {x:Math.round(svgP.x), y:Math.round(svgP.y)});
      } }
    activeToolTouch=null;
  });
  function getStageGroups(){ const full=document.getElementById('stageSvgFull'); if(!full) return []; return Array.from(full.querySelectorAll('g[data-draggable]')); }
  // Draw curvy dotted cables between connected items (routeTo chains)
  function refreshCables(svg){ if(!svg) return; const nodes=Array.from(svg.querySelectorAll('g[data-draggable]'));
    // ensure a dedicated layer
    let layer=svg.querySelector('g[data-layer="cables"]'); if(layer){ layer.remove(); }
    layer=document.createElementNS('http://www.w3.org/2000/svg','g'); layer.setAttribute('data-layer','cables'); layer.setAttribute('pointer-events','none'); svg.appendChild(layer);
    const byId=new Map(nodes.map(n=> [n.dataset.id, n]));
    function centerOf(n){ return {x:parseFloat(n.dataset.x||'0')||0, y:parseFloat(n.dataset.y||'0')||0}; }
    function nodeRadius(n){ const s=Math.max(0.3, parseFloat(n.dataset.scale||'1')||1); const k=n.dataset.key||''; const base=(k==='label'||k==='arrow')? 20 : 30; return base*s; }
    function sampleQuad(a,c,b,t){ const x=(1-t)*(1-t)*a.x + 2*(1-t)*t*c.x + t*t*b.x; const y=(1-t)*(1-t)*a.y + 2*(1-t)*t*c.y + t*t*b.y; return {x,y}; }
    function pickControl(a,b,initial, obstacles){ let c={x:initial.x,y:initial.y}; const clamp=(v,min,max)=> Math.max(min, Math.min(max,v)); const vb=svg.viewBox && svg.viewBox.baseVal; const bx={x:0,y:0,w:(vb?vb.width:1500),h:(vb?vb.height:900)};
      for(let it=0; it<3; it++){
        // sample along curve, compute repulsion from obstacles
        let rx=0, ry=0; const steps=10; for(let i=1;i<steps;i++){ const t=i/steps; const p=sampleQuad(a,c,b,t); obstacles.forEach(o=>{
            const dx=p.x-o.x, dy=p.y-o.y; const d=Math.hypot(dx,dy); const th=o.r+40; if(d<th && d>1e-3){ const f=(th-d)/th; rx += (dx/d)*f; ry += (dy/d)*f; }
        }); }
        // apply small push
        const push=30; c.x = clamp(c.x + rx*push, bx.x+4, bx.x+bx.w-4); c.y = clamp(c.y + ry*push, bx.y+4, bx.y+bx.h-4);
      }
      return c;
    }
    // build obstacle list (centers + radii)
    const obstacles = nodes.map(n=>{ const c=centerOf(n); return {x:c.x,y:c.y,r:nodeRadius(n)}; });
    nodes.forEach(src=>{
      const to=src.dataset.routeTo; if(!to) return; const dst=byId.get(to); if(!dst) return;
      // make sure the connection is allowed; use effectiveTargets if available
      try{ if(typeof effectiveTargets==='function'){ const ok=effectiveTargets(src).includes(dst.dataset.type||'other'); if(!ok) return; } }catch(_){ /* ignore */ }
      const a=centerOf(src), b=centerOf(dst); const dx=b.x-a.x, dy=b.y-a.y; const len=Math.hypot(dx,dy)||1; const mx=(a.x+b.x)/2, my=(a.y+b.y)/2; const nx=-dy/len, ny=dx/len; const baseK=30; const init={x:mx+nx*baseK, y:my+ny*baseK};
      const c=pickControl(a,b,init, obstacles);
      const d=`M ${a.x} ${a.y} Q ${c.x} ${c.y} ${b.x} ${b.y}`;
      const p=document.createElementNS('http://www.w3.org/2000/svg','path'); p.setAttribute('d', d); p.setAttribute('fill','none'); p.setAttribute('stroke','#111'); p.setAttribute('stroke-width','1.5'); p.setAttribute('stroke-dasharray','4 3'); layer.appendChild(p);
    });
  }
  function refreshStageLegend(){
    const host=document.getElementById('stageLegend'); if(!host) return;
    const rows=getStageGroups();
    host.innerHTML='';
    // sort with priority processors first
    rows.sort((a,b)=>{
      const ta=a.dataset.type||'other', tb=b.dataset.type||'other';
      const pa=PRIORITY_TYPES.has(ta), pb=PRIORITY_TYPES.has(tb);
      if(pa&&!pb) return -1; if(pb&&!pa) return 1; return parseInt(a.dataset.id||'0')-parseInt(b.dataset.id||'0');
    });

    // helpers for channels and chains
    function isStereo(node){ return (node.dataset.key||'')==='stereoPair'; }
    function occupiesChannel(node, ch){ if(!ch) return false; const a=parseInt(node.dataset.channel||'0',10); if(!a) return false; if(isStereo(node)){ return ch===a || ch===a+1; } return ch===a; }
    function channelTaken(ch, except){ return rows.find(r=> r!==except && occupiesChannel(r, ch)); }
    function nextFreeChannel(start, dir, stereo){ let c=start; const upper=stereo?63:64; const lower=1; while(true){ if(c<lower || c>upper) return null; const occupied = channelTaken(c, null) || (stereo && channelTaken(c+1, null)); if(!occupied) return c; c += dir; }
    }
    // helper to build chain string
    function buildChain(from){
      const seen=new Set();
      const parts=[];
      let cur=from;
      while(cur){
        if(seen.has(cur)) { parts.push('[loop]'); break; }
        seen.add(cur);
        const t=findText(cur); const base=(t && t.textContent)||cur.dataset.key||'Item';
        parts.push(base);
        const nextId=cur.dataset.routeTo || '';
        if(!nextId) break;
        const next=rows.find(r=> r.dataset.id===nextId);
        if(!next) break;
        // validate that next type is an allowed target from current type
        const allowed=effectiveTargets(cur);
        if(allowed.indexOf(next.dataset.type||'other')===-1){ break; }
        cur=next;
      }
      const last=cur||from;
      if(last.dataset.channel){
        if(isStereo(last)){
          const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1));
        }else{
          parts.push('Ch '+last.dataset.channel);
        }
      }
      return parts.join(' - ');
    }

      // Build incoming map to identify roots (start of chains)
      const incoming=new Set(); rows.forEach(r=>{ const to=r.dataset.routeTo; if(to) incoming.add(to); });
      // Filter: hide annotations & utility props; compact view = only root items OR items that expose a channel directly (need channel editing)
      const displayRows = rows.filter(r=>{
        const k=r.dataset.key||''; const tp=r.dataset.type||'other';
        if(k==='label' || k==='arrow') return false;
        if(tp==='utility') return false;
        const targets=ROUTE_TARGETS[tp]||[];
        const exposesChannel=targets.includes('channel');
        const isRoot=!incoming.has(r.dataset.id);
        return isRoot || exposesChannel; // keep if chain start or endpoint with channel
      });
    // Precompute candidates map for routing dropdown population
    const byType={}; displayRows.forEach(r=>{ const t=r.dataset.type||'other'; (byType[t]||(byType[t]=[])).push(r); });

    // determine dynamic channel range (still consider all rows for occupancy logic)
    const assignedChannels=rows.map(r=> parseInt(r.dataset.channel||'0',10)).filter(n=> n>0);
    const maxChan=assignedChannels.length? Math.max(...assignedChannels):0;
      displayRows.forEach((g,i)=>{
      const item=document.createElement('div'); item.className='row';
      const key=g.dataset.key||''; const icon=ICON_ITEMS.find(x=>x.key===key);
      const iconCell=document.createElement('div'); if(icon){ const im=document.createElement('img'); im.src=icon.src; im.alt=icon.label; iconCell.appendChild(im); } item.appendChild(iconCell);
      const nameCell=document.createElement('div'); nameCell.className='nm'; const tEl=findText(g); nameCell.textContent=(tEl && tEl.textContent) || (icon?icon.label:('Item '+(i+1))); item.appendChild(nameCell);

      const type=g.dataset.type||'other';
  const targets=effectiveTargets(g);
      // Routing (routeTo or channel) cell
      const routeCell=document.createElement('div');
      let chInput=null;
      // Channel editing is applied to the chain endpoint, not necessarily the current row
      const resolveEnd=(start)=>{ let s=new Set(); let cur=start; while(cur && !s.has(cur)){ s.add(cur); const nid=cur.dataset.routeTo||''; if(!nid) break; const nxt=rows.find(r=> r.dataset.id===nid); if(!nxt) break; const allowed=effectiveTargets(cur); if(allowed.indexOf(nxt.dataset.type||'other')===-1) break; cur=nxt; } return cur||start; };
      const endNode=resolveEnd(g);
      const endTargets=effectiveTargets(endNode);
      if(endTargets.includes('channel')){
        const stereo=isStereo(endNode);
        chInput=document.createElement('input'); chInput.type='number'; chInput.min='1'; chInput.max= stereo ? '63' : '64'; chInput.step='1'; chInput.placeholder='Ch'; chInput.style.width='56px'; chInput.value=endNode.dataset.channel||''; chInput.title='Right-click drag between items to auto-chain';
        let prevVal = endNode.dataset.channel||'';
        const applyChannel=(ch)=>{ if(!ch){ endNode.dataset.channel=''; delete endNode.dataset.channel2; saveAll(); refreshStageLegend(); return; }
          // block if taken
          if(channelTaken(ch, endNode) || (stereo && channelTaken(ch+1, endNode))){ chInput.value = prevVal; return; }
          endNode.dataset.channel=String(ch); if(stereo){ endNode.dataset.channel2=String(ch+1); } else { delete endNode.dataset.channel2; }
          prevVal=String(ch); saveAll(); refreshStageLegend(); };
        const onChanChange=()=>{ const v=parseInt(chInput.value||'0',10); if(!isFinite(v) || v<1){ applyChannel(null); }
          else { const val=Math.min(stereo?63:64, v); if(channelTaken(val, endNode) || (stereo && channelTaken(val+1, endNode))){ chInput.value=prevVal; return; } applyChannel(val); } };
        chInput.addEventListener('focus',()=>{ prevVal = chInput.value; });
        chInput.addEventListener('change', onChanChange);
        chInput.addEventListener('blur', onChanChange);
        chInput.addEventListener('keydown', e=>{ if(e.key==='Enter'){ onChanChange(); }
          if(e.key==='ArrowUp' || e.key==='ArrowDown'){ e.preventDefault(); const dir = e.key==='ArrowUp' ? 1 : -1; const cur=parseInt(chInput.value|| (prevVal||'0'),10) || 0; const start = Math.max(1, cur + dir); const nf = nextFreeChannel(start, dir, stereo); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } }
        });
        chInput.addEventListener('input', ()=>{ const cur=parseInt(chInput.value||'0',10)||0; const pv=parseInt(prevVal||'0',10)||0; const stereoNow=stereo; if(cur===pv+1 || cur===pv-1){ const dir = (cur>pv)?1:-1; const nf = nextFreeChannel(cur, dir, stereoNow); if(nf!=null){ chInput.value=String(nf); applyChannel(nf); } } });
        routeCell.appendChild(chInput);
      }
      // RouteTo select for processors / sources that can feed other processors
      if(targets.filter(t=> t!=='channel').length){
        const rtSel=document.createElement('select'); rtSel.className='routeSel'; rtSel.appendChild(new Option('→ none',''));
        const elig=[]; targets.forEach(tt=>{ if(tt==='channel') return; const groups=byType[tt]; if(groups){ groups.forEach(gr=>{ if(gr!==g) elig.push(gr); }); } });
        elig.forEach(gr=>{ const name=findText(gr); const label=(name && name.textContent)||gr.dataset.key||('Item '+gr.dataset.id); rtSel.appendChild(new Option(label, gr.dataset.id)); });
        // sanitize existing route if invalid
        if(g.dataset.routeTo){ const curNext=rows.find(r=> r.dataset.id===g.dataset.routeTo); const allowed=effectiveTargets(g); if(!curNext || allowed.indexOf(curNext.dataset.type||'other')===-1){ g.dataset.routeTo=''; } }
        rtSel.value=g.dataset.routeTo||'';
        rtSel.addEventListener('change',()=>{ const dest=rows.find(r=> r.dataset.id===rtSel.value); const allowed=effectiveTargets(g); if(dest && allowed.indexOf(dest.dataset.type||'other')!==-1){ g.dataset.routeTo=rtSel.value; } else { g.dataset.routeTo=''; } saveAll(); refreshStageLegend(); });
        routeCell.appendChild(rtSel);
      }
      item.appendChild(routeCell);

      // Chain cell
  const chainCell=document.createElement('div'); chainCell.className='chain'; chainCell.style.textAlign='left'; chainCell.textContent=buildChain(g); item.appendChild(chainCell);

      host.appendChild(item);
    });
    // After legend rebuild, refresh visual cables on both editor and stored SVGs
    const svgFull=document.getElementById('stageSvgFull'); if(svgFull) refreshCables(svgFull);
    const svgSmall=document.getElementById('stageSvg'); if(svgSmall) refreshCables(svgSmall);
  }
  /* Filter system removed: icons now assumed to have proper transparency baked in. */

    // Print Tech Rider + Stage
  // Repurpose combined print button to open chooser; user can select Tech and/or Stage
  document.getElementById('printTech').addEventListener('click',()=>{
    openPrintChooser('tech');
    return;
    /* legacy combined flow retained below but unused */
      // Header
      const hdr=$('#hdrTech'); hdr.innerHTML='';
    if(gig.headerFlags?.band) hdr.append(el('div','band',(gig.band||'BAND')));
    if(gig.headerFlags?.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
    if(gig.headerFlags?.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' • '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
    if(gig.headerFlags?.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
      // Tech table clone
      const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table';
      const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>';
      const body=document.createElement('tbody');
      setlist.filter(x=>x.type==='song').forEach((s,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${s.tech||''}</td>`; body.appendChild(tr);
      });
      tbl.append(head,body); techOut.appendChild(tbl);
      // Stage SVG clone
      const stageOut=$('#stagePrint'); stageOut.innerHTML='';
  var svgEl=document.getElementById('stageSvg'); if(svgEl){ const svg=svgEl.cloneNode(true); svg.removeAttribute('id'); svg.setAttribute('preserveAspectRatio','xMidYMid meet'); svg.style.width='100%'; svg.style.height='auto'; svg.style.maxHeight='9in'; stageOut.appendChild(svg); }
  if(gearSummary){ const gdiv=document.createElement('div'); gdiv.style.marginTop='8px'; gdiv.textContent='Gear: '+gearSummary; stageOut.appendChild(gdiv); }
      // Show modal
      document.getElementById('modalTech').classList.add('open');
    });
    document.getElementById('closeTech').addEventListener('click',()=> document.getElementById('modalTech').classList.remove('open'));
      // Print Tech only (no stage)
      const printTechOnlyBtn=document.getElementById('printTechOnly');
      if(printTechOnlyBtn){ printTechOnlyBtn.addEventListener('click',()=>{
        // Header
        const hdr=$('#hdrTech'); hdr.innerHTML='';
        if(gig.headerFlags?.band) hdr.append(el('div','band',(gig.band||'BAND')));
        if(gig.headerFlags?.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
        if(gig.headerFlags?.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' • '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
        if(gig.headerFlags?.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
        // Tech table only
        const techOut=$('#techPrint'); techOut.innerHTML='';
        const stageOut=$('#stagePrint'); stageOut.innerHTML='';
        const tbl=document.createElement('table'); tbl.className='tech-table';
        const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>';
        const body=document.createElement('tbody');
        setlist.filter(x=>x.type==='song').forEach((s,i)=>{
          const tr=document.createElement('tr'); tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${s.tech||''}</td>`; body.appendChild(tr);
        });
        tbl.append(head,body); techOut.appendChild(tbl);
        document.getElementById('modalTech').classList.add('open');
      }); }

    // Save tech notes on edit (kept above); buildTechTableFull populates fullscreen modal

    // Small embedded stage removed. All interactions are in fullscreen editor.

    // Fullscreen toggle for stage
  // No inline fullscreen toggle button anymore

    // Fullscreen stage editor open/close
    function openStageModal(){
      // ensure header reflects current gig
      try{
        refreshStageHeader();
        // ensure toolbox is populated
        try{ buildTools(); }catch(_){ /* ignore */ }
        // seed full editor from stored svg
        const store=document.getElementById('stageSvg');
        const full=document.getElementById('stageSvgFull');
        // enforce stage outline
        if(full && !full.classList.contains('bw')) full.classList.add('bw');
        const bg=full && full.querySelector('rect.stage-bg');
        if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        // initialize resize handles (corner-only interaction) and apply stored size
        (function initStageResize(){
          const frame=document.getElementById('stageFrame'); if(!frame||!full) return;
          // default size if not previously set
          const prevW=parseInt(full.style.width||'0',10); const prevH=parseInt(full.style.height||'0',10);
            if(prevW>0 && prevH>0){ frame.style.width=prevW+'px'; frame.style.height=prevH+'px'; }
            else { frame.style.width='1000px'; frame.style.height='600px'; full.style.width='1000px'; full.style.height='600px'; }
          const handles=frame.querySelectorAll('.stage-handle');
          handles.forEach(h=>{
            h.addEventListener('mousedown',e=>{
              if(e.button!==0) return; e.preventDefault();
              const startX=e.clientX, startY=e.clientY; const startW=frame.offsetWidth, startH=frame.offsetHeight; const pos=h.dataset.handle;
              function move(ev){
                let dx=ev.clientX-startX, dy=ev.clientY-startY; let newW=startW, newH=startH;
                if(pos==='tr'){ newW=startW+dx; newH=startH-dy; }
                if(pos==='tl'){ newW=startW-dx; newH=startH-dy; }
                if(pos==='br'){ newW=startW+dx; newH=startH+dy; }
                if(pos==='bl'){ newW=startW-dx; newH=startH+dy; }
                newW=Math.max(600,newW); newH=Math.max(360,newH);
                frame.style.width=newW+'px'; frame.style.height=newH+'px'; full.style.width=newW+'px'; full.style.height=newH+'px';
              }
              function up(){ document.removeEventListener('mousemove',move); document.removeEventListener('mouseup',up); saveAll(); }
              document.addEventListener('mousemove',move); document.addEventListener('mouseup',up);
            });
          });
        })();
        if(!full){ throw new Error('Stage SVG not found'); }
        // reset children (keep first two nodes: bg rect and title)
        while(full.childNodes.length>2) full.removeChild(full.lastChild);
        if(store){
          Array.from(store.querySelectorAll('g[data-draggable]')).forEach(g=> full.appendChild(g.cloneNode(true)));
          var tnode=store.querySelector('#stageTitle'); var ttl=document.getElementById('stageTitleFull'); if(ttl){ ttl.textContent=(tnode && tnode.textContent) || ttl.textContent; }
        }
  // Ensure arrow markers are available
    ensureStageMarkers(full);
  // Filter defs removed (icons expected to be clean PNGs without white fill)
        // Migration: remove legacy background rects behind emojis/images
        Array.from(full.querySelectorAll('g[data-draggable]')).forEach(gr=>{
          // assign ids/types to legacy nodes
          if(!gr.dataset.id){ gr.dataset.id=String(_nextStageId++); }
          if(!gr.dataset.type){ const k=gr.dataset.key||''; gr.dataset.type=TYPE_MAP[k]||'other'; }
          if(!('showLabel' in gr.dataset)) gr.dataset.showLabel = (gr.dataset.key==='label' || gr.dataset.key==='arrow') ? '1':'0';
          const hasImg = !!gr.querySelector('image');
          const hadEmoji = !!gr.querySelector('text[data-role="emoji"]');
          if(hasImg || hadEmoji){ Array.from(gr.querySelectorAll('rect[data-bg]')).forEach(r=> r.remove()); }
          // Remove any legacy filter attributes
          Array.from(gr.querySelectorAll('image[filter]')).forEach(im=> im.removeAttribute('filter'));
        });
  Array.from(full.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
  refreshCables(full);
        bindSelection(full);
        const modal=document.getElementById('stageModal'); if(!modal){ throw new Error('Stage modal not found'); }
        modal.classList.add('open');
        refreshStageLegend();
      }catch(err){
        if(window && window.alert){ alert('Could not open Stage Plot editor. See console for details.'); }
        if(console && console.error) console.error(err);
      }
    }
    const openStageBtn=document.getElementById('openStage');
    if(openStageBtn){ openStageBtn.addEventListener('click',openStageModal); }
    // make function available to inline onclick as a hard fallback
    window.openStageModal = openStageModal;
    // final safety: delegate click in case listeners were missed
    document.addEventListener('click',ev=>{
      const trg=ev.target && ev.target.closest ? ev.target.closest('#openStage') : null;
      if(trg){ ev.preventDefault(); openStageModal(); }
    });
    document.getElementById('closeStage').addEventListener('click',()=>{
      // Sync full editor back to stored compact SVG so reopening reflects latest layout
      const full=document.getElementById('stageSvgFull');
      let small=document.getElementById('stageSvg');
      if(full){
        if(!small){
          // create a small stored SVG container if missing; clone with children to preserve background/title
          const store=document.getElementById('stageStore');
          if(store){ small=full.cloneNode(true); small.id='stageSvg'; small.classList.add('bw'); store.appendChild(small); }
        }
        if(small){
          // remove previous draggable groups
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(n=> n.remove());
          // clone all current groups from full
          Array.from(full.querySelectorAll('g[data-draggable]')).forEach(g=> small.appendChild(g.cloneNode(true)));
          // Filter system removed; no additional defs needed for small copy
          // rebind drags on stored copy for any inline interactions
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(enableSvgDrag);
          // ensure label hidden state preserved visually
          Array.from(small.querySelectorAll('g[data-draggable]')).forEach(gr=>{ const lbl=findText(gr); if(lbl){ lbl.style.display = gr.dataset.showLabel==='1' ? 'block':'none'; } });
          // ensure arrow marker exists in stored svg
          ensureStageMarkers(small);
          refreshCables(small);
          // sync title text
          const fullTitle=document.getElementById('stageTitleFull');
          let smallTitle=document.getElementById('stageTitle');
          if(!smallTitle && small){
            // attempt to find title node by id inside small
            smallTitle=small.querySelector('#stageTitle');
          }
          if(fullTitle){
            if(smallTitle){ smallTitle.textContent=fullTitle.textContent; }
            else {
              // if title missing, create one centered at top
              const t=document.createElementNS('http://www.w3.org/2000/svg','text');
              t.setAttribute('id','stageTitle'); t.setAttribute('x','500'); t.setAttribute('y','36'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','22'); t.setAttribute('font-weight','bold'); t.textContent=fullTitle.textContent; small.appendChild(t);
            }
          }
          // enforce background outline on stored copy
          const bg=small.querySelector('rect.stage-bg'); if(bg){ bg.setAttribute('fill','#fff'); bg.setAttribute('stroke','#000'); bg.setAttribute('stroke-width','2'); }
        }
      }
      saveAll();
      document.getElementById('stageModal').classList.remove('open');
    });
    // Clear full stage editor
    const clearStageBtn=document.getElementById('clearStage');
    if(clearStageBtn){ clearStageBtn.addEventListener('click',()=>{
      const full=document.getElementById('stageSvgFull'); if(!full) return;
      // preserve background rect and title only
      while(full.childNodes.length>2) full.removeChild(full.lastChild);
      saveAll();
    }); }

    // Open/close Lighting Notes fullscreen
    document.getElementById('openNotes').addEventListener('click',()=>{ buildTechTableFull(); const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary||''; document.getElementById('notesModal').classList.add('open'); });
  const closeNotesBtn=document.getElementById('closeNotes');
  if(closeNotesBtn){ closeNotesBtn.addEventListener('click',()=> document.getElementById('notesModal').classList.remove('open')); }

    // Drag from toolbox into full SVG at drop position
  const fullSvg=document.getElementById('stageSvgFull');
    fullSvg.addEventListener('dragover',ev=> ev.preventDefault());
    fullSvg.addEventListener('drop',ev=>{
      ev.preventDefault();
      const key=ev.dataTransfer.getData('text/plain');
      if(!key) return;
      const pt=fullSvg.createSVGPoint(); pt.x=ev.clientX; pt.y=ev.clientY; const ctm=fullSvg.getScreenCTM().inverse(); const svgP=pt.matrixTransform(ctm);
      addGlyphFull(key,{x:Math.round(svgP.x), y:Math.round(svgP.y)});
    });

    // Arrow drawing: drag anywhere in SVG (hold Shift to draw over items)
    (function(){
      let drawing=null; // {x0,y0, preview}
      const svg=fullSvg;
      ensureStageMarkers(svg);
      function svgPointFromClient(x,y){ const pt=svg.createSVGPoint(); pt.x=x; pt.y=y; return pt.matrixTransform(svg.getScreenCTM().inverse()); }
      function startDraw(x,y){ drawing={x0:x,y0:y, preview:document.createElementNS('http://www.w3.org/2000/svg','line')}; const ln=drawing.preview; ln.setAttribute('x1',String(x)); ln.setAttribute('y1',String(y)); ln.setAttribute('x2',String(x)); ln.setAttribute('y2',String(y)); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-dasharray','4,3'); ln.setAttribute('stroke-width','2'); ln.setAttribute('pointer-events','none'); svg.appendChild(ln); }
      function updateDraw(x,y){ if(!drawing) return; drawing.preview.setAttribute('x2',String(x)); drawing.preview.setAttribute('y2',String(y)); }
      function finishDraw(x1,y1){ if(!drawing){ return; } const {x0,y0, preview}=drawing; svg.removeChild(preview); drawing=null; const dx=x1-x0, dy=y1-y0; const dist=Math.hypot(dx,dy); if(dist<6){ // treat as click -> create label here
          // Ask first; cancel or empty -> abort (no stray labels)
          let entered=prompt('Text label:',''); if(entered==null) return; entered=String(entered).trim(); if(!entered) return;
          // Create label at point
          const gN=document.createElementNS('http://www.w3.org/2000/svg','g'); gN.dataset.x=String(Math.round(x0)); gN.dataset.y=String(Math.round(y0)); gN.dataset.scale='1'; gN.setAttribute('data-draggable','1'); gN.dataset.key='label'; gN.dataset.type='other'; gN.dataset.showLabel='1';
          const t=document.createElementNS('http://www.w3.org/2000/svg','text'); t.setAttribute('x','0'); t.setAttribute('y','0'); t.setAttribute('font-size','16'); t.setAttribute('data-role','label'); t.textContent=entered; gN.appendChild(t);
          applyTransform(gN); svg.appendChild(gN); enableSvgDrag(gN); selectNode(gN); refreshStageLegend(); saveAll(); const nameInp=document.getElementById('selName'); if(nameInp){ nameInp.focus(); nameInp.select && nameInp.select(); }
          _suppressBgClick=true;
          return;
        }
        // Create arrow group anchored at origin (x0,y0) pointing to (x1,y1)
        const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.dataset.x=String(Math.round(x0)); g.dataset.y=String(Math.round(y0)); g.dataset.scale='1'; g.setAttribute('data-draggable','1'); g.dataset.key='arrow'; g.dataset.type='other'; g.dataset.showLabel='1';
        const ln=document.createElementNS('http://www.w3.org/2000/svg','line'); ln.setAttribute('x1','0'); ln.setAttribute('y1','0'); ln.setAttribute('x2',String(Math.round(dx))); ln.setAttribute('y2',String(Math.round(dy))); ln.setAttribute('stroke','#000'); ln.setAttribute('stroke-width','2'); ln.setAttribute('marker-end','url(#arrowHead)'); g.appendChild(ln);
        // Ask for arrow label; cancel or empty -> abort entire arrow creation
        let enteredA=prompt('Arrow label:',''); if(enteredA==null) return; enteredA=String(enteredA).trim(); if(!enteredA) return;
  const t=document.createElementNS('http://www.w3.org/2000/svg','text');
  t.setAttribute('x', (Math.abs(dx)>Math.abs(dy) ? (dx<0?-8:8) : 0) );
  const yOff = (dy<0? 14 : -10);
  t.setAttribute('y', String(yOff));
  t.setAttribute('font-size','14'); t.setAttribute('text-anchor','start'); t.setAttribute('dominant-baseline','alphabetic'); t.setAttribute('data-role','label');
  t.textContent=enteredA; g.appendChild(t);
        applyTransform(g); svg.appendChild(g); enableSvgDrag(g); selectNode(g); refreshStageLegend(); saveAll();
        _suppressBgClick=true;
      }
      // Mouse support (capture to preempt item drag when Shift is held)
      svg.addEventListener('mousedown',e=>{
        if(e.button!==0) return;
        // ignore UI controls outside svg content
        if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions')) return;
        const overItem = !!(e.target.closest && e.target.closest('g[data-draggable]'));
        if(overItem && !e.shiftKey) return; // allow drawing over items only with Shift
        const p=svgPointFromClient(e.clientX,e.clientY); startDraw(p.x,p.y); e.stopImmediatePropagation(); e.preventDefault();
      }, {capture:true});
      svg.addEventListener('mousemove',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); updateDraw(p.x,p.y); }, {capture:true});
      window.addEventListener('mouseup',e=>{ if(!drawing) return; const p=svgPointFromClient(e.clientX,e.clientY); finishDraw(p.x,p.y); }, {capture:true});
      // Touch support (capture); drawing over items is always permitted on touch (no modifier keys)
      svg.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; if(e.target.closest('#stageLegend,.stage-inspector,.stage-actions')) return; const p=svgPointFromClient(t.clientX,t.clientY); startDraw(p.x,p.y); e.preventDefault(); e.stopImmediatePropagation(); }, {passive:false, capture:true});
      window.addEventListener('touchmove',e=>{ if(!drawing) return; const t=e.touches[0]; if(!t) return; const p=svgPointFromClient(t.clientX,t.clientY); updateDraw(p.x,p.y); }, {passive:true});
      window.addEventListener('touchend',e=>{ if(!drawing) return; const ct=(e.changedTouches && e.changedTouches[0])|| (e.touches && e.touches[0]); if(!ct) return; const p=svgPointFromClient(ct.clientX, ct.clientY); finishDraw(p.x,p.y); }, {passive:true});
    })();

    // Removed legacy custom tool buttons (label/rect/default layout). New upload image flow below.
    const uploadBtn=document.getElementById('uploadImageBtn');
    const uploadInput=document.getElementById('uploadImageInput');
    function rebuildCustomImages(){
      const host=document.getElementById('customImages'); if(!host) return; host.innerHTML='';
      (gig.customImages||[]).forEach(ci=>{
        const b=document.createElement('button'); b.className='tool'; b.innerHTML=`<img src="${ci.data}" alt="${ci.label}" style="width:18px;height:18px;object-fit:contain;margin-right:6px"/>${ci.label}`; b.setAttribute('draggable','true'); b.addEventListener('dragstart',ev=>{ ev.dataTransfer.setData('text/plain', ci.key); }); host.appendChild(b);
      });
    }
    if(uploadBtn && uploadInput){
      uploadBtn.addEventListener('click',()=> uploadInput.click());
      uploadInput.addEventListener('change',()=>{
        const file=uploadInput.files && uploadInput.files[0]; if(!file) return; const reader=new FileReader(); reader.onload=()=>{
          const dataUrl=reader.result; const rawName=file.name.replace(/\.[^.]+$/,''); const label=prompt('Image label:', rawName)||rawName;
          const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl});
          saveAll(); rebuildCustomImages(); buildTools(); // add to toolbox drag list
        }; reader.readAsDataURL(file);
        uploadInput.value='';
      });
      // hydrate any existing
      rebuildCustomImages();
    }
    // New Icon drawing logic
    const newIconBtn=document.getElementById('newIconBtn');
    const iconModal=document.getElementById('iconMakerModal');
    const iconCanvas=document.getElementById('iconCanvas');
    const iconLineWidth=document.getElementById('iconLineWidth');
    const iconClear=document.getElementById('iconClear');
    const iconSave=document.getElementById('iconSave');
    const iconCancel=document.getElementById('iconCancel');
    let iconDrawing=false; let iconStrokes=[]; let currentStroke=null;
    function openIconModal(){ if(iconModal){ iconModal.style.display='block'; iconModal.classList.add('open'); iconStrokes=[]; redrawIcon(); } }
    function closeIconModal(){ if(iconModal){ iconModal.classList.remove('open'); iconModal.style.display='none'; } }
    function redrawIcon(){ if(!iconCanvas) return; const ctx=iconCanvas.getContext('2d'); ctx.clearRect(0,0,iconCanvas.width,iconCanvas.height); ctx.lineJoin='round'; ctx.lineCap='round'; ctx.strokeStyle='#000'; iconStrokes.forEach(st=>{ ctx.lineWidth=st.w; ctx.beginPath(); st.pts.forEach((p,i)=>{ if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); }); ctx.stroke(); }); }
    function classifyStroke(pts){ if(pts.length<4) return 'line'; const first=pts[0], last=pts[pts.length-1]; const minX=Math.min(...pts.map(p=>p.x)), maxX=Math.max(...pts.map(p=>p.x)); const minY=Math.min(...pts.map(p=>p.y)), maxY=Math.max(...pts.map(p=>p.y)); const w=maxX-minX, h=maxY-minY; const closeDist=Math.hypot(last.x-first.x,last.y-first.y); const pathLen=pts.reduce((a,p,i)=> i? a+Math.hypot(p.x-pts[i-1].x,p.y-pts[i-1].y):0,0); if(pts.length<12) return 'line'; if(closeDist < Math.max(6,0.15*Math.max(w,h))){ const aspect=w/h; if(aspect>0.8 && aspect<1.25){ return 'ellipse'; } if(Math.abs(w-h)/Math.max(w,h) < 0.25){ return 'rect'; } }
      return 'line'; }
    function normalizeStrokes(){ // replace rough shapes with ideal forms
      iconStrokes=iconStrokes.map(st=>{ const kind=classifyStroke(st.pts); if(kind==='line'){ return st; } const minX=Math.min(...st.pts.map(p=>p.x)), maxX=Math.max(...st.pts.map(p=>p.x)); const minY=Math.min(...st.pts.map(p=>p.y)), maxY=Math.max(...st.pts.map(p=>p.y)); if(kind==='rect'){ return {w:st.w, pts:[{x:minX,y:minY},{x:maxX,y:minY},{x:maxX,y:maxY},{x:minX,y:maxY},{x:minX,y:minY}]}; } if(kind==='ellipse'){ const cx=(minX+maxX)/2, cy=(minY+maxY)/2; const rx=(maxX-minX)/2, ry=(maxY-minY)/2; const steps=40; const pts=[]; for(let i=0;i<=steps;i++){ const a=(i/steps)*Math.PI*2; pts.push({x:cx+rx*Math.cos(a), y:cy+ry*Math.sin(a)}); } return {w:st.w, pts}; } return st; }); }
    function iconPointerDown(x,y){ iconDrawing=true; currentStroke={w:parseInt(iconLineWidth.value)||4, pts:[{x,y}]}; iconStrokes.push(currentStroke); redrawIcon(); }
    function iconPointerMove(x,y){ if(!iconDrawing || !currentStroke) return; currentStroke.pts.push({x,y}); redrawIcon(); }
    function iconPointerUp(){ if(!iconDrawing) return; iconDrawing=false; currentStroke=null; normalizeStrokes(); redrawIcon(); }
    if(iconCanvas){
      iconCanvas.addEventListener('mousedown',e=>{ const r=iconCanvas.getBoundingClientRect(); iconPointerDown(e.clientX-r.left,e.clientY-r.top); });
      window.addEventListener('mousemove',e=>{ if(!iconDrawing) return; const r=iconCanvas.getBoundingClientRect(); iconPointerMove(e.clientX-r.left,e.clientY-r.top); });
      window.addEventListener('mouseup',()=> iconPointerUp());
      iconCanvas.addEventListener('touchstart',e=>{ const t=e.touches[0]; if(!t) return; const r=iconCanvas.getBoundingClientRect(); iconPointerDown(t.clientX-r.left,t.clientY-r.top); e.preventDefault(); }, {passive:false});
      iconCanvas.addEventListener('touchmove',e=>{ const t=e.touches[0]; if(!t) return; const r=iconCanvas.getBoundingClientRect(); iconPointerMove(t.clientX-r.left,t.clientY-r.top); e.preventDefault(); }, {passive:false});
      iconCanvas.addEventListener('touchend',()=> iconPointerUp());
    }
    if(newIconBtn) newIconBtn.addEventListener('click', openIconModal);
    if(iconCancel) iconCancel.addEventListener('click', closeIconModal);
    if(iconClear) iconClear.addEventListener('click',()=>{ iconStrokes=[]; redrawIcon(); });
    if(iconSave) iconSave.addEventListener('click',()=>{ if(!iconCanvas) return; normalizeStrokes(); redrawIcon(); const label=prompt('Icon label:','Custom')||'Custom'; const dataUrl=iconCanvas.toDataURL('image/png'); const key='uimg_'+Date.now(); gig.customImages=gig.customImages||[]; gig.customImages.push({key,label,data:dataUrl}); saveAll(); rebuildCustomImages(); buildTools(); closeIconModal(); });
    // (Removed default layout auto-placement code)

    // Shuffle playlist (guard if legacy button exists)
    (function(){ const sh=document.getElementById('shuffleBtn'); if(!sh) return; sh.addEventListener('click',()=>{
      const songs=setlist.filter(x=>x.type==='song');
      const others=setlist.filter(x=>x.type!=='song');
      const shuffled=shuffle(songs);
      // keep others in their relative positions (insert breaks/encore by index mapping)
      let i=0; setlist=setlist.map(x=> x.type==='song' ? shuffled[i++] : x);
      renderSet(); saveAll();
    }); })();

    // Persist gig band name as default as you type
    document.getElementById('gBand').addEventListener('change',()=>{ gig.band=document.getElementById('gBand').value; saveAll(); refreshStageHeader(); });
      document.getElementById('gVenue').addEventListener('change',()=>{ gig.venue=document.getElementById('gVenue').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gDate').addEventListener('change',()=>{ gig.date=document.getElementById('gDate').value; saveAll(); refreshStageHeader(); buildSheet('sheetInline'); });
      document.getElementById('gAddr').addEventListener('change',()=>{ gig.address=document.getElementById('gAddr').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gContact').addEventListener('change',()=>{ gig.contact=document.getElementById('gContact').value; saveAll(); buildSheet('sheetInline'); });
      document.getElementById('gNotes').addEventListener('change',()=>{ gig.notes=document.getElementById('gNotes').value; saveAll(); buildSheet('sheetInline'); });
    // Header flag persistence & listeners
    ;['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{
      const box=document.getElementById(id);
      if(box){
        box.addEventListener('change',()=>{
          if(!gig.headerFlags) gig.headerFlags={band:true,venue:true,sub:true,notes:true};
          if(id==='hdrBand') gig.headerFlags.band=box.checked;
          else if(id==='hdrVenue') gig.headerFlags.venue=box.checked;
          else if(id==='hdrSub') gig.headerFlags.sub=box.checked;
          else if(id==='hdrNotes') gig.headerFlags.notes=box.checked;
          saveAll();
          if(document.getElementById('modal').classList.contains('open')){ buildSheet(); }
        });
      }
    });
  // Font selection persistence
  const gFontEl=document.getElementById('gFont'); if(gFontEl){ gFontEl.addEventListener('change',()=>{ gig.font=gFontEl.value; saveAll(); buildSheet('sheetInline'); }); if(gig.font) gFontEl.value=gig.font; }
  // Logo upload/preview/clear
  const logoIn=document.getElementById('gLogo'); const logoPrev=document.getElementById('gLogoPrev'); const logoClear=document.getElementById('gLogoClear');
  function refreshLogoPreview(){ if(logoPrev){ if(gig.logo){ logoPrev.src=gig.logo; logoPrev.style.display='block'; } else { logoPrev.removeAttribute('src'); logoPrev.style.display='none'; } } }
  if(logoIn){ logoIn.addEventListener('change',()=>{ const f=logoIn.files && logoIn.files[0]; if(!f) return; const r=new FileReader(); r.onload=e=>{ gig.logo=String(e.target.result||''); saveAll(); refreshLogoPreview(); }; r.readAsDataURL(f); }); }
  if(logoClear){ logoClear.addEventListener('click',()=>{ gig.logo=''; if(logoIn) logoIn.value=''; saveAll(); refreshLogoPreview(); }); }
  refreshLogoPreview();
    // Gear summary persistence
  const gearEl2=document.getElementById('gear'); if(gearEl2){ gearEl2.addEventListener('input',()=>{ gearSummary=gearEl2.value; }); gearEl2.addEventListener('change',()=>{ gearSummary=gearEl2.value; saveAll(); }); }

    // Global print chooser wiring
    function openPrintChooser(pref){
      const dlg=document.getElementById('printChooser');
      // Close other modals so chooser is visible above everything and not printed with them
      ['stageModal','notesModal','modal','modalTech'].forEach(id=>{ const m=document.getElementById(id); if(m) m.classList.remove('open'); });
      const cSet=document.getElementById('pSet');
      const cStage=document.getElementById('pStage');
      const cTech=document.getElementById('pTech');
      // default: at least one checked
      const all=[cSet,cStage,cTech];
      all.forEach(c=> c.checked=false);
      if(pref==='set') cSet.checked=true; else if(pref==='stage') cStage.checked=true; else if(pref==='tech') cTech.checked=true; else cSet.checked=true;
      dlg.classList.add('open');
      validatePrintSelection();
    }
    function validatePrintSelection(){
      const btn=document.getElementById('doPrint');
      const any= document.getElementById('pSet').checked || document.getElementById('pStage').checked || document.getElementById('pTech').checked;
      btn.disabled = !any;
    }
    ['pSet','pStage','pTech'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('change',validatePrintSelection); }});
    const openPrintFab=document.getElementById('openPrintOptions');
    if(openPrintFab){ openPrintFab.addEventListener('click',()=> openPrintChooser()); }
    const openPrintTop=document.getElementById('openPrintOptionsTop');
    if(openPrintTop){ openPrintTop.addEventListener('click',()=> openPrintChooser()); }
    document.getElementById('closePrintChooser').addEventListener('click',()=> document.getElementById('printChooser').classList.remove('open'));
  document.getElementById('printTechModal').addEventListener('click',()=> openPrintChooser('tech'));

    async function printSelected(){
      // Ensure content is built even if user hasn't opened views yet
      try{ buildSheet('sheetInline'); }catch(_){}
      try{ prepHdrTech(); }catch(_){}
      const wantSet=document.getElementById('pSet').checked;
      const wantStage=document.getElementById('pStage').checked;
      const wantTech=document.getElementById('pTech').checked;
      const tasks=[];
      if(wantSet) tasks.push(()=> printSetOnce());
      if(wantStage) tasks.push(()=> printStageOnce());
      if(wantTech) tasks.push(()=> printTechOnlyOnce());
      // Close chooser before printing to prevent it from being captured by print
      document.getElementById('printChooser').classList.remove('open');
      for(const t of tasks){ await t(); }
    }
    document.getElementById('doPrint').addEventListener('click',printSelected);

    // PDF/ZIP download removed: users can use native browser print dialog for PDF saving.

    function makePdfFromCanvas(canvas, paper){
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('p', 'pt', paper||'letter');
      const pageW = pdf.internal.pageSize.getWidth();
      const pageH = pdf.internal.pageSize.getHeight();
      const imgData = canvas.toDataURL('image/png');
      let imgW = pageW;
      let imgH = canvas.height * (imgW / canvas.width);
      if(imgH > pageH){ imgH = pageH; imgW = canvas.width * (imgH / canvas.height); }
      const x = (pageW - imgW)/2, y=(pageH - imgH)/2;
      pdf.addImage(imgData, 'PNG', x, y, imgW, imgH);
      return pdf.output('blob');
    }

    function withOffscreen(el, fn){
      // Ensure element AND its hidden ancestors are visible for layout so html2canvas gets real size
      const stack=[]; let node=el;
      while(node && node.nodeType===1){
        stack.push({node, style:{display:node.style.display, visibility:node.style.visibility, position:node.style.position, left:node.style.left, top:node.style.top}});
        node.style.display='block';
        node.style.visibility='visible';
        node = node.parentElement;
      }
      // Position target far offscreen to avoid flicker
      el.style.position='fixed'; el.style.left='-10000px'; el.style.top='0';
      return Promise.resolve(fn()).finally(()=>{
        // Restore styles in reverse order
        for(let i=0;i<stack.length;i++){
          const {node, style}=stack[i];
          node.style.display=style.display;
          node.style.visibility=style.visibility;
          node.style.position=style.position;
          node.style.left=style.left;
          node.style.top=style.top;
        }
      });
    }
    async function createSetlistPdfBlob(){
      // Use inline sheet for export (already WYSIWYG)
      buildSheet('sheetInline');
      const el=document.getElementById('sheetInline');
      if(typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('PDF libs missing (offline?). Falling back to native print.');
        document.getElementById('modal').classList.add('open'); await printPromise(); window.print(); document.getElementById('modal').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, (el.classList.contains('a4')? 'a4' : 'letter'));
      return blob;
    }
    // Helper: obtain current stage SVG (fullscreen editor if open, else stored miniature)
    function getStageSource(){
      let src=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      if(!src){ const store=document.getElementById('stageStore'); if(store){ src=store.querySelector('svg'); } }
      return src;
    }
    // Helper: build channel-ordered legend + cloned stage (with border) identical to printStageOnce
    function buildStageExport(into){
      const stageOut = into; stageOut.innerHTML='';
      const src=getStageSource();
      const legend=document.createElement('table'); legend.className='tech-table';
      const thead=document.createElement('thead'); thead.innerHTML='<tr><th>Channel</th><th>Chain</th></tr>';
      const tbody=document.createElement('tbody');
      if(src){
        const rows=Array.from(src.querySelectorAll('g[data-draggable]'));
        const isStereo=n=> (n.dataset.key||'')==='stereoPair';
        const typeOf=n=> n.dataset.type||'other';
        const findRoot=(end)=>{ let cur=end; const seen=new Set(); while(cur && !seen.has(cur)){ seen.add(cur); const prev=rows.find(r=> r.dataset.routeTo===cur.dataset.id && effectiveTargets(r).includes(typeOf(cur))); if(!prev) break; cur=prev; } return cur||end; };
        const buildChain=(from)=>{ const seen=new Set(); const parts=[]; let cur=from; while(cur){ if(seen.has(cur)) break; seen.add(cur); const t=cur.querySelector('text[data-role="label"]')||cur.querySelector('text'); const base=(t && t.textContent)||(cur.dataset.key||'Item'); parts.push(base); const nid=cur.dataset.routeTo||''; if(!nid) break; const next=rows.find(r=> r.dataset.id===nid); if(!next) break; const ok=effectiveTargets(cur).includes(typeOf(next)); if(!ok) break; cur=next; } const last=cur||from; if(last.dataset.channel){ if(isStereo(last)){ const a=parseInt(last.dataset.channel,10); parts.push('Ch '+a+' & '+(a+1)); } else { parts.push('Ch '+last.dataset.channel); } } return parts.join(' - '); };
        // Collect endpoints with channels
        const endpoints=rows.filter(r=> r.dataset.channel && r.dataset.channel!=='');
        const assigned= endpoints.map(n=> parseInt(n.dataset.channel||'0',10)).filter(n=> n>0);
        const maxAssigned = assigned.length ? Math.max(...assigned) : 0;
        // Build a deterministic 1..N list (at least 16 rows for common mixers)
        const endByStartCh = new Map();
        endpoints.forEach(end=>{ const ch=parseInt(end.dataset.channel||'0',10)||0; if(ch>0 && !endByStartCh.has(ch)) endByStartCh.set(ch, end); });
        const limit = Math.max(16, maxAssigned);
        for(let ch=1; ch<=limit; ch++){
          // If this channel is the right-half of a stereo pair, skip (will be shown with left)
          const isRightOfStereo = Array.from(endpoints).some(e=> isStereo(e) && parseInt(e.dataset.channel||'0',10)===ch-1);
          if(isRightOfStereo) continue;
          const end=endByStartCh.get(ch);
          const tr=document.createElement('tr');
          const chCell=document.createElement('td');
          if(end && isStereo(end)) chCell.textContent = `${ch} & ${ch+1}`; else chCell.textContent=String(ch);
          const chainCell=document.createElement('td');
          if(end){ const root=findRoot(end); chainCell.textContent = buildChain(root); }
          tr.append(chCell, chainCell); tbody.appendChild(tr);
        }
      }
      legend.append(thead,tbody); stageOut.appendChild(legend);
      if(src){
        const clone=src.cloneNode(true); clone.removeAttribute('id'); clone.setAttribute('preserveAspectRatio','xMidYMid meet'); clone.style.width='100%'; clone.style.height='auto'; clone.style.maxHeight='9in';
        try{ const vb=clone.viewBox && clone.viewBox.baseVal; if(vb){ const br=document.createElementNS('http://www.w3.org/2000/svg','rect'); br.setAttribute('x','1.5'); br.setAttribute('y','1.5'); br.setAttribute('width', String(vb.width-3)); br.setAttribute('height', String(vb.height-3)); br.setAttribute('fill','none'); br.setAttribute('stroke','#000'); br.setAttribute('stroke-width','3'); br.setAttribute('pointer-events','none'); br.setAttribute('data-print-border','1'); clone.appendChild(br); } }catch(_){ }
        stageOut.appendChild(clone);
      }
      return stageOut;
    }
    async function inlineStageImages(svg){
      if(!svg) return;
      const images=Array.from(svg.querySelectorAll('image'));
      for(const im of images){
        const href=im.getAttribute('href')||im.getAttribute('xlink:href');
        if(!href || href.startsWith('data:')) continue;
        try{
          const resp=await fetch(href);
          if(!resp.ok) continue;
          const blob=await resp.blob();
          await new Promise((res)=>{ const fr=new FileReader(); fr.onload=()=>{ im.setAttribute('href', fr.result); res(); }; fr.readAsDataURL(blob); });
        }catch(e){ /* ignore fetch failures (e.g. file:// restrictions) */ }
      }
    }
    async function createStagePdfBlob(){
      prepHdrTech(); const techOut=$('#techPrint'); techOut.innerHTML='';
      const stageOut=$('#stagePrint'); buildStageExport(stageOut); // unified rendering identical to print
      await inlineStageImages(stageOut.querySelector('svg'));
      const el=document.getElementById('sheetTech');
      if(typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('PDF libs missing (offline?). Falling back to native print for stage.');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2, useCORS:true, allowTaint:true}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }
    async function createTechPdfBlob(){
      prepHdrTech(); const stageOut=$('#stagePrint'); stageOut.innerHTML=''; const techOut=$('#techPrint'); techOut.innerHTML='';
      const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl);
      const el=document.getElementById('sheetTech');
      if(typeof html2canvas==='undefined' || typeof window.jspdf==='undefined'){
        console.warn('PDF libs missing (offline?). Falling back to native print for tech sheet.');
        document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
        return null;
      }
      const canvas = await withOffscreen(el, ()=> html2canvas(el, {backgroundColor:'#ffffff', scale:2}));
      const blob = makePdfFromCanvas(canvas, 'letter');
      return blob;
    }

    function printPromise(){ return new Promise(res=> setTimeout(res, 150)); }
    async function printSetOnce(){ buildSheet(); document.getElementById('modal').classList.add('open'); await printPromise(); window.print(); document.getElementById('modal').classList.remove('open'); await printPromise(); }
    function prepHdrTech(){
      const hdr=$('#hdrTech'); hdr.innerHTML='';
      const hf=(function(){ const f=(gig.headerFlags||{band:true,venue:true,sub:true,notes:true}); if(!f.band&&!f.venue&&!f.sub&&!f.notes) return {band:true,venue:true,sub:true,notes:true}; return f; })();
      if(hf.band) hdr.append(el('div','band',(gig.band||'BAND')));
      if(hf.venue) hdr.append(el('div','venue', (gig.venue||'VENUE')));
      if(hf.sub){ const subTxt=[gig.date||'', gig.address||'', gig.contact||''].filter(Boolean).join(' • '); if(subTxt) hdr.append(el('div','sub', subTxt)); }
      if(hf.notes && gig.notes) hdr.append(el('div','notes', gig.notes));
    }
  async function printStageOnce(){
    prepHdrTech(); const techOut=$('#techPrint'); techOut.innerHTML=''; const stageOut=$('#stagePrint'); buildStageExport(stageOut);
    document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise();
  }
    async function printTechOnlyOnce(){ prepHdrTech(); const stageOut=$('#stagePrint'); stageOut.innerHTML=''; const techOut=$('#techPrint'); techOut.innerHTML=''; const tbl=document.createElement('table'); tbl.className='tech-table'; const head=document.createElement('thead'); head.innerHTML='<tr><th>#</th><th>Song</th><th>Lighting/FX Notes</th></tr>'; const body=document.createElement('tbody'); setlist.filter(x=>x.type==='song').forEach((s,i)=>{ const tr=document.createElement('tr'); const note=(techNotes && techNotes[s.id]) || s.tech || ''; tr.innerHTML=`<td>${i+1}</td><td>${s.title}</td><td>${note}</td>`; body.appendChild(tr); }); tbl.append(head,body); techOut.appendChild(tbl); document.getElementById('modalTech').classList.add('open'); await printPromise(); window.print(); document.getElementById('modalTech').classList.remove('open'); await printPromise(); }

    // Save/Load Profile (.BAND)
    const saveProfileBtn=document.getElementById('saveProfile');
    if(saveProfileBtn){ saveProfileBtn.addEventListener('click',()=>{
      var stageEl=document.getElementById('stageSvgFull') || document.getElementById('stageSvg');
      const stage = stageEl ? stageEl.outerHTML : '';
      const data={version:2,type:'fastfast-band', db, gig, gearSummary, stage};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=((gig.band? gig.band.replace(/\s+/g,'_')+'_':'')+'profile.band'); a.click(); URL.revokeObjectURL(a.href);
    }); }
    const loadProfileBtn=document.getElementById('loadProfile'); const loadProfileFile=document.getElementById('loadProfileFile');
    if(loadProfileBtn && loadProfileFile){
      loadProfileBtn.addEventListener('click',()=> loadProfileFile.click());
      loadProfileFile.addEventListener('change',()=>{
        const f=loadProfileFile.files && loadProfileFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && Array.isArray(obj.db)){
              // merge db by title+artist (case-insensitive)
              const keyOf=s=> ((s.title||'').toLowerCase().trim()+'|'+((s.artist||'Original').toLowerCase().trim()));
              const existing=new Set(db.map(keyOf));
              obj.db.forEach(s=>{
                const item={...s};
                if(!item.id) item.id=Date.now()+Math.random();
                if(!item.artist) item.artist='Original';
                if(!item.length) item.length=3.5;
                if(!existing.has(keyOf(item))){ db.push(item); existing.add(keyOf(item)); }
              });
              renderDB();
            }
            if(obj && obj.gig){
              // merge gig fields only if missing
              const fields=['band','date','venue','address','contact','notes','font','logo'];
              fields.forEach(k=>{ if(!gig[k] && obj.gig[k]) gig[k]=obj.gig[k]; });
              if(obj.gig.headerFlags){ gig.headerFlags=Object.assign({band:true,venue:true,sub:true,notes:true}, gig.headerFlags, obj.gig.headerFlags); }
              // hydrate UI
              if(gig.band) document.getElementById('gBand').value=gig.band;
              if(gig.date) document.getElementById('gDate').value=gig.date;
              if(gig.venue) document.getElementById('gVenue').value=gig.venue;
              if(gig.address) document.getElementById('gAddr').value=gig.address;
              if(gig.contact) document.getElementById('gContact').value=gig.contact;
              if(gig.notes) document.getElementById('gNotes').value=gig.notes;
              const gFontElTmp=document.getElementById('gFont'); if(gFontElTmp && gig.font) gFontElTmp.value=gig.font;
              // header flags checkboxes
              ['hdrBand','hdrVenue','hdrSub','hdrNotes'].forEach(id=>{ const el=document.getElementById(id); if(el){ if(id==='hdrBand') el.checked=!!gig.headerFlags.band; else if(id==='hdrVenue') el.checked=!!gig.headerFlags.venue; else if(id==='hdrSub') el.checked=!!gig.headerFlags.sub; else if(id==='hdrNotes') el.checked=!!gig.headerFlags.notes; }});
              refreshLogoPreview();
            }
            // hydrate gear and stage if present
            if(obj && 'gearSummary' in obj){ gearSummary = obj.gearSummary || ''; const gearEl=document.getElementById('gear'); if(gearEl) gearEl.value=gearSummary; }
            if(obj && obj.stage){ const container=document.getElementById('stageStore'); if(container){ container.innerHTML=obj.stage; const svg=container.querySelector('svg'); if(svg){ svg.id='stageSvg'; svg.classList.add('bw'); } } }
            saveAll();
          }catch(err){ alert('Failed to read .BAND file'); }
        };
        r.readAsText(f);
      });
    }

    // Zoom control for stage (applies to small canvas)
    // No inline zoom control anymore

    // Save .SET (export setlist only)
    const saveSetBtn=document.getElementById('saveSet'); if(saveSetBtn){ saveSetBtn.addEventListener('click',()=>{
      const data={version:1,type:'fastfast-set',setlist};
      const blob=new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=(gig.band? gig.band.replace(/\s+/g,'_')+'_' : '')+'setlist.set'; a.click(); URL.revokeObjectURL(a.href);
    }); }
    // Load .SET (import setlist only, keep current gig)
    const loadSetBtn=document.getElementById('loadSet'); const loadSetFile=document.getElementById('loadSetFile');
    if(loadSetBtn && loadSetFile){
      loadSetBtn.addEventListener('click',()=> loadSetFile.click());
      loadSetFile.addEventListener('change',()=>{
        const f=loadSetFile.files && loadSetFile.files[0]; if(!f) return;
        const r=new FileReader(); r.onload=e=>{
          try{
            const obj=JSON.parse(String(e.target.result||'{}'));
            if(obj && obj.setlist && Array.isArray(obj.setlist)){
              setlist=obj.setlist; renderSet(); saveAll();
            }else{ alert('Invalid .SET file'); }
          }catch(err){ alert('Failed to read .SET file'); }
        };
        r.readAsText(f);
      });
    }
    // --- Import (OCR / Paste) ---
    (function setupImport(){
      const txt=document.getElementById('importText');
      const file=document.getElementById('importFile');
      const parseBtn=document.getElementById('importParseBtn');
      const commitBtn=document.getElementById('importCommitBtn');
      const statusEl=document.getElementById('importStatus');
      const previewEl=document.getElementById('importPreview');
      if(!txt || !file || !parseBtn || !commitBtn) return;
      let parsed=[];
      function sanitizeLine(line){ return line.replace(/\s+/g,' ').trim(); }
      function detectCapo(str){ const m=str.match(/capo\s*(\d{1,2})/i); if(m){ const v=parseInt(m[1],10); if(Number.isInteger(v) && v>=0 && v<=24) return v; } return 0; }
      function detectKey(str){ // first standalone musical key token
        const m=str.match(/\b([A-G](?:#|b)?m?)\b/); return m? m[1] : ''; }
      function parseSongLines(text){
        const out=[]; const lines=text.split(/\r?\n/);
        for(let raw of lines){ let line=sanitizeLine(raw); if(!line) continue; const capo=detectCapo(line); if(capo) line=line.replace(/capo\s*\d{1,2}/i,'').trim(); const key=detectKey(line); let title=line; // remove key if separated by dash/pipe/colon or at end
          if(key){ const sepPattern=new RegExp('[-|:]?\s*'+key+'\s*$','i'); title=title.replace(sepPattern,'').trim(); if(title.toLowerCase().startsWith(key.toLowerCase()+' ')) title=title.slice(key.length).trim(); }
          // Remove trailing parentheses or brackets containing key or capo info
          title=title.replace(/\((?:capo|key)[^)]*\)$/i,'').trim();
          if(title) out.push({title, key, capo, length:3.5, artist:'Original'}); }
        return out; }
      function dedupe(list){ const seen=new Set(); return list.filter(s=>{ const k=(s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); if(seen.has(k)) return false; seen.add(k); return true; }); }
      function renderPreview(){ if(!parsed.length){ previewEl.innerHTML='<em>No parsed songs.</em>'; commitBtn.disabled=true; return; }
        // Build editable table
        const tbl=document.createElement('table'); tbl.style.width='100%'; tbl.style.borderCollapse='collapse';
        const thead=document.createElement('thead'); thead.innerHTML='<tr style="background:#e2e8f0"><th style="text-align:left;padding:4px 6px">Title</th><th style="text-align:left;padding:4px 6px">Key</th><th style="text-align:left;padding:4px 6px">Capo</th><th style="text-align:left;padding:4px 6px">Len (m)</th><th style="text-align:left;padding:4px 6px">Remove</th></tr>';
        const tbody=document.createElement('tbody');
        parsed.forEach((s,i)=>{
          const tr=document.createElement('tr');
          const tdTitle=document.createElement('td'); const inpTitle=document.createElement('input'); inpTitle.type='text'; inpTitle.value=s.title; inpTitle.style.width='100%'; inpTitle.addEventListener('input',()=>{ s.title=inpTitle.value.trim(); }); tdTitle.style.padding='4px 6px'; tdTitle.appendChild(inpTitle);
          const tdKey=document.createElement('td'); const inpKey=document.createElement('input'); inpKey.type='text'; inpKey.value=s.key||''; inpKey.placeholder='Key'; inpKey.style.width='70px'; inpKey.addEventListener('input',()=>{ s.key=inpKey.value.trim(); }); tdKey.style.padding='4px 6px'; tdKey.appendChild(inpKey);
          const tdCapo=document.createElement('td'); const inpCapo=document.createElement('input'); inpCapo.type='number'; inpCapo.min='0'; inpCapo.max='24'; inpCapo.value=String(Number.isInteger(s.capo)? s.capo:0); inpCapo.style.width='56px'; inpCapo.addEventListener('change',()=>{ let v=parseInt(inpCapo.value,10); if(!Number.isInteger(v)||v<0) v=0; if(v>24) v=24; s.capo=v; inpCapo.value=String(v); }); tdCapo.style.padding='4px 6px'; tdCapo.appendChild(inpCapo);
          const tdLen=document.createElement('td'); const inpLen=document.createElement('input'); inpLen.type='number'; inpLen.min='0.5'; inpLen.step='0.5'; inpLen.value=String(s.length||3.5); inpLen.style.width='70px'; inpLen.addEventListener('change',()=>{ let v=parseFloat(inpLen.value); if(!isFinite(v)||v<=0) v=3.5; s.length=v; inpLen.value=String(v); }); tdLen.style.padding='4px 6px'; tdLen.appendChild(inpLen);
          const tdRemove=document.createElement('td'); tdRemove.style.padding='4px 6px'; const btnRem=document.createElement('button'); btnRem.type='button'; btnRem.textContent='×'; btnRem.className='btn danger'; btnRem.style.padding='2px 8px'; btnRem.style.fontSize='14px'; btnRem.addEventListener('click',()=>{ parsed.splice(i,1); renderPreview(); }); tdRemove.appendChild(btnRem);
          tr.append(tdTitle,tdKey,tdCapo,tdLen,tdRemove); tbody.appendChild(tr);
        });
        tbl.append(thead,tbody); previewEl.innerHTML=''; previewEl.appendChild(tbl); commitBtn.disabled=false;
      }
      function addParsedToDb(){ const existingKeyOf=s=> (s.title.toLowerCase()+'|'+(s.artist||'Original').toLowerCase()); const existing=new Set(db.map(existingKeyOf)); let added=0; parsed.forEach(s=>{ if(!existing.has(existingKeyOf(s))){ s.id=Date.now()+Math.random(); db.push(s); existing.add(existingKeyOf(s)); added++; } }); renderDB(); renderSongPool(); saveAll(); statusEl.textContent=`Imported ${added} new song${added===1?'':'s'}.`; }
      parseBtn.addEventListener('click',()=>{ parsed=dedupe(parseSongLines(txt.value||'')); statusEl.textContent=`Parsed ${parsed.length} song line${parsed.length===1?'':'s'}.`; renderPreview(); });
      commitBtn.addEventListener('click', addParsedToDb);
      async function ensurePdfJs(){ if(window.pdfjsLib) return; statusEl.textContent='Loading PDF.js…'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); if(window.pdfjsLib){ window.pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'; } }
      async function ensureTesseract(){ if(window.Tesseract) return; statusEl.textContent='Loading Tesseract…'; await new Promise((res,rej)=>{ const sc=document.createElement('script'); sc.src='https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js'; sc.onload=res; sc.onerror=rej; document.head.appendChild(sc); }); }
      file.addEventListener('change', async()=>{
        previewEl.innerHTML=''; parsed=[]; commitBtn.disabled=true; statusEl.textContent=''; const f=file.files && file.files[0]; if(!f) return;
        const type=f.type||''; const name=(f.name||'').toLowerCase();
        if(type.startsWith('text') || name.endsWith('.txt')){ const r=new FileReader(); r.onload=e=>{ parsed=dedupe(parseSongLines(String(e.target.result||''))); statusEl.textContent=`Parsed ${parsed.length} from text file.`; renderPreview(); }; r.readAsText(f); return; }
        if(name.endsWith('.pdf') || type==='application/pdf'){ try{ await ensurePdfJs(); statusEl.textContent='Reading PDF…'; const url=URL.createObjectURL(f); const doc=await window.pdfjsLib.getDocument(url).promise; let full=''; for(let p=1;p<=doc.numPages;p++){ const page=await doc.getPage(p); const txtC=await page.getTextContent(); full += txtC.items.map(i=> i.str).join(' ')+'\n'; } URL.revokeObjectURL(url); parsed=dedupe(parseSongLines(full)); statusEl.textContent=`Parsed ${parsed.length} from PDF.`; renderPreview(); }catch(err){ statusEl.textContent='PDF parsing failed.'; console.error(err); } return; }
        if(type.startsWith('image/')){ try{ await ensureTesseract(); statusEl.textContent='Running OCR…'; const { Tesseract }=window; const result=await Tesseract.recognize(f,'eng',{ logger:m=>{ if(m.status==='recognizing text'){ statusEl.textContent=`OCR: ${Math.round(m.progress*100)}%`; } } }); const text=result && result.data && result.data.text || ''; parsed=dedupe(parseSongLines(text)); statusEl.textContent=`Parsed ${parsed.length} from image OCR.`; renderPreview(); }catch(err){ statusEl.textContent='Image OCR failed.'; console.error(err); } return; }
        statusEl.textContent='Unsupported file type.';
      });
    })();
  </script>
  <!-- Lightweight libs for client PDF/ZIP export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
